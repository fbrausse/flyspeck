(* ***** LIST PAIRS *******)
`list_pairs (core L r)`

list_pairs_core.  MAP LAST (parts L r).
List_hypermap.mem_list_pairs_explicit.   MEM (x,y) (list_pairs s) ==> y = next_el s x.
next_el_list_pairs_eq   MEM (x,next_el s x) (list_pairs s)
next_el_core_list_pairs.   If next_el (core L r) u1 = v1. then MEM (u1,v1) (list_pairs (core L r))
List_hypermap.next_el_list_pairs. next_el (list_pairs s ) (x,y) ==> y = next_el s x.
  (So SND (LAST p) = FST (next_el (find_face L x) (LAST p)) ).


(* **** BETWN *****)
Aq8.next_cat_betwn_same;;  next_el on betwn agrees with next_el on full r.

1;;
(* **** HLT next_el ****)
More_lemmas.next_core_FST;;  if f_list L d = next_el r d, then next_el (core L r) (FST d) = FST (next_el r d).
;;
More_lemmas.next_core_FST_SYM;;  same but r is not the marked_list L N r x.
Reduction4.next_core_ne_FST;; My version where FST d != FST (next_el r d).

(* **** PARTS LAST F_LIST *)

normal_list_parts_next_last : next_el r (LAST p) = f_list L (LAST p).
normal_list_parts_next_last_not: ~(next_el r (LAST p) = f_list (e_list (LAST p)).
parts_next_unlast: if not last next_el p x = f_list L (e_list x).
f_list_imp_last: if f-step then x = LAST p.
edge_nondeg_f_xor_ni:

parts_last_as_fst_hd: LAST p = FST (HD p), FST (HD p')




