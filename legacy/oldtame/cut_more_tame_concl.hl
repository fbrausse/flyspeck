(* cut from more_tame_concl.hl on Feb 2, 2014 *)

(* deprecated.
let subquotient = new_definition `subquotient L N = 
  (let H = hypermap_of_list L in
     hypermap_of_list (map (partition_into_atom (inverse (node_map H))) N))`;;
*)


(*
let split_normal_list = new_definition `!L r f x y. 
  split_normal_list L r f x y = 
    (let x' = next_el r x in
     let y' = next_el r y in
     let sz = (\x. sizel (filter (\t. t = x) (flatten L))) in
     let nd = (\x. map (\i. (n_list L POWER i) x) (upt 1 (sz (FST x)))) in
     let new2 = betwn f x y' in
     let new1 = flatten (map nd new2) in
     let f1 = APPEND [x'] (APPEND (betwn r x' y) [y]) in
     let f2 = APPEND [y'] (APPEND (betwn r y' x) [x]) in
       (APPEND (REVERSE new1) f1,APPEND f2 new2))`;;
*)


(*
let respect_final = new_definition 
  `respect_final (phi:num#num->A->bool) g H NF = 
  final_quotient_faces H NF =  set_of_list 
    (MAP ((IMAGE phi) o set_of_list o list_pairs o FST) 
       (FILTER SND (faces g)))`;;
*)

(* deprecated 
let transform = new_definition `transform (H:(A)hypermap) x (NF,L) = 
  if (L IN final_loops H NF) then (NF,L) else
    (family_transform H NF L x,loop1_transform H NF L x)`;;



let AQIUNPP2_concl = 
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked (H ,NF, L, x) 
   ==> (let (NF',L') =  (transform H x (NF,L)) in is_marked (H,NF',L',x))`;;
*)

(* DEPRECATED
let weak_respect_final = new_definition 
  `respect_final (phi:num#num->A->bool) g H NF = 
  set_of_list 
    (MAP ((IMAGE phi) o set_of_list o list_pairs o FST) 
       (FILTER SND (faces g))) SUBSET final_quotient_faces H NF`;;

let UYOUIXG_concl = 
  `!H (x:A) n L1 L2. is_restricted H /\ x IN dart H /\ (n = CARD(face H x)) /\
    is_normal H {L1,L2} /\ (L1 = loop_of_face H x) /\
    (path_of_loop L2 x = complement H x) /\
    dih2k (quotient H {L1,L2}) n /\
    ~(L2 = loop_of_face H x) ==>
    (?phi. 
      hyp_iso phi ((hypermap_of_list (fgraph (Seed (n-3)))) ,
		   (quotient H {L1,L2})) /\
      respect_final phi (Seed (n-3)) H {L1,L2}) `;;
*)

(*
let path_index = new_definition `path_index n p x = 
  indexl (x:A) (mkseq p n)`;;

let modify_loop = new_definition `modify_loop n L (x:A) y p = 
  (let q1 = path_of_loop L y in 
   let index' = path_index n in
   let q2 = shift_path p (index' p x) in
   let m = index L y x in
   let q = glue q1 q2 m  in
   let n = index' q2 y + m in
  loop (support_of_sequence q n, samsara q n))
  `;;

let LPWFYMU_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     (let f =  face_contour H x in
      let fc =  complement H x in
      let z = hyp'z H (MF i) (M i) x in
      let n = CARD (dart H) in
      let Mminus  = modify_loop n (M i) x z f in 
      let Mplus = modify_loop n (M i) 
	(inverse (node_map H) x) (node_map H z) fc in
	(MF (SUC i) = ((MF i) DIFF {M i}) UNION {Mminus,Mplus}) /\
	  M (SUC i) = Mminus))`;;
*)


(*
let RYIUUVK_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
       index (loop_of_face H x) x (hyp'z H (MF i) (M i) x) < 
	 index (loop_of_face H x) x (hyp'y H (MF (SUC i)) (M (SUC i)) x))`;;
*)


(*
let CESHTIN1_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     hyp'z H (MF i) (M i) x IN dart_of_loop L)`;;
*)


(*
let CESHTIN2_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     hyp'y H (MF i) (M i) x IN dart_of_loop L)`;;
*)


(*
let CESHTIN3_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M (SUC i) IN final_loops H NF) ==>
     index L x (hyp'z H (MF i) (M i) x) < 
	 index L x (hyp'y H (MF (SUC i)) (M (SUC i)) x))`;;
*)

(*
let CESHTIN4_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     index L x (hyp'y H (MF i) (M i) x) < 
	 index L x (hyp'z H (MF i) (M i) x))`;;
*)


(* to here *)

(*
let CESHTIN5_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
    (let y = hyp'y H (MF i) (M i) x in
     let z = hyp'z H (MF i) (M i) x in
     let niy = inverse (node_map H) y in
     let Lp = path_of_loop L niy in
     let Mp = path_of_loop (M i) niy in
     let j = index L niy (node_map H z) in
       (!k. k <= j ==> Lp k = Mp k)))`;;
*)


(* to here *)

(*
let CESHTIN5_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
    (let y = hyp'y H (MF i) (M i) x in
     let z = hyp'z H (MF i) (M i) x in
     let niy = inverse (node_map H) y in
     let Lp = path_of_loop L niy in
     let Mp = path_of_loop (M i) niy in
     let j = index L niy (node_map H z) in
       (!k. k <= j ==> Lp k = Mp k)))`;;
*)


(* to here *)

(*
let CESHTIN5_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ 
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
    (let y = hyp'y H (MF i) (M i) x in
     let z = hyp'z H (MF i) (M i) x in
     let niy = inverse (node_map H) y in
     let Lp = path_of_loop L niy in
     let Mp = path_of_loop (M i) niy in
     let j = index L niy (node_map H z) in
       (!k. k <= j ==> Lp k = Mp k)))`;;
*)

(* I'm not sure this is really needed *)

(*
let KBWPBHQ1_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  ({ y | y IN dart_of_loop L /\ y IN (face H x) /\ 
	 loop_map L y = (inverse (node_map H) y) } = 
   { hyp'y H (MF i) (M i) x | i | ~(M i IN final_loops H NF) })`;;

let KBWPBHQ2_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  ({ z | z IN dart_of_loop L /\ z IN (face H x) /\ 
	 inverse (loop_map L) z = node_map H z } = 
   { hyp'z H (MF i) (M i) x | i | ~(M i IN final_loops H NF) })`;;
*)

(*
let corresponding_hyperdata = new_definition `
  corresponding_hyperdata (H,NF,g,phi) <=> 
  (is_normal (H:(A) hypermap) NF /\
    planegraph g /\
    hyp_iso phi (hypermap_of_list (fgraph g),quotient H NF) /\
    respect_final phi g H NF /\
   simple_hypermap (quotient H NF) /\
   is_node_nondegenerate (quotient H NF) /\
   empty_flagged H NF)`;;
*)

(*
let loop_choice = new_definition `loop_choice_v1 (H,NF,g,phi) = @Lx.
  (
    let L = FST Lx in
    let (x:A) = SND Lx in
   let f = minimalFace (nonFinals g) in
   let v = minimalVertex g f in
   let w = nextVertex f v in
   let a = phi(v,w) in
      (x = tail_of_atom H NF x /\ x IN a /\ a IN atoms_of_loop H L))`;;
*)

    
(*
let phi_normal_family = new_definition `
  phi_normal_family_v1 (H,NF,g,phi) = 
    (let (L,(x:A)) = loop_choice_v1 (H,NF,g,phi) in
     let k = min_num {i | 
	(let MF = (FST ((transform H x POWER i) (NF,L))) in
          final_loops H MF = MF)  } in
       FST ((transform H x POWER k) (NF,L)))`;;

let HKBGWJI_concl = 
  `!H NF g phi L (x:A).
      is_restricted H /\
     corresponding_hyperdata (H,NF,g,phi) /\
     ~(nonFinals g = []) /\
     ((L,x) = loop_choice_v1(H,NF,g,phi)) ==>
    is_marked (H,NF,L,x)`;;
*)

(* deprecated Feb 1, 2014

let c'hyp = new_definition
  `!H L (x:A) i.
      c'hyp H L x i = 
         if (face_path H x i IN dart_of_loop L) 
	 then SOME (atom H L (face_path H x i))
	 else NONE`;;

let b'hyp = new_definition
  `!H NF L (x:A) (i:num) .
      b'hyp H NF L x i = 
        if c'hyp H L x i = NONE then NONE
	else 
	  (let Hq = quotient H NF in
	   let Lq = loop_of_face Hq (atom H L x) in
	   let a = the (c'hyp H L x i) in
	     SOME (index Lq (atom H L (face_map H x)) a))`;;

let a'hyp = define
  `(a'hyp H NF L (x:A) 0 = 0) /\
      (a'hyp H NF L x (SUC i) = 
        (if b'hyp H NF L x (SUC i) = NONE then a'hyp H NF L x i 
	else the (b'hyp H NF L x (SUC i))))`;;

(*
let a'enum = new_definition
  `a'enum H NF L (x:A) = mkseq (a'hyp H NF L x) (CARD (face H x))`;;
*)

let UWAHKWU_concl = `!g f p.
   planegraphP p g /\ 
   LENGTH (FST f) <= p ==>
   (planegraphP p (makeFaceFinal f g))`;;

let next_plane_step = new_definition' `next_plane_step g enum1 = 
  (let fs = nonFinals g in
     if (fs = []) then g else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	let vertexLists = indexToVertexList f v enum1 in
	  subdivFace g f vertexLists))`;;

(*
let next_plane_step_next_plane = `!g e.
  ~(nonFinals g = []) /\ ...
   ==> (?p. next_plane_step g e IN next_plane p g)`;;
*)

let RKXPIXF_concl = `!(H:(A)hypermap) NF. is_restricted H /\
  is_normal H NF ==>
  is_no_double_joins (quotient H NF) `;;

let jump_index = new_definition `jump_index a i <=> 
  ((0 < i /\ a (i-1) + 2 <= a i) \/ 
  (1 < i /\ a (i-2) = a(i-1) /\ a(i-1) < a i))`;;

let XIZEQEV1_concl = `!H NF g phi L (x:A) i e.
   corresponding_hyperdata (H,NF,g,phi) /\
   ~(nonFinals g = []) /\
   (L,x) = loop_choice_v1 (H,NF,g,phi) /\
   i <= CARD (face H x) /\
   jump_index (a'hyp H NF L x) i /\ 
   ~(a'hyp H NF L x i = a'hyp H NF L x (i-1)) /\
   e = mkseq (a'hyp H NF L x) i  ==>
       planegraph_relaxed (next_plane_step g e)`;;

let XIZEQEV2_concl = `!H NF g phi L (x:A) e.
   corresponding_hyperdata (H,NF,g,phi) /\
   ~(nonFinals g = []) /\
   (L,x) = loop_choice_v1 (H,NF,g,phi) /\
   e = mkseq (a'hyp H NF L x) (CARD (face H x))  ==>
       planegraph (next_plane_step g e)`;;

*)

(*
let phi_g' = `!H NF g phi.
  phi_g' (H, NF, g, phi) = 
    (let    (L,(x:A)) = loop_choice_v1 (H,NF,g,phi) in
     let e = mkseq (a'hyp H NF L x) (CARD (face H x)) in
        (next_plane_step g e))`;;
*)

(* ========================================================================== *)
(* Induction step -- phi' -- phi_phi'. *)
(* ========================================================================== *)

(* deprecated Feb 1, 2014:

let EPWRLGS1_concl = `!H NF g phi phi' L (x:A) MF M i M' MF' a e e' gi jump_indices.
  corresponding_hyperdata (H,NF,g,phi) /\
  ~(nonFinals g = []) /\
  (L,x) = loop_choice_v1 (H,NF,g,phi) /\
  a = a'hyp H NF L x /\
  (MF,M) = (transform H x POWER i) (NF,L) /\
  ~(M IN final_loops H MF) /\
  (MF',M') = (transform H x POWER (i+1)) (NF,L) /\
  jump_indices = FILTER (jump_index a) (iota 0 (CARD (face H x))) /\ 
  e = mkseq (a'hyp H NF L x) (EL (i-1) jump_indices) /\
  (gi = if (i=0) then g else next_plane_step g e) /\
  e' = mkseq (a'hyp H NF L x) (EL i jump_indices) /\
  hyp_iso phi' (hypermap_of_list (fgraph gi),quotient H MF) 
==>
  (?phi''.
     hyp_iso phi'' (hypermap_of_list (fgraph (next_plane_step g e')),
		   quotient H MF') /\
     (!y. y IN dart (hypermap_of_list (fgraph gi)) /\ 
	~(phi' y IN atoms_of_loop H M) ==>
	phi'' y = phi' y))`;;

let EPWRLGS2_concl = `!H NF g phi L (x:A).
  corresponding_hyperdata (H,NF,g,phi) /\
  ~(nonFinals g = []) /\
  (L,x) = loop_choice_v1 (H,NF,g,phi) /\
  a = a'hyp H NF L x /\
  MF = phi_normal_family_v1 (H,NF,g,phi) /\
  e = mkseq (a'hyp H NF L x) (CARD (face H x)) /\ 
  g' = next_plane_step g e 
==>
  (?phi'.
     hyp_iso phi' (hypermap_of_list (fgraph g'),quotient H MF) /\
     (let prefinal = FILTER (\f. ~(SND f) /\   
        IMAGE phi (set_of_list (list_pairs (FST f)))
        IN final_quotient_faces H NF) (faces g') in 
      let g'' = ITLIST makeFaceFinal prefinal g' in
	corresponding_hyperdata (H,MF,g'',phi')))`;;

*)


(* was samsara_well_defined.  This stuff is no longer used.
   It can be moved to cut_...  *)

let next_set_well_defined = prove_by_refinement(
  `!r. uniq (flatten r) ==> ?f. !p. MEM p r ==> 
     f (set_of_list p) = set_of_list (next_el r p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Tactics.WELLDEFINED_FUNCTION_1P];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  TYPIFY `p = []` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `set_of_list` MP_TAC;
    BY(ASM_MESON_TAC[SET_OF_LIST_EQ_EMPTY]);
  RULE_ASSUM_TAC (REWRITE_RULE[List_hypermap.mem_not_nil]);
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x x'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique])
  ]);;
  (* }}} *)

let next_set_permutes = prove_by_refinement(
  `!r. uniq (flatten r) /\ uniq r ==> (?f. 
     f permutes (set_of_list (MAP set_of_list r)) /\
    (!p. MEM (p:A list) r ==> 
     f (set_of_list p) = set_of_list (next_el r p))) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_set_well_defined [`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `res f (set_of_list (MAP set_of_list r))` EXISTS_TAC;
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `res f (set_of_list (MAP set_of_list r)) (set_of_list p) = f (set_of_list p)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Sphere.res];
    ASM_REWRITE_TAC[IN_SET_OF_LIST];
    TYPIFY_GOAL_THEN `MEM (set_of_list p) (MAP set_of_list r)` (unlist REWRITE_TAC);
    REWRITE_TAC[Seq.map_MAP];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Hypermap_and_fan.RES_PERMUTES;
  REWRITE_TAC[IN_SET_OF_LIST];
  SUBCONJ_TAC;
    REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `next_el r x'` EXISTS_TAC;
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq2.next_el_permutes [`r`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[permutes;IN_SET_OF_LIST;EXISTS_UNIQUE];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    REBIND_TAC (`x:A->bool`,"s");
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `MEM` MP_TAC);
  FIRST_X_ASSUM_ST `MEM` kill;
  REWRITE_TAC[MEM_MAP;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  AP_TERM_TAC;
  TYPIFY `set_of_list (next_el r x) = set_of_list (next_el r x')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `next_el r x = next_el r x'` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `next_el r x = []` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `set_of_list` MP_TAC;
    BY(ASM_MESON_TAC[SET_OF_LIST_EQ_EMPTY]);
  RULE_ASSUM_TAC (REWRITE_RULE[List_hypermap.mem_not_nil]);
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x'' (next_el r x')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique;Seq2.mem_next_el])
  ]);;
  (* }}} *)

(* was nextset *)

let next_set = new_specification ["next_set"]
  (REWRITE_RULE[SKOLEM_THM;RIGHT_IMP_EXISTS_THM] next_set_permutes);;

(*
let normal_family_of_list = new_definition `normal_family_of_list L N = 
  set_of_list 
  (MAP (\r. loop (set_of_list (MAP set_of_list (parts L r))   , 
		  next_set (parts L r))) N)`;;

let loop_of_list = new_definition `loop_of_list L r = 
  loop (set_of_list (MAP set_of_list (parts L r)),next_set (parts L r))`;;

let concl = `normal_family_of_list L N = 
  set_of_list (MAP (loop_of_list L) N)`;;
*)

(*
let list_complement = new_definition
  `!r f x. list_complement f r (x:A) =
      filter (\d. ~MEM d r) (rotate_to f x)`;;
*)



(*
let flast = new_definition 
 `flast H s <=> (next_el s (LAST s) = face_map H (LAST s))`;;

let conloop_list = new_definition
  `contour_list H s <=>
    (!x. MEM x s ==> (one_step_contour H x (next_el s x) /\ x IN dart H))`;;


let normal_list = new_definition
  `normal_list H L <=>
     (uniq (flatten L) /\
      all (\s. ~(s = [])) L /\ 
      all (flast H) L /\
      all (conloop_list H) L /\
      (!d. MEM d (flatten L) ==> node H d SUBSET set_of_list (flatten L)))`;;

*)


(* moved to more_...
let f_last = new_definition 
 `f_last L s <=> (next_el s (LAST s) = f_list L (LAST s))`;;

let one_step_list = new_definition `one_step_list L x y = 
  (y = f_list L x \/ y = (f_list L (e_list x)))`;;

let loop_list = new_definition
  `loop_list L s <=>
    (all (\x. MEM x (list_of_darts L) /\ one_step_list L x (next_el s x)) s)`;;

let norm_list = new_definition
  `norm_list L N <=>
    (uniq (flatten N) /\
     all (\s. ~(s = [])) N /\
     all (f_last L) N /\
     all (loop_list L) N /\
     (!d. MEM d (flatten N) ==> 
	(node (hypermap_of_list L) d SUBSET set_of_list (flatten N))))`;;

let list_of_face = new_definition `list_of_face H ff = 
  map (\i. node H ((face_map H POWER i) (CHOICE ff))) (upt 0 (CARD ff))`;;

let list_of_hypermap = new_definition `list_of_hypermap H = 
  map (list_of_face H) (list_of_set (face_set H))`;;

let core_list = new_definition `core_list PN = 
  map (\f. map (\x. FST (HD x)) f) PN`;;
*)

(* need to reload first.
let split_list_face_n = new_definition' 
   `split_list_face_n (f:(A) list) (ram1) ram2 newVs = 
      (let f1 =  [ram1] #@#  (betwn f ram1 ram2) #@# [ram2] in
       let f2 =  [ram2] #@# (betwn f ram2 ram1) #@# [ram1] in
	 ( (REVERSE newVs #@# f1)),  (f2 #@# newVs))`;;


let split_list_face_n_split_face = prove_by_refinement(
  `!f ram1 ram2 newVs.
    split_face f ram1 ram2 newVs = 
    (let f1 = FST f in
     let sln = split_list_face_n f1 ram1 ram2 newVs
     in (FST sln,F),(SND sln,F))`,
  (* {{{ proof *)
  [
  rt[Import_tame_classification.split_list_face_n;Import_tame_classification.split_face]
  #
  ]);;
  (* }}} *)
*)


(*
let MEMf_MAP = prove_by_refinement(
  `!f:A->B x u. MEM x u ==> MEM (f x) (MAP f u)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)
