(*
let input_ineqs = ref ([]:(string*int)list);;

 let add_inequality i  = 
   let _ = input_ineqs:= i :: !input_ineqs in
  ();;

 let get_inequality s = 
   filter (fun t -> fst t = s) (!input_ineqs);;

  let oxl_parameters (i,j) = 
   let m = Printf.sprintf "prep-OXLZLEZ 6346351218 %d %d" i j in
     idv_parameters m;;

   let count = count_iargs m in
     map (fun i -> (m,i)) (0-- (count - 1));;

*)



(*

let mk_post_prep_oxl s = 
  let idq = get_prep s in
  let _ = g idq.ineq in
  let _ = e POSTPREP_OXL_634_TAC in
  let a,w = top_goal() in
  let _ = a=[] or failwith s in
    w;;

let mk_one (i,j) = 
  mk_post_prep_oxl (Printf.sprintf "prep-OXLZLEZ 6346351218 %d %d" i j);;

map get_one_iarg all_oxl_parameters ;;

get_nth (Random.int 5070);;
*)

(*

 (* let has_quad = some_const_name ((=) "quad_cross_diag2_x");;   *)

let (sz,nth_term,nth_idv) = 
  let p = reduced_prep_idv in
    (List.length p,
     (fun k-> strip_term(get_ineq (List.nth p k))),
     List.nth p);;
*)

(* let onfirst tacs = [EVERY tacs;ALL_TAC];; *)

(* 
let process_delta_pos_idv s = 
  let tt0 = get_ineq s in
  let delta_thm = find_domain tt0 in
  let DTAC = DELTA_TAC delta_thm in
  let _ = g tt0 in
  let _ = e(DTAC) in
  let a,t' = top_goal() in
  let _ = a = [] or failwith s in
(*  let _ = (bad_names t' = []) or failwith s in *)
    t';;

let process_delta_inert_idv s = 
  let t = get_ineq s in
(*  let _ = (bad_names t = []) or failwith s in *)
    t;;

setify (map process_delta_inert_idv delta_inert_idv);;    
setify (map process_delta_pos_idv delta_pos_idv);;


let mk_post_prep_delta s = 
  let t = get_ineq s in
  let _ = g t in
  let _ = e(get_delta_tactic s) in
  let a,w = top_goal() in
  let _ = a = [] or failwith ("delta unexpected assumption: "^s) in
    w;;


mk_post_prep_delta (random_elt (delta_idv));; 

let get_one_iarg_delta (s,i) = 
  let t = mk_post_prep_delta s in
  let iarg =  get_iarg s in 
  let cl = mk_case_list t iarg in
    List.nth cl i;;

*)

(*

let delta_nok_idv = subtract (reduced_prep_idv) delta_idv;;

let alpha_idv = subtract tough_idv (beta_idv @ gamma_idv);;
*)

let delta_pos_idv = 
  filter (is_delta_pos o get_ineq) delta_idv;;

let delta_inert_idv = 
  filter (is_delta_inert o get_ineq) delta_idv;;



(*
let run_alpha s =
  let t = get_ineq s in
  let pos = Break_case_exec.is_delta_pos t in
  let TAC = if pos then DELTA1_TAC (find_domain t) else ALL_TAC in
  let _ = g t in
  let _ = try e(PREP_TAC THEN PRE_DELTA_TAC THEN TAC THEN POS_SIMP_TAC THEN POST_TAC) with Failure m -> failwith (m^" "^s) in
  let a,w = top_goal() in
(*  let _ = (bad_names w = []) or failwith s in  *)
  let _ = a = [] or failwith ("delta unexpected assumption: "^s) in
    w;;
*)

(*
let tough_data = map (data_of_run run_alpha) tough_idv;;

let alpha_idv = map fst (filter (fun _,b -> (b=[])) tough_data);;

let really_tough_data =  (filter (fun _,b -> not(b=[])) tough_data);; 

let really_tough_idv = map fst really_tough_data;;

let really_tough_idv = ["prep-TEWNSCJ split(1/2)"; "prep-TEWNSCJ split(0/2)";
   "prep-PEMKWKU split(1/2)"; "prep-PEMKWKU split(0/2)";
   "prep-QITNPEAv2 4003532128 split(1/2)";
   "prep-QITNPEAv2 4003532128 split(0/2)"; "prep-TXQTPVC split(1/2)";
   "prep-TXQTPVC split(0/2)"; "prep-IXPOTPA split(1/2)";
   "prep-IXPOTPA split(0/2)"; "prep-2314572187"; "prep-7550003505 0 0 2";
   "prep-7550003505 0 1 2"; "prep-7550003505 0 2 2"; "prep-7550003505 0 2 3";
   "prep-7550003505 0 2 4"; "prep-7550003505 1 1 2"; "prep-7550003505 1 2 2";
   "prep-7550003505 1 2 3"; "prep-7550003505 1 2 4"; "prep-7550003505 2 2 2";
   "prep-7550003505 2 2 3"; "prep-7550003505 2 2 4"; "prep-7550003505 2 3 3";
   "prep-7550003505 2 3 4"; "prep-7550003505 2 4 4"];;

*)





(*
let run_beta s  =
  let di = `delta_ineq_v6:bool` in
  let t = get_ineq s in
  let gt = if needs_delta_ineq1 t or needs_delta_ineq2 t or needs_delta_ineq3 t then 
    mk_imp(di,t) else t in
  let _ = g gt in
  let _ = try e(PREP_TAC THEN Z_TAC THEN POS_SIMP_TAC THEN POST_TAC THEN TRY DISCH_TAC) with Failure m -> failwith (m^" "^s) in
  let a,w = top_goal() in
(*  let _ = (bad_names w = []) or failwith s in *)
  let _ = a = [] or a = [di] or failwith ("delta unexpected assumption: "^s) in 
(*  let data =   (s,List.length a,bad_names w) in *)
    w (* data *);;
*)

(* parameter families *)



(*
let beta_data,gamma_data = 
  (partition (fun _,b -> subset b  ["rhazim2_x"; "rhazim3_x"; "rhazim_x"]) really_tough_data);;


let beta_data_1 = map ((data_of_run run_beta) o fst) beta_data;;

forall (fun (_,ls) -> (ls = [])) beta_data_1;;

let beta_idv = map fst beta_data;;
let gamma_idv = map fst gamma_data;;

*)






(*
let really_tough_data = (filter (fun _,b -> not(b=[])) tough_data);;

let beta_data = 
  (filter (fun _,b -> not(b=[]) && subset b  ["rhazim2_x"; "rhazim3_x"; "rhazim_x"]) tough_data);;

let gamma_data = 
  (filter (fun _,b -> not(b=[]) && not (subset b  ["rhazim2_x"; "rhazim3_x"; "rhazim_x"])) tough_data);;

let gamma_data,quad_data = 
  partition (fun (_,xs) -> subset xs ["gamma23_full8_x";"gamma23_keep135_x"]) gamma_data;;
*)


(*
let run_gamma s = 
  let t = (Break_case_exec.get_prep s).ineq in
  let di = `delta_ineq_v6:bool` in
  let gt = if needs_delta_ineq2 t then mk_imp(di,t) else t in
  let _ = has_full8 t or has_keep135 t or failwith "gamma series expected" in
  let _ = g gt in
  let _ = 
    try e(PREP_TAC THEN DTAC t THEN POST_DTAC THEN 
	    ETA126_TAC THEN ETA135_TAC THEN 
	    TRY FULL8_TAC THEN TRY KEEP135_TAC THEN 
	    REPLICATE_TAC 4 (POP_ASSUM kill) THEN POST_TAC THEN REPEAT DISCH_TAC) 
    with Failure m -> failwith(m^" "^s) in
  let a,w = top_goal() in
(*  let _ = (bad_names w = []) or failwith s in *)
  let _ = a = [] or a = [di] or failwith ("delta unexpected assumption: "^s) in 
     w;;
*)


(*  MOVED to .
let postprocess t = 
  let t2 = cconv (REWRITE_CONV [GSYM Nonlinear_lemma.sol0_over_pi_EQ_const1;ineqm_mp_simple]) t in
  let t3 = snd(dest_imp t2) in
    t3;;

let postprocess_int i = 
  let t1 =  get_nth i in
    postprocess1 t1;;
*)



(* ********************************************************************** *)
(* post analysis of oxl cases -> moved to break_case_exec.hl *)
(* ********************************************************************** *)


(* FUTURE WORK *)


let stot = Parse_ineq.ocaml_string_of_term;;

(* INACTIVE *)

let (sz,nth_term,nth_idv) = 
  let p = tough_idq in
    (List.length p,
     (fun k->  (snd(strip_forall (List.nth p k).ineq))),
     (fun k-> (List.nth p k).idv));;

List.length really_tough_idv;;
map snd really_tough_data;;
List.nth really_tough_data 23;;
gamma_data;;



(*
let numerical_domain (* not used *) inq = 
  let (_,axb,_) = simple_dest_ineq (snd (strip_forall inq)) in
  let ab = map (fun (a,_,b) -> (a,b)) axb in
  let a,b = unzip ab in
  let ud  = rhs o concl o (REWRITE_CONV [DECIMAL]) in
    let f = ((* rhs o concl o REAL_RAT_REDUCE_CONV o *) Break_case_exec.scrub_c (* o ud*)) in
    map f a,map f b;;
*)

(*
let minlist x = end_itlist min x;;
let maxlist x = end_itlist max x;;

let qtest i = 
  let eps = 1.0e-10 in
  let (_,b) = (ocaml_domain ( (nth_term i))) in
    maxlist b > 8.0+.eps;;

let atest i =
  let eps = 1.0e-10 in
  let (b,_) = (ocaml_domain ( (nth_term i))) in
    maxlist (fst (chop_list 3 b)) < 6.3504 +.eps;;
*)

let show i =
  let t =  (nth_term ( i)) in
    (t, ocaml_domain t);;

show 583;;
Sphere.rad2_x;;
show 1;;
let f1 = filter (exists_domain o nth_term) (0--(sz-1));;
List.length 

let f1 = filter (not o  exists_domain) (0--604);;

(*
let has_subterm sub tm = 
  can (find_term ((=) sub)) tm;; 

let has_quad = 
  let a = `quad_cross_diag2_x` in
     (has_subterm a);;
*)

List.length delta_ok_idv;;

let gg = filter
  (fun i ->
     let t =  (nth_term i) in
       not (is_delta_inert t) && exists_domain t) (0-- (sz-1));;

let gg0 = filter
  (fun i ->
     let t =  (nth_term i) in
        (is_delta_inert t) ) (0-- (sz-1));;




let test1 i = 
  let tt0 =  (nth_term i) in
  let delta_thm = find_domain tt0 in
  let DTAC = DELTA_TAC delta_thm in
  let _ = g tt0 in
  let _ = e(DTAC) in
  let t' = snd (top_goal()) in
    (bad_names t',t');;



List.length gg0;;
let fx0 = map (fun (r,_),i-> (r,i)) (filter (fun ((r,_),_) -> not(r=[])) 
  (map (fun i -> (test0 (List.nth gg0 i),List.nth gg0 i)) (0--122)));;
setify (List.flatten (map fst fx0));;
List.length gg0 - List.length fx0;;

sz;;
List.length gg;;
test1 297;; (* good to 296, mostly ok to 400  -- 446*)
let fx = map (fun (r,_),i-> (r,i)) (filter (fun ((r,_),_) -> not(r=[])) 
  (map (fun i -> (test1 (List.nth gg i),List.nth gg i)) (100--446)));;
setify (List.flatten (map fst fx));;
let fx2 = map snd fx;;
List.length gg - List.length fx;;

["flat_term2_135_x"; "gamma23_full8_x"; "gamma23_keep135_x";
   "mud_126_x_v1"; "mud_135_x_v1"; "vol3_x_sqrt"; "vol3f_x_lfun";
   "vol3f_x_sqrt2_lmplus"];;


let gg = [1; 2; 3; 4; 5; 6; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22; 23; 24;
   25; 26; 27; 28; 29; 30; 31; 32; 33; 34; 35; 36; 37; 38; 39; 40; 41; 42;
   43; 44; 45; 46; 47; 48; 49; 50; 51; 52; 53; 54; 55; 56; 57; 58; 59; 60;
   61; 62; 63; 64; 65; 66; 67; 68; 69; 70; 71; 72; 73; 74; 75; 76; 77; 78;
   79; 80; 81; 82; 83; 84; 85; 86; 87; 88; 89; 90; 91; 92; 93; 94; 95; 96;
   97; 98; 99; 100; 101; 102; 103; 104; 105; 106; 107; 108; 109; 110; 111;
   112; 113; 114; 115; 116; 117; 118; 119; 120; 121; 122; 123; 124; 125; 126;
   127; 128; 129; 130; 131; 132; 133; 134; 135; 136; 137; 138; 139; 140; 141;
   142; 143; 144; 145; 146; 147; 148; 149; 150; 151; 152; 153; 154; 155; 156;
   157; 158; 159; 160; 161; 162; 163; 164; 165; 166; 167; 168; 169; 170; 171;
   172; 175; 176; 177; 178; 179; 180; 181; 182; 183; 184; 185; 186; 187; 188;
   189; 190; 191; 192; 193; 194; 195; 196; 197; 198; 199; 200; 201; 202; 203;
   204; 205; 206; 207; 208; 209; 210; 211; 212; 213; 214; 215; 216; 217; 218;
   219; 220; 221; 222; 223; 224; 225; 226; 227; 228; 229; 230; 231; 232; 233;
   234; 235; 236; 237; 238; 239; 240; 241; 242; 243; 244; 245; 246; 247; 248;
   249; 250; 251; 252; 253; 254; 255; 256; 257; 258; 259; 261; 262; 263; 264;
   265; 266; 267; 268; 269; 270; 271; 272; 273; 274; 275; 276; 277; 278; 279;
   280; 281; 282; 283; 284; 285; 286; 287; 288; 289; 290; 291; 292; 293; 294;
   295; 296; 297; 298; 300; 301; 302; 303; 304; 305; 306; 307; 308; 309; 310;
   311; 312; 313; 314; 315; 316; 317; 318; 319; 320; 321; 322; 323; 324; 325;
   326; 330; 331; 332; 403; 404; 405; 411; 412; 413; 414; 415; 416; 419; 420;
   421; 422; 423; 424; 425; 426; 427; 428; 429; 430; 431; 432; 433; 434; 435;
   436; 437; 438; 439; 440; 441; 442; 443; 444; 445; 446; 447; 448; 449; 450;
   451; 452; 453; 454; 455; 456; 457; 458; 459; 460; 461; 462; 463; 464; 465;
   466; 467; 468; 469; 470; 471; 472; 473; 474; 475; 476; 477; 478; 479; 480;
   481; 482; 483; 484; 485; 486; 487; 488; 489; 490; 491; 492; 493; 494; 495;
   496; 497; 498; 499; 500; 501; 502; 503; 504; 505; 506; 507; 517; 518; 524;
   525; 526; 527; 528; 529; 530; 531; 532; 533; 534; 535; 582; 584; 588; 592;
   593; 594; 595; 596; 597; 598; 599; 600; 602; 603];;

  

let tt0  =  (nth_term 253);;
let delta_thm = find_domain tt0;;
g tt0;;
DELTA_TAC delta_thm

top_goal();;




let DELTA_TAC_DESIGN_GAME = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  REWRITE_TAC[arith `a * b * a * b = (a * b) * (a * b)`];
  REWRITE_TAC[Sphere.ineq] THEN REPEAT DISCH_TAC;
  COMMENT "delta_pos";
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ANTS_TAC;
    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
    EVERY x_lbs;
    EVERY x_ubs;
    BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST h_series THEN REAL_ARITH_TAC) THEN FAIL_TAC "1");
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
    EVERY x_poss;
    BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST h_series THEN REAL_ARITH_TAC));
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  DISCH_THEN kill;
  REPLICATE_TAC 2 (POP_ASSUM kill);
  ASM_TAC THEN REWRITE_TAC[GSYM Nonlinear_lemma.ineq_expand6];
  BY((GSPECL_TAC (List.rev Optimize.x6list)))

  ]);;
  (* }}} *)
fyn
Merge_ineq.square_x_4;;

(*
report (snd (Preprocess.preprocess1 "5744538693"));;
  open Break_case_exec;;
run_one false "prep-7823243247";;
*)
open Break_case_exec;;

  let pp () = 
    process_delta_pos_idv (random_elt delta_pos_idv);;

pp();;





map (fun i -> report (string_of_int i); Break_case_exec.get_nth_delta (100 *i)) (0--61) ;;
map (fun i ->
       report (string_of_int i); get_nth_delta (i)) (0-- (List.length all_delta_ok_parameters - 1)) ;;

delta_time /. total_time;;


  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Sphere.quadratic_root_plus];
  REWRITE_TAC[LET_THM];
  Calc_derivative.CALC_ID_TAC;
  TYPED_ABBREV_TAC `d = sqrt (b pow 2- &4 * a * c)`;
  ASM_REWRITE_TAC[];
  TYPIFY `b pow 2 - &4 * a * c = d pow 2` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "d";
    GMATCH_SIMP_TAC SQRT_POW_2;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[arith `~(&2 = &0)`];
  BY(ASM_TAC THEN CONV_TAC REAL_RING)

let s = List.nth delta_nok_idv 0;;

let t = (get_prep s).ineq;;
needs_delta_ineq1 t;;

filter (fun s ->
	  let t = (get_prep s).ineq in
	    not(needs_delta_ineq1 t)) delta_nok_idv;;

	  
g t;;
g (mk_imp(`delta_ineq_v6:bool`,t));;
PREP_TAC;;  
Z_TAC;;

top_goal();;
has_match;;
let dk = 
  let w = snd(top_goal()) in
  find (fun s -> has_match `delta_x x1 x2 x3 x4 x5 x6 + unit6 x1 x2 x3 x4 x5 x6 * -- y < &0` s)
    (disjuncts w);;

get_ineq "7550003505 0 1 3";;

map fst oxl_times;;
map fst delta_ok_times;;
alpha_idv;;

let bads = setify (List.flatten (map snd bad_cases));;

List.length bad_cases;;

let eta126_idq = 
  filter 
    (fun t -> Break_case_exec.some_const_name 
       (fun s -> mem s ["arclength_x_123"]) t.ineq)  tough_idq;;

List.length eta126_idq;;

eta126_idq;;

g (hd eta126_idq).ineq;;

PREP_TAC

map (fun idq -> ocaml_domain idq.ineq) eta126_idq;;
List.nth eta126_idq 9;;

map (fun t -> exists_domain t.ineq ) eta126_idq;;

let out126 = map run_alpha eta126_idq;;

get_ineq "prep-FHBVYXZ b split(0/2)";;

let etaout = filter (fun (_,t) -> some_const_name (fun s -> mem s ["mud_126_x_v1";"mud_135_x_v1";"mud_234_x_v1";"arclength_x1";"vol3_x_sqrt";"taud_x";"eta2_126";"eta2_135";"eta2_456"]) t)  out126;;

let (s,t) = hd etaout;;
let w = t;;
g t;;

  let has_eta126 = some_const_name ((=) "eta2_126") w ;;
  let has_eta135 = some_const_name ((=) "eta2_135") w ;;
  let has_eta456 = some_const_name ((=) "eta2_456") w ;;
  let TAC1 = if has_eta126 then POS_TAC `&0 < x1 /\ &0 < x2 /\ &0 < x6` else ALL_TAC ;;
PREP_TAC
TAC1  

let TAC2 = if has_eta135 then POS_TAC `&0 < x1 /\ &0 < x3 /\ &0 < x5` else ALL_TAC in
  let TAC3 = if has_eta456 then POS_TAC `&0 < x4 /\ &0 < x5 /\ &0 < x6` else ALL_TAC in
  let TAC0 = if has_eta126 or has_eta135 or has_eta456 then 
      INTRO_TAC eta_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`]
  else ALL_TAC in
    (TAC0 THEN TAC1 THEN TAC2 THEN TAC3 THEN SIMP_TAC[] THEN REPEAT(DISCH_THEN kill)) gl;;


  
List.length !Prep.prep_ineqs;;
Scripts.unfinished_cases();;
Scripts.finished_rejects;;
List.length alpha_idv + List.length really_tough_idv;;
List.length all_oxl_cases +
List.length reduced_prep_idq +
List.length tough_idq;;
List.length really_tough_idv;;
List.length delta_nok_idv;;
List.length !Prep.prep_ineqs;;

Scripts.times;;




(*
  conj
  EVERY [  art[] THEN    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY Break_case_exec.x_lbs;      EVERY Break_case_exec.x_ubs; rule (rr[arith `&4 * hminus = &2 * (&2 * hminus)`]);    (REPEAT STRIP_TAC THEN TRY (mmp (arith `x <= n - &1 ==> x < n`)) THEN TRY (FIRST_X_ASSUM MATCH_MP_TAC) THEN  TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST Break_case_exec.h_series THEN TRY REAL_ARITH_TAC))];

  comment "eta"
     let (_,w) = top_goal();;
  let d = disjuncts w ;;
    let fl = filter  (has_match `unit6 x1 x2 x3 x4 x5 x6 * c + eta_x x1 x3 x5 pow 2 * -- &1 <
    &0`) d;;
  let hdd = hd fl;;
  	if fl=[] then ALL_TAC gl else ... (hd fl) gl;;
  ASM_CASES_TAC (hdd) THENL [ ASM_REWRITE_TAC[];ALL_TAC]
  FIRST_X_ASSUM (MP_TAC o MATCH_MP eta135_x_bd);
  ONFIRST ANTS_TAC [  ARITH_TAC ];
  dt

  COMMENT "delta_via_ineq";;

  let d = disjuncts w ;;
      let fl = filter  (has_match `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
    delta4_squared_x x1 x2 x3 x4 x5 x6 * -- c <
    &0`) d;;
	if fl=[] then ALL_TAC gl else DELTA_TAC_PREP (hd fl) gl;;
      let hdd = hd fl;;
let DELTA_TAC_PREP d = 
  ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];
  FIRST_X_ASSUM (MP_TAC o MATCH_MP delta_ineq_delta4_x_squared2);
  PROVE_INEQ_TAC;
  comment "end delta_via_ineq";;
let DELTA1_TAC delta_thm = EVERY [
  COMMENT "delta_pos";
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [      ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY Break_case_exec.x_lbs;      EVERY Break_case_exec.x_ubs;      BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST Break_case_exec.h_series THEN REAL_ARITH_TAC))];

*)


(*
  ONFIRST ANTS_TAC [  art[] THEN    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY Break_case_exec.x_lbs;      EVERY Break_case_exec.x_ubs; rule (rr[arith `&4 * hminus = &2 * (&2 * hminus)`]);     (REPEAT STRIP_TAC THEN TRY (FIRST_X_ASSUM MATCH_MP_TAC) THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST Break_case_exec.h_series THEN TRY REAL_ARITH_TAC))];;
*)

(*
let DELTA2_TAC delta_thm = EVERY [
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [ PROVE_INEQ_TAC ];
  ];;
*)


map (fun s,_ -> (get_prep s).ineq) gamma_data;;
map (fun (s,_) -> 
       let t = (get_prep s).ineq in
	 (s,Break_case_exec.is_delta_pos t)) gamma_data;;


run_gamma "prep-IXPOTPA split(1/2)";;
get_prep "prep-IXPOTPA split(1/2)";;
run_gamma "prep-IXPOTPA split(0/2)";;
run_gamma "prep-TEWNSCJ split(1/2)";;
let s = "prep-IXPOTPA split(0/2)";;
let s = "prep-TEWNSCJ split(1/2)";;
let t = (Break_case_exec.get_prep s).ineq;;

let di = `delta_ineq_v6:bool`;;
let gt = if needs_delta_ineq2 t then mk_imp(di,t) else t;;

g gt;;
PREP_TAC;;
DTAC t;;
POST_DTAC;;
ETA126_TAC;;
ETA135_TAC;;
TRY FULL8_TAC;;
TRY KEEP135_TAC;;
REPLICATE_TAC 4 (POP_ASSUM kill);
POST_TAC;;


(*
  
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC) THENL [Break_case_exec.POSITIVE_DOMAIN_TAC;ALL_TAC];
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [    BY(ASM_REWRITE_TAC[]) ];
  SIMP_TAC[];
  DISCH_THEN kill;
  REPLICATE_TAC 2 (POP_ASSUM kill);
TAC;;
POST_TAC

*)

  
let _ = g gt in
  let _ = try e(PREP_TAC THEN Z_TAC THEN POST_TAC THEN TRY DISCH_TAC) with Failure m -> failwith (m^" "^s) in
  let a,w = top_goal() in
(*  let _ = (bad_names w = []) or failwith s in *)
  let _ = a = [] or a = [di] or failwith ("delta unexpected assumption: "^s) in 
  let data =   (s,List.length a,bad_names w) in
    w;;

let DELTA1_TAC delta_thm = EVERY [
  COMMENT "delta_pos";
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [      ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY Break_case_exec.x_lbs;      EVERY Break_case_exec.x_ubs;      BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST Break_case_exec.h_series THEN REAL_ARITH_TAC))];
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC) THENL [Break_case_exec.POSITIVE_DOMAIN_TAC;ALL_TAC];
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [    BY(ASM_REWRITE_TAC[]) ];
  SIMP_TAC[];
  DISCH_THEN kill;
  REPLICATE_TAC 2 (POP_ASSUM kill);
  ];;

run  { 
  idv= "prep-5744538693";
  doc="constant x1 min changed to 5 on 6/2014.";
  tags= [];
  ineq= `!x1 x2 x3 x4 x5 x6.
     ineq [&4,x1,&8; &4,x2,&7; &4,x3,&7; &8,x4,&28; &4,x5,&7; &4,x6,&7]
     (delta4_squared_x x1 x2 x3 x4 x5 x6 * -- &1 < &0 \/
      delta_x x1 x2 x3 x4 x5 x6 * -- &1 < &0)`;
};;

let is_enclosed = some_const_name (fun s -> s = "enclosed");;
is_enclosed (hd(Ineq.getexact "7043724150 a")).ineq;;
is_enclosed (hd(Ineq.getexact "7043724150 a reduced v2")).ineq;;

pack_nonlinear_non_ox3q1h;;

 /\ ox3q1h /\ 
     main_nonlinear_terminal_v11 /\ lp_ineqs /\ pack_ineq_def_a /\
    kcblrqc_ineq_def;;

let has_idq = filter (fun idq -> has_stv idq.ineq) !Ineq.ineqs;;

Preprocess.exec();;
Preprocess.prep_file;;
Scripts.remain_to_be_used;;
   flyspeck_needs "local/terminal.hl";;
   flyspeck_needs "local/lp_details.hl";;
open Terminal;;


help_grep "REAL_RAT";;

Nonlin_def.functional_overload();;




  let di = `delta_ineq_v6:bool`;;
  let s = "prep-7550003505 0 0 0";;
let t = (get_prep s).ineq;;
  let gt = if needs_delta_ineq1 t or needs_delta_ineq3 t then mk_imp(di,t) else t;;
  let gt = if needs_delta_ineq1 t then mk_imp(di,t) else t;;
g gt;; (* run1 *)
PREP_TAC
Z_TAC
DELTA_234_TAC


  let (_,w) = top_goal();;
let hdd = get_matching_disjunct `delta_234_x ((#2.0 * #1.26) * #2.0 * #1.26) (&4) (&4) x1 x2 x3 x4 x5 x6 +	unit6 x1 x2 x3 x4 x5 x6 * -- c < &0` w;;
	  ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];;  
	  FIRST_X_ASSUM (MP_TAC o MATCH_MP (UNDISCH_ALL delta_ineq_delta_234_x))
	  ONFIRST ANTS_TAC [ASM_TAC THEN REAL_ARITH_TAC];
let _ = g gt in
  let _ = try e(PREP_TAC THEN Z_TAC THEN POS_SIMP_TAC THEN POST_TAC THEN TRY DISCH_TAC) with Failure m -> failwith (m^" "^s) in
  let a,w = top_goal() in
(*  let _ = (bad_names w = []) or failwith s in *)
  let _ = a = [] or a = [di] or failwith ("delta unexpected assumption: "^s) in 
(*  let data =   (s,List.length a,bad_names w) in *)
    w (* data *);;

 Z_TAC gl;;
  let (_,w) = top_goal();;
  let d = disjuncts w ;;
    has_eulerA d;;
EULERA_TAC_PREP;;
 then EULERA_TAC_PREP gl else 
      if has_delta_234_x d then DELTA_234_TAC gl else
      let fl = filter  (has_match `delta_x x1 x2 x3 x4 x5 x6 + unit6 x1 x2 x3 x4 x5 x6 * -- y < &0`) d in
	if fl=[] then ALL_TAC gl else DELTA_TAC_PREP (hd fl) gl;;

let s = "prep-5429228381";;
let s = "prep-6723997360";;
let s = "prep-8293089898";;
let s = "prep-6723997360";;
  let di = `delta_ineq_v6:bool`;;
  let t = (get_prep s).ineq;;
  let gt = if needs_delta_ineq1 t or needs_delta_ineq2 t or needs_delta_ineq3 t then mk_imp(di,t) else t ;;
  let _ = g gt ;;
  PREP_TAC;;
  Z_TAC;;

let Z_TAC gl;;
  let (_,w) = top_goal ();;
  let d = disjuncts w ;;
     has_eulerA d;;
 then EULERA_TAC_PREP gl else ;;
       has_delta_234_x d ;;
then DELTA_234_TAC gl else;;
	  has_delta4_squared_x d;;
  let hdd = get_matching_disjunct `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
    delta4_squared_x x1 x2 x3 x4 x5 x6 * -- c <    &0` w;;
    EVERY [
      ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];
      FIRST_X_ASSUM (MP_TAC o MATCH_MP delta_ineq_delta4_x_squared2_wide);
      ONFIRST ANTS_TAC [ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[Sphere.h0] THEN REAL_ARITH_TAC];
    ] gl;;

	  EVERY [
	    DELTA_X1_TAC_WIDE;
	    POST_DTAC;
	    REPLICATE_TAC 2 (POP_ASSUM kill)];;

 gl else
	  let fl = filter  (has_match 
			      `delta_x x1 x2 x3 x4 x5 x6 + unit6 x1 x2 x3 x4 x5 x6 * -- y < &0`) d in
	    if fl=[] then ALL_TAC gl else DELTA_TAC_PREP (hd fl) gl;;
rat

(* timing stats

let oxl_times = filter (fun t,_ -> Str.string_match (Str.regexp "OXLZLEZ 6346351218 [1234]") t 0) (Scripts.times);;

let delta_ok_times  = 
  let preptime = map (fun (s,t) -> ("prep-"^s, t)) Scripts.times in
    filter (fun (s,_) -> mem s delta_ok_idv) preptime;;

let [oxl_time;delta_time;total_time] = map (Scripts.hour o Scripts.total) 
  [oxl_times;delta_ok_times;Scripts.times];;

*)


let tough_idq = Break_case_exec.tough_idq;;

let tough_idv = map (fun idq -> idq.idv) tough_idq;;
(*

let tough_names = 
  [
    "quad_cross_diag2_x";
    "arclength_x1";"arclength_x_123";
    "eta2_126";"eta2_135";"eta2_456";
    "taud_x";
    "mud_126_x_v1";"mud_135_x_v1";"mud_234_x_v1";
    "vol3f_x_lfun";"vol3f_x_sqrt2_lmplus";"vol3_x_sqrt";
    "gamma23_full8_x";
    "gamma23_keep135_x";
  ];;

let remain = [
    "gamma23_full8_x";
    "gamma23_keep135_x";
];; 
*)

(* CURRENT WORK, JUNE 2014 ******)

flyspeck_needs "nonlinear/break_case_exec.hl";;
open Break_case_exec;;
let random_elt ls = 
  let i = Random.int (List.length ls) in
    List.nth ls i;;

let test() = 
  let get = Break_case_exec.get_nth in
  let one i = (report (string_of_int i);  get i; ()) in
    setify (map one (7270--14062));;

let test4() = 
  let get = Break_case_exec.get_nth in
  let one _ = 
    let i = random_elt (0--23241) in
      (report (string_of_int i);  get i; ()) in
    map one (0--1000);;
  
test();;
1;;
Break_case_exec.get_nth (Break_case_exec.random_elt (0--23241));;
Break_case_exec.get_nth 14061;;


  let noarg f x = f;;
  let cases = 
    [("oxl",oxl_idv,noarg POSTPREP_OXL_634_TAC,noarg false);
     ("alpha",alpha_idv,get_alpha_tactic,noarg false);
     ("beta",beta_idv,get_beta_tactic,needs_beta);
     ("gamma",gamma_idv,get_gamma_tactic,needs_gamma);
     ("delta",delta_idv,get_delta_tactic,noarg false)];;
  let jj = 17033;;
  let (s,i) = List.nth all_parameters jj ;;
  let (sk,_,tac,need) = find (fun (_,ls,_,_)-> mem s ls) cases;;
  let run0 = run_generic (fun s -> tac s) need ;;
  let run0 = run_generic (fun s -> tac s THEN check_tac s) need ;;
    get_one_iarg run0 (s,i);;

List.length Break_case_exec.all_oxl_parameters
  + List.length Break_case_exec.all_delta_parameters;;
find (fun r -> r = (s,i)) all_delta_parameters;;
List.nth all_delta_parameters 0;;
    
get_nth 17033;;

let get_delta_tactic s = ;;
  let t = get_ineq s;;
  let inert = is_delta_inert t ;;
  let pos = is_delta_pos t ;;
  exists_domain t;;
  let _ = inert or pos or failwith ("delta series expected: "^s) in
  let TAC = if pos then DELTA_TAC (find_domain t) else ALL_TAC in
    TAC;;







