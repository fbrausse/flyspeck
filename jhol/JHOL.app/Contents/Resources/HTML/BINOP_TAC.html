<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>BINOP_TAC : tactic</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Breaks apart equation between binary operator applications into equality
between their arguments.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
Given a goal whose conclusion is an equation between applications of the same
curried binary function <SPAN CLASS=BRKT>f</SPAN>, the tactic <SPAN CLASS=BRKT>BINOP_TAC</SPAN> breaks it down to two
subgoals expressing equality of the corresponding arguments:
<DIV class=XMPL><PRE>
       A ?- f x1 y1 = f x2 y2
   ================================  BINOP_TAC
      A ?- x1 = x2    A ?- y1 = y2
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if the conclusion of the goal is not an equation between applications of
the same curried binary operator.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
We can set up the following goal which is an equation between applications of
the binary operator <SPAN CLASS=BRKT>+</SPAN>:

<DIV class=XMPL><PRE>
  # g `f(2 * x + 1) + w * z = f(SUC(x + 1) * 2 - 1) + z * w`;;
</PRE></DIV>
and it is simplest to prove if we split it up into two subgoals:
<DIV class=XMPL><PRE>
  # e BINOP_TAC;;
  val it : goalstack = 2 subgoals (2 total)

  `w * z = z * w`

  `f (2 * x + 1) = f (SUC (x + 1) * 2 - 1)`
</PRE></DIV>
the first of which can be solved by <SPAN CLASS=BRKT>ARITH_TAC</SPAN>, and the second by
<SPAN CLASS=BRKT>AP_TERM_TAC THEN ARITH_TAC</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="ABS_TAC.html">ABS_TAC</A>, <A href="AP_TERM_TAC.html">AP_TERM_TAC</A>, <A href="AP_THM_TAC.html">AP_THM_TAC</A>, <A href="MK_BINOP_UPPERCASE.html">MK_BINOP</A>, <A href="MK_COMB_TAC.html">MK_COMB_TAC</A>.


</DL>
