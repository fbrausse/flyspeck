<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>PROP_ATOM_CONV : conv -&gt; conv</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Applies a conversion to the `atomic subformulas' of a formula.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
When applied to a Boolean term, <SPAN CLASS=BRKT>PROP_ATOM_CONV conv</SPAN> descends recursively
through any number of the core propositional connectives `<SPAN CLASS=BRKT>~</SPAN>', `<SPAN CLASS=BRKT>/\</SPAN>', `<SPAN CLASS=BRKT>\/</SPAN>',
`<SPAN CLASS=BRKT>==></SPAN>' and `<SPAN CLASS=BRKT><=></SPAN>', as well as the quantifiers `<SPAN CLASS=BRKT>!x. p[x]</SPAN>', `<SPAN CLASS=BRKT>?x. p[x]</SPAN>' and
`<SPAN CLASS=BRKT>?!x. p[x]</SPAN>'. When it reaches a subterm that can no longer be decomposed into
any of those items (e.g. the starting term if it is not of Boolean type), the
conversion <SPAN CLASS=BRKT>conv</SPAN> is tried, with a reflexive theorem returned in case of
failure. That is, the conversion is applied to the ``atomic subformulas'' in
the usual sense of first-order logic.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
Here we swap all equations in a formula, but not any logical equivalences that
are part of its logical structure:
<DIV class=XMPL><PRE>
 # PROP_ATOM_CONV(ONCE_DEPTH_CONV SYM_CONV)
    `(!x. x = y ==> x = z) <=> (y = z <=> 1 + z = z + 1)`;;
  val it : thm =
    |- ((!x. x = y ==> x = z) <=> y = z <=> 1 + z = z + 1) <=>
       (!x. y = x ==> z = x) <=>
       z = y <=>
       z + 1 = 1 + z
</PRE></DIV>
By contrast, just <SPAN CLASS=BRKT>ONCE_DEPTH_CONV SYM_CONV</SPAN> would just swap the
top-level logical equivalence.

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Carefully constraining the application of conversions.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="DEPTH_BINOP_CONV.html">DEPTH_BINOP_CONV</A>, <A href="ONCE_DEPTH_CONV.html">ONCE_DEPTH_CONV</A>.


</DL>
