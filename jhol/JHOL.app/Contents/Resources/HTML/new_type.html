<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>new_type : string * int -&gt; unit</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Declares a new type or type constructor.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
A call <SPAN CLASS=BRKT>new_type("t",n)</SPAN> declares a new <SPAN CLASS=BRKT>n</SPAN>-ary type constructor called <SPAN CLASS=BRKT>t</SPAN>; if
<SPAN CLASS=BRKT>n</SPAN> is zero, this is just a new base type.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if HOL is there is already a type operator of that name in the current
theory.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
A version of ZF set theory might declare a new type <SPAN CLASS=BRKT>set</SPAN> and start using it as
follows:
<DIV class=XMPL><PRE>
  # new_type("set",0);;
  val it : unit = ()
  # new_constant("mem",`:set->set->bool`);;
  val it : unit = ()
  # parse_as_infix("mem",(11,"right"));;
  val it : unit = ()
  # let ZF_EXT = new_axiom `(!z. z mem x <=> z mem y) ==> (x = y)`;;
  val ( ZF_EXT ) : thm = |- (!z. z mem x <=> z mem y) ==> x = y
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>COMMENTS</SPAN><DD>
As usual, asserting new concepts is discouraged; if possible it is better to
use type definitions; see <SPAN CLASS=BRKT>new_type_definition</SPAN> and <SPAN CLASS=BRKT>define_type</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="define_type.html">define_type</A>, <A href="new_axiom.html">new_axiom</A>, <A href="new_constant.html">new_constant</A>, <A href="new_definition.html">new_definition</A>, <A href="new_type_definition.html">new_type_definition</A>.


</DL>
