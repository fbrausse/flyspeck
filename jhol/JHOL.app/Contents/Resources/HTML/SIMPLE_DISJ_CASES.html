<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>SIMPLE_DISJ_CASES : thm -&gt; thm -&gt; thm</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Disjoins hypotheses of two theorems with same conclusion.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
The rule <SPAN CLASS=BRKT>SIMPLE_DISJ_CASES</SPAN> takes two `case' theorems with alpha-equivalent
conclusions and returns a theorem with the first hypotheses disjoined:
<DIV class=XMPL><PRE>

        A u {p} |- r    B u {q} |- r
      ----------------------------------- SIMPLE_DISJ_CASES
            A u B u {p \/ q} |- r
</PRE></DIV>
To avoid dependency on the order of the hypotheses, it is only recommended when
each theorem has exactly one hypothesis:
<DIV class=XMPL><PRE>
         {p} |- r    {q} |- r
      ----------------------------------- SIMPLE_DISJ_CASES
                {p \/ q} |- r
</PRE></DIV>
For more sophisticated or-elimination, use <SPAN CLASS=BRKT>DISJ_CASES</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if the conclusions of the theorems are not alpha-equivalent.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
<DIV class=XMPL><PRE>
  # let [th1; th2] = map (UNDISCH o TAUT)
      [`~p ==> p ==> q`; `q ==> p ==> q`];;
  ...
  val th1 : thm = ~p |- p ==> q
  val th2 : thm = q |- p ==> q

  # SIMPLE_DISJ_CASES th1 th2;;
  val it : thm = ~p \/ q |- p ==> q
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="DISJ_CASES.html">DISJ_CASES</A>, <A href="DISJ_CASES_TAC.html">DISJ_CASES_TAC</A>, <A href="DISJ_CASES_THEN.html">DISJ_CASES_THEN</A>, <A href="DISJ_CASES_THEN2.html">DISJ_CASES_THEN2</A>, <A href="DISJ1.html">DISJ1</A>, <A href="DISJ2.html">DISJ2</A>.


</DL>
