<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>INT_OF_REAL_THM : thm -&gt; thm</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Map a universally quantified theorem from reals to integers.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
We often regard integers as a subset of the reals, so any universally
quantified theorem over the reals also holds for the integers, and indeed any
other subset. In HOL, integers and reals are completely separate types (<SPAN CLASS=BRKT>int</SPAN>
and <SPAN CLASS=BRKT>real</SPAN> respectively). However, there is a natural injection (actually
called <SPAN CLASS=BRKT>dest_int</SPAN>) from integers to reals that maps integer operations to their
real counterparts, and using this we can similarly show that any universally
quantified formula over the reals also holds over the integers with operations
mapped to the right type. The rule <SPAN CLASS=BRKT>INT_OF_REAL_THM</SPAN> embodies this procedure;
given a universally quantified theorem over the reals, it maps it to a
corresponding theorem over the integers.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
<DIV class=XMPL><PRE>
  # REAL_ABS_TRIANGLE;;
  val it : thm = |- !x y. abs (x + y) <= abs x + abs y
  # map dest_var (variables(concl it));;
  val it : (string * hol_type) list = [("y", `:real`); ("x", `:real`)]

  # INT_OF_REAL_THM REAL_ABS_TRIANGLE;;
  val it : thm = |- !x y. abs (x + y) <= abs x + abs y
  # map dest_var (variables(concl it));;
  val it : (string * hol_type) list = [("y", `:int`); ("x", `:int`)]
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="ARITH_RULE.html">ARITH_RULE</A>, <A href="INT_ARITH.html">INT_ARITH</A>, <A href="INT_ARITH_CONV.html">INT_ARITH_CONV</A>, <A href="INT_ARITH_TAC.html">INT_ARITH_TAC</A>, <A href="NUM_TO_INT_CONV.html">NUM_TO_INT_CONV</A>,
<A href="REAL_ARITH.html">REAL_ARITH</A>.


</DL>
