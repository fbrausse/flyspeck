<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>DISJ_CASES_TAC : thm_tactic</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Produces a case split based on a disjunctive theorem.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
Given a theorem <SPAN CLASS=BRKT>th</SPAN> of the form <SPAN CLASS=BRKT>A |- u \/ v</SPAN>, <SPAN CLASS=BRKT>DISJ_CASES_TAC th</SPAN>
applied to a goal
produces two subgoals, one with <SPAN CLASS=BRKT>u</SPAN> as an assumption and one with <SPAN CLASS=BRKT>v</SPAN>:
<DIV class=XMPL><PRE>
              A ?- t
   =================================  DISJ_CASES_TAC (A |- u \/ v)
    A u {u} ?- t   A u {v}?- t
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if the given theorem does not have a disjunctive conclusion.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
Given the simple fact about arithmetic <SPAN CLASS=BRKT>th</SPAN>, <SPAN CLASS=BRKT>|- m = 0 \/ (?n. m = SUC n)</SPAN>,
the tactic <SPAN CLASS=BRKT>DISJ_CASES_TAC th</SPAN> can be used to produce a case split:
<DIV class=XMPL><PRE>
  # let th = SPEC `m:num` num_CASES;;
  val th : thm = |- m = 0 \/ (?n. m = SUC n)

  # g `(P:num -> bool) m`;;
  Warning: Free variables in goal: P, m
  val it : goalstack = 1 subgoal (1 total)

  `P m`

  # e(DISJ_CASES_TAC th);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`?n. m = SUC n`]

  `P m`

   0 [`m = 0`]

  `P m`
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Performing a case analysis according to a disjunctive theorem.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="ASSUME_TAC.html">ASSUME_TAC</A>, <A href="ASM_CASES_TAC.html">ASM_CASES_TAC</A>, <A href="COND_CASES_TAC.html">COND_CASES_TAC</A>, <A href="DISJ_CASES_THEN.html">DISJ_CASES_THEN</A>, <A href="STRUCT_CASES_TAC.html">STRUCT_CASES_TAC</A>.


</DL>
