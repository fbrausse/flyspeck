<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>(THENL) : tactic -&gt; tactic list -&gt; tactic</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Applies a list of tactics to the corresponding subgoals generated by a tactic.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
If <SPAN CLASS=BRKT>t,t1,...,tn</SPAN> are tactics, <SPAN CLASS=BRKT>t THENL [t1;...;tn]</SPAN> is a tactic which applies
<SPAN CLASS=BRKT>t</SPAN> to a goal, and if it does not fail, applies the tactics <SPAN CLASS=BRKT>t1,...,tn</SPAN> to the
corresponding subgoals, unless <SPAN CLASS=BRKT>t</SPAN> completely solves the goal.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
The application of <SPAN CLASS=BRKT>THENL</SPAN> to a tactic and tactic list never fails.
The resulting tactic fails if <SPAN CLASS=BRKT>t</SPAN> fails when applied to the goal, or if
the goal list is not empty and its length is not the same as that of the
tactic list, or finally if <SPAN CLASS=BRKT>ti</SPAN> fails when applied to the <SPAN CLASS=BRKT>i</SPAN>'th subgoal
generated by <SPAN CLASS=BRKT>t</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
If we want to prove the inbuilt theorem <SPAN CLASS=BRKT>LE_LDIV</SPAN> ourselves:
<DIV class=XMPL><PRE>
  # g `!a b n. ~(a = 0) /\ b <= a * n ==> b DIV a <= n`;;
  ...
</PRE></DIV>
we may start by proving a lemma <SPAN CLASS=BRKT>n = (a * n) DIV a</SPAN> from the given
hypotheses. The following step generates two subgoals:
<DIV class=XMPL><PRE>
  # e(REPEAT STRIP_TAC THEN SUBGOAL_THEN `n = (a * n) DIV a` SUBST1_TAC);;
  val it : goalstack = 2 subgoals (2 total)

   0 [`~(a = 0)`]
   1 [`b <= a * n`]

  `b DIV a <= (a * n) DIV a`

   0 [`~(a = 0)`]
   1 [`b <= a * n`]

  `n = (a * n) DIV a`
</PRE></DIV>
Each subgoal has a relatively short proof, but these proofs are quite
different. We can combine them with the initial tactic above using <SPAN CLASS=BRKT>THENL</SPAN>, so
the following would solve the initial goal:
<DIV class=XMPL><PRE>
  # e(REPEAT STRIP_TAC THEN SUBGOAL_THEN `n = (a * n) DIV a` SUBST1_TAC THENL
      [ASM_SIMP_TAC[DIV_MULT]; MATCH_MP_TAC DIV_MONO THEN ASM_REWRITE_TAC[]]);;
</PRE></DIV>
Note that it is quite a common situation for the same tactic to be applied to
all generated subgoals. In that case, you can just use <SPAN CLASS=BRKT>THEN</SPAN>, e.g. in the
proof of the pre-proved theorem <SPAN CLASS=BRKT>ADD_0</SPAN>:
<DIV class=XMPL><PRE>
  # g `!m. m + 0 = m`;;
  ...
  # e(INDUCT_TAC THEN ASM_REWRITE_TAC[ADD]);;
  val it : goalstack = No subgoals
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Applying different tactics to different subgoals.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="EVERY.html">EVERY</A>, <A href="ORELSE.html">ORELSE</A>, <A href="THEN.html">THEN</A>.


</DL>
