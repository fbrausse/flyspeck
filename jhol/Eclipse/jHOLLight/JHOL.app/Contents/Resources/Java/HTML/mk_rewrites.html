<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>mk_rewrites : bool -&gt; thm -&gt; thm list -&gt; thm list</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Turn theorem into list of (conditional) rewrites.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
Given a Boolean flag <SPAN CLASS=BRKT>b</SPAN>, a theorem <SPAN CLASS=BRKT>th</SPAN> and a list of theorems <SPAN CLASS=BRKT>thl</SPAN>, the call
<SPAN CLASS=BRKT>mk_rewrites b th thl</SPAN> breaks <SPAN CLASS=BRKT>th</SPAN> down into a collection of rewrites (for
example, splitting conjunctions up into several sub-theorems) and appends them
to the front of <SPAN CLASS=BRKT>thl</SPAN> (which are normally theorems already processed in this
way). Non-equational theorems <SPAN CLASS=BRKT>|- p</SPAN> are converted to <SPAN CLASS=BRKT>|- p <=> T</SPAN>. If the flag
<SPAN CLASS=BRKT>b</SPAN> is true, then implicational theorems <SPAN CLASS=BRKT>|- p ==> s = t</SPAN> are used as
conditional rewrites; otherwise they are converted to <SPAN CLASS=BRKT>|- (p ==> s = t) <=> T</SPAN>.
This function is applied inside <SPAN CLASS=BRKT>extend_basic_rewrites</SPAN> and
<SPAN CLASS=BRKT>set_basic_rewrites</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
<DIV class=XMPL><PRE>
  # ADD_CLAUSES;;
  val it : thm =
    |- (!n. 0 + n = n) /\
       (!m. m + 0 = m) /\
       (!m n. SUC m + n = SUC (m + n)) /\
       (!m n. m + SUC n = SUC (m + n))

  # mk_rewrites false ADD_CLAUSES [];;
  val it : thm list =
    [|- 0 + n = n; |- m + 0 = m; |- SUC m + n = SUC (m + n);
     |- m + SUC n = SUC (m + n)]
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="extend_basic_rewrites.html">extend_basic_rewrites</A>, <A href="GEN_REWRITE_CONV.html">GEN_REWRITE_CONV</A>, <A href="REWRITE_CONV.html">REWRITE_CONV</A>, <A href="set_basic_rewrites.html">set_basic_rewrites</A>,
<A href="SIMP_CONV.html">SIMP_CONV</A>.


</DL>
