<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>define_finite_type : int -&gt; thm</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Defines a new type of a specified finite size.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
The call <SPAN CLASS=BRKT>define_finite_type n</SPAN> where <SPAN CLASS=BRKT>n</SPAN> is a positive integer defines a new
type also called simply `<SPAN CLASS=BRKT>n</SPAN>', and returns a theorem asserting that its
universe has size <SPAN CLASS=BRKT>n</SPAN>, in the form:
<DIV class=XMPL><PRE>
  |- (:n) HAS_SIZE n
</PRE></DIV>
where <SPAN CLASS=BRKT>(:n)</SPAN> is the customary HOL Light printing of the universe set
<SPAN CLASS=BRKT>UNIV:n->bool</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if <SPAN CLASS=BRKT>n</SPAN> is zero or negative, or if there is a type of the same name
(unless it was also defined by the same call for <SPAN CLASS=BRKT>define_finite_type</SPAN>, which is
perfectly permissible), or if the names of the type constructor and destructor
functions are already in use:
<DIV class=XMPL><PRE>
  mk_auto_define_finite_type_n:num->n
  dest_auto_define_finite_type_n:32->num
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
Here we define a 32-element type, perhaps useful for indexing the bits of a
word:
<DIV class=XMPL><PRE>
  # define_finite_type 32;;
  val it : thm = |- (:32) HAS_SIZE 32
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
In conjunction with Cartesian powers such as <SPAN CLASS=BRKT>real^3</SPAN>, where only the size of
the indexing type is relevant and the simple name <SPAN CLASS=BRKT>n</SPAN> is intuitive.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="define_type.html">define_type</A>, <A href="new_type_definition.html">new_type_definition</A>.


</DL>
