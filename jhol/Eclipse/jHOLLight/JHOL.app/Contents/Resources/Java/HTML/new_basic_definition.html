<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>new_basic_definition : term -&gt; thm</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Makes a simple new definition of the form <SPAN CLASS=BRKT>c = t</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
If <SPAN CLASS=BRKT>t</SPAN> is a closed term and <SPAN CLASS=BRKT>c</SPAN> a variable whose name has not been used as a
constant, then <SPAN CLASS=BRKT>new_basic_definition `c = t`</SPAN> will define a new constant <SPAN CLASS=BRKT>c</SPAN>
and return the theorem <SPAN CLASS=BRKT>|- c = t</SPAN> for that new constant (not the variable in
the given term). There is an additional restriction that all type variables
involved in <SPAN CLASS=BRKT>t</SPAN> must occur in the constant's type.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if <SPAN CLASS=BRKT>c</SPAN> is already a constant.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
Here is a simple example
<DIV class=XMPL><PRE>
  # let googolplex = new_basic_definition
     `googolplex = 10 EXP (10 EXP 100)`;;
  val googolplex : thm = |- googolplex = 10 EXP (10 EXP 100)
</PRE></DIV>
and of course we can equally well use logical equivalence:
<DIV class=XMPL><PRE>
  # let true_def = new_basic_definition `true <=> T`;;
  val true_def : thm = |- true <=> T
</PRE></DIV>
The following example helps to explain why the restriction on type
variables is present:
<DIV class=XMPL><PRE>
  # new_basic_definition `trivial <=> !x y:A. x = y`;;
  Exception:
  Failure "new_definition: Type variables not reflected in constant".
</PRE></DIV>
If we had been allowed to get back a definitional theorem, we could separately
type-instantiate it to the 1-element type <SPAN CLASS=BRKT>1</SPAN> and the 2-element type <SPAN CLASS=BRKT>bool</SPAN>. In
one case the RHS is true, and in the other it is false, yet both are asserted
equal to the constant <SPAN CLASS=BRKT>trivial</SPAN>.

<P><DT><SPAN CLASS=FIELD-NAME>COMMENTS</SPAN><DD>
There are simpler or more convenient ways of making definitions, such as
<SPAN CLASS=BRKT>define</SPAN> and <SPAN CLASS=BRKT>new_definition</SPAN>, but this is the primitive principle underlying
them all.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="define.html">define</A>, <A href="new_definition.html">new_definition</A>, <A href="new_inductive_definition.html">new_inductive_definition</A>, <A href="new_recursive_definition.html">new_recursive_definition</A>,
<A href="new_specification.html">new_specification</A>.


</DL>
