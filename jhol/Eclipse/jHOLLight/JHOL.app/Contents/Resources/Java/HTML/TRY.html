<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>TRY : tactic -&gt; tactic</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Makes a tactic have no effect rather than fail.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
For any tactic <SPAN CLASS=BRKT>t</SPAN>, the application <SPAN CLASS=BRKT>TRY t</SPAN> gives a new tactic
which has the same effect as <SPAN CLASS=BRKT>t</SPAN> if that succeeds, and otherwise has
no effect.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
The application of <SPAN CLASS=BRKT>TRY</SPAN> to a tactic never fails. The resulting
tactic never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
We might want to try a certain tactic ``speculatively'', even if we're not sure
that it will work, for example, to handle the ``easy'' subgoals from breaking
apart a large conjunction. On a small scale, we might want to prove:
<DIV class=XMPL><PRE>
  # g `(x + 1) EXP 2 = x EXP 2 + 2 * x + 1 /\
       (x EXP 2 = y EXP 2 ==> x = y) /\
       (x < y ==> 2 * x + 1 < 2 * y)`;;
  ...
</PRE></DIV>
and just see which conjuncts we can get rid of automatically by
<SPAN CLASS=BRKT>ARITH_TAC</SPAN>. It turns out that it only leaves one subgoal with some nonlinear
reasoning:
<DIV class=XMPL><PRE>
  # e(REPEAT CONJ_TAC THEN TRY ARITH_TAC);;
  val it : goalstack = 1 subgoal (1 total)

  `x EXP 2 = y EXP 2 ==> x = y`
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="CHANGED_TAC.html">CHANGED_TAC</A>, <A href="VALID.html">VALID</A>.


</DL>
