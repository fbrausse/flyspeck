<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>list_mk_binop : term -&gt; term list -&gt; term</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Makes an iterative application of a binary operator.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
The call <SPAN CLASS=BRKT>list_mk_binop op [t1; ...; tn]</SPAN> constructs the term
<SPAN CLASS=BRKT>op t1 (op t2 (op ... (op tn-1 tn) ...)))</SPAN>. If we think of <SPAN CLASS=BRKT>op</SPAN> as an infix
operator we can write it <SPAN CLASS=BRKT>t1 op t2 op t3 ... op tn</SPAN>, but the call will work for
any term <SPAN CLASS=BRKT>op</SPAN> compatible with all the types.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Fails if the list of terms is empty or if the types would not work for the
composite term. In particular, if the list contains at least three items, all
the types must be the same.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
This example is typical:
<DIV class=XMPL><PRE>
  # list_mk_binop `(+):num->num->num` (map mk_small_numeral (1--10));;
  val it : term = `1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10`
</PRE></DIV>
while these show that for smaller lists, one can just regard it as
<SPAN CLASS=BRKT>mk_comb</SPAN> or <SPAN CLASS=BRKT>mk_binop</SPAN>:
<DIV class=XMPL><PRE>
  # list_mk_binop `SUC` [`0`];;
  val it : term = `0`

   # list_mk_binop `f:A->B->C` [`x:A`; `y:B`];;
  val it : term = `f x y`
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="binops.html">binops</A>, <A href="MK_BINOP_UPPERCASE.html">mk_binop</A>.


</DL>
