<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>parse_as_infix : string * (int * string) -&gt; unit</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Adds identifier to list of infixes, with given precedence and associativity.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
Certain identifiers are treated as infix operators with a given precedence and
associativity (left or right). The call <SPAN CLASS=BRKT>parse_as_infix("op",(p,a))</SPAN> adds <SPAN CLASS=BRKT>op</SPAN>
to the infix operators with precedence <SPAN CLASS=BRKT>p</SPAN> and associativity <SPAN CLASS=BRKT>a</SPAN> (it should be
one of the two strings <SPAN CLASS=BRKT>"left"</SPAN> or <SPAN CLASS=BRKT>"right"</SPAN>). Note that the infix status is
based purely on the name, which can be alphanumeric or symbolic, and does not
depend on whether the name denotes a constant.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails; if the given string was already an infix, its precedence and
associativity are changed to the new values.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
<DIV class=XMPL><PRE>
  # strip_comb `n choose k`;;
  Warning: inventing type variables
  val it : term * term list = (`n`, [`choose`; `k`])

  # parse_as_infix("choose",(22,"right"));;
  val it : unit = ()
  # strip_comb `n choose k`;;
  Warning: inventing type variables
  val it : term * term list = (`(choose)`, [`n`; `k`])
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Adding user-defined binary operators.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="get_infix_status.html">get_infix_status</A>, <A href="infixes.html">infixes</A>, <A href="unparse_as_infix.html">unparse_as_infix</A>.


</DL>
