<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>aconv : term -&gt; term -&gt; bool</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Tests for alpha-convertibility of terms.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
When applied to two terms, <SPAN CLASS=BRKT>aconv</SPAN> returns <SPAN CLASS=BRKT>true</SPAN> if they are
alpha-convertible, and <SPAN CLASS=BRKT>false</SPAN> otherwise.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
A simple case of alpha-convertibility is the renaming of a single quantified
variable:
<DIV class=XMPL><PRE>
  # aconv `?x. x <=> T` `?y. y <=> T`;;
  val it : bool = true
</PRE></DIV>
but other cases can be more involved:
<DIV class=XMPL><PRE>
# aconv `\x y z. x + y + z` `\y x z. y + x + z`;;
val it : bool = true
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>COMMENTS</SPAN><DD>
The code for alpha-conversion first checks for simple equality with pointer
equality shortcutting, and can therefore often returns <SPAN CLASS=BRKT>true</SPAN> without a full
traversal.

In principle, most of the HOL Light deductive apparatus should work modulo
alpha-conversion. At least, all the primitive inference rules do.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="ALPHA_UPPERCASE.html">ALPHA</A>, <A href="ALPHA_CONV.html">ALPHA_CONV</A>.


</DL>
