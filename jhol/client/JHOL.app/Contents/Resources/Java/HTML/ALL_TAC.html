<link rel = "stylesheet" href = "hollightref.css">
<DIV class=TYPE><PRE>ALL_TAC : tactic</PRE></DIV>
<DL>

<P><DT><SPAN CLASS=FIELD-NAME>SYNOPSIS</SPAN><DD>
Passes on a goal unchanged.

<P><DT><SPAN CLASS=FIELD-NAME>DESCRIPTION</SPAN><DD>
<SPAN CLASS=BRKT>ALL_TAC</SPAN> applied to a goal <SPAN CLASS=BRKT>g</SPAN> simply produces the subgoal list <SPAN CLASS=BRKT>[g]</SPAN>. It is
the identity for the <SPAN CLASS=BRKT>THEN</SPAN> tactical.

<P><DT><SPAN CLASS=FIELD-NAME>FAILURE CONDITIONS</SPAN><DD>
Never fails.

<P><DT><SPAN CLASS=FIELD-NAME>EXAMPLE</SPAN><DD>
Suppose we want to solve the goal:
<DIV class=XMPL><PRE>
  # g `~(n MOD 2 = 0) <=> n MOD 2 = 1`;;
  ...
</PRE></DIV>
We could just solve it with <SPAN CLASS=BRKT>e ARITH_TAC</SPAN>, but suppose we want to introduce a
little lemma that <SPAN CLASS=BRKT>n MOD 2 < 2</SPAN>, proving that by <SPAN CLASS=BRKT>ARITH_TAC</SPAN>. We could do
<DIV class=XMPL><PRE>
  # e(SUBGOAL_THEN `n MOD 2 < 2` ASSUME_TAC THENL
       [ARITH_TAC;
        ...rest of proof...]);;
</PRE></DIV>
However if we split off many lemmas, we get a deeply nested proof structure
that's a bit confusing. In cases where the proofs of the lemmas are trivial
one-liners like this we might just want to keep the proof basically linear with
<DIV class=XMPL><PRE>
  # e(SUBGOL_THEN `n MOD 2 < 2` ASSUME_TAC THENL [ARITH_TAC; ALL_TAC] THEN
      ...rest of proof...);;
</PRE></DIV>

<P><DT><SPAN CLASS=FIELD-NAME>USES</SPAN><DD>
Keeping proof structures linear, as in the above example, or convenient
algebraic combinations in complicated tactic structures.

<P><DT><SPAN CLASS=FIELD-NAME>SEE ALSO</SPAN><DD>
<A href="NO_TAC.html">NO_TAC</A>, <A href="REPEAT_UPPERCASE">REPEAT</A>, <A href="THENL.html">THENL</A>.


</DL>
