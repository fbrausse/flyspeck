Lemma is_true_true : `T`. done. Qed.
Lemma not_false_is_true : `~F`. done. Qed.
"let isT = is_true_true".
"let notF = not_false_is_true".

Lemma negbT b : `(b = F) ==> ~b`. done. Qed.
Lemma negbTE b: `~b ==> b = F`. done. Qed.
Lemma negbF b: `b ==> ~b = F`. done. Qed.
Lemma negbFE b: `~b = F ==> b`. done. Qed.
Lemma negbK b: `~ ~b = b`. done. Qed.
Lemma negbNE b: `~ ~ b ==> b`. done. Qed.
Lemma negb_inj b1 b2: `~b1 = ~b2 ==> b1 = b2`. by case: b1; case: b2 => /=. Qed.
Lemma negbLR b c: `b = ~c ==> ~b = c`. by move => ->; rewrite negbK. Qed.
Lemma negbRL b c: `~b = c ==> b = ~c`. by move => <-; rewrite negbK. Qed.

Lemma contra c b: `(c ==> b) ==> ~b ==> ~c`. case: b; case: c => /=. Qed.
"let contraNN = contra".
Lemma contraL c b: `(c ==> ~b) ==> b ==> ~c`.
move => h.
by move: (contra h); rewrite negbK.
Qed.

Lemma contraR c b: `(~c ==> b) ==> ~b ==> c`.
move => h.
by move: (contra h); rewrite negbK.
Qed.

Lemma contraLR c b: `(~c ==> ~b) ==> b ==> c`.
move => h.
by move: (contra h); rewrite !negbK.
Qed.

Lemma contraT b: `(~b ==> F) ==> b`. done. Qed.
Lemma wlog_neg b: `(~b ==> b) ==> b`. case: b => /=. Qed.

Lemma contraFT c b: `(~c ==> b) ==> b = F ==> c`. case: b; case: c => /=. Qed.

Lemma contraFN c b: `(c ==> b) ==> b = F ==> ~c`. case: b; case: c => /=. Qed.

Lemma contraTF c b: `(c ==> ~b) ==> b ==> c = F`. case: b; case: c => /=. Qed.

Lemma contraNF c b: `(c ==> b) ==> ~b ==> c = F`. case: b; case: c => /=. Qed.

Lemma contraFF c b: `(c ==> b) ==> b = F ==> c = F`. case: b; case: c => /=. Qed.

Section BoolIf.
Variables vT vF : `:A`.
Variable f : `:A -> B`.
Variable b : `:bool`.


Lemma if_same : `(if b then vT else vT) = vT`.
by case: b => /=. Qed.

Lemma if_neg : `(if ~b then vT else vF) = if b then vF else vT`.
by case: b => /=. Qed.

Lemma fun_if : `f (if b then vT else vF) = if b then f vT else f vF`.
by case: b => /=. Qed.

Lemma if_arg fT fF x : `(if b then (fT:A->B) else fF) x = if b then fT x else fF x`.
by case: b => /=. Qed.

End BoolIf.


Lemma andTb b: `(T /\ b) = b`. done. Qed.
Lemma andFb b: `(F /\ b) = F`. done. Qed.
Lemma andbT b: `(b /\ T) = b`. done. Qed.
Lemma andbF b: `(b /\ F) = F`. done. Qed.
Lemma andbb b: `(b /\ b) = b`. done. Qed.
Lemma andbC b c: `(b /\ c) = (c /\ b)`. by case: b; case: c => /=. Qed.
Lemma andbA b c p: `b /\ (c /\ p) <=> (b /\ c) /\ p`. by case: b; case: c => /=. Qed.
Lemma andbCA b c p: `b /\ (c /\ p) <=> c /\ (b /\ p)`. by case: b; case: c => /=. Qed.
Lemma andbAC b c p: `(b /\ c) /\ p <=> (b /\ p) /\ c`. by case: b; case: c => /=. Qed.

Lemma orTb b: `T \/ b <=> T`. done. Qed.
Lemma orFb b: `F \/ b <=> b`. done. Qed.
Lemma orbT b: `b \/ T <=> T`. done. Qed.
Lemma orbF b: `b \/ F <=> b`. done. Qed.
Lemma orbb b: `b \/ b <=> b`. done. Qed.
Lemma orbC b c: `b \/ c <=> c \/ b`. by case: b; case: c => /=. Qed.
Lemma orbA b c p: `b \/ (c \/ p) <=> (b \/ c) \/ p`. by case: b; case: c => /=. Qed.
Lemma orbCA b c p: `b \/ (c \/ p) <=> c \/ (b \/ p)`. by case: b; case: c => /=. Qed.
Lemma orbAC b c p: `(b \/ c) \/ p <=> (b \/ p) \/ c`. by case: b; case: c => /=. Qed.

Lemma andbN b: `b /\ ~b <=> F`. by case: b => /=. Qed.
Lemma andNb b: `~b /\ b <=> F`. by case: b => /=. Qed.

Lemma orbN b: `b \/ ~b <=> T`. by case: b => /=. Qed.
Lemma orNb b: `~b \/ b <=> T`. by case: b => /=. Qed.

Lemma andb_orl b c p: `(b \/ c) /\ p <=> (b /\ p) \/ (c /\ p)`.
by case: b; case: c => /=. Qed.

Lemma andb_orr b c p: `b /\ (c \/ p) <=> (b /\ c) \/ (b /\ p)`.
by case: b; case: c => /=. Qed.

Lemma orb_andl b c p: `(b /\ c) \/ p <=> (b \/ p) /\ (c \/ p)`.
by case: b; case: c => /=. Qed.

Lemma orb_andr b c p: `b \/ (c /\ p) <=> (b \/ c) /\ (b \/ p)`.
by case: b; case: c => /=. Qed.

Lemma andb_idl a b: `(b ==> a) ==> (a /\ b <=> b)`.
by case: a; case: b => /=. Qed.

Lemma andb_idr a b: `(a ==> b) ==> (a /\ b <=> a)`.
by case: a; case: b => /=. Qed.

Lemma andb_id2l a b c: `(a ==> (b <=> c)) ==> (a /\ b <=> a /\ c)`.
by case: a=> /=. Qed.

Lemma andb_id2r a b c: `(b ==> (a <=> c)) ==> (a /\ b <=> c /\ b)`.
by case: a; case: b => /=. Qed.

Lemma orb_idl a b : `(a ==> b) ==> (a \/ b <=> b)`.
by case: a => /=. Qed.

Lemma orbb_idr a b : `(b ==> a) ==> (a \/ b <=> a)`. by case: a => /=. Qed.
Lemma orb_id2l a b c : `(~ a ==> (b <=> c)) ==> (a \/ b <=> a \/ c)`. by case: a => /=. Qed.
Lemma orb_id2r a b c : `(~ b ==> (a <=> c)) ==> (a \/ b <=> c \/ b)`.
by case: a; case: b => /=. Qed.

Lemma negb_and a b : `~ (a /\ b) <=> ~ a \/ ~ b`. by case: a => /=. Qed.

Lemma negb_or a b : `~ (a \/ b) <=> ~ a /\ ~ b`. by case: a => /=. Qed.


Lemma andbK a b : `((a /\ b) \/ a) = a`. by case: a => /=. Qed.

Lemma andKb a b : `a \/ b /\ a <=> a`. by case: a => /=. Qed.

Lemma orbK a b : `(a \/ b) /\ a <=> a`. by case: a => /=. Qed.

Lemma orKb a b : `a /\ (b \/ a) <=> a`. by case: a => /=. Qed.

Lemma implybT b : `b ==> T`. done. Qed.

Lemma implybF b : `(b ==> F) <=> ~ b`. done. Qed.

Lemma implyFb b : `F ==> b`. done. Qed.

Lemma implyTb b : `(T ==> b) <=> b`. done. Qed.

Lemma implybb b : `b ==> b`. done. Qed.

Lemma negb_imply a b : `~ (a ==> b) <=> a /\ ~ b`. by case: a => /=. Qed.

Lemma implybE a b : `(a ==> b) <=> ~ a \/ b`. by case: a => /=. Qed.

Lemma implyNb a b : `(~ a ==> b) <=> a \/ b`. by case: a => /=. Qed.

Lemma implybN a b : `(a ==> ~ b) <=> (b ==> ~ a)`. by case: a => /=. Qed.

Lemma implybNN a b : `(~ a ==> ~ b) <=> b ==> a`. by case: a => /=. Qed.

Lemma implyb_idl a b : `(~ a ==> b) ==> ((a ==> b) <=> b)`. by case: a => /=. Qed.
Lemma implyb_idr a b : `(b ==> ~ a) ==> ((a ==> b) <=> ~ a)`. by case: a => /=. Qed.
Lemma implyb_id2l a b c : `(a ==> (b <=> c)) ==> ((a ==> b) <=> (a ==> c))`.
by case: a => /=. Qed.


(* XOR *)

"let XOR_DEF = new_definition `XOR p q = if p then ~q else q`".
"overload_interface(\"+\", `XOR`)".

Lemma addFb b: `F + b <=> b`. by rewrite XOR_DEF. Qed.

Lemma addbF b: `b + F <=> b`. by rewrite XOR_DEF; case: b => /=. Qed.

Lemma addbb b: `b + b <=> F`. by rewrite XOR_DEF; case: b => /=. Qed.

Lemma addbC b c: `b + c <=> c + b`.
by rewrite !XOR_DEF; case: b; case: c => -> ->/=. Qed.

Lemma addbA a b c: `a + (b + c) <=> (a + b) + c`.
rewrite !XOR_DEF; case: b; case: c; case: a => -> -> -> /=. Qed.

Lemma addbCA a b c: `(a + b) + c <=> (a + c) + b`.
rewrite !XOR_DEF; case: b; case: c; case: a => -> -> -> /=. Qed.

Lemma addbAC a b c: `a + (b + c) <=> b + (a + c)`.
rewrite !XOR_DEF; case: b; case: c; case: a => -> -> -> /=. Qed.

Lemma andb_addl a b c: `(a + b) /\ c <=> (a /\ c) + (b /\ c)`.
rewrite !XOR_DEF; case: b; case: c; case: a => -> -> -> /=. Qed.

Lemma andb_addr a b c: `a /\ (b + c) <=> (a /\ b) + (a /\ c)`.
rewrite !XOR_DEF; case: b; case: c; case: a => -> -> -> /=. Qed.

Lemma addKb x y: `x + (x + y) <=> y`.
rewrite !XOR_DEF; case: x; case: y => -> -> /=. Qed.

Lemma addbK x y: `(y + x) + x <=> y`.
rewrite !XOR_DEF; case: x; case: y => -> -> /=. Qed.

Lemma addIb x y1 y2: `(y1 + x <=> y2 + x) ==> (y1 = y2)`.
rewrite !XOR_DEF; case: y1; case: y2; case: x => -> -> -> /=. Qed.

Lemma addbI x y1 y2: `(x + y1 <=> x + y2) ==> (y1 = y2)`.
rewrite !XOR_DEF; case: x; case: y1; case: y2 => -> -> -> /=. Qed.

Lemma addTb b : `T + b <=> ~b`.
by rewrite XOR_DEF //. Qed.

Lemma addbT b : `b + T <=> ~ b`.
by rewrite XOR_DEF; case: b => -> /=. Qed.

Lemma addbN a b : `a + ~ b <=> ~ (a + b)`.
rewrite !XOR_DEF; case: a; case: b => -> -> /=. Qed.

Lemma addNb a b : `~ a + b <=> ~ (a + b)`.
rewrite !XOR_DEF; case: a; case: b => -> -> /=. Qed.








