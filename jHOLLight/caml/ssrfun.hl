let oapp = define `!f x y. oapp f x (SOME y) = f y /\ oapp f x NONE = x`;;
let odflt = new_definition `odflt = oapp I`;;
let obind = new_definition `obind f = oapp f NONE`;;
let omap = new_definition `omap f = obind (\x. SOME (f x))`;;
let pcomp = new_definition `pcomp f g x = obind f (g x)`;;
(start_section_proof ["x"](`(!y. odflt x (SOME y) = y) /\ odflt x NONE = x`));;
refine (by (VALID (((((USE_THM_THEN odflt)(new_rewrite [] [])) THEN repeat_tactic 1 9 (((USE_THM_THEN oapp)(new_rewrite [] []))) THEN ((USE_THM_THEN I_THM)(new_rewrite [] []))) THEN (done_tac)))));;
let odflt_alt = end_section_proof();;
(start_section_proof ["f"](`obind f NONE = NONE /\ (!x. obind f (SOME x) = f x)`));;
refine (by (VALID (((((USE_THM_THEN obind)(new_rewrite [] [])) THEN repeat_tactic 1 9 (((USE_THM_THEN oapp)(new_rewrite [] [])))) THEN (done_tac)))));;
let obind_alt = end_section_proof();;
(start_section_proof ["f"](`omap f NONE = NONE /\ (!x. omap f (SOME x) = SOME (f x))`));;
refine (by (VALID (((((USE_THM_THEN omap)(new_rewrite [] [])) THEN ((USE_THM_THEN obind)(new_rewrite [] [])) THEN repeat_tactic 1 9 (((USE_THM_THEN oapp)(new_rewrite [] [])))) THEN (done_tac)))));;
let omap_alt = end_section_proof();;
(start_section_proof ["x";"y"](`x = y ==> y = x`));;
refine (by (VALID (((BETA_TAC THEN (DISCH_THEN(new_rewrite [] []))) THEN (done_tac)))));;
let eq_sym = end_section_proof();;
(start_section_proof ["x";"y";"z"](`x = y ==> y = z ==> x = z`));;
refine (by (VALID (((BETA_TAC THEN (DISCH_THEN(new_rewrite [] [])) THEN (DISCH_THEN(new_rewrite [] []))) THEN (done_tac)))));;
let eq_trans = end_section_proof();;
(start_section_proof ["f";"x";"y"](`x = y ==> f x = f y`));;
refine (by (VALID (((BETA_TAC THEN (DISCH_THEN(new_rewrite [] []))) THEN (done_tac)))));;
let f_equal = end_section_proof();;
(start_section_proof ["f";"x1";"y1";"x2";"y2"](`x1 = y1 ==> x2 = y2 ==> f x1 x2 = f y1 y2`));;
refine (by (VALID (((BETA_TAC THEN (DISCH_THEN(new_rewrite [] [])) THEN (DISCH_THEN(new_rewrite [] []))) THEN (done_tac)))));;
let f_equal2 = end_section_proof();;
let erefl = eq_sym;;
let esym = eq_sym;;
let etrans = eq_trans;;
let congr1 = f_equal;;
let congr2 = f_equal2;;
(start_section_proof ["f";"g"](`(!x. f x = g x) <=> f = g`));;
refine (by (VALID ((((split_tac) THENL [(DISCH_THEN (fun snd_th -> (USE_THM_THEN EQ_EXT)(MATCH_MP_THEN snd_th MP_TAC))); (DISCH_THEN(new_rewrite [] []))]) THEN (done_tac)))));;
let eq_ext = end_section_proof();;
(begin_section "Injections");;
(add_section_var (mk_var ("f", (`:A -> R`))));;
let injective = new_definition `injective f <=> (!x1 x2. f x1 = f x2 ==> x1 = x2)`;;
let cancel = new_definition `cancel f g <=> !x. g (f x) = x`;;
let pcancel = new_definition `pcancel f g <=> !x. g (f x) = SOME x`;;
let ocancel = new_definition `ocancel g h <=> !x. oapp h x (g x) = x`;;
(start_section_proof ["g"](`cancel f g ==> pcancel f (\y. SOME (g y))`));;
refine (by (VALID (((((USE_THM_THEN cancel)(new_rewrite [] [])) THEN ((USE_THM_THEN pcancel)(new_rewrite [] [])) THEN (simp_tac)) THEN (done_tac)))));;
let can_pcan = end_section_proof();;
(start_section_proof ["g"](`pcancel f g ==> injective f`));;
refine (by (VALID (((((USE_THM_THEN pcancel)(new_rewrite [] [])) THEN ((USE_THM_THEN injective)(new_rewrite [] []))) THEN (move ["can"]) THEN (move ["x1"]) THEN (move ["x2"]) THEN (move ["f_eq"])))));;
refine (by (VALID (((((fun thm_tac -> (USE_THEN "can")(ISPEC_THEN (mk_var("x2",mk_vartype "A")) thm_tac))MP_TAC) THEN ((fun thm_tac -> (USE_THEN "can")(ISPEC_THEN (mk_var("x1",mk_vartype "A")) thm_tac))MP_TAC) THEN BETA_TAC) THEN (((USE_THEN "f_eq")(new_rewrite [] [])) THEN (DISCH_THEN(new_rewrite [] []))) THEN ((USE_THM_THEN (injectivity "option"))(new_rewrite [] [])) THEN (done_tac)))));;
let pcan_inj = end_section_proof();;
(start_section_proof ["g"](`cancel f g ==> injective f`));;
refine (by (VALID (((((USE_THM_THEN cancel)(new_rewrite [] [])) THEN ((USE_THM_THEN injective)(new_rewrite [] []))) THEN (move ["can"]) THEN (move ["x1"]) THEN (move ["x2"]) THEN (move ["f_eq"])))));;
refine (by (VALID (((((fun thm_tac -> (USE_THEN "can")(ISPEC_THEN (mk_var("x1",mk_vartype "A")) thm_tac))(GSYM_THEN (new_rewrite [] []))) THEN ((fun thm_tac -> (USE_THEN "can")(ISPEC_THEN (mk_var("x2",mk_vartype "A")) thm_tac))(GSYM_THEN (new_rewrite [] []))) THEN ((USE_THEN "f_eq")(new_rewrite [] []))) THEN (done_tac)))));;
let can_inj = end_section_proof();;
(start_section_proof ["g";"x";"y"](`cancel f g ==> x = f y ==> g x = y`));;
refine (by (VALID (((((USE_THM_THEN cancel)(new_rewrite [] [])) THEN (move ["can"]) THEN (DISCH_THEN(new_rewrite [] []))) THEN (done_tac)))));;
let canLR = end_section_proof();;
(start_section_proof ["g";"x";"y"](`cancel f g ==> f x = y ==> x = g y`));;
refine (by (VALID (((((USE_THM_THEN cancel)(new_rewrite [] [])) THEN (move ["can"]) THEN (DISCH_THEN(GSYM_THEN (new_rewrite [] [])))) THEN (done_tac)))));;
let canRL = end_section_proof();;
let canRL = finalize_theorem canRL;;
let canLR = finalize_theorem canLR;;
let can_inj = finalize_theorem can_inj;;
let pcan_inj = finalize_theorem pcan_inj;;
let can_pcan = finalize_theorem can_pcan;;
(end_section "Injections");;
(start_section_proof [](`injective SOME`));;
refine (by (VALID (((((USE_THM_THEN injective)(new_rewrite [] [])) THEN ((USE_THM_THEN (injectivity "option"))(new_rewrite [] []))) THEN (done_tac)))));;
let some_inj = end_section_proof();;
(begin_section "InjectionsTheory");;
(add_section_var (mk_var ("f", (`:B -> A`))); add_section_var (mk_var ("g", (`:B -> A`))));;
(add_section_var (mk_var ("h", (`:C -> B`))));;
(start_section_proof [](`injective I`));;
refine (by (VALID (((((USE_THM_THEN injective)(new_rewrite [] [])) THEN repeat_tactic 1 9 (((USE_THM_THEN I_THM)(new_rewrite [] [])))) THEN (done_tac)))));;
let inj_id = end_section_proof();;
(start_section_proof ["f'"](`cancel f f' ==> injective f' ==> cancel f' f`));;
refine (by (VALID (((repeat_tactic 2 0 (((USE_THM_THEN cancel)(new_rewrite [] []))) THEN ((USE_THM_THEN injective)(new_rewrite [] []))) THEN (move ["can1"]) THEN (move ["inj"]) THEN (move ["x"])))));;
refine (by (VALID (((((USE_THEN "inj")MP_TAC) THEN (clear_assumption "inj") THEN (DISCH_THEN apply_tac)) THEN ((USE_THEN "can1")(new_rewrite [] [])) THEN (done_tac)))));;
let inj_can_sym = end_section_proof();;
(start_section_proof [](`injective f ==> injective h ==> injective (f o h)`));;
refine (by (VALID (((repeat_tactic 3 0 (((USE_THM_THEN injective)(new_rewrite [] []))) THEN repeat_tactic 2 0 (((USE_THM_THEN o_THM)(new_rewrite [] [])))) THEN (move ["inj_f"]) THEN (move ["inj_h"]) THEN (move ["x1"]) THEN (move ["x2"])))));;
refine (by (VALID (((BETA_TAC THEN (DISCH_THEN (fun snd_th -> (USE_THEN "inj_f")(MATCH_MP_THEN snd_th MP_TAC))) THEN (DISCH_THEN (fun snd_th -> (USE_THEN "inj_h")(MATCH_MP_THEN snd_th MP_TAC)))) THEN (done_tac)))));;
let inj_comp = end_section_proof();;
(start_section_proof ["f'";"h'"](`cancel f f' ==> cancel h h' ==> cancel (f o h) (h' o f')`));;
refine (by (VALID ((((repeat_tactic 3 0 (((USE_THM_THEN cancel)(new_rewrite [] []))) THEN repeat_tactic 2 0 (((USE_THM_THEN o_THM)(new_rewrite [] [])))) THEN (move ["f_can"]) THEN (move ["h_can"]) THEN (move ["x"])) THEN (done_tac)))));;
let can_comp = end_section_proof();;
(start_section_proof ["f'";"h'"](`pcancel f f' ==> pcancel h h' ==> pcancel (f o h) (pcomp h' f')`));;
refine (by (VALID ((((repeat_tactic 3 0 (((USE_THM_THEN pcancel)(new_rewrite [] []))) THEN ((USE_THM_THEN pcomp)(new_rewrite [] [])) THEN ((USE_THM_THEN o_THM)(new_rewrite [] []))) THEN (DISCH_THEN(new_rewrite [] []))) THEN (((USE_THM_THEN obind)(new_rewrite [] [])) THEN ((USE_THM_THEN oapp)(new_rewrite [] []))) THEN (done_tac)))));;
let pcan_pcomp = end_section_proof();;
(start_section_proof [](`injective f ==> (!x. f x = g x) ==> injective g`));;
refine (by (VALID (((((USE_THM_THEN eq_ext)(new_rewrite [] [])) THEN (move ["inj"]) THEN (DISCH_THEN(GSYM_THEN (new_rewrite [] [])))) THEN (done_tac)))));;
let eq_inj = end_section_proof();;
(start_section_proof ["f'";"g'"](`cancel f f' ==> (!x. f x = g x) ==> (!x. f' x = g' x) ==> cancel g g'`));;
refine (by (VALID (((repeat_tactic 1 9 (((USE_THM_THEN eq_ext)(new_rewrite [] []))) THEN (move ["can"]) THEN (DISCH_THEN(GSYM_THEN (new_rewrite [] []))) THEN (DISCH_THEN(GSYM_THEN (new_rewrite [] [])))) THEN (done_tac)))));;
let eq_can = end_section_proof();;
(start_section_proof ["f'"](`cancel f f' ==> injective f' ==> cancel g f' ==> f = g`));;
refine (by (VALID ((((repeat_tactic 2 0 (((USE_THM_THEN cancel)(new_rewrite [] []))) THEN ((USE_THM_THEN injective)(new_rewrite [] []))) THEN (move ["f_can"]) THEN (move ["inj"]) THEN (move ["g_can"])) THEN (((USE_THM_THEN eq_ext)(GSYM_THEN (new_rewrite [] []))) THEN (move ["x"]))))));;
refine (by (VALID (((((USE_THEN "inj")MP_TAC) THEN (clear_assumption "inj") THEN (DISCH_THEN apply_tac)) THEN (done_tac)))));;
let inj_can_eq = end_section_proof();;
let inj_can_eq = finalize_theorem inj_can_eq;;
let eq_can = finalize_theorem eq_can;;
let eq_inj = finalize_theorem eq_inj;;
let pcan_pcomp = finalize_theorem pcan_pcomp;;
let can_comp = finalize_theorem can_comp;;
let inj_comp = finalize_theorem inj_comp;;
let inj_can_sym = finalize_theorem inj_can_sym;;
let inj_id = finalize_theorem inj_id;;
(end_section "InjectionsTheory");;
(begin_section "Bijections");;
(add_section_var (mk_var ("f", (`:B -> A`))));;
let bijective = new_definition `bijective f <=> ?g. cancel f g /\ cancel g f`;;
(add_section_hyp "bijf" (`bijective f`));;
(start_section_proof [](`injective f`));;
refine (by (VALID (((((USE_THEN "bijf")MP_TAC) THEN (clear_assumption "bijf") THEN BETA_TAC) THEN (((USE_THM_THEN bijective)(new_rewrite [] [])) THEN ALL_TAC THEN (case THEN (move ["g"])) THEN (case THEN ((DISCH_THEN (fun snd_th -> (USE_THM_THEN can_inj)(MATCH_MP_THEN snd_th MP_TAC))) THEN (DISCH_THEN(new_rewrite [] []))))) THEN (done_tac)))));;
let bij_inj = end_section_proof();;
(start_section_proof ["f'"](`cancel f' f <=> cancel f f'`));;
refine (by (VALID (((THENL_FIRST) (split_tac) (((DISCH_THEN (fun snd_th -> (USE_THM_THEN inj_can_sym)(MATCH_MP_THEN snd_th MP_TAC))) THEN BETA_TAC THEN ((fun thm_tac -> DISCH_THEN (fun fst_th ->(USE_THM_THEN bij_inj)(fun th -> MATCH_MP_THEN th thm_tac fst_th)))MP_TAC)) THEN (done_tac))))));;
refine (by (VALID (((((USE_THEN "bijf")MP_TAC) THEN (clear_assumption "bijf") THEN BETA_TAC) THEN (((USE_THM_THEN bijective)(new_rewrite [] [])) THEN ALL_TAC THEN (case THEN (move ["g"])) THEN (case THEN ALL_TAC)) THEN (repeat_tactic 1 9 (((USE_THM_THEN cancel)(new_rewrite [] []))) THEN (move ["gf"]) THEN (move ["fg"]) THEN (move ["f'f"]) THEN (move ["x"]))))));;
refine (by (VALID (((((fun thm_tac -> (USE_THEN "fg")(ISPEC_THEN (mk_var("x",mk_vartype "A")) thm_tac))(GSYM_THEN (new_rewrite [] []))) THEN ((USE_THEN "f'f")(new_rewrite [] []))) THEN (done_tac)))));;
let bij_can_sym = end_section_proof();;
(start_section_proof ["f'";"f''"](`cancel f f' ==> cancel f f'' ==> f' = f''`));;
refine (by (VALID (((((fun thm_tac -> (USE_THM_THEN bij_can_sym)(ISPEC_THEN (mk_var("f''",mk_type("fun",[mk_vartype "A";mk_vartype "B"]))) thm_tac))(GSYM_THEN (new_rewrite [] []))) THEN ((USE_THM_THEN bij_can_sym)(GSYM_THEN (new_rewrite [] [])))) THEN (move ["can1"]) THEN (move ["can2"])))));;
refine (by (VALID (((((fun thm_tac -> (fun thm_tac -> (fun thm_tac -> (USE_THM_THEN inj_can_eq)(fun fst_th ->(USE_THEN "can1")(fun th -> MATCH_MP_THEN th thm_tac fst_th)))(fun fst_th ->(USE_THM_THEN bij_inj)(fun th -> MATCH_MP_THEN th thm_tac fst_th)))(fun fst_th ->(USE_THEN "can2")(fun th -> MATCH_MP_THEN th thm_tac fst_th)))MP_TAC) THEN BETA_TAC) THEN (done_tac)))));;
let bij_can_eq = end_section_proof();;
let bij_can_eq = finalize_theorem bij_can_eq;;
let bij_can_sym = finalize_theorem bij_can_sym;;
let bij_inj = finalize_theorem bij_inj;;
(end_section "Bijections");;
(begin_section "BijectionsTheory");;
(add_section_var (mk_var ("f", (`:BB -> AA`))));;
(add_section_var (mk_var ("h", (`:CC -> BB`))));;
(start_section_proof [](`bijective f ==> !g. (!x. f x = g x) ==> bijective g`));;
refine (by (VALID (((((USE_THM_THEN eq_ext)(new_rewrite [] [])) THEN (move ["bij"]) THEN (move ["g"]) THEN (DISCH_THEN(GSYM_THEN (new_rewrite [] [])))) THEN (done_tac)))));;
let eq_bij = end_section_proof();;
(start_section_proof [](`bijective f ==> bijective h ==> bijective (f o h)`));;
refine (by (VALID ((repeat_tactic 3 0 (((USE_THM_THEN bijective)(new_rewrite [] []))) THEN ALL_TAC THEN (case THEN (move ["g"])) THEN (case THEN ((move ["can_fg"]) THEN (move ["can_gf"]))) THEN (case THEN ((move ["r"]) THEN (case THEN ((move ["can_hr"]) THEN (move ["can_rh"])))))))));;
refine (by (VALID (((exists_tac (`r o g`)) THEN (split_tac)))));;
refine (by (VALID ((((fun thm_tac -> (fun thm_tac -> (fun thm_tac -> (fun thm_tac -> (USE_THM_THEN can_comp)(ISPEC_THEN (mk_var("f",mk_type("fun",[mk_vartype "BB";mk_vartype "AA"]))) thm_tac))(ISPEC_THEN (mk_var("h",mk_type("fun",[mk_vartype "CC";mk_vartype "BB"]))) thm_tac))(ISPEC_THEN (mk_var("g",mk_type("fun",[mk_vartype "AA";mk_vartype "BB"]))) thm_tac))(ISPEC_THEN (mk_var("r",mk_type("fun",[mk_vartype "BB";mk_vartype "CC"]))) thm_tac))MP_TAC) THEN BETA_TAC))));;
refine (by (VALID (((((fun thm_tac -> DISCH_THEN (fun fst_th ->(USE_THEN "can_fg")(fun th -> MATCH_MP_THEN th thm_tac fst_th)))MP_TAC) THEN BETA_TAC) THEN (DISCH_THEN apply_tac) THEN (done_tac)))));;
refine (by (VALID ((((fun thm_tac -> (fun thm_tac -> (fun thm_tac -> (fun thm_tac -> (USE_THM_THEN can_comp)(ISPEC_THEN (mk_var("r",mk_type("fun",[mk_vartype "BB";mk_vartype "CC"]))) thm_tac))(ISPEC_THEN (mk_var("g",mk_type("fun",[mk_vartype "AA";mk_vartype "BB"]))) thm_tac))(ISPEC_THEN (mk_var("h",mk_type("fun",[mk_vartype "CC";mk_vartype "BB"]))) thm_tac))(ISPEC_THEN (mk_var("f",mk_type("fun",[mk_vartype "BB";mk_vartype "AA"]))) thm_tac))MP_TAC) THEN BETA_TAC))));;
refine (by (VALID (((((fun thm_tac -> DISCH_THEN (fun fst_th ->(USE_THEN "can_rh")(fun th -> MATCH_MP_THEN th thm_tac fst_th)))MP_TAC) THEN BETA_TAC) THEN (DISCH_THEN apply_tac) THEN (done_tac)))));;
let bij_comp = end_section_proof();;
(start_section_proof [](`bijective f ==> !f'. cancel f f' ==> bijective f'`));;
refine (by (VALID ((((DISCH_THEN (fun snd_th -> (USE_THM_THEN bij_can_sym)(MATCH_MP_THEN snd_th MP_TAC))) THEN BETA_TAC THEN (move ["can_sym"]) THEN (move ["f'"]) THEN (move ["can_ff'"])) THEN ((USE_THM_THEN bijective)(new_rewrite [] []))))));;
refine (by (VALID (((exists_tac (mk_var("f",mk_type("fun",[mk_vartype "BB";mk_vartype "AA"])))) THEN ((USE_THEN "can_sym")(new_rewrite [] [])) THEN (done_tac)))));;
let bij_can_bij = end_section_proof();;
let bij_can_bij = finalize_theorem bij_can_bij;;
let bij_comp = finalize_theorem bij_comp;;
let eq_bij = finalize_theorem eq_bij;;
(end_section "BijectionsTheory");;
(begin_section "Involutions");;
(add_section_var (mk_var ("f", (`:A -> A`))));;
let involutive = new_definition `involutive f <=> cancel f f`;;
(add_section_hyp "Hf" (`involutive f`));;
(start_section_proof [](`injective f`));;
refine (by (VALID (((((USE_THEN "Hf")MP_TAC) THEN (clear_assumption "Hf") THEN BETA_TAC) THEN (((USE_THM_THEN involutive)(new_rewrite [] [])) THEN (DISCH_THEN (fun snd_th -> (USE_THM_THEN can_inj)(MATCH_MP_THEN snd_th MP_TAC)))) THEN (done_tac)))));;
let inv_inj = end_section_proof();;
(start_section_proof [](`bijective f`));;
refine (by (VALID ((((USE_THM_THEN bijective)(new_rewrite [] [])) THEN (exists_tac (mk_var("f",mk_type("fun",[mk_vartype "A";mk_vartype "A"])))) THEN (((USE_THEN "Hf")MP_TAC) THEN (clear_assumption "Hf") THEN BETA_TAC) THEN ((USE_THM_THEN involutive)(new_rewrite [] [])) THEN (done_tac)))));;
let inv_bij = end_section_proof();;
let inv_bij = finalize_theorem inv_bij;;
let inv_inj = finalize_theorem inv_inj;;
(end_section "Involutions");;
(begin_section "OperationProperties");;
(begin_section "SopTisR");;
let left_inverse = new_definition `left_inverse e inv op = !x. op (inv x) x = e`;;
let right_inverse = new_definition `right_inverse e inv op = !x. op x (inv x) = e`;;
let left_injective = new_definition `left_injective op = !x. injective (\y. op y x)`;;
let right_injective = new_definition `right_injective op = !y. injective (op y)`;;
(end_section "SopTisR");;
(begin_section "SopTisS");;
let right_id = new_definition `right_id e op = !x. op x e = x`;;
let left_zero = new_definition `left_zero z op = !x. op z x = z`;;
let right_commutative = new_definition 
	`right_commutative op = !x y z. op (op x y) z = op (op x z) y`;;
let left_distributive = new_definition
	`left_distributive op add = !x y z. op (add x y) z = add (op x z) (op y z)`;;
let right_loop = new_definition
	`right_loop inv op = !y. cancel (\x. op x y) (\x. op x (inv y))`;;
let rev_right_loop = new_definition
	`rev_right_loop inv op = !y. cancel (\x. op x (inv y)) (\x. op x y)`;;
(end_section "SopTisS");;
(begin_section "SopTisT");;
let left_id = new_definition `left_id e op = !x. op e x = x`;;
let right_zero = new_definition `right_zero z op = !x. op x z = z`;;
let left_commutative = new_definition 
	`left_commutative op = !x y z. op x (op y z) = op y (op x z)`;;
let right_distributive = new_definition
	`right_distributive op add = !x y z. op x (add y z) = add (op x y) (op x z)`;;
let left_loop = new_definition 
	`left_loop inv op = !x. cancel (op x) (op (inv x))`;;
let rev_left_loop = new_definition 
	`rev_left_loop inv op = !x. cancel (op (inv x)) (op x)`;;
(end_section "SopTisT");;
(begin_section "SopSisT");;
let self_inverse = new_definition `self_inverse e op = !x. op x x = e`;;
let commutative = new_definition `commutative op = !x y. op x y = op y x`;;
(end_section "SopSisT");;
(begin_section "SopSisS");;
let idempotent = new_definition `idempotent op = !x. op x x = x`;;
let associative = new_definition `associative op = !x y z. op x (op y z) = op (op x y) z`;;
(end_section "SopSisS");;
(end_section "OperationProperties");;
