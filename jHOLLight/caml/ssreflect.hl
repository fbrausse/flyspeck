(* Based on the code from tactics.ml *)
(* Applies the second tactic to either the first subgoal or
   the last subgoal *)
let (THENL_FIRST),(THENL_LAST) =
  let propagate_empty i [] = []
  and propagate_thm th i [] = INSTANTIATE_ALL i th in
  let compose_justs n just1 just2 i ths =
    let ths1,ths2 = chop_list n ths in
    (just1 i ths1)::(just2 i ths2) in
  let rec seqapply l1 l2 = match (l1,l2) with
     ([],[]) -> null_meta,[],propagate_empty
   | ((tac:tactic)::tacs),((goal:goal)::goals) ->
            let ((mvs1,insts1),gls1,just1) = tac goal in
            let goals' = map (inst_goal insts1) goals in
            let ((mvs2,insts2),gls2,just2) = seqapply tacs goals' in
            ((union mvs1 mvs2,compose_insts insts1 insts2),
             gls1@gls2,compose_justs (length gls1) just1 just2)
   | _,_ -> failwith "seqapply: Length mismatch" in
  let justsequence just1 just2 insts2 i ths =
    just1 (compose_insts insts2 i) (just2 i ths) in
  let tacsequence ((mvs1,insts1),gls1,just1) tacl =
    let ((mvs2,insts2),gls2,just2) = seqapply tacl gls1 in
    let jst = justsequence just1 just2 insts2 in
    let just = if gls2 = [] then propagate_thm (jst null_inst []) else jst in
    ((union mvs1 mvs2,compose_insts insts1 insts2),gls2,just) in
  let (thenl_first: tactic -> tactic -> tactic) =
    fun tac1 tac2 g ->
      let _,gls,_ as gstate = tac1 g in
	if gls = [] then failwith "No subgoals"
	else 
	  let tac_list = tac2 :: (replicate ALL_TAC (length gls - 1)) in
	    tacsequence gstate tac_list
  and (thenl_last: tactic -> tactic -> tactic) =
    fun tac1 tac2 g ->
      let _,gls,_ as gstate = tac1 g in
	if gls = [] then failwith "No subgoals"
	else 
	  let tac_list = (replicate ALL_TAC (length gls - 1)) @ [tac2] in
	    tacsequence gstate tac_list in
    thenl_first, thenl_last;;



let (THENL_ROT: int -> tactic -> tactic) =
  fun n tac g ->
    let gstate = tac g in
      rotate n gstate;;



(* Returns all free variables in the goal *)
let get_context_vars (g : goal) =
  let list, g_tm = g in
  let tms = g_tm :: map (concl o snd) list in
  let f_vars = setify (flat (map frees tms)) in
    map (fun v -> ((fst o dest_var) v, v)) f_vars;;



(* DISCH_THEN (LABEL_TAC name) for assumptions and X_GEN_TAC name for variables *)
let move labels (g:goal) =
  let g_tm = snd g in
  let move_name name g_tm =
    if is_forall g_tm then
      let tm0, g_tm1 = dest_forall g_tm in
      let tm = mk_var (name, type_of tm0) in
	if name = "_" then
	  (GEN_TAC, g_tm1)
	else
	  (X_GEN_TAC tm, g_tm1)
    else
      if is_imp g_tm then
	let tm = rand g_tm in
	  if name = "_" then
	    (DISCH_THEN (fun th -> ALL_TAC), tm)
	  else
	    (DISCH_THEN (LABEL_TAC name), tm)
      else
	failwith "move: not (!) or (==>)" in
  let rec build labels g_tm = 
    match labels with
      | [] -> ALL_TAC
      | l :: ls ->
	  let tac, tm = move_name l g_tm in
	    tac THEN (build ls tm) in
    (build labels g_tm) g;;




(* Finds a subterm in the given term which matches against the given
   pattern; local_consts is a list of variable which must be fixed in 
   the pattern.
   This function returns the path to the first matched subterm *)
let match_subterm local_consts pat tm =
  let rec find tm path =
    try
      let inst = term_match local_consts pat tm in
	if instantiate inst pat = tm then path else failwith "Bad instantiation"
    with x ->
      try 
	match tm with
	  | Abs(_, b_tm) -> find b_tm (path^"b")
	  | Comb(l_tm, r_tm) ->
	      try find l_tm (path^"l")
	      with Failure _ -> find r_tm (path^"r")
  	  | _ -> failwith "match_subterm: no match"
      with x ->
	failwith ("match_subterm: no match: "^string_of_term pat) in
    find tm "";;



(* Returns paths to all subterms satisfying p *)
let find_all_paths p tm =
  let rec find_path p tm path =
    let paths =
      match tm with
	| Abs(_, b_tm) ->
	    find_path p b_tm (path ^ "b")
	| Comb(l_tm, r_tm) ->
	    (find_path p l_tm (path ^ "l")) @ (find_path p r_tm (path ^ "r"))
	| _ -> [] in
      if p tm then path :: paths else paths in
    find_path p tm "";;


(* Instantiates types of the given context variables in the given term.*)
let inst_context_vars vars tm_vars tm = 
  let find_type var =
    let name, ty = dest_var var in
      try
	(ty, type_of (assoc name vars))
      with Failure _ -> 
	failwith (name^" is free in the term `"^(string_of_term tm)^"` and in the context") in
  let ty_src, ty_dst = unzip (map find_type tm_vars) in
  let ty_inst = itlist2 type_match ty_src ty_dst [] in
    inst ty_inst tm;;


(* Instantiates types of all free variables in the term using the context *)
let inst_all_free_vars tm (g : goal) =
  let context_vars = get_context_vars g in
  let f_vars = frees tm in
    inst_context_vars context_vars f_vars tm;;


(* Finds a subterm corresponding to the given pattern.
   Before matching, the term types are instantiated in the given context. *)
let match_subterm_in_context pat tm (g : goal) =
  let context_vars = get_context_vars g in
  let f0_vars = filter (fun tm -> ((fst o dest_var) tm).[0] <> '_') (frees pat) in
  let pattern = inst_context_vars context_vars f0_vars pat in
  let f1_vars = filter (fun tm -> ((fst o dest_var) tm).[0] <> '_') (frees pattern) in
    match_subterm f1_vars pattern tm;;


(* Returns the number of explicit assumptions and the subterm for matching *)
let prepare_theorem th =
  (* Convert P ==> (!x. Q x) to !x. P ==> Q x *)
  let th1 = PURE_REWRITE_RULE[GSYM RIGHT_FORALL_IMP_THM] th in
  let th_tm = concl th1 in
  let bound_vars, body_tm = strip_forall th_tm in
  (* Returns the final conclusion and the number of assumptions *)
  let rec find_concl tm =
    if is_imp tm then
      let _, c_tm = dest_imp tm in
      let c_tm2, n = find_concl c_tm in
	(c_tm2, n + 1)
    else
      (tm, 0) in
  let concl_tm, n = find_concl body_tm in
  (* Ensure that the conclusion is an equation; make an equation if necessary *)
  concl_tm;;


(*
  let rec strip_tm tm =
    let bound_vars, body = strip_forall tm in
    (* Rename bound variables *)
    let vars = map (fun var -> let name, ty = dest_var var in mk_var("$"^name, ty)) bound_vars in
    let tm0 = subst (zip vars bound_vars) body in
    if is_imp tm0 then
      let assumption, tm1 = dest_imp tm0 in
      let assumptions, conclusion = strip_tm tm1 in
	(assumption :: assumptions, conclusion)
    else
      ([], tm0) in
    strip_tm concl_tm;;
*)


let path_rewrite path th tm =
  let rec build path tm =
    let n = String.length path in
      if n = 0 then
	th
      else
	let ch = path.[0] in
	let path' = String.sub path 1 (n - 1) in
	  if ch = 'l' then
	    let lhs, rhs = dest_comb tm in
	    let th0 = build path' lhs in
	      AP_THM th0 rhs
	  else if ch = 'r' then
	    let lhs, rhs = dest_comb tm in
	    let th0 = build path' rhs in
	      AP_TERM lhs th0
	  else if ch = 'a' then
	    let var, body = dest_abs tm in
	    let th0 = build path' body in
	      ABS var th0
	  else
	    failwith ("Bad path symbol: "^path) in
  let res = build path tm in
  let lhs = (lhand o concl) res in
    if lhs <> tm then failwith ("path_rewrite: incorrect result [required: "^
				  (string_of_term tm)^"; obtained: "^
				  (string_of_term lhs))
    else
      res;;

  

  

(*let th = ASSUME `!x. x ==> (!x. x = ~x ==> (!y. y = 2))`;;
PURE_REWRITE_RULE[GSYM RIGHT_FORALL_IMP_THM] th;;
(* prepare_theorem ITERATE_UNION;; *)
    
*)

(* Rewrite tactic for usual and conditional theorems *)
let rewrite occ pat th g =
  let rec match_theorem ffun th tm str =
    try (PART_MATCH ffun th tm, true, str)
    with Failure _ ->
      match tm with
	| Comb(l_tm, r_tm) ->
	    let r_th, flag, s = match_theorem ffun th l_tm (str ^ "l") in
	      if flag then (r_th, flag, s)
	      else
		match_theorem ffun th r_tm (str ^ "r")
	| Abs(_, b_tm) ->
	    match_theorem ffun th b_tm (str ^ "b")
	| _ -> (th, false, str) in
  (* Initialize auxiliary variables *)
  let goal_tm = snd g in
  let th0 = PURE_REWRITE_RULE[IMP_IMP] th in
  let concl_th = concl (SPEC_ALL th0) in
  let cond_flag = is_imp concl_th in
  let eq_tm = if cond_flag then rand concl_th else concl_th in
  let match_fun = (if is_eq eq_tm then lhand else I) o (if cond_flag then rand else I) in

  (* Apply the pattern *)
  let goal_subterm_path = 
    if pat = [] then "" else match_subterm_in_context (hd pat) goal_tm g in
  let goal_subterm = follow_path goal_subterm_path goal_tm in

  (* Match the theorem *)
  let matched_th, flag, path = match_theorem match_fun th0 goal_subterm goal_subterm_path in
  if not flag then
    failwith "lhs does not match any term in the goal"
  else
    let matched_tm = (match_fun o concl) matched_th in
    (* Find all matched subterms *)
    let paths = find_all_paths (fun x -> x = matched_tm) goal_tm in
    let paths = if occ = [] then paths else
      map (fun i -> List.nth paths (i - 1)) occ in
    (* Find all free variables in the matched theorem which do not correspond to free variables in
       the matched subterm *)
    let tm_frees = frees matched_tm in
    let th_frees = frees (concl th0) in
    let mth_frees = frees (concl matched_th) in
    let vars = subtract mth_frees (union th_frees tm_frees) in
      if vars = [] then
	let r_tac = fun th -> MAP_EVERY (fun path -> GEN_REWRITE_TAC (PATH_CONV path) [th]) paths in
	  if cond_flag then
	    (MP_TAC matched_th THEN ANTS_TAC THENL [ALL_TAC; DISCH_THEN r_tac]) g
	  else
	    (r_tac matched_th) g
      else
	let rec gen_vars vars th =
	  match vars with
	    | v :: vs -> gen_vars vs (GEN v th)
	    | [] -> th in
	let th2 = gen_vars vars matched_th in
	  (MP_TAC th2 THEN REWRITE_TAC[LEFT_IMP_FORALL_THM]) g;;




(* Analogue of the "done" tactic in SSReflect *)
let done_tac = ASM_REWRITE_TAC[] THEN FAIL_TAC "done: not all subgoals are proved";;

(* Simplification: /= *)
let simp_tac = SIMP_TAC[];;



(* Linear arithmetic simplification *)
let arith_tac = FIRST [ARITH_TAC; REAL_ARITH_TAC; INT_ARITH_TAC];;


(* split *)
let split_tac = FIRST [CONJ_TAC; EQ_TAC];;



(* Creates an abbreviation for the given term with the given name *)
let set_tac name tm (g : goal) =
  let goal_tm = snd g in
  let tm0 = 
    try 
      follow_path (match_subterm_in_context tm goal_tm g) goal_tm
    with Failure _ -> tm in
  let abbrev_tm = mk_eq (mk_var (name, type_of tm0), tm0) in
    (ABBREV_TAC abbrev_tm THEN POP_ASSUM (LABEL_TAC (name ^ "_def"))) g;;


(* Introduces a subgoal *)
let have_tac then_tac tm (g : goal) =
  let tm0 = inst_all_free_vars tm g in
    (SUBGOAL_THEN tm0 (fun th -> MP_TAC th THEN then_tac)) g;;

(* Provides a witness for an existance goal *)
let exists_tac tm (g : goal) =
  let tm0 = inst_all_free_vars tm g in
    (EXISTS_TAC tm0) g;;


(* Specializes a variable and applies the next tactic *)
let ISPEC_THEN tm (tac : thm_tactic) th (g : goal) =
  let tm0 = inst_all_free_vars tm g in
    tac (ISPEC tm0 th) g;;


let USE_THM_THEN th (tac : thm_tactic) =
  tac th;;


let MATCH_MP_THEN th2 (tac : thm_tactic) th1 =
    tac (MATCH_MP th1 th2);;


let GSYM_THEN tac th =
  tac (GSYM th);;


(* The 'apply' tactic *)
let apply_tac = DISCH_THEN (fun th -> FIRST [MATCH_ACCEPT_TAC th; MATCH_MP_TAC th]);;

(* The 'exact' tactic *)
(* TODO: do [done | by move => top; apply top], here apply top 
   works as ACCEPT_TAC with matching (rewriting) in some cases *)
let exact_tac = FIRST [done_tac; 
		       move ["_tmp_"] THEN USE_THEN "_tmp_" (fun th -> MATCH_MP_TAC th) THEN done_tac];;



(* Specializes the theorem using the given set of variables *)
let spec0 names vars = 
  let find name =
    try (assoc name vars, true)
    with Failure _ -> (parse_term name, false) in
  let find_type var =
    let name, ty = dest_var var in
    let t, flag = find name in
      if flag then
	(ty, type_of t)
      else 
	(`:bool`, `:bool`) in
  let inst_term tm =
    let ty_src, ty_dst = unzip (map find_type (frees tm)) in
    let ty_inst = itlist2 type_match ty_src ty_dst [] in
      inst ty_inst tm in
  let list = map find names in
  let tm_list = map (fun tm, flag -> if flag then tm else inst_term tm) list in
    ISPECL tm_list;;


let spec names = spec0 names (get_context_vars (top_realgoal()));;


let spec_mp names th g = MP_TAC (spec0 names (get_context_vars g) th) g;;

(* case: works only for (A /\ B) -> C; (A \/ B) -> C; (?x. P) -> Q; !(n:num). P; !(l:list(A)). P *)
let case (g:goal) = 
  let goal_tm = snd g in
    if not (is_imp goal_tm) then
      (* !a. P *)
      if is_forall goal_tm then
	let var, tm = dest_forall goal_tm in
	let ty = type_of var in
	let case_th = if ty = `:num` then num_CASES 
	else if ty = `:bool` then BOOL_CASES_AX 
	else list_CASES in
	  (GEN_TAC THEN MP_TAC (ISPEC var case_th) THEN DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC) g
      else
	failwith "case: not imp or forall"
    else
      let tm = lhand goal_tm in
	(* A /\ B *)
	if is_conj tm then
	  (DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN POP_ASSUM MP_TAC) g
	(* A \/ B *)
	else if is_disj tm then
	  (DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC) g
        (* ?x. P *)
	else if is_exists tm then
	  (ONCE_REWRITE_TAC[GSYM LEFT_FORALL_IMP_THM]) g
	else
	  failwith "case: not implemented";;



(* elim: works only for num and list *)
let elim (g:goal) = 
  let goal_tm = snd g in
    (* !a. P *)
    if is_forall goal_tm then
      let var, tm = dest_forall goal_tm in
      let ty = type_of var in
      let induct_th = if ty = `:num` then num_INDUCTION else list_INDUCT in
	(MATCH_MP_TAC induct_th THEN CONJ_TAC) g
    else
      failwith "elim: not forall";;


	  
(* Instantiates the first type variable in the given theorem *)
let INST_FIRST_TYPE_THEN ty (then_tac:thm_tactic) th =
  let ty_vars = type_vars_in_term (concl th) in
  if ty_vars = [] then
    failwith "inst_first_type: no type variables in the theorem"
  else
    then_tac (INST_TYPE [(ty, hd ty_vars)] th);;


(* Repeats the given tactic exactly n times and then repeats the same tactic at most m times *)
let repeat_tactic n m tac =
  let rec replicate_at_most m tac =
    if m <= 0 then ALL_TAC else (tac THEN replicate_at_most (m - 1) tac) ORELSE ALL_TAC in
  REPLICATE_TAC n tac THEN replicate_at_most m tac;;
