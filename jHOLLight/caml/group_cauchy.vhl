"needs \"Library/prime.ml\"".
"needs \"caml/seq.hl\"".


"let group = new_definition `group (G,op,i,e) <=> (!x y. x IN G /\ y IN G ==> op x y IN G) /\
		(!x. x IN G ==> i x IN G) /\ e IN G /\
		(!x. x IN G ==> op x e = x /\ op e x = x) /\
		(!x. x IN G ==> op x (i x) = e /\ op (i x) x = e) /\
		(!x y z. x IN G /\ y IN G /\ z IN G ==> op x (op y z) = op (op x y) z)`".

"let subgroup = new_definition `subgroup op i H G <=> H SUBSET G /\ ~(H = {}) /\
		(!x y. x IN H /\ y IN H ==> op x (i y) IN H)`".


"let morphism = new_definition `morphism (f:A->B) op1 op2 G1 G2 <=> 
	(!x. x IN G1 ==> f x IN G2) /\ 
	(!x y. x IN G1 /\ y IN G1 ==> f (op1 x y) = op2 (f x) (f y))`".

"let normal = new_definition `normal op i H G <=> subgroup op i H G /\ 
	(!x y. x IN G /\ y IN H ==> op (i x) (op y x) IN H)`".

"let coset = new_definition `coset op x H = {op x y | y | y IN H}`".
"let cosets = new_definition `cosets op G H = {coset op x H | x | x IN G}`".

"let set_op = new_definition `set_op (op:A->A->A) = (\A B. {op x y | x IN A /\ y IN B})`".

"let set_op1 = new_definition `set_op1 (i:A->A) = (\A. {i x | x IN A})`".

"let conjg = new_definition `conjg op i x g = op (i g) (op x g)`".

"let normalizer = new_definition `normalizer op i G H = {g | g IN G /\ (IMAGE (\h. op (i g) (op h g)) H = H)}`".

Lemma inE : `(!p x. x IN {y | p y} <=> p x) /\
	(!P x. x IN GSPEC (\v. P (SETSPEC v)) <=> P (\p t. p /\ x = t))`.
by rewr !IN_ELIM_THM. Qed.


Lemma coset_op op x H : `coset op x H = set_op op {x} H`.
rewrite coset set_op /= IN_SING EXTENSION => y; rewr IN_ELIM_THM /=; split.
  move => [z [zH ->]].
  by exists x z.
move => [z] [t] [[-> tH] ->].
by exists t.
Qed.

Lemma normal_conj op i G H x y: `normal op i H G ==> x IN G ==> y IN H ==> 
	op (i x) (op y x) IN H`.
by rewrite normal /=. Qed.


Lemma normal_subgroup op i H G : `normal op i H G ==> subgroup op i H G`.
by rewrite normal /=. Qed.

Lemma in_subgroup op i H G x: `subgroup op i H G ==> x IN H ==> x IN G`.
by rewrite subgroup SUBSET /=. Qed.

Lemma subgroup_subset op i H G : `subgroup op i H G ==> H SUBSET G`.
by rewrite subgroup /=. Qed.

Lemma subgroup_subset_trans op i H K G : `subgroup op i H G ==> H SUBSET K ==> subgroup op i H K`.
by rewrite !subgroup /=. Qed.

Lemma normal_subset_trans op i H K G : `normal op i H G ==> H SUBSET K ==> K SUBSET G ==> normal op i H K`.
rewrite !normal [`K SUBSET G`]SUBSET => [] [subHG] nH sHK sKG.
rewrite (subgroup_subset_trans subHG) // andTb => k h [kK hH].
by rewrite nH hH sKG.
Qed.

Lemma cosets_full_preimage_sub op G H K: `K SUBSET G ==> K SUBSET {g | g IN G /\ coset op g H IN (cosets op K H)}`.
Proof.
rewrite cosets !SUBSET; move => sKG; rewrite !IN_ELIM_THM /= => k kK.
by exists k; rewrite sKG //=; exists k.
Qed.


Section Groups.

Variable G : `:A->bool`.
Variable e : `:A`.
Variable op : `:A -> A -> A`.
Variable i : `:A -> A`.

Hypothesis grG : `group (G,op,i,e)`.


Lemma e_in_group : `e IN G`. by move: grG; rewrite group /=. Qed.
Lemma in_group x y : `x IN G ==> y IN G ==> op x y IN G`. by move: grG; rewrite group /=. Qed.
Lemma i_in_group x : `x IN G ==> i x IN G`. by move: grG; rewrite group /=. Qed.
Lemma mul1g x : `x IN G ==> op e x = x`. by move: grG; rewrite group /=. Qed.
Lemma mulg1 x : `x IN G ==> op x e = x`. by move: grG; rewrite group /=. Qed.
Lemma mulIg x : `x IN G ==> op (i x) x = e`. by move: grG; rewrite group /=. Qed.
Lemma mulgI x : `x IN G ==> op x (i x) = e`. by move: grG; rewrite group /=. Qed.
Lemma mulgA x y z: `x IN G ==> y IN G ==> z IN G ==> op x (op y z) = op (op x y) z`.
by move: grG; rewrite group /=. Qed.
Lemma mulgK x y : `x IN G ==> y IN G ==> op (op x y) (i y) = x`.
by move => xG yG; rewrite -mulgA ?i_in_group // mulgI // mulg1. Qed.
Lemma mulKg x y : `x IN G ==> y IN G ==> op (op x (i y)) y = x`.
by move => xG yG; rewrite -mulgA ?i_in_group // mulIg // mulg1. Qed.


Lemma i_uniq x y : `x IN G ==> y IN G ==> op x y = e ==> y = i x`.
move => xG yG eq.
have: `op (op (i x) x) y = op (i x) e`.
	by rewrite -mulgA ?yG ?i_in_group ?xG //.
by rewrite mulIg // mul1g // mulg1 ?i_in_group.
Qed.

Lemma invgK x : `x IN G ==> i (i x) = x`.
move => xG; rewrite EQ_SYM_EQ; apply: "REWRITE_RULE[IMP_IMP] i_uniq".
by rewrite mulIg ?i_in_group.
Qed.


Lemma mulI x y : `x IN G ==> y IN G ==> i (op x y) = op (i y) (i x)`.
move => xG yG.
rewrite EQ_SYM_EQ.
apply: "REWRITE_RULE[IMP_IMP] i_uniq".
by rewrite !in_group // ?i_in_group // !mulgA ?in_group ?i_in_group // mulgK // mulgI.
Qed.

Lemma mulg_leftI x y z: `x IN G ==> y IN G ==> z IN G ==> op x y = op x z ==> y = z`.
move => xG yG zG eq.
by rewrite -(mul1g y) // -(mul1g z) // -(mulIg x) // -!mulgA ?i_in_group.
Qed.

Lemma mulg_rightI x y z: `x IN G ==> y IN G ==> z IN G ==> op y x = op z x ==> y = z`.
move => xG yG zG eq.
by rewrite -(mulg1 y) // -[`z`]mulg1 // -(mulgI x) // !mulgA ?i_in_group.
Qed.


Lemma mulg_left x y z : `x IN G ==> y IN G ==> z IN G ==> (op x y = z <=> x = op z (i y))`.
move => xG yG zG; split => [opxy | ->].
  by rewrite -(mulg1 x) // -(mulgI y) // mulgA ?i_in_group.
by rewrite -mulgA ?mulIg ?i_in_group ?mulg1.
Qed.

Lemma mulg_right x y z : `x IN G ==> y IN G ==> z IN G ==> (op x y = z <=> y = op (i x) z)`.
move => xG yG zG; split => [opxy | ->].
  by rewrite -(mul1g y) // -(mulIg x) // -mulgA ?i_in_group.
by rewrite mulgA ?mulgI ?i_in_group ?mul1g.
Qed.


Lemma invg_e : `i e = e`.
by rewrite eq_sym; apply: i_uniq; rewrite mul1g e_in_group. Qed.


Lemma subgroup_alt H : `subgroup op i H G <=> 
	H SUBSET G /\ ~(H = {}) /\ (!x y. x IN H ==> y IN H ==> op x y IN H) /\
	(!x. x IN H ==> i x IN H)`.
rewrite subgroup SUBSET; split => [] [subHG] [->] //=.
rewr subHG /=; move => h.
have ixH : `!x. x IN H ==> i x IN H`.
  move => x xH.
  have xG := subHG xH.
  by rewrite -(mul1g `i x`) ?i_in_group // h xH andbT -(mulgI x) // h.
rewr ixH /= => x y xH yH.
have xG := subHG xH; have yG := subHG yH.
by rewrite -(invgK y) // h xH ixH.
Qed.


Lemma subgroup_group H : `subgroup op i H G ==> group (H, op, i, e)`.
move: (grG).
rewrite subgroup 2!group SUBSET => [] [opG] [iG] [eG] [idG] [invG aG] [sHG] [nH op_iH].
have eH : `e:A IN H`.
  move: nH; rewrite -MEMBER_NOT_EMPTY => [] [x xH].
  by rewrite -(mulgI x) ?sHG // op_iH.
have iH : `!y. y IN H ==> i y IN H`.
  move => y yH.
  by rewrite -(mul1g `i y`) ?i_in_group ?sHG // op_iH.

do 6? split => //.
  by move => x y [xH yH]; rewrite -[`y`]invgK ?sHG // op_iH iH.
  by move => x xH; apply: idG; rewrite sHG.
  by move => x xH; apply: invG; rewrite sHG.
move => x y z [xH] [yH zH].
by apply: aG; rewrite !sHG.
Qed.


Lemma set_opK : `set_op op G G = G`.
rewrite set_op /= EXTENSION => x; rewr IN_ELIM_THM /=; split.
  move => [x'] [y] [[xG yG] ->].
  by rewrite in_group.
move => xG.
by exists e x; rewrite xG e_in_group mul1g.
Qed.


Lemma normal_conj2 H x y: `normal op i H G ==> x IN G ==> y IN H ==> 
	op x (op y (i x)) IN H`.
move/normal_conj => conj xG yH.
move: (conj `(i:A->A) x` y).
by rewrite i_in_group // yH /= invgK.
Qed.


Lemma set_opA A B C: `A SUBSET G ==> B SUBSET G ==> C SUBSET G ==>
	set_op op A (set_op op B C) = set_op op (set_op op A B) C`.
rewrite !SUBSET => AG BG CG.
rewrite !set_op /= EXTENSION => x; rewr !IN_ELIM_THM /=; split.
  move => [a] [u] [[aA]] [b] [c] [[bB cC] ->] x_eq.
  exists `op a b` c.
  rewrite -mulgA 1?AG 1?BG 1?CG // -x_eq cC /=.
  by exists a b.
move => [u] [c] [] [] [a] [b] [[aA bB] ->] cC x_eq.
exists a `op b c`.
rewrite mulgA 1?AG 1?BG ?CG // -x_eq aA /=.
by exists b c.
Qed.


Lemma coset_subset x S: `x IN G ==> S SUBSET G ==> coset op x S SUBSET G`.
rewrite SUBSET => xG SG.
rewrite coset SUBSET => y; rewr IN_ELIM_THM /= => [] [z] [zS ->].
by rewrite in_group xG SG.
Qed.


Lemma coset_e S: `S SUBSET G ==> coset op e S = S`.
rewrite SUBSET => sSG.
rewrite coset EXTENSION; rewr !IN_ELIM_THM /= => x; split.
  by move => [y] [yH ->]; rewrite mul1g ?sSG.
by move => xH; exists x; rewrite mul1g ?sSG.
Qed.

Lemma coset_eq_e g : `g IN G ==> coset op g G = G`.
Proof.
rewrite coset EXTENSION IN_ELIM_THM /= => gG g'; split => [|g'G].
  by move => [h] [hG] ->; rewrite in_group.
exists `op (i g) g'`.
by rewrite mulgA ?mulgI ?mul1g ?in_group ?i_in_group.
Qed.


End Groups.




Section Normal.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variable H : `:A->bool`.

Hypothesis grG : `group (G,op,i,e)`.

Lemma cosets_full_preimage0 K: `subgroup op i K G ==> H SUBSET K ==> ~(H = {}) ==> 
	K = {g | g IN G /\ coset op g H IN (cosets op K H)}`.
Proof.
rewrite -MEMBER_NOT_EMPTY SUBSET => subKG sHK [h] hH.
have sKG := subgroup_subset subKG.
have grK := subgroup_group grG subKG.
rewrite -SUBSET_ANTISYM_EQ cosets_full_preimage_sub // andTb SUBSET => k.
rewrite cosets !IN_ELIM_THM /= => [] [g] [] [gG] [x] [xK].
rewrite !coset -SUBSET_ANTISYM_EQ SUBSET !IN_ELIM_THM /= => [] [h1 _] _.
move: (h1 `op g h`); "ANTS_TAC"; first by exists h.
move => [y] [yH].
rewrite (mulg_left grG) ?gG ?(in_subgroup subKG) ?(in_group grK) ?xK ?(sHK h) ?(sHK y) //.
by move => ->; rewrite !(in_group grK) ?(i_in_group grK) ?xK ?sHK.
Qed.

Lemma preimages_eq0 K1 K2: `subgroup op i K1 G ==> subgroup op i K2 G ==> 
	H SUBSET K1 ==> H SUBSET K2 ==> ~(H = {}) ==>
	(cosets op K1 H = cosets op K2 H <=> K1 = K2)`.
Proof.
move => subK1G subK2G sHK1 sHK2 nH0; split => [c_eq | -> //].
by rewrite (cosets_full_preimage0 K1) // (cosets_full_preimage0 K2).
Qed.

Lemma subgroup_alt2 H : `subgroup op i H G <=> (H SUBSET G /\ group (H, op, i, e))`.
Proof.
split => [subHG | [sHG grH]].
  by rewrite (subgroup_group grG subHG) (subgroup_subset subHG).
rewrite subgroup sHG andTb -MEMBER_NOT_EMPTY; split.
  by exists e; rewrite (e_in_group grH).
move => x y [xH yH].
by rewrite (in_group grH) xH (i_in_group grH).
Qed.


(* H <| G *)
Hypothesis normH : `normal op i H G`.

Lemma cosets_full_preimage K: `subgroup op i K G ==> H SUBSET K ==>
	K = {g | g IN G /\ coset op g H IN (cosets op K H)}`.
Proof.
move => subKG sHK; apply: cosets_full_preimage0.
rewrite sHK subKG !andTb.
by move: normH; rewrite normal subgroup /=.
Qed.

Lemma preimages_eq K1 K2: `subgroup op i K1 G ==> subgroup op i K2 G ==>
	H SUBSET K1 ==> H SUBSET K2 ==> (cosets op K1 H = cosets op K2 H <=> K1 = K2)`.
Proof.
move => sub1 sub2 s1 s2; apply: preimages_eq0.
by move: normH; rewrite normal subgroup sub1 sub2 s1 s2 /=.
Qed.



Lemma left_right_coset x : `x IN G ==> coset op x H = set_op op H {x}`.
move: (in_subgroup (normal_subgroup normH)) => xHG.
move => xG; rewrite coset_op set_op /= !IN_SING EXTENSION; rewr IN_ELIM_THM /= => z; split.
  move => [u] [v] [[-> vH] ->].
  exists `op (x:A) (op v (i x)):A` x.
  rewrite (normal_conj2 grG) //= -!(mulgA grG) 
	?(in_group grG) ?(i_in_group grG) ?xG ?xHG //.
  by rewrite (mulIg grG) // (mulg1 grG) ?xHG.
move => [u] [v] [[uH ->] ->].
exists x `op (i x:A) (op (u:A) (x:A))`.
rewrite (normal_conj normH) //.
rewrite (mulgA grG) ?(i_in_group grG) ?(in_group grG) // ?xG ?xHG //.
by rewrite (mulgI grG) // (mul1g grG) ?(in_group grG) ?xG ?xHG.
Qed.


Lemma coset_mul_normal x y : `x IN G ==> y IN G ==>
	set_op op (coset op x H) (coset op y H) = coset op (op x y) H`.
move => xG yG.
move: (subgroup_subset (normal_subgroup normH)) => sHG.
rewrite left_right_coset // coset_op.
rewrite (set_opA grG).
  by rewrite SING_SUBSET -left_right_coset // yG (coset_subset grG) sHG.
rewrite -[`set_op op _1 {y}`](set_opA grG) ?sHG ?SING_SUBSET //.
have ->: `set_op op {x:A} {y:A} = {op x y}`.
  rewrite set_op /= !IN_SING EXTENSION => z; rewr !IN_ELIM_THM /= IN_SING; split.
    by move => [u] [v] [[-> ->]].
  by move => ->; exists x y.
rewrite -left_right_coset ?(in_group grG) // coset_op -(set_opA grG).
  by rewrite SING_SUBSET (in_group grG).
by rewrite (set_opK (subgroup_group grG (normal_subgroup normH))).
Qed.


Lemma coset_inv_normal x : `x IN G ==> set_op1 i (coset op x H) = coset op (i x) H`.
move => xG.
move: (subgroup_group grG (normal_subgroup normH)) => grH.
move: (normal_subgroup normH) => subH.
rewrite set_op1 !coset /= EXTENSION; rewr !IN_ELIM_THM /= => z; split.
  move => [u] [] [h] [hH ->] ->.
  exists `(op:A->A->A) x (op (i h) (i x))`.
  rewrite (normal_conj2 grG) ?(i_in_group grH) //.
  rewrite (mulI grG) ?xG ?(in_subgroup subH) // 
	(mulgA grG) ?(in_group grG) ?(i_in_group grG) ?xG ?(in_subgroup subH) //.
  by rewrite (mulIg grG) // (mul1g grG) ?(in_group grG) ?(i_in_group grG) ?xG ?(in_subgroup subH).
move => [u] [uH ->].
exists `i ((op:A->A->A) (i x) u):A`.
rewrite (invgK grG) ?(in_group grG) ?(i_in_group grG) ?xG ?(in_subgroup subH) //=.
exists `(op:A->A->A) (i x) (op (i u) x)`.
rewrite (normal_conj normH) ?xG ?(i_in_group grH) //=.
by rewrite (mulI grG) ?(mulgA grG) ?(mulgI grG) ?(mul1g grG) ?(invgK grG) ?xG //
	?(in_group grG) ?(i_in_group grG) ?xG // ?(in_subgroup subH) // (e_in_group grH).
Qed.




Lemma quotient_group : `group (cosets op G H, set_op op, set_op1 i, H)`.
move: (normal_subgroup normH) => subH.
move: (in_subgroup subH) => sHG.
move: (subgroup_subset subH) => SHG.
move: (subgroup_group grG subH) => grH.
rewrite group.
do 6? split; rewr cosets IN_ELIM_THM /=.
  move => x y [] [u] [uG ->] [v] [vG ->].
  by exists `op u v`; rewrite ?(in_group grG) // coset_mul_normal.

  move => x [u] [uG ->].
  exists `i u`; rewrite (i_in_group grG) //=.
  by rewrite coset_inv_normal.

  by exists e; rewrite (e_in_group grG) (coset_e grG).

  move => c [x] [xG ->].
  rewrite -{2 4}[`H`](coset_e grG) // !coset_mul_normal ?(e_in_group grG) //.
  by rewrite (mulg1 grG) // (mul1g grG).

  move => c [x] [xG ->].
  rewrite coset_inv_normal // !coset_mul_normal ?(i_in_group grG) //.
  by rewrite (mulgI grG) // (mulIg grG) // (coset_e grG).

move => A B C [] [a] [aG ->] [] [b] [bG ->] [c] [cG ->].
by rewrite (set_opA grG) // !(coset_subset grG).
Qed.


Lemma subgroup_of_quotient K1 : `subgroup (set_op op) (set_op1 i) K1 (cosets op G H) <=>
	?K. subgroup op i K G /\ normal op i H K /\ cosets op K H = K1`.
Proof.
split; last first.
  move => [K] [subKG [nHK eqK]].
  have grK := subgroup_group grG subKG.
  rewrite subgroup -eqK.
  rewrite SUBSET -MEMBER_NOT_EMPTY !cosets !IN_ELIM_THM /=; split => [c [g] [gK] -> | ].
    by exists g; rewrite (in_subgroup subKG).
  split; first by exists `coset op e H` e; rewrite (e_in_group grK).
  move => c1 c2 [[g1] [g1K ->]] [g2] [g2K ->].
  exists `op g1 (i g2)`.
  rewrite (in_group grK) ?(i_in_group grK) // andTb.
  by rewrite coset_inv_normal ?coset_mul_normal ?(in_subgroup subKG) // ?(i_in_group grK).
move => subK1.
have grG1 := quotient_group.
set K := `{g | g IN G /\ coset op g H IN K1}`.
exists K.
have grK1 := subgroup_group grG1 subK1.
have eK1 := e_in_group grK1.
have subH := normal_subgroup normH.
have grH := subgroup_group grG subH.
have sHK: `H SUBSET K`.
  rewrite SUBSET -K_def IN_ELIM_THM /= => h hH.
  by exists h; rewrite (coset_eq_e grH) //= eK1 andbT (in_subgroup (normal_subgroup normH)).
have sKG: `K SUBSET G`.
  by rewrite SUBSET -K_def IN_ELIM_THM /= => g [g'] [in] ->.
suff subKG: `subgroup op i K G`.
  have := subgroup_subset subK1.
  rewrite subKG andTb (normal_subset_trans normH) // andTb !cosets SUBSET EXTENSION -K_def !IN_ELIM_THM /=.
  move => inK1 c; split => [|cK1]; first by move => [g'] [[g]] [[gG cK1] ->] c_eq.
  move: (inK1 cK1) => [g] [gG eq].
  by exists g; rewrite eq /=; exists g; rewrite -eq.
rewrite subgroup sKG -MEMBER_NOT_EMPTY andTb -K_def !IN_ELIM_THM /=; split.
  by exists e e; rewrite (e_in_group grG) (coset_e grG (subgroup_subset subH)).
move => x y [[h] [] [hG chK1] ->] [k] [] [kG ckK1] ->.
exists `op h (i k)`; rewrite (in_group grG) ?(i_in_group grG) //=.
rewrite -coset_mul_normal ?(i_in_group grG) // -coset_inv_normal //.
by rewrite (in_group grK1) chK1 andTb (i_in_group grK1).
Qed.


End Normal.


(* Normalizer *)
Section Normalizer.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variable H : `:A->bool`.

Lemma image_eq: `!f g H. (!x. x IN H ==> f x = g x) ==> IMAGE (f:A->A) H = IMAGE g H`.
Proof.
move => f g H eq; rewrite EXTENSION !IN_IMAGE => xx; split => [[yy]] [eq2 in_s].
  by exists yy; rewrite eq2 -eq.
by exists yy; rewrite eq2 -eq.
Qed.

Lemma set_op_sing a b: `set_op op {a} {b} = {op a b}`.
Proof.
rewrite set_op /= EXTENSION inE /= !IN_SING => x; split.
  by move => [z] [y] [[-> ->] ->].
by move => ->; exists a b.
Qed.

Lemma normalizer_subset : `normalizer op i G H SUBSET G`.
Proof. by rewrite SUBSET normalizer IN_ELIM_THM /= => x [g] [] [gG] _ ->. Qed.


Hypothesis grG : `group (G,op,i,e)`.

Lemma set_op_subset A B : `A SUBSET G ==> B SUBSET G ==> set_op op A B SUBSET G`.
Proof.
rewrite !SUBSET set_op /= inE /= => sAG sBG g [a] [b] [[aA bB] ->].
by rewrite (in_group grG) (sBG b) // sAG.
Qed.

Lemma in_normalizer0 g : `g IN normalizer op i G H <=> g IN G /\ H = set_op op {i g} (set_op op H {g})`.
Proof.
rewrite normalizer inE; apply: andb_id2l => gG.
set s1 := `IMAGE _1 _2`.
set s2 := `set_op op _1 _2`.
suff ->: `s1 = s2`; first by rewrite [`_ = H`]eq_sym.
rewrite EXTENSION -s1_def -s2_def IN_IMAGE set_op /= !IN_ELIM_THM /= !IN_SING => y; split.
  move => [x] [y_eq xH].
  exists `i g` `op x g`; rewrite -y_eq /=.
  by exists x g.
move => [x] [z] [] [x_eq] [a] [b] [[aH ->] ->] ->.
by exists a; rewrite x_eq.
Qed.


Lemma normalizerK : `normalizer op i G G = G`.
Proof.
rewrite normalizer EXTENSION IN_ELIM_THM /= => g; split => [[x] [] [gG] _ -> //| gG].
exists g; rewrite gG andTb /= EXTENSION IN_IMAGE /= => h; split.
  by move => [x] [->] xG; rewrite !(in_group grG) ?(i_in_group grG).
move => hG; exists `op (op g h) (i g)`.
by rewrite (mulKg grG) ?(mulgA grG) ?(mulIg grG) ?(mul1g grG) ?(in_group grG) ?(i_in_group grG).
Qed.


Lemma normalizer_subgroup : `H SUBSET G ==> subgroup op i (normalizer op i G H) G`.
Proof.
rewrite subgroup SUBSET -MEMBER_NOT_EMPTY => sHG.
rewrite normalizer_subset andTb normalizer !IN_ELIM_THM /=; split.
  exists e e; rewrite (e_in_group grG) /= EXTENSION IN_IMAGE /= => h; split.
    by move => [x] [-> xH]; rewrite (invg_e grG) (mul1g grG) ?(mulg1 grG) ?sHG.
  by move => hH; exists h; rewrite (invg_e grG) (mul1g grG) ?(mulg1 grG) // ?sHG.
move => x y [] [g1] [] [g1G eq1] x_eq [g2] [] [g2G eq2] y_eq.
exists `op g1 (i g2)`; rewrite x_eq y_eq /= (in_group grG) ?(i_in_group grG) // andTb.
rewrite (mulI grG) ?(invgK grG) ?(i_in_group grG) //.
move: x_eq y_eq => _ _.
set lhs := `IMAGE _1 _2`.
have ->: `lhs = IMAGE (\h. op g2 (op h (i g2))) H`.
  rewrite -eq1 -IMAGE_o -lhs_def; apply: image_eq => h /sHG hG.
  by rewrite o_THM /= !(mulgA grG) // ?(in_group grG) ?(i_in_group grG).
rewrite -{1}eq2 EQ_SYM_EQ -{1}(IMAGE_I H) -IMAGE_o; apply: image_eq => h hH.
rewrite o_THM I_THM /=.
rewrite (mulgA grG) ?(in_group grG) ?(i_in_group grG) ?g2G ?sHG //.
rewrite (mulgA grG) ?(i_in_group grG) ?(in_group grG) ?g2G ?sHG //.
rewrite (mulgI grG) // (mul1g grG) ?(in_group grG) ?g2G ?sHG //.
by rewrite (mulgK grG) ?g2G ?sHG.
Qed.


Hypothesis subH : `subgroup op i H G`.


Lemma subset_normalizer : `H SUBSET (normalizer op i G H)`.
Proof.
have grH := (subgroup_group grG subH).
rewrite SUBSET normalizer IN_ELIM_THM /= => h hH.
exists h; rewrite (in_subgroup subH) //=.
rewrite EXTENSION IN_IMAGE /= => x; split.
  move => [g] [-> gH].
  by rewrite !(in_group grH) ?(i_in_group grH).
move => xH; exists `op (op h x) (i h)`.
rewrite !(in_group grH) ?(i_in_group grH) // andbT.
rewrite !(mulgA grH) ?(in_group grH) ?(i_in_group grH) //.
by rewrite (mulIg grH) // (mul1g grH) // (mulKg grH).
Qed.


Lemma normal_in_normalizer : `normal op i H (normalizer op i G H)`.
Proof.
have sHG := (subgroup_subset subH).
have grN := (subgroup_group grG (normalizer_subgroup sHG)).
have grH := (subgroup_group grG subH).
rewrite normal (subgroup_alt2 grN) subset_normalizer grH !andTb => x y.
rewrite normalizer IN_ELIM_THM /= => [] [] [g] [] [gG].
rewrite EXTENSION IN_IMAGE /= => eq _ yH.
by rewrite -eq; exists y.
Qed.


Lemma in_normalizer g : `g IN normalizer op i G H <=> g IN G /\ coset op g H = set_op op H {g}`.
Proof.
have sHG := subgroup_subset subH.
rewrite in_normalizer0; apply: andb_id2l => gG; split; last first.
  rewrite coset_op => <-.
  rewrite (set_opA grG) ?SING_SUBSET ?(i_in_group grG) //.
  by rewrite set_op_sing (mulIg grG) // -coset_op (coset_e grG).
move/(congr1 `set_op op {g}`).
rewrite -coset_op => ->.
rewrite (set_opA grG) ?SING_SUBSET ?(i_in_group grG) ?set_op_subset // ?SING_SUBSET //.
by rewrite set_op_sing (mulgI grG) // -coset_op (coset_e grG) ?set_op_subset ?SING_SUBSET.
Qed.


End Normalizer.





(* Morph *)
Section Morph.

Variable G : `:A->bool`.
Variable e : `:A`.
Variable op : `:A -> A -> A`.
Variable i : `:A -> A`.
Hypothesis grG : `group (G,op,i,e)`.

Variable H : `:B->bool`.
Variable hop : `:B->B->B`.
Variable he : `:B`.
Variable hi : `:B->B`.
Hypothesis grH : `group (H, hop, hi, he)`.

Variable f : `:A->B`.
Hypothesis morph : `morphism f op hop G H`.

Lemma morph_closed x : `x IN G ==> f x IN H`. by move: morph; rewrite morphism /=. Qed.
Lemma morph_mul x y : `x IN G ==> y IN G ==> f (op x y) = hop (f x) (f y)`.
by move: morph; rewrite morphism /=. Qed.

Lemma morph_e : `f e = he`.
have: `f e = hop (f e) (f e)`.
  by rewrite -{1}(mulg1 grG e) ?morph_mul ?(e_in_group grG).
rewrite -{1}[`f e`](mul1g grH) ?morph_closed ?(e_in_group grG).
move: (mulg_rightI grH `f (e:A):B` he `f (e:A):B`).
by rewrite !morph_closed ?(e_in_group grG) ?(e_in_group grH) /=.
Qed.

Lemma morph_i x : `x IN G ==> f (i x) = hi (f x)`.
move => xG.
apply: ("REWRITE_RULE[IMP_IMP] i_uniq" grH).
rewrite !morph_closed ?(i_in_group grG) //=.
by rewrite -morph_mul ?(i_in_group grG) // (mulgI grG) // morph_e.
Qed.

End Morph.


Section Lagrange.

Variable G : `:A->bool`.
Variable e : `:A`.
Variable op : `:A -> A -> A`.
Variable i : `:A -> A`.
Variable n : `:num`.
Hypothesis grG : `group (G,op,i,e)`.

Variable H : `:A->bool`.
Hypothesis subH : `subgroup op i H G`.

Lemma coset_eq h x : `x IN G ==> h IN H ==> coset op (op x h) H = coset op x H`.
move: (subgroup_group grG subH) => grH.
move: (subgroup_subset subH); rewrite SUBSET => sHG.
move => xG hH; rewrite !coset EXTENSION => z; rewr IN_ELIM_THM /=; split.
  move => [y] [yH eq].
  by exists `op h y`; rewrite eq ?(mulgA grG) ?(in_group grH) ?xG // ?sHG.
move => [u] [uH ->].
exists `op (i (op x h)) (op x u)`.
rewrite [`op (op x h) _`](mulgA grG) ?(mulgI grG) ?(mul1g grG) 
	?(i_in_group grG) ?(in_group grG) ?xG ?sHG //.
rewrite (mulI grG) ?xG ?sHG // (mulgA grG) ?(mulKg grG) ?(i_in_group grG) ?(in_group grG)
	?(i_in_group grG) ?xG ?sHG //.
by rewrite (in_group grH) ?(i_in_group grH).
Qed.

Lemma coset_inter x y : `x IN G ==> y IN G ==> ~(coset op x H = coset op y H) ==>
	coset op x H INTER coset op y H = {}`.
move => xG yG nc.
move: (subgroup_subset subH) => SHG.
move: (SHG); rewrite SUBSET => sHG.
move: (subgroup_group grG subH) => grH.
rewrite "TAUT `!P. P <=> ~ ~P`"; move: nc; rewrite CONTRAPOS_THM -MEMBER_NOT_EMPTY.
move => [u].
rewrite 2!{1}coset IN_INTER; rewr IN_ELIM_THM /=.
move => [] [h1] [h1H ->] [h2] [h2H] eq.
have: `op (op x h1) (i h1) = op (op y h2) (i h1)`; first by rewrite eq.
rewrite -!(mulgA grG) ?xG ?yG ?(i_in_group grG) ?sHG // (mulgI grH) // (mulg1 grG) // => ->.
set h := `op h2 _`.
have hH: `h IN H`; first by  rewrite -h_def ?(in_group grH) ?(i_in_group grH).
by rewrite coset_eq.
Qed.


Lemma x_in_coset x : `x IN G ==> x IN coset op x H`.
move: (subgroup_group grG subH) => grH.
move => xG; rewr coset IN_ELIM_THM /=.
by exists e; rewrite (e_in_group grH) (mulg1 grG).
Qed.


Lemma cosets_unions : `G = UNIONS (cosets op G H)`.
move: (subgroup_subset subH) => SHG.
rewrite EXTENSION IN_UNIONS cosets; rewr IN_ELIM_THM => x /=; split.
  move => xG.
  exists `coset op x H`; rewrite x_in_coset //=.
  by exists x.
move => [c] [] [y] [yG ->].
rewrite coset; rewr IN_ELIM_THM /= => [] [u] [uH ->].
move: SHG; rewrite SUBSET => sHG.
by rewrite (in_group grG) yG sHG.
Qed.

Lemma coset_equiv g1 g2 : `g1 IN G ==> g2 IN G ==> 
	(coset op g1 H = coset op g2 H <=> op (i g2) g1 IN H)`.
move => g1G g2G.
move: (subgroup_group grG subH) => grH; split; last first.
  rewrite !coset EXTENSION !inE /= => eq x; split => [[y] [yH x_eq]].
    exists `op (op (i g2) g1) y`; rewrite (in_group grH) // andTb.
    rewrite !(mulgA grG) ?(mulgI grG) ?(mul1g grG) ?(in_group grG) ?(i_in_group grG) //.
    by rewrite g2G (in_subgroup subH).
  exists `op (op (i g1) g2) y`; rewrite (in_group grH).
    by move: (i_in_group grH eq); rewrite (mulI grG) ?(invgK grG) ?(i_in_group grG).
  rewrite andTb !(mulgA grG) ?(mulgI grG) ?(mul1g grG) ?(in_group grG) ?(i_in_group grG) //.
  by rewrite g1G (in_subgroup subH).
rewrite EXTENSION => /(_ g1).
have -> /=: `g1 IN coset op g1 H`.
  by rewrite coset inE /=; exists e; rewrite (e_in_group grH) (mulg1 grG).
rewrite coset inE /= => [] [y] [yH].
rewrite -{1}(mul1g grG g1) // -(mulgI grG g2) //.
move/(congr1 `op (i g2)`).
rewrite !(mulgA grG) ?(in_group grG) ?(i_in_group grG) // ?g2G ?(in_subgroup subH) //.
rewrite !(mulIg grG) ?(mul1g grG) ?(i_in_group grG) // ?(in_subgroup subH) //.
by move => ->.
Qed.

Lemma coset_not_empty g : `g IN G ==> ~(coset op g H = {})`.
have grH := subgroup_group grG subH.
move => gG; rewrite -MEMBER_NOT_EMPTY coset inE /=; exists g.
by exists e; rewrite (e_in_group grH) (mulg1 grG).
Qed.




Hypothesis finG : `FINITE G`.

Lemma subgroup_size : `H HAS_SIZE (CARD H)`.
move: (subgroup_subset subH).
rewrite -FINITE_HAS_SIZE => SHG.
apply: FINITE_SUBSET.
by exists G; rewrite SHG /=.
Qed.

Lemma coset_card x : `x IN G ==> CARD (coset op x H) = CARD H`.
move => xG; move: (subgroup_subset subH) => SHG.
move: (SHG); rewrite SUBSET => sHG.
have ->: `coset op x H = IMAGE (op x) H`.
  by rewrite coset IMAGE EXTENSION => z; rewr IN_ELIM_THM.
rewrite CARD_IMAGE_INJ //; split; last first.
  by apply: FINITE_SUBSET; exists G.
move => u v [uH] [vH] op_eq.
by move: (mulg_leftI grG xG (sHG uH) (sHG vH) op_eq).
Qed.

Lemma finite_index : `FINITE (cosets op G H)`.
have ->: `cosets op G H = IMAGE (\x. coset op x H) G`.
  by rewrite cosets IMAGE EXTENSION; rewr IN_ELIM_THM /=.
by rewrite FINITE_IMAGE.
Qed.

Lemma LaGrange : `CARD G = CARD (cosets op G H) * CARD H`.
move: (subgroup_subset subH) => SHG.
rewrite {1}cosets_unions CARD_UNIONS; last first.
  rewrite -NSUM_CONST ?finite_index //.
  apply NSUM_EQ.
  move => c; rewr cosets IN_ELIM_THM /= => [] [x] [xG ->].
  by rewrite coset_card.
rewrite finite_index /=; split.
  move => c; rewr cosets IN_ELIM_THM /= => [] [x] [xG ->].
  by apply: FINITE_SUBSET; exists G; rewrite (coset_subset grG).
move => c1 c2; rewr cosets IN_ELIM_THM /= => [] [] [x] [xG ->] [] [y] [yG ->] nc.
exact: (coset_inter xG yG nc).
Qed.


End Lagrange.


Lemma real_group : `group((:real), (+), (--), &0)`.
by rewrite group !IN_UNIV /= REAL_ADD_LID REAL_ADD_RID /= REAL_ADD_LINV REAL_ADD_RINV /= REAL_ADD_ASSOC. Qed.

Lemma real_mul_group : `group({x | &0 < x}, (*), inv, &1)`.
rewrite group; rewr IN_ELIM_THM; rewrite REAL_MUL_LID REAL_MUL_RID REAL_MUL_ASSOC REAL_LT_01 /=. split; first by apply: REAL_LT_MUL.
split; first by apply: REAL_LT_INV.
by move => x /REAL_POS_NZ x0; rewrite REAL_MUL_RINV // REAL_MUL_LINV.
Qed.

Lemma test x y : `&0 < y ==> &0 < x ==> inv (x * y) = inv y * inv x`.
move => y0 x0.
by rewrite (mulI real_mul_group) //; rewr IN_ELIM_THM.
Qed.


Section BijGroup.

Implicit Type s t : `:A->bool`.

"let inv_fun = new_definition `inv_fun s t f = 
	(\y. if y IN t then @x. f x = y /\ x IN s else y)`".

Lemma inv_fun_spec f s t y : `(?x. x IN s /\ f x = y) ==> y IN t ==>
		inv_fun s t f y IN s /\ f (inv_fun s t f y) = y`.
rewrite inv_fun /= => [] [z] [zs fzy] yt.
set P := `\x. f x = y /\ x IN s`.
have/SELECT_AX: `P z`; first by rewrite -P_def /=.
by rewrite -P_def /=.
Qed.

Lemma inv_fun_surj_in f s t y : `SURJ f s t ==> y IN t ==> inv_fun s t f y IN s`.
rewrite SURJ => [] [_ sf] yt.
by move: (inv_fun_spec (sf yt) yt) => [H _].
Qed.

Lemma inv_fun_rid f s t y : `SURJ f s t ==> y IN t ==> f (inv_fun s t f y) = y`.
rewrite SURJ => [] [_ sf] yt.
by move: (inv_fun_spec (sf yt) yt) => [_].
Qed.

Lemma inv_fun_lid f s t x : `INJ f s t ==> x IN s ==> inv_fun s t f (f x) = x`.
rewrite INJ => [] [f_in f_inj] xs.
apply: f_inj; rewrite xs /=.
apply "REWRITE_RULE[IMP_IMP] inv_fun_spec".
by rewrite f_in //=; exists x.
Qed.

"let bij_s = new_definition `bij_s f s <=> BIJ f s s /\ (!x. ~(x IN s) ==> f x = x)`".


Lemma f_ext f g: `(f = g) <=> (!x. f x = g x)`.
split => [-> //| eq].
by rewrite -[`f`]ETA_AX -[`g`]ETA_AX; "ABS_TAC".
Qed.


Lemma bij_ext s t f: `s SUBSET t ==> bij_s f s ==> bij_s f t`.
rewrite SUBSET !bij_s !BIJ => s_t [[inj_f surj_f] f_out]; split => [|x xnt]; last first.
  move: (s_t x); rewrite -[`x IN s ==> _`]CONTRAPOS_THM => h; apply: f_out.
  exact: h.
move: surj_f inj_f; rewr !INJ !SURJ -!IMP_IMP => fs f_surj _ f_inj.
do 2!split; move => x; case: (EXCLUDED_MIDDLE `x IN s`) => xs.
  by move: (fs xs) => /s_t /=.
  by move: (f_out xs) => ->.
  move => y; case: (EXCLUDED_MIDDLE `y IN s`) => ys _ _.
    by move => eq; apply: (f_inj xs ys).
  rewrite (f_out ys) => eq.
  by move: (fs xs) ys; rewrite eq /=.
  move => y; case: (EXCLUDED_MIDDLE `y IN s`) => ys _ _; last by rewrite !f_out.
  rewrite f_out // => eq; move: (fs ys) xs.
  by rewrite -eq /=.
  by move => _; apply: s_t; apply: fs.
  by rewrite f_out.
  move => _; move: (f_surj xs) => [y] [/s_t yt eq].
  by exists y.
by move => xt; exists x; rewrite f_out.
Qed.
    

  
Lemma inv_fun_ext s t f : `s SUBSET t ==> bij_s f s ==> inv_fun t t f = inv_fun s s f`.
move => st bs.
move: st bs (bij_ext st bs).
rewrite SUBSET !bij_s !BIJ f_ext => s_t [[inj_s surj_s] s_out] [[inj_t surj_t] t_out] x.
case: (EXCLUDED_MIDDLE `x IN s`) => xs; last first.
  rewrite -(s_out xs).
  case: (EXCLUDED_MIDDLE `x IN t`) => xt.
    by rewrite inv_fun_lid // inv_fun /= (s_out xs).
  by rewrite !inv_fun /= (s_out xs).
have xt := s_t xs.
move: (inj_t); rewrite INJ => [] [_]; apply.
rewrite !inv_fun_surj_in //= s_t ?inv_fun_surj_in //=.
by rewrite !inv_fun_rid.
Qed.


Lemma bij_group s t : `s SUBSET t ==> group({f | bij_s f s}, (o), inv_fun t t, I)`.
move/inv_fun_ext => inv_ext.
rewr group IN_ELIM_THM bij_s BIJ !o_THM !I_THM; do 8?split.

rewr INJ SURJ -20!IMP_IMP !o_THM.
move => f g fs f_inj _ f_surj f_out gs g_inj _ g_surj g_out; do 2?split; last first.
  move => x xns.
  by rewrite (g_out xns) f_out.
split => [x /gs /fs //| x y xs ys f_eq].
  by rewrite (g_inj x y) // xs ys /= (f_inj `g x` `g y`) // !gs //.
split => [x /gs /fs //| x xs].
move: (f_surj xs) => [z] [zs <-].
move: (g_surj zs) => [y] [ys eq].
by exists y.

move => f [[f_inj f_surj] f_out]; rewrite inv_ext ?bij_s ?BIJ //.
split; last by move => x xns; rewrite inv_fun.
split.
  rewrite INJ; split => [x /(inv_fun_surj_in f_surj) // |].
  move => x y [xs [ys inv_eq]].
  have H := inv_fun_rid f_surj.
  by move: (H xs) (H ys); rewrite inv_eq => ->.
rewrite SURJ; split => [x /(inv_fun_surj_in f_surj) // |].
move => x xs.
exists `f x`; move: (f_inj); rewrite INJ => [] [fs _].
by rewrite (fs xs) /= (inv_fun_lid f s s) //.

by rewrite INJ !I_THM /=.

rewrite SURJ !I_THM /= => x xs.
by exists x.

by rewr I_O_ID.

move => f [[f_inj f_surj] f_out]; rewrite inv_ext ?bij_s ?BIJ //.
rewrite !f_ext !o_THM I_THM; split => x.
  case: (EXCLUDED_MIDDLE `x IN s`) => xs; first by rewrite inv_fun_rid.
  by rewr inv_fun /= xs /=; exact: f_out.
case: (EXCLUDED_MIDDLE `x IN s`) => xs; first by rewrite inv_fun_lid.
rewr inv_fun /=.
by move: (f_out xs) => ->; rewr xs.

by rewrite o_ASSOC.
Qed.


Lemma bij_gr s : `group ({f | bij_s f s}, (o), inv_fun s s, I)`.
by apply: bij_group; rewrite SUBSET_REFL. Qed.


Lemma test s f g : `bij_s f s ==> bij_s g s ==> inv_fun s s (f o g) = inv_fun s s g o inv_fun s s f`.
move => bf bg.
by rewrite (mulI (bij_gr s)) //; rewr IN_ELIM_THM.
Qed.


Lemma bij_sub s t : `s SUBSET t ==> subgroup (o) (inv_fun t t) {f | bij_s f s} {g | bij_s g t}`.
move => s_t; rewrite subgroup; split.
  by rewrite SUBSET; rewr IN_ELIM_THM => f; exact: bij_ext.
split.
  rewrite -MEMBER_NOT_EMPTY; exists `I:A->A`.
  by rewrite (e_in_group (bij_gr s)).
move => f g [fb gb].
by rewrite (in_group (bij_gr s)) fb /= (i_in_group (bij_group s_t)).
Qed.


End BijGroup.


Section Z_group.

"let add_mod = new_definition `add_mod p m n = (m + n) MOD p`".
"let inv_add_mod = new_definition `inv_add_mod p x = if x = 0 then 0 else p - x`".

Lemma grZ n : `0 < n ==> group({i:num | i < n}, (add_mod n), inv_add_mod n, 0)`.
move/lt0n_neq0 => n0.
rewrite group; rewr !IN_ELIM_THM !add_mod inv_add_mod; do 6?split.
  by rewr (DIVISION n0).
  by case => /=; move: n0; arith.
  by move: n0; arith.
  by move => x xn; rewrite add0n addn0 MOD_LT.
  case => [|m lt_m_n] /=; first by rewrite add0n MOD_0.
    by rewrite eqS0 /= subnKC ?subnK ?ltnW // -{1 3}(muln1 n) MOD_MULT.
move => x y z [xn [yn zn]].
by rewrite -{1}(MOD_LT xn) -{2}(MOD_LT zn) !MOD_ADD_MOD // addnA.
Qed.

Lemma test n x y : 
	`0 < n ==> x < n ==> y < n ==> add_mod n (add_mod n x y) (inv_add_mod n y) = x`.
move => n0 xn yn.
(*
rewrite !add_mod inv_add_mod.
case: y yn => [/=|y yn].
  by rewrite !addn0 !MOD_LT.
rewrite eqS0 /= -(MOD_LT `n - SUC y` n); first by move: n0 yn; arith.
rewrite MOD_ADD_MOD ?lt0n_neq0 // -addnA subnKC ?ltnW //.
by rewrite addnC -{1}(mul1n n) MOD_MULT_ADD MOD_LT.
*)
by rewrite (mulgK (grZ n0)) //; rewr IN_ELIM_THM.
Qed.

End Z_group.



Lemma SING_HAS_SIZE_1 x : `{x} HAS_SIZE 1`.
Proof. by rewrite HAS_SIZE_1_EXISTS EXISTS_UNIQUE; exists x; rewrite !IN_SING. Qed.

Lemma HAS_SIZE_1_SING X : `X HAS_SIZE 1 <=> ?x. X = {x}`.
split; last by move => [x ->]; rewrite SING_HAS_SIZE_1.
rewrite ONE "GEN_ALL HAS_SIZE_CLAUSES" HAS_SIZE_0 => [] [x] [t] [->] [_ eq].
by exists x.
Qed.



Lemma BIJ_SYM f V U : `BIJ f V U ==> ?g. BIJ g U V`.
rewrite !BIJ INJ SURJ => [] [[f_on f_inj] [_ f_surj]].
move: (BIJECTIVE_ON_LEFT_RIGHT_INVERSE f_on).
rewr f_inj f_surj /= => [] [g] [g_on] [fg gf].
exists g; rewrite INJ SURJ; rewr g_on /=; split.
  move => x y [xU] [yU] g_eq.
  by rewrite -(fg yU) -(fg xU) g_eq.
move => x xV.
by exists `f x`; rewrite f_on // gf.
Qed.


Lemma BIJ_CARD_EQ V U f : `FINITE V ==> BIJ f V U ==> CARD U = CARD V`.
move => finV bij_f.
move: (Hypermap.BIJ_INVERSE bij_f) => [g] [gf] [fg] bij_g.
apply BIJECTIONS_CARD_EQ; exists g f; rewrite finV /=; split => x x_in.
  by rewrite fg //; move: bij_g; rewrite BIJ INJ => [] [] [/(_ x_in)] /=.
by rewrite gf //; move: bij_f; rewrite BIJ INJ => [] [] [/(_ x_in)] /=.
Qed.


(* Action *)
Section Action.

"let acts = new_definition `acts (G, op, e) S a <=> 
	(!g x. g IN G ==> x IN S ==> a g x IN S) /\
	(!g h x. g IN G ==> h IN G ==> x IN S ==> a g (a h x) = a (op g h) x) /\
	(!x. x IN S ==> a e x = x)`".

"let stab = new_definition `Stab G a x = {g | g IN G /\ a g x = x}`".
"let orbit = new_definition `Orbit G a x = {a g x | g | g IN G}`".
"let fix = new_definition `Fix G S a = {x | x IN S /\ (!g. g IN G ==> a g x = x)}`".

Variable G : `:A -> bool`.
Variable op : `:A -> A -> A`.
Variable i : `:A -> A`.
Variable e : `:A`.
Variable S : `:B -> bool`.
Variable a : `:A -> B -> B`.

Lemma in_stab g x : `g IN Stab G a x ==> a g x = x`.
by rewrite stab IN_ELIM_THM /= => [] [h] [hyp ->]. Qed.


Lemma fix_subset : `Fix G S a SUBSET S`. by rewrite SUBSET fix inE => x /=. Qed.


Hypothesis acts_a : `acts (G, op, e) S a`.

Lemma acts1 x : `x IN S ==> a e x = x`. by move: acts_a; rewrite acts /=. Qed.
Lemma acts_in g x : `g IN G ==> x IN S ==> a g x IN S`. by move: acts_a; rewrite acts /=. Qed.
Lemma acts_op g h x : `g IN G ==> h IN G ==> x IN S ==> a g (a h x) = a (op g h) x`.
Proof. by move: acts_a; rewrite acts /=. Qed.

Lemma acts_sub H : `H SUBSET G ==> acts (H, op, e) S a`.
Proof.
rewrite SUBSET acts => sHG; do !split.
  move => g x [gH xS].
  by rewrite acts_in xS sHG.
  move => g h x [[gH hH] xS].
  by rewrite acts_op // xS ?sHG.
by move => x xS; rewrite acts1.
Qed.


Lemma orbit_subset x : `x IN S ==> Orbit G a x SUBSET S`.
by move => xS; rewrite orbit SUBSET inE /= => y [g [gG ->]]; rewrite acts_in. Qed.


Hypothesis grG : `group (G, op, i, e)`.


Lemma x_in_orbit x : `x IN S ==> x IN Orbit G a x`.
by move => xS; rewrite orbit inE /=; exists e; rewrite (e_in_group grG) acts1. Qed.


Lemma stab_subgroup x : `x IN S ==> subgroup op i (Stab G a x) G`.
move => xS; rewrite subgroup stab; do 2?split.
  by rewrite SUBSET inE => x [->].
  by rewrite -MEMBER_NOT_EMPTY; exists e; rewrite inE (e_in_group grG) acts1.
rewrite !inE => g h [[gG agx] [hG ahx]].
rewrite (in_group grG) ?(i_in_group grG) // andTb -acts_op ?(i_in_group grG) //.
suff ->: `a (i h) x = x`; first by done.
by rewrite -{2}(acts1 x) // -(mulIg grG h) // -acts_op ?(i_in_group grG).
Qed.

Lemma stab_group x : `x IN S ==> group (Stab G a x, op, i, e)`.
by move => xS; rewrite subgroup_group stab_subgroup. Qed.


Lemma orbits_disj x y : `x IN S ==> y IN S ==> 
	~(Orbit G a x = Orbit G a y) ==> (Orbit G a x INTER Orbit G a y = {})`.
move => xS yS; apply: contraR; rewrite -MEMBER_NOT_EMPTY !orbit IN_INTER !inE /=.
move => [z] [[g [gG zgx]] [h [hG zhx]]]; rewrite EXTENSION !inE /= => t; split => [] [u] [uG tu].
  exists `op u (op (i g) h)`.
  rewrite ?(in_group grG) ?(i_in_group grG) // andTb -acts_op ?(in_group grG) ?(i_in_group grG) //.
  rewrite tu; "AP_TERM_TAC".
  by rewrite -(acts1 x) // -(mulIg grG g) // -!acts_op ?(i_in_group grG) // -zhx -zgx.
exists `op u (op (i h) g)`.
rewrite ?(in_group grG) ?(i_in_group grG) // andTb -acts_op ?(in_group grG) ?(i_in_group grG) //.
rewrite tu; "AP_TERM_TAC".
by rewrite -(acts1 y) // -(mulIg grG h) // -!acts_op ?(i_in_group grG) // -zhx -zgx.
Qed.


Lemma fix_orbit_imp x : `x IN Fix G S a ==> Orbit G a x = {x}`.
rewrite fix orbit EXTENSION !inE /= IN_SING => [] [xS fix] y.
split; last by move => ->; exists e; rewrite (e_in_group grG) acts1.
by move => [g [/fix ->]].
Qed.


Lemma fix_orbit x : `x IN S ==> (x IN Fix G S a <=> Orbit G a x = {x})`.
move => xS; split; first exact: fix_orbit_imp.
rewrite fix orbit EXTENSION !inE /= IN_SING.
move => eq; rewrite xS andTb => g gG.
by rewrite -eq; exists g.
Qed.


Lemma x_in_orbit x : `x IN S ==> x IN Orbit G a x`.
by move => xS; rewrite orbit inE /=; exists e; rewrite (e_in_group grG) acts1. Qed.



Lemma sing_orbit x : `x IN S ==> (x IN Fix G S a <=> Orbit G a x HAS_SIZE 1)`.
move => xS; rewrite fix_orbit // HAS_SIZE_1_SING; split => [-> | ]; first by exists x.
move => [y eq]; move: (x_in_orbit xS).
by rewrite eq IN_SING => ->.
Qed.






Lemma orbit_image x : `Orbit G a x = IMAGE (\g. a g x) G`.
by rewrite orbit EXTENSION inE IN_IMAGE /= andbC. Qed.

Lemma finite_orbit x : `FINITE S ==> x IN S ==> FINITE (Orbit G a x)`.
by move => finS xS; apply FINITE_SUBSET; exists S; rewrite orbit_subset. Qed.

Lemma bij_orbit_cosets x : `x IN S ==> ?f. BIJ f (cosets op G (Stab G a x)) (Orbit G a x)`.
move => xS.
move: (stab_group xS) (stab_subgroup xS) => grS subS.
set f := `\c:A->bool. a (CHOICE c) x`.
have f_eq : `!g. g IN G ==> f (coset op g (Stab G a x)) = a g x`.
  move => g gG; rewrite -f_def /=.
  move: (CHOICE_DEF `coset op g (Stab G a x)`); rewrite (coset_not_empty grG subS) //=.
  rewrite {2}coset inE /= => [] [h] [h_stab ->].
  by rewrite -acts_op ?gG ?xS ?(in_subgroup subS) // (in_stab h_stab).
exists f.
rewrite BIJ; split; last first.
  rewrite SURJ cosets !inE /=; split.
    move => c [g] [gG ->]; rewrite f_eq // orbit_image IN_IMAGE /=.
    by exists g.
  move => y; rewrite orbit_image IN_IMAGE => [] [g] /= [y_eq gG].
  exists `coset op g (Stab G a x)`; split; first by exists g.
  by rewrite f_eq.
rewrite INJ cosets !inE /=; split.
  move => c [g] [gG ->]; rewrite f_eq // orbit_image IN_IMAGE /=.
  by exists g.
move => c1 c2 [[g [gG ->]] [] [h [hG ->]]].
rewrite !f_eq // => a_eq.
rewrite (coset_equiv grG subS) // stab inE (in_group grG) ?(i_in_group grG) // andTb.
by rewrite -{2}(acts1 xS) -(mulIg grG h) // -!acts_op ?(i_in_group grG).
Qed.



Lemma card_orbit x : `FINITE S ==> x IN S ==> 
	CARD (Orbit G a x) = CARD (cosets op G (Stab G a x))`.
move => finS xS.
move: (bij_orbit_cosets xS) => [f] /BIJ_SYM [g] bij.
move: (finite_orbit finS xS) => finO.
by move: (BIJ_CARD_EQ finO bij) => ->.
Qed.


Lemma set_union_orbits : `S = UNIONS (IMAGE (Orbit G a) S)`.
rewrite EXTENSION IN_UNIONS IN_IMAGE => x; split.
  by move => xS; exists `Orbit G a x`; rewrite x_in_orbit // andbT; exists x.
move => [t] [] [y] [-> yS].
rewrite orbit_image IN_IMAGE => [] [h] [-> hG] /=; exact: acts_in.
Qed.

Lemma card_set : `FINITE S ==> CARD S = nsum (IMAGE (Orbit G a) S) CARD`.
move => finS; rewrite {1}set_union_orbits CARD_UNIONS // FINITE_IMAGE // andTb; split.
  move => t; rewrite IN_IMAGE => [] [x] [-> xS]; apply FINITE_SUBSET.
  by exists S; rewrite orbit_subset.
move => t u; rewrite 2!IN_IMAGE => [] [] [x] [-> xS] [] [y] [-> yS] disj.
exact: orbits_disj.
Qed.


Lemma card_set_fix : `FINITE S ==> CARD S = CARD (Fix G S a) + 
	nsum {Orbit G a x | x | x IN S /\ CARD (Orbit G a x) > 1} CARD`.
move => finS. 
rewrite (card_set finS).
set A := `{Orbit G a x | x | x IN S /\ CARD (Orbit G a x) > 1}`.
set B := `{Orbit G a x | x | x IN S /\ CARD (Orbit G a x) = 1}`.
have ->: `IMAGE (Orbit G a) S = A UNION B`.
  rewrite EXTENSION IN_UNION IN_IMAGE -A_def -B_def !inE /= => orb; split; last first.
    case => [] [x] [xS eq].
      by exists x.
    by exists x.
  move => [x] [eq xS].
  set n := `CARD (Orbit G a x)`.
  have finO := finite_orbit finS xS.
  case: n n_def => [ | [card1|n card_ge2]].
    rewrite CARD_EQ_0 // => x_eq.
    by move: (x_in_orbit xS); rewrite {1}x_eq NOT_IN_EMPTY.
    by right; exists x; rewrite card1 ONE.
  by left; exists x; rewrite card_ge2 gtE ONE ltSS ltn0Sn.
have finB: `FINITE B`.
  apply FINITE_SUBSET; exists `IMAGE (Orbit G a) S`.
  rewrite FINITE_IMAGE // andTb SUBSET -B_def inE IN_IMAGE /= => orb [x] [] [xS _] eq.
  by exists x.
rewrite NSUM_UNION ?DISJOINT ?finB ?andTb.
  split.
    apply FINITE_SUBSET; exists `IMAGE (Orbit G a) S`.
    rewrite FINITE_IMAGE // andTb SUBSET -A_def inE IN_IMAGE /= => orb [x] [] [xS _] eq.
    by exists x.
  rewrite -A_def -B_def EXTENSION IN_INTER NOT_IN_EMPTY !inE /= => orb.
  rewrite "TAUT `!P. ~P <=> (P ==> F)`" => [] [] [x] [] [xS gt1] eq [y] [] [yS] eq1.
  rewrite eq => orb_eq; move: eq1 gt1.
  by rewrite orb_eq; arith.
rewrite addnC eqn_addr.
have ->: `nsum B CARD = CARD B`.
  rewrite CARD_EQ_NSUM //; apply NSUM_EQ => orb.
  by rewrite -B_def inE /= => [] [x] [] [xS] <- ->.
have ->: `B = IMAGE (Orbit G a) (Fix G S a)`.
  rewrite -B_def EXTENSION inE /= IN_IMAGE => orb; split.
    move => [x] [[xS card1] orb_eq].
    exists x; rewrite orb_eq /= fix_orbit // (Hypermap.set_one_point `Orbit G a x` x) //.
    by rewrite finite_orbit // x_in_orbit.
  move => [x] [orb_eq] fix.
  have xS: `x IN S`; first by move: fix_subset; rewrite SUBSET; exact.
  by exists x; move: fix orb_eq; rewrite fix_orbit // => -> ->; rewrite Hypermap.CARD_SINGLETON.
apply CARD_IMAGE_INJ; split; last first.
  by apply FINITE_SUBSET; exists S; rewrite fix_subset.
move => x y [/fix_orbit_imp ->] [/fix_orbit_imp ->].
by rewrite Hypermap.SING_EQ.
Qed.




Variable p r : `:num`.
Hypothesis prime_p : `prime p`.
Hypothesis finG : `FINITE G`.
Hypothesis cardG : `CARD G = p EXP r`.
Hypothesis finS : `FINITE S`.


Lemma card_orbit_p_group x : `x IN S ==> CARD (Orbit G a x) > 1 ==> p divides CARD (Orbit G a x)`.
move => xS; rewrite card_orbit // => card_gt1.
have: `CARD (cosets op G (Stab G a x)) divides p EXP r`.
  rewrite -cardG "GEN_ALL divides"; exists `CARD (Stab G a x)`.
  by rewrite -(LaGrange grG) // stab_subgroup.
rewrite "GEN_ALL DIVIDES_PRIMEPOW" // => [] [q] [_ card_eq].
move: card_eq card_gt1 => ->.
case: q; rewrite EXP ?gtE ?ltnn // => n _.
by rewrite "GEN_ALL divides"; exists `p EXP n`.
Qed.


"let divides = GEN_ALL divides".

Lemma DIVIDES_NSUM f s q : `(!x. x IN s ==> q divides f x) ==> q divides nsum s f`.
move => H.
rewrite divides; exists `nsum s (\x. f x DIV q)`.
rewrite mulnC -NSUM_RMUL; apply NSUM_EQ => x xs /=.
by rewrite eq_sym -DIVIDES_DIV_MULT H.
Qed.

Lemma sum_orbit_p_group : 
	`p divides nsum {Orbit G a x | x | x IN S /\ CARD (Orbit G a x) > 1} CARD`.
apply DIVIDES_NSUM => orb; rewrite inE /= => [] [x] [] [xS] card_gt1 ->.
exact: card_orbit_p_group.
Qed.

Lemma p_div_fix : `p divides CARD S ==> p divides CARD (Fix G S a)`.
rewrite card_set_fix // => p_div_sum.
have p_div2 := sum_orbit_p_group.
exact: (DIVIDES_ADD_REVL (p_div2, p_div_sum)).
Qed.

Lemma fix_mod_p : `CARD (Fix G S a) MOD p = CARD S MOD p`.
Proof.
rewrite eq_sym; apply: MOD_EQ.
move: sum_orbit_p_group; rewrite divides => [] [q] eq.
by exists q; rewrite card_set_fix // eq mulnC.
Qed.



End Action.


Lemma eqxx x : `x = x <=> T`. done. Qed.


Lemma has_size_tuples s n : `FINITE (s:T -> bool) ==> 
	{t | sizel t = n /\ (!x. x <- t ==> x IN s)} HAS_SIZE CARD s EXP n`.
move => finS.
elim: n => [|n]; rewrite EXP.
  rewrite HAS_SIZE_1_SING; exists `[]:(T)list`.
  rewrite EXTENSION IN_SING inE size_eq0 => x.
  by split => -> //= y; rewr MEM.
set r := `GSPEC _`.
set l := `GSPEC _`.
move => IHn.
have ->: `l = IMAGE (\p. FST p :: SND p) (s CROSS r)`.
  rewrite -l_def EXTENSION IN_IMAGE CROSS !inE /= => u.
  case: u => [|a u].
    rewrite size_nil [`0 = _`]eq_sym eqS0 /= NOT_EXISTS_THM negb_and => x.
    by rewrite eq_sym NOT_CONS_NIL.
  rewrite size_cons eqSS in_cons eqseq_cons; split.
    move => [size_u x_mem]; exists `a, u` => /=; exists a u => /=.
    rewrite (x_mem a) // andTb -r_def inE size_u eqxx andTb => x mem_x.
    by rewrite (x_mem x).
  move => [p] [[-> ->]] [a] [u] [[as ur] ->] /=.
  move: ur; rewrite -r_def inE => [] [-> mem_x].
  by rewrite eqxx andTb => x; case => [-> //|]; exact: mem_x.
move: IHn; rewrite HAS_SIZE => [] [finR <-].
apply HAS_SIZE_IMAGE_INJ; split; last first.
  by rewrite HAS_SIZE FINITE_CROSS ?CARD_CROSS.
move => p1 p2 /= [_] [_]; rewrite eqseq_cons.
by case: p1 => x1 y1; case: p2 => x2 y2 /=.
Qed.


Lemma card_tuples s n : 
	`FINITE s ==> CARD {t | sizel t = n /\ (!x. x <- t ==> x IN s)} = CARD s EXP n`.
by move/has_size_tuples; rewrite HAS_SIZE /=. Qed.

Lemma finite_tuples s n : 
	`FINITE s ==> FINITE {t | sizel t = n /\ (!x. x <- t ==> x IN s)}`.
by move/has_size_tuples; rewrite HAS_SIZE /=. Qed.

(* More sequences *)
Section MoreSeq.

Lemma rot_nseq n x k : `rot k (nseq n x) = nseq n x`.
apply (eq_from_nth x).
rewrite size_rot eqxx andTb size_nseq => j jn.
rewrite rot nth_cat size_drop size_nseq nth_nseq if_same.
case: (ltnP j `n - k`) => [ineq | ].
  by rewrite ineq /= nth_drop nth_nseq if_same.
rewrite leqNgt => -> /=.
case: k => [|k]; first by rewrite take nth.
rewrite nth_take; first by move: jn; arith.
by rewrite nth_nseq if_same.
Qed.


Lemma in_nseq_imp n x y : `y <- nseq n x ==> y = x`.
by elim: n => [|n IHn]; rewr nseq ncons !iter in_nil // in_cons -ncons -nseq; case. Qed.

Lemma in_nseq n x y : `~(n = 0) ==> (y <- nseq n x <=> y = x)`.
elim: n => [//= | n IHn _].
by case: n IHn => //=; rewr nseq ncons !iter !in_cons in_nil // -ncons -nseq eqS0 /=.
Qed.


Lemma rot_same t : `(!k. k < sizel t ==> rot k t = t) <=> (!k. rot k t = t)`.
split => /= rot_eq k.
case: (ltnP k `sizel t`); try exact.
by apply rot_oversize.
Qed.


Lemma rot_const t : `(!k. k < sizel t ==> rot k t = t) ==> t = nseq (sizel t) (HD t)`.
rewrite rot_same.
case: t => [|h t]; rewr HD; first by rewr size_nil nseq ncons iter.
set l := `h :: t`; move => rot_eq.
apply: (eq_from_nth h).
rewrite size_nseq eqxx andTb => j j_size; rewrite nth_nseq if_same.
rewrite -(rot_eq `sizel l - j`).
rewrite rot nth_cat size_drop subKn ?ltnW // ltnn /= subnn (nth0 h).
have: `?n. sizel l - j = SUC n`.
  by exists `sizel l - j - 1`; move: j_size; arith.
by move => [n ->]; rewrite -l_def take head.
Qed.


Lemma cat_nseq_nseq n m x : `cat (nseq n x) (nseq m x) = nseq (n + m) x`.
elim: n => [| n IHn]; rewr nseq ncons iter add0n cat0s // -ncons -nseq.
by rewrite addSn eq_sym nseq ncons; rewr iter -ncons -nseq -IHn cat.
Qed.


End MoreSeq.


(* Products and exponents *)
Section ProdExp.

"let expg = GEN_ALL (define `expg (op, e) g 0 = e /\ 
			  expg (op, e) g (SUC n) = op g (expg (op, e) g n)`)".

Lemma expg_prod op e g n : `expg (op, e) g n = foldr op e (nseq n g)`.
elim: n => [|n IHn]; rewrite expg nseq ncons; rewr iter foldr //.
by rewrite -ncons -nseq IHn.
Qed.

Lemma expg0 op e g : `expg (op, e) g 0 = e`. by rewrite expg. Qed.
Lemma expgS op e g n : `expg (op, e) g (SUC n) = op g (expg (op, e) g n)`. by rewrite expg. Qed.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.

Hypothesis grG : `group (G, op, i, e)`.

Lemma exp1g n : `expg (op, e) e n = e`.
elim: n => [|n IHn]; rewrite expg //.
by rewrite IHn (mul1g grG) ?(e_in_group grG).
Qed.

Lemma expg1 g : `g IN G ==> expg (op, e) g 1 = g`.
by move => gG; rewrite ONE 2!expg (mulg1 grG). Qed.


Lemma prod_in t : `(!g. g <- t ==> g IN G) ==> foldr op e t IN G`.
elim: t => [|a t IHt]; rewr foldr; first by rewrite (e_in_group grG).
move => memG; rewrite (in_group grG).
by rewrite memG ?in_cons // andTb IHt => g mem_g; apply: memG; rewrite !in_cons.
Qed.


Lemma expg_in n g : `g IN G ==> expg (op, e) g n IN G`.
by move => gG; rewrite expg_prod prod_in => x /in_nseq_imp ->. Qed.


Lemma prod_cat t1 t2 : `(!g. g <- t1 \/ g <- t2 ==> g IN G) ==>
	foldr op e (t1 ++ t2) = op (foldr op e t1) (foldr op e t2)`.
elim: t1 t2 => [t2 inG | a t IHt t2 inG]; rewr cat foldr.
  by rewrite (mul1g grG) // prod_in => g mem_g; rewrite inG.
rewrite -(mulgA grG) ?prod_in; try move => g mem_g; rewrite ?inG ?in_cons //.
by rewrite IHt // => g; case => h; rewrite inG in_cons.
Qed.


Lemma expg_add g n m : `g IN G ==> 
	expg (op, e) g (n + m) = op (expg (op, e) g n) (expg (op, e) g m)`.
move => inG; rewrite !expg_prod -prod_cat -?cat_nseq_nseq //.
by move => x; case => /in_nseq_imp ->.
Qed.

Lemma expg_expg g n m : `g IN G ==>
	expg (op, e) (expg (op, e) g n) m = expg (op, e) g (n * m)`.
move => gG; elim: m => [|m IHm].
  by rewrite muln0 !expg.
by rewrite expg IHm mulnS expg_add.
Qed.

Lemma expg_inv n g : `g IN G ==> i (expg (op, e) g n) = expg (op, e) (i g) n`.
move => gG; elim: n => [|n IHn]; first by rewrite !expg (invg_e grG).
by rewrite -{1}addn1 expg_add // (mulI grG) ?expg_in // IHn expg1 // expg.
Qed.



End ProdExp.


Lemma minP_exists P k: `P k ==> ?n. P n /\ (!m. P m ==> n <= m)`.
Proof.
move: k; apply: num_WF => k IH Pk.
case: (EXCLUDED_MIDDLE `?m. m < k /\ P m`).
  move => [m] [mk Pm].
  exact: (IH m).
rewrite NOT_EXISTS_THM negb_and => h.
exists k; rewrite Pk andTb => m Pm.
by move: (h m); rewrite Pm NOT_LT.
Qed.


Section Cyclic.

"let orderg = new_definition `orderg (op, e) g = 
  @n. ~(n = 0) /\ expg (op, e) g n = e /\ (!m. ~(m = 0) /\ expg (op, e) g m = e ==> n <= m)`".

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variable g : `:A`.

Hypothesis grG : `group (G, op, i, e)`.

Lemma order_e : `orderg (op, e) e = 1`.
rewrite orderg; apply SELECT_UNIQUE => /= n; split; last first.
  by move => ->; rewrite (expg1 grG) ?(e_in_group grG) ONE eqS0 /= => m; arith.
move => [n0] [_] /(_ `1`).
by rewrite (expg1 grG) ?(e_in_group grG) ONE eqS0 /=; move: n0; arith.
Qed.


Lemma INFINITE_SUBSET s t : `INFINITE s ==> s SUBSET t ==> INFINITE t`.
rewrite !INFINITE => hs hst.
apply: contra hs => fin_t.
by apply FINITE_SUBSET; exists t.
Qed.


Hypothesis finG : `FINITE G`.
Hypothesis gG : `g IN G`.



Lemma order_exists0 : `?n. ~(n = 0) /\ expg (op, e) g n = e`.
Proof.
apply: contraLR finG; rewrite NOT_EXISTS_THM -INFINITE negb_and negbK => Hexp.
apply INFINITE_SUBSET.
exists `IMAGE (expg (op, e) g) UNIV`; split; last first.
  by rewrite SUBSET IN_IMAGE => h [n] [-> _]; rewrite (expg_in grG).
rewrite INFINITE_IMAGE_INJ num_INFINITE andbT => n m.
wlog: n m / `n <= m`.
  move => h.
  by case: (leq_total n m); last rewrite eq_sym; move => /h /=.
move => n_le_m.
case: (ltngtP m n); first by rewrite ltnNge n_le_m.
case => [n_lt_m exp_eq | -> //].
move: (Hexp `m - n`).
rewrite subn_eq0 leqNgt n_lt_m /=.
apply: contraR => _.
apply: (mulg_rightI grG `expg (op, e) g n`).
rewrite !(expg_in grG) // (e_in_group grG) !andTb (mul1g grG) ?(expg_in grG) //.
by rewrite -(expg_add grG) // subnK.
Qed.


Lemma order_exists : `~(orderg (op, e) g = 0) /\ 
	expg (op, e) g (orderg (op, e) g) = e /\
	(!m. ~(m = 0) /\ expg (op, e) g m = e ==> orderg (op, e) g <= m)`.
Proof.
set P := `\n. ~(n = 0) /\ expg (op, e) g n = e /\ (!m. ~(m = 0) /\ expg (op, e) g m = e ==> n <= m)`.
move: (SELECT_AX P).
rewrite -P_def /= -orderg; apply.
rewrite CONJ_ASSOC; apply: minP_exists.
exact: order_exists0.
Qed.


Lemma order1 : `orderg (op, e) g = 1 <=> g = e`.
Proof.
split; last by move => ->; rewrite order_e.
move => o1; move: order_exists.
by rewrite o1 (expg1 grG) // => ->.
Qed.


Lemma fin_inv_expg : `?k. i g = expg (op, e) g k`.
move: order_exists0; rewrite -lt0n => [] [n] [/prednK n_eq exp1].
exists `n - 1`.
apply: (mulg_leftI grG g); rewrite (i_in_group grG) ?(expg_in grG) // gG !andTb.
by rewrite -expgS n_eq exp1 (mulgI grG).
Qed.


Lemma expg_inj n m : `n < orderg (op, e) g ==> m < orderg (op, e) g ==>
	(expg (op, e) g n = expg (op, e) g m <=> n = m)`.
Proof.
wlog: n m / `n <= m` => [h n_lt m_lt | n_le_m n_lt m_lt].
  case: (EXCLUDED_MIDDLE `n <= m`); first by move/h; exact.
  by rewrite (eq_sym `expg (op, e) g n`) (eq_sym n) NOT_LE ltn_neqAle => [] [_] /h; exact.
split; last by move => ->.
rewrite -{1}(subnK n_le_m) (expg_add grG) //.
rewrite eq_sym (mulg_left grG) ?(mulgI grG) ?(expg_in grG) // => eq.
move: n_le_m; rewrite leq_eqVlt; case => // n_lt_m.
move: order_exists => [_] [_] /(_ `m - n`); rewrite eq eqxx andbT.
"ANTS_TAC"; first by move: n_lt_m; arith.
move: n_lt_m m_lt; arith.
Qed.


Lemma expg_eq_mod n : `expg (op, e) g n = expg (op, e) g (n MOD orderg (op, e) g) /\ 
	n MOD orderg (op, e) g < orderg (op, e) g`.
Proof.
have [] [on0] [] oe _ := order_exists.
move: (DIVMOD_EXIST on0 n) => [q] [r] [n_eq r_lt].
move: (DIVMOD_UNIQ (n_eq, r_lt)) => ->.
rewrite r_lt andbT n_eq (expg_add grG) // mulnC -(expg_expg grG) //.
by rewrite oe (exp1g grG) (mul1g grG) // (expg_in grG).
Qed.


Lemma expg_eq n : `?r. r < orderg (op, e) g /\ expg (op, e) g n = expg (op, e) g r`.
Proof.
exists `n MOD orderg (op, e) g`.
by rewrite expg_eq_mod eqxx expg_eq_mod.
Qed.



Lemma cyclic_eq : `IMAGE (expg (op, e) g) UNIV = IMAGE (expg (op, e) g) (0..(orderg (op, e) g - 1))`.
Proof.
rewrite EXTENSION !IN_IMAGE IN_UNIV /= => y; split => [[n y_eq] | [n] h]; last first.
  by exists n.
move: (expg_eq n) => [r] [r_lt r_eq].
by exists r; rewrite -r_eq -y_eq IN_NUMSEG; move: r_lt; arith.
Qed.


Lemma cyclic_eq2 : `IMAGE (expg (op, e) g) UNIV = IMAGE (expg (op, e) g) (1..orderg (op, e) g)`.
Proof.
have [] [on0] [] oe _ := order_exists.
rewrite cyclic_eq // EXTENSION !IN_IMAGE !IN_NUMSEG => y; split => [] [n] [y_eq n_in].
  case: (EXCLUDED_MIDDLE `n = 0`) => n_eq.
    by exists `orderg (op, e) g`; rewrite y_eq n_eq expg0 oe eqxx andTb leqnn; move: on0; arith.
  by exists n; rewrite y_eq eqxx andTb; move: n_eq n_in; arith.
case: (EXCLUDED_MIDDLE `n = orderg (op, e) g`) => n_eq.
  by exists `0`; rewrite y_eq n_eq expg0 oe eqxx leqnn leq0n.
by exists n; rewrite y_eq eqxx; move: n_eq n_in; arith.
Qed.


Lemma cyclic_finite : `FINITE (IMAGE (expg (op, e) g) UNIV)`.
Proof. by rewrite cyclic_eq2 FINITE_IMAGE FINITE_NUMSEG. Qed.


Lemma cyclic_card : `CARD (IMAGE (expg (op, e) g) UNIV) = orderg (op, e) g`.
Proof.
have [] [on0] [] oe _ := order_exists.
rewrite cyclic_eq // CARD_IMAGE_INJ ?CARD_NUMSEG ?FINITE_NUMSEG ?andbT ?IN_NUMSEG.
  move => n m [n_in] [m_in].
  by rewrite expg_inj //; move: n_in m_in on0; arith.
by move: on0; arith.
Qed.


Lemma lt_order n : `expg (op, e) g n = e ==> n < orderg (op, e) g ==> n = 0`.
Proof.
move => n_eq n_lt.
have [] [on0] [] oe o_min := order_exists.
move: (o_min n); rewrite n_eq eqxx andbT implyNb; case => //.
by move: n_lt; arith.
Qed.


Lemma order_div n : `expg (op, e) g n = e <=> orderg (op, e) g divides n`.
Proof.
have [] [on0] [oe] _ := order_exists.
split => [n_eq |].
  rewrite (DIVIDES_MOD on0); apply: lt_order.
  by rewrite -expg_eq_mod n_eq expg_eq_mod.
rewrite divides => [] [q] ->.
by rewrite -(expg_expg grG) // oe (exp1g grG).
Qed.


Lemma order_prime p : `prime p ==> expg (op, e) g p = e ==> g = e \/ orderg (op, e) g = p`.
Proof.
rewrite prime order_div => [] [_] pH.
by move/pH; rewrite order1.
Qed.




End Cyclic.


Section MoreCyclic.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variable g : `:A`.

Hypothesis grG : `group (G, op, i, e)`.
Hypothesis finG : `FINITE G`.
Hypothesis gG : `g IN G`.


Lemma cyclic_subgroup : `subgroup op i (IMAGE (expg (op, e) g) UNIV) G`.
Proof.
rewrite subgroup SUBSET !IN_IMAGE !IN_UNIV !andbT; split.
  by move => x [n] ->; rewrite (expg_in grG).
rewrite IMAGE_EQ_EMPTY UNIV_NOT_EMPTY /= => x y [] [n ->] [m ->].
have := fin_inv_expg grG `expg (op, e) g m` finG.
rewrite (expg_in grG) //= => [] [k] ->.
exists `n + m * k`.
by rewrite (expg_expg grG) // -(expg_add grG).
Qed.


Lemma cyclic_group : `group (IMAGE (expg (op, e) g) UNIV, op, i, e)`.
Proof. by apply: (subgroup_group grG); exact: cyclic_subgroup. Qed.


Lemma order_div_group : `orderg (op, e) g divides CARD G`.
Proof.
rewrite (LaGrange grG cyclic_subgroup) // (cyclic_card grG) //.
set c := `CARD _`.
by rewrite divides; exists c; rewrite mulnC.
Qed.


End MoreCyclic.


(* Cauchy Theorem *)
Section Cauchy.

Variable p : `:num`.
Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.

Lemma add_mod_alt n m : `n < p ==> m < p ==> 
	add_mod p n m = if n + m < p then n + m else (n + m) - p`.
move => np mp; rewrite add_mod.
case: (ltnP `n + m` p) => [|le] /=; first by move/MOD_LT.
rewrite ltnNge le /= -{1}(subnK le) addnC -{1}(mul1n p) MOD_MULT_ADD MOD_LT //.
by move: mp np; arith.
Qed.

Hypothesis prime_p : `prime p`.


Lemma PRIME_DIVIDES n : `p divides n ==> n = 0 \/ 2 <= n`.
rewrite divides => [] [m] ->.
case: m => [|m]; rewrite ?muln0 //; right.
by move: (PRIME_GE_2 prime_p); arith.
Qed.


Hypothesis grG : `group (G, op, i, e)`.
Hypothesis finG : `FINITE G`.


Lemma has_size_group_tuples : 
  `{t | sizel t = p /\ (!g. g <- t ==> g IN G) /\ foldr op e t = e} HAS_SIZE CARD G EXP (p - 1)`.
set l := `GSPEC _`.
have ->: `l = IMAGE (\y. i (foldr op e y) :: y) {t | sizel t = p - 1 /\ (!g. g <- t ==> g IN G)}`.
  rewrite -l_def EXTENSION IN_IMAGE !inE => t.
  case: t => [|h t].
    rewrite size_nil [`0 = p`]eq_sym [`[] = _`]eq_sym NOT_CONS_NIL /= negb_and; left.
    rewrite "TAUT `!P. ~P <=> (P ==> F)`" => p_eq; move: prime_p.
    by rewrite p_eq PRIME_0.
  rewrite size_cons; split.
    move => [size_t] [inG]; rewr foldr => prod_eq.
    exists t; rewrite eqseq_cons eqxx andbT -size_t -addn1 addnK eqxx andTb; split; last first.
      by move => g mem_g; rewrite inG in_cons.
    by move: prod_eq; rewrite (mulg_left grG) ?(mul1g grG) ?(i_in_group grG) ?(prod_in grG) //;
	rewrite ?(e_in_group grG); try move => g mem_g; rewrite inG ?in_cons.
  move => [t2]; rewrite eqseq_cons => [] [[-> ->]] [-> inG].
  rewrite prednK ?lt0n ?PRIME_IMP_NZ // eqxx andTb.
  rewr foldr; rewrite (mulIg grG) ?(prod_in grG) // eqxx andbT in_cons => g; case => [->|//].
  by rewrite (i_in_group grG) (prod_in grG).
apply HAS_SIZE_IMAGE_INJ; split; last by rewrite has_size_tuples.
by move => x y; rewrite eqseq_cons /=.
Qed.




Lemma actsZ : `acts ({k | k < p}, add_mod p, 0) 
	{t | sizel t = p /\ (!g. g <- t ==> g IN G) /\ foldr op e t = e} rot`.
rewrite acts; do 2?split; last by rewrite rot0.
  move => k t; rewrite !inE => [] [k_p] [size_t] [inG].
  rewrite size_rot size_t mem_rot; rewr inG /=.
  rewrite -{1}(cat_take_drop k t) rot !(prod_cat grG) => [g|g|]; try case;
	try move/mem_drop; try move/mem_take; try done.
  rewrite (mulg_left grG) ?(prod_in grG) ?(e_in_group grG) // => [g|g|->];
	try move/mem_drop; try move/mem_take; try done.
  by rewrite (mul1g grG) ?(mulgI grG) ?(i_in_group grG) ?(prod_in grG) // => g; move/mem_drop.
move => k1 k2 t; rewrite !inE => [] [[k1_p k2_p]] [size_t _].
rewrite rot_add_mod ?[`k1 <= _`]ltnW ?[`k2 <= _`]ltnW //.
case: (leqP `k1 + k2` `sizel t`) => /=.
  rewrite leq_eqVlt; case => [eq|ineq].
    by rewrite eq rot_size add_mod_alt // eq size_t ltnn /= subnn rot0.
  by rewrite add_mod_alt // -size_t ineq.
move => ineq.
rewrite leqNgt add_mod_alt // ineq /= -size_t.
by move: (ltnW ineq); rewrite leqNgt => -> /=.
Qed.



Lemma fix_order : 
  `Fix {k | k < p} {t | sizel t = p /\ (!g. g <- t ==> g IN G) /\ foldr op e t = e} rot =
	{nseq p g | g | g IN G /\ expg (op, e) g p = e}`.
rewrite fix EXTENSION !inE /= => t; split; last first.
  move => [g] [[gG eq] t_eq].
  rewrite {1}t_eq size_nseq eqxx andTb {2}t_eq -expg_prod eq eqxx andbT; split => h.
    rewrite t_eq in_nseq; try by move => ->.
    rewrite -implybF => p0; move: prime_p.
    by rewrite p0 PRIME_0.
  by rewrite t_eq rot_nseq.
move => [[size_t]] [inG prod_e rot_eq].
exists `HD t`.
suff eq: `t = nseq p (HD t)`.
  rewrite {3}eq eqxx andbT expg_prod -{2}prod_e -eq eqxx andbT inG.
  case: t size_t => [|h tt]; last by rewr HD in_cons.
  rewrite size_nil => eq; move: prime_p.
  by rewrite -eq PRIME_0.
by rewrite -size_t -rot_const // size_t eq_sym.
Qed.




Lemma cauchy0 : `p divides CARD G ==> ?g. g IN G /\ ~(g = e) /\ expg (op, e) g p = e`.
move => p_div_G.
set S := `{t | sizel t = p /\ (!g. g <- t ==> g IN G) /\ foldr op e t = e}`.
have: `p divides CARD S /\ FINITE S`.
  move: has_size_group_tuples; rewrite S_def HAS_SIZE => [] [-> ->].
  rewrite andbT DIVIDES_REXP p_div_G.
  by move: (PRIME_GE_2 prime_p); arith.
move => [p_divS finS].
move: (PRIME_IMP_NZ prime_p); rewrite -lt0n => /grZ grZ.
have cardZ : `CARD {k | k < p} = p EXP 1`.
  by rewrite CARD_NUMSEG_LT EXP_1.
have := p_div_fix actsZ grZ prime_p (FINITE_NUMSEG_LT p) cardZ.
rewrite S_def => /(_ finS p_divS).
have fix_finite : `FINITE (Fix {k | k < p} S rot)`.
  by apply FINITE_SUBSET; exists S; rewrite finS andTb fix_subset.
move: fix_finite; rewrite -S_def fix_order => fix_finite /PRIME_DIVIDES.
case.
  rewrite (CARD_EQ_0 fix_finite); apply: contraLR => _.
  rewrite -MEMBER_NOT_EMPTY; exists `nseq p e`.
  by rewrite inE /=; exists e; rewrite (e_in_group grG) (exp1g grG).
set fix := `GSPEC _` => fix2.
have: `?n. fix HAS_SIZE (SUC (SUC n))`.
  by exists `CARD fix - 2`; rewrite -!addn1 -addnA add1n -TWO subnK // -FINITE_HAS_SIZE.
move => [n]; rewrite !"GEN_ALL HAS_SIZE_CLAUSES" => [] [a1] [t1] [] [a2] [t2] [_] [_] ->.
rewrite IN_INSERT negb_or => [] [] [na12 _] fix_eq.
have: `a1 IN fix /\ a2 IN fix`; first by rewrite fix_eq !IN_INSERT.
rewrite -!fix_def !inE /= => [] [[g1]] [[g1G g1e] a1_eq] [g2] [[g2G g2e] a2_eq].
case: (EXCLUDED_MIDDLE `g1 = e`); last by move => g1_not_e; exists g1.
move => g1_eq_e.
exists g2; rewrite g2G g2e eqxx andTb andbT -g1_eq_e.
by apply: contra na12; rewrite a1_eq a2_eq => ->.
Qed.


Lemma cauchy : `p divides CARD G ==> ?H. subgroup op i H G /\ CARD H = p`.
Proof.
move/cauchy0 => [g] [gG] [gne] exp_e.
exists `IMAGE (expg (op, e) g) UNIV`.
rewrite (cyclic_subgroup grG) // (cyclic_card grG) //.
have := order_prime grG finG gG prime_p exp_e.
by rewrite gne.
Qed.


End Cauchy.


(* Actions of groups on groups *)
Section GroupActions.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variables H : `:A->bool`.


Lemma set_op1_left_mul g : `set_op1 (op g) = set_op op {g}`.
Proof.
rewrite set_op1 set_op -eq_ext /= IN_SING EXTENSION !IN_ELIM_THM /= => S a; split.
  move => [x] [xS a_eq].
  by exists g x.
move => [x] [y] [] [xg yS] ->.
by exists y; rewrite yS xg.
Qed.

Lemma op_in_coset k x K : `k IN K ==> op x k IN coset op x K`.
Proof. by move => kK; rewrite coset inE /=; exists k. Qed.

Hypothesis grG : `group (G, op, i, e)`.


Lemma left_mul_coset g h K : `g IN G ==> h IN G ==> K SUBSET G ==> 
	set_op1 (op g) (coset op h K) = coset op (op g h) K`.
Proof.
move => gG hG sKG.
rewrite set_op1_left_mul !coset_op.
rewrite (set_opA grG) ?SING_SUBSET //.
apply congr2; rewrite eqxx andbT set_op /= !IN_SING EXTENSION IN_SING inE /= => x; split.
  by move => [a] [b] [] [-> ->].
by move => x_eq; exists g h.
Qed.


Lemma group_acts_on_cosets K : `K SUBSET G ==> acts (G, op, e) (cosets op G K) (\g. set_op1 (op g))`.
Proof.
move => sKG; rewrite acts; do !split.
  (* 1 *)
  move => g c; rewrite cosets !IN_ELIM_THM /= => [] [gG] [h] [hG] ->.
  by exists `op g h`; rewrite (in_group grG) // andTb left_mul_coset.
  (* 2 *)
  rewrite cosets /= inE /= => g1 g2 c [] [g1G g2G] [g] [gG] ->.
  by rewrite !left_mul_coset ?(in_group grG) // (mulgA grG).
(* 3 *)
rewrite cosets inE /= => c [g] [gG ->].
by rewrite left_mul_coset ?(e_in_group grG) // (mul1g grG).
Qed.

Hypothesis subH : `subgroup op i H G`.


Lemma subgroup_acts_on_cosets K : `K SUBSET G ==> acts (H, op, e) (cosets op G K) (\h. set_op1 (op h))`.
Proof.
have sHG := subgroup_subset subH.
move => sKG.
exact: (acts_sub (group_acts_on_cosets sKG)).
Qed.

Hypothesis finG : `FINITE G`.

Lemma subgroup_left_mul_fix : `Fix H (cosets op G H) (\h. set_op1 (op h)) = 
	cosets op (normalizer op i G H) H`.
Proof.
have sHG := subgroup_subset subH.
have grH := subgroup_group grG subH.
move: (sHG); rewrite SUBSET => sHG'.
rewrite fix !cosets EXTENSION !IN_ELIM_THM /= => c; split; last first.
  move => [x]; rewrite (in_normalizer grG) // => [] [] [xG] eq ->.
  exists `coset op x H`; rewrite eqxx andbT; split; first by exists x.
  by move => h hH; rewrite eq set_op1_left_mul (set_opA grG) ?SING_SUBSET ?xG ?sHG' // -coset_op (coset_eq_e grH).
move => [c1] [] [] [x] [xG c1_eq] h_eq ->.
exists x; rewrite -c1_eq eqxx andbT.
have h_ex: `!h. h IN H ==> ?h2. h2 IN H /\ op h x = op x h2`.
  move => h hH.
  move: (h_eq hH); rewrite c1_eq EXTENSION => /(_ `op x h`).
  rewrite op_in_coset //= coset set_op1 /= !inE /= => [] [a] [] [h2] [h2H] -> eq.
  exists `op h (i h2)`; rewrite (in_group grH) ?(i_in_group grH) // andTb.
  rewrite (mulgA grG) ?(i_in_group grG) ?xG ?sHG' // eq.
  by rewrite (mulgA grG) ?xG ?sHG' // (mulgK grG) ?(in_group grG) ?xG ?sHG'.
rewrite (in_normalizer grG) // xG andTb.
rewrite eq_sym -SUBSET_CARD_EQ.
  split; first by apply FINITE_SUBSET; exists G; rewrite finG (coset_subset grG).
  rewrite SUBSET coset set_op /= !inE /= IN_SING => a.
  move => [h] [y] [[hH y_eq] a_eq].
  move: (h_ex hH) => [h2] [h2H eq].
  by exists h2; rewrite h2H a_eq y_eq.
rewrite (coset_card grG) //.
have ->: `set_op op H {x} = IMAGE (\h. op h x) H`.
  rewrite set_op /= EXTENSION IN_IMAGE IN_ELIM_THM /= IN_SING => a; split => [[z] [y] [[zH ->] ->] | [z] [-> zH]].
    by exists z.
  by exists z x.
apply CARD_IMAGE_INJ; split; last by apply FINITE_SUBSET; exists G.
move => a b [aH] [bH]; apply: (mulg_rightI grG).
by rewrite xG !sHG'.
Qed.



End GroupActions.


Lemma card_sing a : `CARD {a} = 1`.
Proof. by apply HAS_SIZE_CARD; rewrite HAS_SIZE_1_SING; exists a. Qed.



(* Sylow *)
Section Sylow.

Variable G : `:A->bool`.
Variable op : `:A->A->A`.
Variable i : `:A->A`.
Variable e : `:A`.
Variable p : `:num`.

Hypothesis grG : `group (G,op,i,e)`.

Lemma subgroup_trans H K : `subgroup op i H K ==> subgroup op i K G ==> subgroup op i H G`.
Proof.
move => subHK.
rewrite !(subgroup_alt2 grG) => [] [sKG grK].
move: subHK; rewrite (subgroup_alt2 grK) => [] [sHK ->].
exact: (SUBSET_TRANS (sHK, sKG)).
Qed.


Lemma subgroup_e : `subgroup op i {e} G`.
Proof.
rewrite subgroup SING_SUBSET -MEMBER_NOT_EMPTY !IN_SING (e_in_group grG) andTb; split.
  by exists e.
move => x y [-> ->].
by rewrite (mulgI grG) ?(e_in_group grG).
Qed.


Hypothesis finG : `FINITE G`.
Hypothesis prime_p : `prime p`.

Lemma sylow1 : `!n. p EXP n divides CARD G ==> ?H. subgroup op i H G /\ CARD H = p EXP n`.
Proof.
elim => [_ | n IH pSn]; first by exists `{e}`; rewrite subgroup_e card_sing EXP.
move: (pSn); rewrite EXP => /DIVIDES_LMUL2 /IH [H] [subH cH].
have sHG := subgroup_subset subH.
have subN := normalizer_subgroup grG sHG.
have grN := subgroup_group grG subN.
have normH := normal_in_normalizer grG subH.
have grNH := quotient_group grN normH.
have finN := FINITE_SUBSET (finG, (normalizer_subset op i H G)).
have finNH := finite_index grN (normal_subgroup normH) finN.
set N := `normalizer op i G H`.
suff: `p divides CARD (cosets op N H)` => [p_div | ].
  move: (cauchy prime_p grNH finNH p_div) => [K1] [subK1 cK1].
  move: (subgroup_of_quotient grN normH K1); rewrite subK1 /= => [] [K] [subK] [normK] K_eq_K1.
  exists K; rewrite (subgroup_trans subK) // andTb.
  rewrite (LaGrange (subgroup_group grN subK) (normal_subgroup normK)) ?cH ?K_eq_K1 ?cK1 //.
  by apply: FINITE_SUBSET; exists N; rewrite finN (subgroup_subset subK).
rewrite -N_def -(subgroup_left_mul_fix grG) //.
apply p_div_fix; exists op i e n.
have finH := FINITE_SUBSET (finG, sHG).
have finGH := finite_index grG subH finG.
rewrite (subgroup_group grG subH) (subgroup_acts_on_cosets grG) // prime_p cH eqxx finH finGH !andTb.
apply: DIVIDES_CMUL2; exists `p EXP n`.
by rewrite mulnC -EXP expn_eq0 negb_and (PRIME_IMP_NZ prime_p) /= -cH mulnC -(LaGrange grG).
Qed.


Lemma sylow2 n H K: `~(p EXP (SUC n) divides CARD G) ==>
	subgroup op i H G ==> subgroup op i K G ==> CARD H = p EXP n ==> CARD K = p EXP n ==>
	?g. g IN G /\ set_op op {g} H = set_op op K {g}`.
Proof.
move => p_n_div subH subK cH cK.
have grK := subgroup_group grG subK.
have grH := subgroup_group grG subH.
have sHG := subgroup_subset subH.
have sKG := subgroup_subset subK.
have finK := FINITE_SUBSET (finG, sKG).
have finGH := finite_index grG subH finG.
have actsK := subgroup_acts_on_cosets grG subK sHG.
have := fix_mod_p actsK grK prime_p finK cK finGH; set S := `Fix K _1 _2`.
move => fix_mod.
have: `?c. c IN S`.
  case: (EXCLUDED_MIDDLE `S HAS_SIZE 0`); last by rewrite HAS_SIZE_0 -MEMBER_NOT_EMPTY.
  rewrite HAS_SIZE => [] [finS cS0].
  move: fix_mod; rewrite cS0 MOD_0 ?PRIME_IMP_NZ // eq_sym -DIVIDES_MOD 1?eq_sym ?PRIME_IMP_NZ //.
  apply: contraLR => _; apply: contra p_n_div => p_div.
  by rewrite (LaGrange grG subH) // cH EXP DIVIDES_MUL_R.
move => [c]; rewrite -S_def fix inE cosets inE /= => [] [] [x] [xG ->] x_eq.
exists x; rewrite xG andTb.
(* Repeating almost the same proof as in subgroup_left_mul_fix *)
rewrite eq_sym -SUBSET_CARD_EQ; last first.
  have ->: `set_op op K {x} = IMAGE (\h. op h x) K`.
    rewrite set_op /= EXTENSION IN_IMAGE IN_ELIM_THM /= IN_SING => a; split => [[z] [y] [[zH ->] ->] | [z] [-> zH]].
      by exists z.
    by exists z x.
  rewrite -coset_op (coset_card grG) // cH -cK.
  apply CARD_IMAGE_INJ. split; last by apply FINITE_SUBSET; exists G.
  move => a b [aH] [bH]; apply: (mulg_rightI grG).
  move: sKG; rewrite SUBSET => sKG.
  by rewrite xG !sKG.
rewrite -coset_op; split; first by apply FINITE_SUBSET; exists G; rewrite (coset_subset grG).
rewrite SUBSET coset set_op /= !inE /= IN_SING => a.
move => [k] [y] [[kK y_eq] a_eq].
move: (x_eq kK); rewrite EXTENSION => /(_ `op k x`).
set R := `set_op1 _1 _2`.
have -> /=: `op k x IN R`.
  rewrite -R_def set_op1 coset /= !inE /=.
  exists x; rewrite eqxx andbT; exists e.
  by rewrite (e_in_group grH) (mulg1 grG).
rewrite coset inE /= => [] [h] [hH eq].
by exists h; rewrite hH a_eq y_eq.
Qed.


End Sylow.


