needs "Examples/ssrnat-compiled.hl";;

(* Section Sequences *)
begin_section "Sequences";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_var (mk_var ("x0", (`:A`))));;
(add_section_type (mk_var ("x", (`:A`))); add_section_type (mk_var ("y", (`:A`))); add_section_type (mk_var ("z", (`:A`))));;
(add_section_type (mk_var ("m", (`:num`))); add_section_type (mk_var ("n", (`:num`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;
let size = new_definition `sizel = LENGTH`;;

(* Lemma size0nil *)
let size0nil = section_proof ["s"] `sizel s = 0 ==> s = []` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN case) [ALL_TAC; ((move ["h"]) THEN (move ["t"]))]) THEN (BETA_TAC THEN ((TRY done_tac))) THEN ((((use_arg_then "size")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "LENGTH")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (arith_tac) THEN (done_tac));
];;
let nilp = new_definition `!(s:(A)list). nilp s <=> (sizel s = 0)`;;

(* Lemma nilP *)
let nilP = section_proof ["s"] `s = [] <=> nilp s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN case) [ALL_TAC; ((move ["h"]) THEN (move ["t"]))]) THEN ((((use_arg_then "nilp")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "LENGTH")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "NOT_CONS_NIL")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "NOT_SUC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let head = define `!(x0:A) h t. headl x0 [] = x0 /\ headl x0 (CONS h t) = h`;;
let behead = define `!(h:A) t. behead [] = [] /\ behead (CONS h t) = t`;;

(* Lemma size_behead *)
let size_behead = section_proof ["s"] `sizel (behead s) = (sizel s) - 1` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN case) [ALL_TAC; ((move ["h"]) THEN (move ["t"]))]) THEN ((((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "LENGTH")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "SUC_SUB1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sub0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;
let ncons = new_definition `!n (x:A). ncons n x = iter n (CONS x)`;;
let nseq = new_definition `!n (x:A). nseq n x = ncons n x []`;;

(* Lemma size_nil *)
let size_nil = section_proof [] `sizel ([]:(A)list) = 0` [
   (((((use_arg_then "size")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "LENGTH")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma size_cons *)
let size_cons = section_proof ["h";"t"] `sizel (CONS (h:A) t) = SUC (sizel t)` [
   (((((use_arg_then "size")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "LENGTH")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma size_ncons *)
let size_ncons = section_proof ["n";"x";"s"] `sizel (ncons n x s) = n + sizel s` [
   ((((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) THEN (repeat_tactic 1 9 (((use_arg_then "ncons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((repeat_tactic 0 10 (((use_arg_then "add0n")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (move ["n"]) THEN (move ["IH"])));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IH")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addSn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_nseq *)
let size_nseq = section_proof ["n";"x"] `sizel (nseq n (x:A)) = n` [
   (((((use_arg_then "nseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_ncons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addn0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
parse_as_infix ("::", (12, "right"));;
override_interface ("::", `CONS`);;
make_overloadable "++" `:A -> A -> A`;;
let cat = define `!(x:A) t s2. cat [] s2 = s2 /\ cat (CONS x t) s2 = x :: cat t s2`;;
overload_interface ("++", `cat`);;

(* Lemma cat0s *)
let cat0s = section_proof ["s"] `[] ++ (s:(A)list) = s` [
   ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma cat1s *)
let cat1s = section_proof ["x";"s"] `[x:A] ++ s = x :: s` [
   ((repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma cat_cons *)
let cat_cons = section_proof ["x";"s1";"s2"] `(x :: s1) ++ s2 = x :: s1 ++ s2` [
   ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma cat_nseq *)
let cat_nseq = section_proof ["n";"x";"s"] `nseq n (x:A) ++ s = ncons n x s` [
   ((((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) THEN (((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (move ["n"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma cats0 *)
let cats0 = section_proof ["s"] `s ++ [] = (s:(A)list)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN (((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma catA *)
let catA = section_proof ["s1";"s2";"s3"] `s1 ++ s2 ++ s3 = (s1 ++ s2) ++ s3:(A)list` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]))]) THEN (((repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_cat *)
let size_cat = section_proof ["s1";"s2"] `sizel (s1 ++ s2) = sizel s1 + sizel (s2:(A)list)` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]))]) THEN (((repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "addSn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let rcons = define `!x t (z:A). rcons [] z = [z] /\ rcons (x :: t) z = x :: rcons t z`;;

(* Lemma rcons_cons *)
let rcons_cons = section_proof ["x";"s";"z"] `rcons (x :: s) z = x:A :: rcons s z` [
   ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma cats1 *)
let cats1 = section_proof ["s";"z"] `s ++ [z:A] = rcons s z` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN (((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let last = define `!(x:A) h t. last x [] = x /\ last x (h :: t) = last h t`;;
let belast = define `!(x:A) h t. belast x [] = [] /\ belast x (h :: t) = x :: (belast h t)`;;

(* Lemma lastI *)
let lastI = section_proof ["x";"s"] `(x:A :: s) = rcons (belast x s) (last x s)` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma last_cons *)
let last_cons = section_proof ["x";"y";"s"] `last x (y:A :: s) = last y s` [
   ((((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma size_rcons *)
let size_rcons = section_proof ["s";"x"] `sizel (rcons s (x:A)) = SUC (sizel s)` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addn0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_belast *)
let size_belast = section_proof ["x";"s"] `sizel (belast (x:A) s) = sizel s` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma last_cat *)
let last_cat = section_proof ["x";"s1";"s2"] `last (x:A) (s1 ++ s2) = last (last x s1) s2` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma last_rcons *)
let last_rcons = section_proof ["x";"s";"z"] `last x (rcons s z) = z:A` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "last_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma belast_cat *)
let belast_cat = section_proof ["x";"s1";"s2"] `belast x (s1 ++ s2) = belast x s1 ++ belast (last (x:A) s1) s2` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma belast_rcons *)
let belast_rcons = section_proof ["x";"s";"z"] `belast x (rcons s z) = x:A :: s` [
   (((((use_arg_then "lastI")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "belast_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma cat_rcons *)
let cat_rcons = section_proof ["x";"s1";"s2"] `rcons s1 x ++ s2 = s1 ++ (x:A :: s2)` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catA")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma rcons_cat *)
let rcons_cat = section_proof ["x";"s1";"s2"] `rcons (s1 ++ s2) x = s1 ++ rcons s2 (x:A)` [
   (((repeat_tactic 1 9 (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "catA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma last_ind *)
let last_ind = section_proof ["P"] `P [] ==> (!s (x : A). P s ==> P (rcons s x)) ==> (!s. P s)` [
   (BETA_TAC THEN (move ["Hnil"]) THEN (move ["Hlast"]) THEN (move ["s"]));
   (((fun arg_tac -> (use_arg_then "cat0s") (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((THENL) (((use_arg_then "Hnil") (disch_tac [])) THEN (clear_assumption "Hnil") THEN ((fun arg_tac -> arg_tac (Arg_term (`[]`))) (disch_tac [])) THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s2"]) THEN (move ["IHs"]))]) ((((use_arg_then "cats0")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((((use_arg_then "cat_rcons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["s1"]) THEN (move ["Ps1"])) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "Hlast") (disch_tac [])) THEN (clear_assumption "Hlast") THEN (exact_tac)) THEN (done_tac));
];;
let nth = define `!(x0:A) h t n. nth x0 [] n = x0 /\ nth x0 (h :: t) 0 = h /\ nth x0 (h :: t) (SUC n) = nth x0 t n`;;
let set_nth = define `!(x0:A) h t n y. 
	set_nth x0 [] n y = ncons n x0 [y] /\
	set_nth x0 (h :: t) 0 y = y :: t /\
	set_nth x0 (h :: t) (SUC n) y = h :: set_nth x0 t n y`;;

(* Lemma nth0 *)
let nth0 = section_proof ["s"] `nth x0 s 0 = headl x0 s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["h"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "head")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_default *)
let nth_default = section_proof ["s";"n"] `sizel s <= n ==> nth x0 s n = x0` [
   ((((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) case [ALL_TAC; (move ["n"])])) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN (exact_tac)) THEN (done_tac));
];;

(* Lemma nth_nil *)
let nth_nil = section_proof ["n"] `nth x0 [] n = x0` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma last_nth *)
let last_nth = section_proof ["x";"s"] `last x s = nth x0 (x :: s) (sizel s)` [
   ((THENL_FIRST) (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) (done_tac));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma nth_last *)
let nth_last = section_proof ["s"] `nth x0 s (sizel s - 1) = last x0 s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["t"]) THEN (move ["h"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "succnK")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_behead *)
let nth_behead = section_proof ["s";"n"] `nth x0 (behead s) n = nth x0 s (SUC n)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_cat *)
let nth_cat = section_proof ["s1";"s2";"n"] `nth x0 (s1 ++ s2) n = if n < sizel s1 then nth x0 s1 n else nth x0 s2 (n - sizel s1)` [
   ((THENL) (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sub0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) [(arith_tac); (arith_tac); BETA_TAC]);
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_rcons *)
let nth_rcons = section_proof ["s";"x";"n"] `nth x0 (rcons s x) n =
    if n < sizel s then nth x0 s n else if n = sizel s then x else x0` [
   ((THENL_FIRST) (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0Sn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_ncons *)
let nth_ncons = section_proof ["m";"x";"s";"n"] `nth x0 (ncons m x s) n = if n < m then x else nth x0 s (n - m)` [
   ((((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN ((THENL) case [ALL_TAC; (move ["n"])])) THEN ((((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "ncons")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (TRY ((arith_tac))));
   (((((use_arg_then "IHm")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_nseq *)
let nth_nseq = section_proof ["m";"x";"n"] `nth x0 (nseq m x) n = (if n < m then x else x0)` [
   ((((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN ((THENL) case [ALL_TAC; (move ["n"])])) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (TRY ((arith_tac))));
   (((((use_arg_then "ncons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nseq")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHm")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_from_nth *)
let eq_from_nth = section_proof ["s1";"s2"] `sizel s1 = sizel s2 ==> (!i. i < sizel s1 ==> nth x0 s1 i = nth x0 s2 i) ==>
  s1 = s2` [
   ((((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x1"]) THEN (move ["s1"]) THEN (move ["IHs1"]))]) THEN ((THENL) case [ALL_TAC; ((move ["x2"]) THEN (move ["s2"]))])) THEN ((((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "NOT_SUC")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (move ["eq_sz"]) THEN (move ["eq_s12"]));
   ((((fun arg_tac -> (use_arg_then "eq_s12") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then "ltn0Sn")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 2 0 (((use_arg_then "nth")(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["_"])) THEN (((((fun arg_tac -> (use_arg_then "IHs1") (fun fst_arg -> (use_arg_then "s2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "eq_sz")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["i"])));
   ((((fun arg_tac -> (use_arg_then "eq_s12") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`SUC i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 2 0 (((use_arg_then "nth")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma size_set_nth *)
let size_set_nth = section_proof ["s";"n";"y"] `sizel (set_nth x0 s n y) = maxn (SUC n) (sizel s)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN (((use_arg_then "set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))));
   (((((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "maxn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then "size_ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ONE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "addn1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "maxn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then "add_sub_maxn")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (arith_tac) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "add1n")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "addn_maxr")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "add1n")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma set_nth_nil *)
let set_nth_nil = section_proof ["n";"y"] `set_nth x0 [] n y = ncons n x0 [y]` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN (((use_arg_then "set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma ltS0 *)
let ltS0 = section_proof ["n"] `SUC n < 0 <=> F` [
   ((arith_tac) THEN (done_tac));
];;

(* Lemma eqS0 *)
let eqS0 = section_proof ["n"] `SUC n = 0 <=> F` [
   ((arith_tac) THEN (done_tac));
];;

(* Lemma eq0S *)
let eq0S = section_proof ["n"] `0 = SUC n <=> F` [
   ((arith_tac) THEN (done_tac));
];;

(* Lemma gtS0 *)
let gtS0 = section_proof ["n"] `0 < SUC n` [
   ((arith_tac) THEN (done_tac));
];;

(* Lemma ltSS *)
let ltSS = section_proof ["m";"n"] `SUC m < SUC n <=> m < n` [
   ((arith_tac) THEN (done_tac));
];;

(* Lemma nth_set_nth *)
let nth_set_nth = section_proof ["s";"n";"y";"i"] `nth x0 (set_nth x0 s n y) i = if i = n then y else nth x0 s i` [
   ((THENL_ROT (-1)) (((THENL) (((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["m"]) THEN (move ["_"]))]) THEN ((((use_arg_then "set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth_ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sub0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "eqS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "eq0S")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "gtS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))))));
   (((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((((use_arg_then "ltSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((THENL) (((fun arg_tac -> (fun arg_tac -> (use_arg_then "ltngtP") (fun fst_arg -> (use_arg_then "m") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "n") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [(move ["lt_mn"]); ((THENL) case [(move ["lt_nm"]); (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))])]) (((((use_arg_then "subnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac)));
   (((((use_arg_then "lt_mn")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `m < n ==> (m = n <=> F)`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_LAST) ((((use_arg_then "nth_default")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "if_same")(thm_tac (new_rewrite [] [])))))) ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `n < m ==> (m = n <=> F)`)))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "subn_gt0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma set_set_nth *)
let set_set_nth = section_proof ["s";"n1";"y1";"n2";"y2"] `set_nth x0 (set_nth x0 s n1 y1) n2 y2 = 
	if n1 = n2 then set_nth x0 s n2 y2 else set_nth x0 (set_nth x0 s n2 y2) n1 y1` [
   ((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n1 = n2:num`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (simp_tac)); (move ["ne_n12"])]);
   ((THENL_FIRST) ((((fun arg_tac -> arg_tac (Arg_theorem (REWRITE_RULE[IMP_IMP] eq_from_nth))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) (((repeat_tactic 1 9 (((use_arg_then "size_set_nth")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "maxnA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "maxnn")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["_"])) THEN ((repeat_tactic 1 9 (((use_arg_then "nth_set_nth")(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((THENL_FIRST) ((((fun arg_tac -> arg_tac (Arg_theorem (REWRITE_RULE[IMP_IMP] eq_from_nth))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) (((((use_arg_then "ne_n12")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then "size_set_nth")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "maxnCA")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["_"])) THEN (((simp_tac THEN TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then "nth_set_nth")(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN ((((use_arg_then "ne_n12")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`i = n2:num`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); (move ["ne_i2"])]) THEN (simp_tac));
   (((((use_arg_then "nth_set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ne_n12")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nth_set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   (((((use_arg_then "ne_i2")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then "nth_set_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ne_i2")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Section SeqFind *)
begin_section "SeqFind";;
(add_section_var (mk_var ("a", (`:A -> bool`))));;
let find = define `!a (x:A) s'. find a [] = 0 /\ 
	find a (x :: s') = if a x then 0 else SUC(find a s')`;;
let filter = define `!a (x:A) s'. filter a [] = [] /\
	filter a (x :: s') = if a x then x :: filter a s' else filter a s'`;;
let count = define `!a (x:A) s'. count a [] = 0 /\
	count a (x :: s') = (if a x then 1 else 0) + count a s'`;;
let has = define `!a (x:A) s'. has a [] = F /\
	has a (x :: s') = (a x \/ has a s')`;;
let all = define `!a (x:A) s'. all a [] = T /\
	all a (x :: s') = (a x /\ all a s')`;;

(* Lemma find_nil *)
let find_nil = section_proof [] `find a [] = 0` [
   ((((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma find_cons *)
let find_cons = section_proof ["x";"t"] `find a (x::t) = if a x then 0 else SUC (find a t)` [
   ((((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma filter_nil *)
let filter_nil = section_proof [] `filter a [] = []` [
   ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma filter_cons *)
let filter_cons = section_proof ["x";"t"] `filter a (x::t) = if a x then x :: filter a t else filter a t` [
   ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma count_nil *)
let count_nil = section_proof [] `count a [] = 0` [
   ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma count_cons *)
let count_cons = section_proof ["x";"t"] `count a (x::t) = (if a x then 1 else 0) + count a t` [
   ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma has_nil *)
let has_nil = section_proof [] `has a [] = F` [
   ((repeat_tactic 1 9 (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma has_cons *)
let has_cons = section_proof ["x";"t"] `has a (x::t) <=> a x \/ has a t` [
   ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma all_nil *)
let all_nil = section_proof [] `all a [] = T` [
   ((repeat_tactic 1 9 (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma all_cons *)
let all_cons = section_proof ["x";"t"] `all a (x::t) <=> a x /\ all a t` [
   ((((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma count_filter *)
let count_filter = section_proof ["s"] `count a s = sizel (filter a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN (((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (simp_tac)); (move ["nax"])]) THEN ((((use_arg_then "add1n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "nax")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma has_count *)
let has_count = section_proof ["s"] `has a s = (0 < count a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN (((((use_arg_then "has")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "ltnn")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_term (`a x`))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma count_size *)
let count_size = section_proof ["s"] `count a s <= sizel s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "leqnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> arg_tac (Arg_term (`a x`))) (disch_tac [])) THEN case THEN (simp_tac)) THEN ((((fun arg_tac ->(use_arg_then "add1n")(fun tmp_arg1 -> (use_arg_then "add0n")(fun tmp_arg2 -> arg_tac (Arg_theorem (CONJ (get_arg_thm tmp_arg1) (get_arg_thm tmp_arg2))))))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then "leqW") (disch_tac [])) THEN (clear_assumption "leqW") THEN (exact_tac)));
];;

(* Lemma all_count *)
let all_count = section_proof ["s"] `all a s = (count a s = sizel s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN ((((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((THENL_FIRST) ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"]) THEN (move ["_"])) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then "add0n")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqn_leq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_size")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma filter_all *)
let filter_all = section_proof ["s"] `all a (filter a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma all_filterP *)
let all_filterP = section_proof ["s"] `(filter a s = s) <=> (all a s)` [
   ((THENL_FIRST) ((THENL) (EQ_TAC) [(((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))); ALL_TAC]) ((((use_arg_then "filter_all")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN ALL_TAC THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (move ["Hs"]))) THEN (simp_tac)));
   ((((fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "Hs") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma filter_id *)
let filter_id = section_proof ["s"] `filter a (filter a s) = filter a s` [
   (((((use_arg_then "all_filterP")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "filter_all")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_find *)
let has_find = section_proof ["s"] `has a s <=> (find a s < sizel s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((simp_tac THEN TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN ((repeat_tactic 0 10 (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "gtS0")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma find_size *)
let find_size = section_proof ["s"] `find a s <= sizel s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "leqnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN ((repeat_tactic 0 10 (((use_arg_then "leq0n")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma find_cat *)
let find_cat = section_proof ["s1";"s2"] `find a (s1 ++ s2) = if has a s1 then find a s1 else sizel s1 + find a s2` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"]));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "fun_if")(thm_tac (new_rewrite [] [(`SUC _1`)])))) THEN (((use_arg_then "addSn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_nil *)
let has_nil = section_proof [] `has a [] = F` [
   ((repeat_tactic 1 9 (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma has_seq1 *)
let has_seq1 = section_proof ["x"] `has a [x] = a x` [
   ((repeat_tactic 1 9 (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma has_seqb *)
let has_seqb = section_proof ["b";"x"] `has a (nseq (if b then 1 else 0) x) <=> (b /\ a x)` [
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case THEN (simp_tac)) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ONE")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "has_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "has_seq1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma all_nil *)
let all_nil = section_proof [] `all a [] = T` [
   ((repeat_tactic 1 9 (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma all_seq1 *)
let all_seq1 = section_proof ["x"] `all a [x] = a x` [
   ((repeat_tactic 1 9 (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_find *)
let nth_find = section_proof ["s"] `has a s ==> a (nth x0 s (find a s))` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma before_find *)
let before_find = section_proof ["s";"i"] `i < find a s ==> (a (nth x0 s i) <=> F)` [
   (((THENL) (((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((THENL_FIRST) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ax"])) ((((use_arg_then "ltn0")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ax")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltSS")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma filter_cat *)
let filter_cat = section_proof ["s1";"s2"] `filter a (s1 ++ s2) = filter a s1 ++ filter a s2` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["Ihs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma filter_rcons *)
let filter_rcons = section_proof ["s";"x"] `filter a (rcons s x) = if a x then rcons (filter a s) x else filter a s` [
   (((repeat_tactic 1 9 (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "filter_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN (((use_arg_then "cats0")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma count_cat *)
let count_cat = section_proof ["s1";"s2"] `count a (s1 ++ s2) = count a s1 + count a s2` [
   (((repeat_tactic 1 9 (((use_arg_then "count_filter")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "filter_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cat")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_cat *)
let has_cat = section_proof ["s1";"s2"] `has a (s1 ++ s2) = (has a s1 \/ has a s2)` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_rcons *)
let has_rcons = section_proof ["s";"x"] `has a (rcons s x) = (a x \/ has a s)` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_seq1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_cat *)
let all_cat = section_proof ["s1";"s2"] `all a (s1 ++ s2) = (all a s1 /\ all a s2)` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_rcons *)
let all_rcons = section_proof ["s";"x"] `all a (rcons s x) = (a x /\ all a s)` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "all_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "all_seq1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section SeqFind *)
let find_nil = finalize_theorem find_nil;;
let find_cons = finalize_theorem find_cons;;
let filter_nil = finalize_theorem filter_nil;;
let filter_cons = finalize_theorem filter_cons;;
let count_nil = finalize_theorem count_nil;;
let count_cons = finalize_theorem count_cons;;
let has_nil = finalize_theorem has_nil;;
let has_cons = finalize_theorem has_cons;;
let all_nil = finalize_theorem all_nil;;
let all_cons = finalize_theorem all_cons;;
let count_filter = finalize_theorem count_filter;;
let has_count = finalize_theorem has_count;;
let count_size = finalize_theorem count_size;;
let all_count = finalize_theorem all_count;;
let filter_all = finalize_theorem filter_all;;
let all_filterP = finalize_theorem all_filterP;;
let filter_id = finalize_theorem filter_id;;
let has_find = finalize_theorem has_find;;
let find_size = finalize_theorem find_size;;
let find_cat = finalize_theorem find_cat;;
let has_nil = finalize_theorem has_nil;;
let has_seq1 = finalize_theorem has_seq1;;
let has_seqb = finalize_theorem has_seqb;;
let all_nil = finalize_theorem all_nil;;
let all_seq1 = finalize_theorem all_seq1;;
let nth_find = finalize_theorem nth_find;;
let before_find = finalize_theorem before_find;;
let filter_cat = finalize_theorem filter_cat;;
let filter_rcons = finalize_theorem filter_rcons;;
let count_cat = finalize_theorem count_cat;;
let has_cat = finalize_theorem has_cat;;
let has_rcons = finalize_theorem has_rcons;;
let all_cat = finalize_theorem all_cat;;
let all_rcons = finalize_theorem all_rcons;;
end_section "SeqFind";;
let pred1 = new_definition `pred1 (a:A) = (\x. x = a)`;;
let predD1 = new_definition `predD1 a x = predD a (pred1 x)`;;

(* Lemma eq_find *)
let eq_find = section_proof ["a1";"a2"] `(!x:A. a1 x = a2 x) ==> (!s. find a1 s = find a2 s)` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "EQ_EXT") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_filter *)
let eq_filter = section_proof ["a1";"a2"] `(!x:A. a1 x = a2 x) ==> (!s. filter a1 s = filter a2 s)` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "EQ_EXT") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_count *)
let eq_count = section_proof ["a1";"a2"] `(!x:A. a1 x = a2 x) ==> (!s. count a1 s = count a2 s)` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "EQ_EXT") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_has *)
let eq_has = section_proof ["a1";"a2"] `(!x. a1 x = a2 x) ==> (!s. has a1 s = has a2 s)` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "EQ_EXT") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_all *)
let eq_all = section_proof ["a1";"a2"] `(!x. a1 x = a2 x) ==> (!s. all a1 s = all a2 s)` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "EQ_EXT") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma filter_pred0 *)
let filter_pred0 = section_proof ["s"] `filter pred0 s = []` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "pred0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "pred0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma filter_predT *)
let filter_predT = section_proof ["s"] `filter predT s = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "predT")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [2] []))))) THEN (((use_arg_then "predT")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma filter_predI *)
let filter_predI = section_proof ["a1";"a2";"s"] `filter (predI a1 a2) s = filter a1 (filter a2 s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((repeat_tactic 1 9 (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then "predI")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((THENL_LAST) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a2:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) (((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "predI")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a1:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["a1x"])) THEN (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))));
   (((((use_arg_then "a1x")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "IHs")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "predI")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   (((((use_arg_then "a1x")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "IHs")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "predI")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma count_pred0 *)
let count_pred0 = section_proof ["s"] `count pred0 s = 0` [
   (((((use_arg_then "count_filter")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "filter_pred0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_nil")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma count_predT *)
let count_predT = section_proof ["s"] `count predT s = sizel s` [
   (((((use_arg_then "count_filter")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "filter_predT")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma count_predUI *)
let count_predUI = section_proof ["a1";"a2";"s"] `count (predU a1 a2) s + count (predI a1 a2) s = count a1 s + count a2 (s:(A)list)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then "predI")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "predU")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a1:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["a1x"])) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a2:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["a2x"])) THEN ((((use_arg_then "predI")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "predU")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN BETA_TAC) THEN (arith_tac));
];;

(* Lemma count_predC *)
let count_predC = section_proof ["a";"s"] `count a s + count (predC a) s = sizel (s:(A)list)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   ((((use_arg_then "addnCA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addnA")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predC")(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ax"])) THEN (arith_tac));
];;

(* Lemma has_pred0 *)
let has_pred0 = section_proof ["s"] `has pred0 s = F` [
   (((((use_arg_then "has_count")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_pred0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_predT *)
let has_predT = section_proof ["s"] `has predT s = (0 < sizel s)` [
   (((((use_arg_then "has_count")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_predT")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_predC *)
let has_predC = section_proof ["a";"s"] `has (predC a) s = ~ all a s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predC")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "negb_and")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_predU *)
let has_predU = section_proof ["a1";"a2";"s"] `has (predU a1 a2) s <=> (has a1 s \/ has a2 s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predU")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then "orbA")(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then "orbCA")(thm_tac (new_rewrite [] [(`has a1 s \/ _ \/ _1`)])))) THEN (done_tac));
];;

(* Lemma all_pred0 *)
let all_pred0 = section_proof ["s"] `all pred0 s = (sizel s = 0)` [
   (((((use_arg_then "all_count")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_pred0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`0 = _`)]))))) THEN (done_tac));
];;

(* Lemma all_predT *)
let all_predT = section_proof ["s"] `all predT s` [
   (((((use_arg_then "all_count")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_predT")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_predC *)
let all_predC = section_proof ["a";"s"] `all (predC a) s = ~ has a s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_or")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma can_inj *)
let can_inj = section_proof ["f";"g"] `(!x. g (f x) = x) ==> (!x y. f x = f y ==> x = y)` [
   (BETA_TAC THEN (move ["h"]) THEN (move ["x"]) THEN (move ["y"]) THEN (move ["f_eq"]));
   (((((fun arg_tac -> (use_arg_then "h") (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "h") (fun fst_arg -> (use_arg_then "y") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "f_eq")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_predI *)
let all_predI = section_proof ["a1";"a2";"s"] `all (predI a1 a2) s <=> all a1 s /\ all a2 s` [
   ((((fun arg_tac -> (use_arg_then "can_inj") (fun fst_arg -> (use_arg_then "negbK") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then "negb_and")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "has_predC")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "has_predU")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "predU")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predI")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "predC")(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then "negb_and")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let drop = define `!n x s. dropl (SUC n) (x :: s) = dropl n s /\ 
	dropl n [] = [] /\ dropl 0 s = s`;;

(* Lemma eq_ext *)
let eq_ext = section_proof ["f";"g"] `(!x. f x = g x) <=> f = g` [
   ((THENL_FIRST) ((split_tac) THEN (move ["h"])) ((MATCH_MP_TAC EQ_EXT) THEN (done_tac)));
   ((((use_arg_then "h")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma drop_nil *)
let drop_nil = section_proof ["n"] `dropl n [] = []` [
   ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma drop0 *)
let drop0 = section_proof [] `dropl 0 = I` [
   (((((use_arg_then "eq_ext")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "I_THM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma drop_cons *)
let drop_cons = section_proof ["n";"x";"s"] `dropl (SUC n) (x :: s) = dropl n s` [
   ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma drop_behead *)
let drop_behead = section_proof [] `dropl n0 = iter n0 behead` [
   ((THENL_FIRST) (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then "eq_ext")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) ((((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac)));
   (((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "iterSr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHn")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma drop0 *)
let drop0 = section_proof ["s"] `dropl 0 s = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma drop1 *)
let drop1 = section_proof ["s"] `dropl 1 s = behead s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "ONE")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "drop0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma drop_oversize *)
let drop_oversize = section_proof ["n";"s"] `sizel s <= n ==> dropl n s = []` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHn") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma drop_size *)
let drop_size = section_proof ["s"] `dropl (sizel s) s = []` [
   (((((use_arg_then "drop_oversize")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "leqnn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_drop *)
let size_drop = section_proof ["s"] `sizel (dropl n0 s) = sizel s - n0` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sub0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma drop_cat *)
let drop_cat = section_proof ["s1";"s2"] `dropl n0 (s1 ++ s2) =
    if n0 < sizel s1 then dropl n0 s1 ++ s2 else dropl (n0 - sizel s1) s2` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sub0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "if_same")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "gtS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma drop_size_cat *)
let drop_size_cat = section_proof ["n";"s1";"s2"] `sizel s1 = n ==> dropl n (s1 ++ s2) = s2` [
   ((BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nconsK *)
let nconsK = section_proof ["n";"x";"s"] `dropl n (ncons n x s) = s` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;
let take = define `!x s n. take (SUC n) (x :: s) = x :: take n s /\
	take 0 s = [] /\ take n [] = []`;;

(* Lemma take0 *)
let take0 = section_proof ["s"] `take 0 s = []` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma take_oversize *)
let take_oversize = section_proof ["n";"s"] `sizel s <= n ==> take n s = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltn0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (move ["Hsn"])) THEN (((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma take_size *)
let take_size = section_proof ["s"] `take (sizel s) s = s` [
   (((((use_arg_then "take_oversize")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "leqnn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma take_cons *)
let take_cons = section_proof ["x";"s"] `take (SUC n0) (x :: s) = x :: (take n0 s)` [
   ((((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma drop_rcons *)
let drop_rcons = section_proof ["s"] `n0 <= sizel s ==>
  !x. dropl n0 (rcons s x) = rcons (dropl n0 s) x` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop_cons")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma congr1 *)
let congr1 = section_proof ["f";"x";"y"] `x = y ==> f x = f y` [
   ((BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma cat_take_drop *)
let cat_take_drop = section_proof ["s"] `take n0 s ++ dropl n0 s = s` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma size_takel *)
let size_takel = section_proof ["s"] `n0 <= sizel s ==> sizel (take n0 s) = n0` [
   (((DISCH_THEN (fun snd_th -> (use_arg_then "subnKC") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [2] []))))) THEN (((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_drop")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "addIn") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma size_take *)
let size_take = section_proof ["s"] `sizel (take n0 s) = if n0 < sizel s then n0 else sizel s` [
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then "leqP") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel (s:(A)list)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN ((THENL) case [(move ["le_sn"]); (move ["lt_ns"])]));
   (((((use_arg_then "take_oversize")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "le_sn")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   (((((use_arg_then "lt_ns")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "size_takel")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltnW")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma take_cat *)
let take_cat = section_proof ["s1";"s2"] `take n0 (s1 ++ s2) =
   if n0 < sizel s1 then take n0 s1 else s1 ++ take (n0 - sizel s1) s2` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "subn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "gtS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "ltSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "fun_if")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma take_size_cat *)
let take_size_cat = section_proof ["n";"s1";"s2"] `sizel s1 = n ==> take n (s1 ++ s2) = s1` [
   ((BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma takel_cat *)
let takel_cat = section_proof ["s1"] `n0 <= sizel (s1:(A)list) ==> (!s2. take n0 (s1 ++ s2) = take n0 s1)` [
   (BETA_TAC THEN (move ["Hn0"]) THEN (move ["s2"]));
   ((((use_arg_then "take_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltn_neqAle")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hn0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbT")(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n0 = sizel (s1:(A)list)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["eq"]));
   (((((use_arg_then "subnn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take_size")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_drop *)
let nth_drop = section_proof ["s";"i"] `nth x0 (dropl n0 s) i = nth x0 s (n0 + i)` [
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then "ltnP") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel (s:(A)list)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN ((THENL) case [(move ["lt_n0_s"]); (move ["le_s_n0"])]));
   ((((use_arg_then "cat_take_drop")(gsym_then (thm_tac (new_rewrite [2] [(`s`)]))))) THEN (((use_arg_then "nth_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "lt_n0_s")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "addKn")(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_addr")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then "nth_default")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then "le_s_n0") (disch_tac [])) THEN (clear_assumption "le_s_n0") THEN BETA_TAC) THEN (((((use_arg_then "size_drop")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "leqE")(thm_tac (new_rewrite [] [])))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "sub0n")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then "leq_trans") (fun fst_arg -> (use_arg_then "le_s_n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "leq_addr")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_take *)
let nth_take = section_proof ["i"] `i < n0 ==> !s. nth x0 (take n0 s) i = nth x0 s i` [
   ((BETA_TAC THEN (move ["lt_i_n0"]) THEN (move ["s"])) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n0 < sizel (s:(A)list)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["lt_n0_s"])));
   (((((use_arg_then "cat_take_drop")(gsym_then (thm_tac (new_rewrite [2] [(`s`)]))))) THEN (((use_arg_then "nth_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "lt_n0_s")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "lt_i_n0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then "cats0")(gsym_then (thm_tac (new_rewrite [1] [(`s`)]))))) THEN (((use_arg_then "take_cat")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "lt_n0_s")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cats0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma drop_nth *)
let drop_nth = section_proof ["n";"s"] `n < sizel s ==> dropl n s = nth x0 s n :: dropl (SUC n) s` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma take_nth *)
let take_nth = section_proof ["n";"s"] `n < sizel s ==> take (SUC n) s = rcons (take n s) (nth x0 s n)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let rot = new_definition `rot n s = dropl n s ++ take n s`;;

(* Lemma rot0 *)
let rot0 = section_proof ["s"] `rot 0 s = s` [
   (((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_rot *)
let size_rot = section_proof ["s"] `sizel (rot n0 s) = sizel s` [
   (((((use_arg_then "cat_take_drop")(gsym_then (thm_tac (new_rewrite [2] [(`s`)]))))) THEN (((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "size_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "addnC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rot_oversize *)
let rot_oversize = section_proof ["n";"s"] `sizel s <= n ==> rot n s = s` [
   ((BETA_TAC THEN (move ["le_s_n"])) THEN ((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take_oversize")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "drop_oversize")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma rot_size *)
let rot_size = section_proof ["s"] `rot (sizel s) s = s` [
   ((((use_arg_then "rot_oversize") (disch_tac [])) THEN (clear_assumption "rot_oversize") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "leqnn")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma has_rot *)
let has_rot = section_proof ["s";"a"] `has a (rot n0 s) = has a s` [
   (((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_cat")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rot_size_cat *)
let rot_size_cat = section_proof ["s1";"s2"] `rot (sizel s1) (s1 ++ s2) = s2 ++ s1` [
   (((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take_size_cat")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "drop_size_cat")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;
let rotr = new_definition `rotr n s = rot (sizel s - n) s`;;

(* Lemma rotK *)
let rotK = section_proof ["s"] `rotr n0 (rot n0 s) = s` [
   ((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_drop")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rot")(thm_tac (new_rewrite [] [(`rot n0 _`)])))));
   (((((use_arg_then "rot_size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rot_inj *)
let rot_inj = section_proof ["s1";"s2"] `rot n0 (s1:(A)list) = rot n0 s2 ==> s1 = s2` [
   ((((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then "can_inj") (fun fst_arg -> (use_arg_then "rotK") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma rot1_cons *)
let rot1_cons = section_proof ["x";"s"] `rot 1 (x :: s) = rcons s x` [
   (((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ONE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "take0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Finalization of the section Sequences *)
let size0nil = finalize_theorem size0nil;;
let nilP = finalize_theorem nilP;;
let size_behead = finalize_theorem size_behead;;
let size_nil = finalize_theorem size_nil;;
let size_cons = finalize_theorem size_cons;;
let size_ncons = finalize_theorem size_ncons;;
let size_nseq = finalize_theorem size_nseq;;
let cat0s = finalize_theorem cat0s;;
let cat1s = finalize_theorem cat1s;;
let cat_cons = finalize_theorem cat_cons;;
let cat_nseq = finalize_theorem cat_nseq;;
let cats0 = finalize_theorem cats0;;
let catA = finalize_theorem catA;;
let size_cat = finalize_theorem size_cat;;
let rcons_cons = finalize_theorem rcons_cons;;
let cats1 = finalize_theorem cats1;;
let lastI = finalize_theorem lastI;;
let last_cons = finalize_theorem last_cons;;
let size_rcons = finalize_theorem size_rcons;;
let size_belast = finalize_theorem size_belast;;
let last_cat = finalize_theorem last_cat;;
let last_rcons = finalize_theorem last_rcons;;
let belast_cat = finalize_theorem belast_cat;;
let belast_rcons = finalize_theorem belast_rcons;;
let cat_rcons = finalize_theorem cat_rcons;;
let rcons_cat = finalize_theorem rcons_cat;;
let last_ind = finalize_theorem last_ind;;
let nth0 = finalize_theorem nth0;;
let nth_default = finalize_theorem nth_default;;
let nth_nil = finalize_theorem nth_nil;;
let last_nth = finalize_theorem last_nth;;
let nth_last = finalize_theorem nth_last;;
let nth_behead = finalize_theorem nth_behead;;
let nth_cat = finalize_theorem nth_cat;;
let nth_rcons = finalize_theorem nth_rcons;;
let nth_ncons = finalize_theorem nth_ncons;;
let nth_nseq = finalize_theorem nth_nseq;;
let eq_from_nth = finalize_theorem eq_from_nth;;
let size_set_nth = finalize_theorem size_set_nth;;
let set_nth_nil = finalize_theorem set_nth_nil;;
let ltS0 = finalize_theorem ltS0;;
let eqS0 = finalize_theorem eqS0;;
let eq0S = finalize_theorem eq0S;;
let gtS0 = finalize_theorem gtS0;;
let ltSS = finalize_theorem ltSS;;
let nth_set_nth = finalize_theorem nth_set_nth;;
let set_set_nth = finalize_theorem set_set_nth;;
let find_nil = finalize_theorem find_nil;;
let find_cons = finalize_theorem find_cons;;
let filter_nil = finalize_theorem filter_nil;;
let filter_cons = finalize_theorem filter_cons;;
let count_nil = finalize_theorem count_nil;;
let count_cons = finalize_theorem count_cons;;
let has_nil = finalize_theorem has_nil;;
let has_cons = finalize_theorem has_cons;;
let all_nil = finalize_theorem all_nil;;
let all_cons = finalize_theorem all_cons;;
let count_filter = finalize_theorem count_filter;;
let has_count = finalize_theorem has_count;;
let count_size = finalize_theorem count_size;;
let all_count = finalize_theorem all_count;;
let filter_all = finalize_theorem filter_all;;
let all_filterP = finalize_theorem all_filterP;;
let filter_id = finalize_theorem filter_id;;
let has_find = finalize_theorem has_find;;
let find_size = finalize_theorem find_size;;
let find_cat = finalize_theorem find_cat;;
let has_nil = finalize_theorem has_nil;;
let has_seq1 = finalize_theorem has_seq1;;
let has_seqb = finalize_theorem has_seqb;;
let all_nil = finalize_theorem all_nil;;
let all_seq1 = finalize_theorem all_seq1;;
let nth_find = finalize_theorem nth_find;;
let before_find = finalize_theorem before_find;;
let filter_cat = finalize_theorem filter_cat;;
let filter_rcons = finalize_theorem filter_rcons;;
let count_cat = finalize_theorem count_cat;;
let has_cat = finalize_theorem has_cat;;
let has_rcons = finalize_theorem has_rcons;;
let all_cat = finalize_theorem all_cat;;
let all_rcons = finalize_theorem all_rcons;;
let eq_find = finalize_theorem eq_find;;
let eq_filter = finalize_theorem eq_filter;;
let eq_count = finalize_theorem eq_count;;
let eq_has = finalize_theorem eq_has;;
let eq_all = finalize_theorem eq_all;;
let filter_pred0 = finalize_theorem filter_pred0;;
let filter_predT = finalize_theorem filter_predT;;
let filter_predI = finalize_theorem filter_predI;;
let count_pred0 = finalize_theorem count_pred0;;
let count_predT = finalize_theorem count_predT;;
let count_predUI = finalize_theorem count_predUI;;
let count_predC = finalize_theorem count_predC;;
let has_pred0 = finalize_theorem has_pred0;;
let has_predT = finalize_theorem has_predT;;
let has_predC = finalize_theorem has_predC;;
let has_predU = finalize_theorem has_predU;;
let all_pred0 = finalize_theorem all_pred0;;
let all_predT = finalize_theorem all_predT;;
let all_predC = finalize_theorem all_predC;;
let can_inj = finalize_theorem can_inj;;
let all_predI = finalize_theorem all_predI;;
let eq_ext = finalize_theorem eq_ext;;
let drop_nil = finalize_theorem drop_nil;;
let drop0 = finalize_theorem drop0;;
let drop_cons = finalize_theorem drop_cons;;
let drop_behead = finalize_theorem drop_behead;;
let drop0 = finalize_theorem drop0;;
let drop1 = finalize_theorem drop1;;
let drop_oversize = finalize_theorem drop_oversize;;
let drop_size = finalize_theorem drop_size;;
let size_drop = finalize_theorem size_drop;;
let drop_cat = finalize_theorem drop_cat;;
let drop_size_cat = finalize_theorem drop_size_cat;;
let nconsK = finalize_theorem nconsK;;
let take0 = finalize_theorem take0;;
let take_oversize = finalize_theorem take_oversize;;
let take_size = finalize_theorem take_size;;
let take_cons = finalize_theorem take_cons;;
let drop_rcons = finalize_theorem drop_rcons;;
let congr1 = finalize_theorem congr1;;
let cat_take_drop = finalize_theorem cat_take_drop;;
let size_takel = finalize_theorem size_takel;;
let size_take = finalize_theorem size_take;;
let take_cat = finalize_theorem take_cat;;
let take_size_cat = finalize_theorem take_size_cat;;
let takel_cat = finalize_theorem takel_cat;;
let nth_drop = finalize_theorem nth_drop;;
let nth_take = finalize_theorem nth_take;;
let drop_nth = finalize_theorem drop_nth;;
let take_nth = finalize_theorem take_nth;;
let rot0 = finalize_theorem rot0;;
let size_rot = finalize_theorem size_rot;;
let rot_oversize = finalize_theorem rot_oversize;;
let rot_size = finalize_theorem rot_size;;
let has_rot = finalize_theorem has_rot;;
let rot_size_cat = finalize_theorem rot_size_cat;;
let rotK = finalize_theorem rotK;;
let rot_inj = finalize_theorem rot_inj;;
let rot1_cons = finalize_theorem rot1_cons;;
end_section "Sequences";;
let catrev = define `catrev (x :: s1) s2 = catrev s1 (x :: s2) /\ catrev [] s2 = s2`;;
let rev = new_definition `rev s = catrev s []`;;

(* Section Rev *)
begin_section "Rev";;
(add_section_type (mk_var ("s", (`:(A)list`))); add_section_type (mk_var ("t", (`:(A)list`))));;

(* Lemma catrev_catl *)
let catrev_catl = section_proof ["s";"t";"u"] `catrev (s ++ t) u = catrev t (catrev s u)` [
   ((((use_arg_then "u") (disch_tac [])) THEN (clear_assumption "u") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma catrev_catr *)
let catrev_catr = section_proof ["s";"t";"u"] `catrev s (t ++ u) = catrev s t ++ u` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (BETA_TAC THEN (move ["t"])) THEN ((((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "IHs")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma catrevE *)
let catrevE = section_proof ["s";"t"] `catrev s t = rev s ++ t` [
   (((((use_arg_then "rev")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "catrev_catr")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma rev_cons *)
let rev_cons = section_proof ["x";"s"] `rev (x :: s) = rcons (rev s) x` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catrevE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rev")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma size_rev *)
let size_rev = section_proof ["s"] `sizel (rev s) = sizel s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "catrevE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rev_cat *)
let rev_cat = section_proof ["s";"t"] `rev (s ++ t) = rev t ++ rev s` [
   (((repeat_tactic 1 9 (((use_arg_then "rev")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catrev_catr")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "cat0s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "catrev_catl")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma rev_rcons *)
let rev_rcons = section_proof ["s";"x"] `rev (rcons s x) = x :: rev s` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rev_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rev")(thm_tac (new_rewrite [] []))))) THEN ((repeat_tactic 1 9 (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;

(* Lemma revK *)
let revK = section_proof ["s"] `rev (rev s) = s` [
   ((THENL_FIRST) ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) ((repeat_tactic 1 9 (((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (repeat_tactic 1 9 (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (simp_tac)));
   (((((use_arg_then "rev_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rev_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_rev *)
let nth_rev = section_proof ["x0";"n";"s"] `n < sizel s ==> nth x0 (rev s) n = nth x0 s (sizel s - SUC n)` [
   ((((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN BETA_TAC) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REWRITE_RULE[IMP_IMP] last_ind))) (disch_tac [])) THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltn0")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["s"]) THEN (move ["x"]) THEN (move ["IHs"]) THEN (move ["n"]));
   ((((use_arg_then "rev_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "subSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nth_cat")(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) (((((use_arg_then "subn0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnn")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "subnn")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "nth0")(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "head")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac)));
   (BETA_TAC THEN (move ["lt_n_s"]));
   ((((fun arg_tac -> (use_arg_then "subnK") (fun fst_arg -> (use_arg_then "lt_n_s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [2] []))))) THEN (((use_arg_then "addSnnS")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_addr")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Finalization of the section Rev *)
let catrev_catl = finalize_theorem catrev_catl;;
let catrev_catr = finalize_theorem catrev_catr;;
let catrevE = finalize_theorem catrevE;;
let rev_cons = finalize_theorem rev_cons;;
let size_rev = finalize_theorem size_rev;;
let rev_cat = finalize_theorem rev_cat;;
let rev_rcons = finalize_theorem rev_rcons;;
let revK = finalize_theorem revK;;
let nth_rev = finalize_theorem nth_rev;;
end_section "Rev";;

(* Section EqSeq *)
begin_section "EqSeq";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_var (mk_var ("x0", (`:A`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;
(add_section_type (mk_var ("x", (`:A`))); add_section_type (mk_var ("y", (`:A`))); add_section_type (mk_var ("z", (`:A`))));;

(* Lemma eqseq_cons *)
let eqseq_cons = section_proof ["x1";"x2";"s1";"s2"] `((x1 :: s1) = x2 :: s2) <=> (x1 = x2 /\ s1 = s2)` [
   ((((fun arg_tac -> arg_tac (Arg_theorem (injectivity "list")))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma eqseq_cat *)
let eqseq_cat = section_proof ["s1";"s2";"s3";"s4"] `sizel s1 = sizel s2 ==> (s1 ++ s3 = s2 ++ s4 <=> (s1 = s2 /\ s3 = s4))` [
   ((THENL) (((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x1"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x2"]) THEN (move ["s2"]) THEN (move ["_"]))]) THEN ((repeat_tactic 1 9 (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) [(arith_tac); (arith_tac); BETA_TAC]);
   (((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "eqseq_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "andbA")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eqseq_rcons *)
let eqseq_rcons = section_proof ["s1";"s2";"x1";"x2"] `(rcons s1 x1 = rcons s2 x2) <=> (s1 = s2 /\ x1 = x2)` [
   ((THENL_ROT (-1)) (((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y1"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y2"]) THEN (move ["s2"]) THEN (move ["_"]))]) THEN ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "eqseq_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s2"]) THEN (move ["_"]))]) THEN ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["xx"]) THEN (move ["ss"]) THEN (move ["_"]))]) THEN ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma has_filter *)
let has_filter = section_proof ["a";"s"] `has a s <=> ~(filter a s = [])` [
   ((((use_arg_then "has_count")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "count_filter")(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`filter a s`))) (term_tac (set_tac "l")));
   (((THENL) (((use_arg_then "l_def") (disch_tac [])) THEN (clear_assumption "l_def") THEN ((use_arg_then "l") (disch_tac [])) THEN (clear_assumption "l") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["l"]) THEN (move ["_"]))]) THEN (BETA_TAC THEN (move ["_"])) THEN ((repeat_tactic 0 10 (((use_arg_then "size_nil")(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 0 10 (((use_arg_then "ltnn")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "gtS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma size_eq0 *)
let size_eq0 = section_proof ["s"] `(sizel s = 0) <=> (s = [])` [
   (((THENL) (split_tac) [ALL_TAC; (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))]) THEN ((repeat_tactic 0 10 (((use_arg_then "size_nil")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "size0nil") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;
parse_as_infix("<-", (11, "right"));;
override_interface("<-", `MEM`);;

(* Lemma in_cons *)
let in_cons = section_proof ["y";"s";"x"] `(x <- y :: s) <=> (x = y \/ x <- s)` [
   ((repeat_tactic 1 9 (((use_arg_then "MEM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma in_nil *)
let in_nil = section_proof ["x"] `(x <- []) = F` [
   ((repeat_tactic 1 9 (((use_arg_then "MEM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma mem_seq1 *)
let mem_seq1 = section_proof ["x";"y"] `(x <- [y]) <=> (x = y)` [
   (((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbF")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_seq2 *)
let mem_seq2 = section_proof ["x";"y1";"y2"] `(x <- [y1; y2]) <=> (x = y1 \/ x = y2)` [
   (((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbF")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_seq3 *)
let mem_seq3 = section_proof ["x";"y1";"y2";"y3"] `(x <- [y1; y2; y3]) <=> (x = y1 \/ x = y2 \/ x = y3)` [
   (((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbF")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_seq4 *)
let mem_seq4 = section_proof ["x";"y1";"y2";"y3";"y4"] `(x <- [y1; y2; y3; y4]) <=> (x = y1 \/ x = y2 \/ x = y3 \/ x = y4)` [
   (((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbF")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_cat *)
let mem_cat = section_proof ["x";"s1";"s2"] `(x <- s1 ++ s2) <=> (x <- s1 \/ x <- s2)` [
   ((THENL_FIRST) ((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) (((((use_arg_then "cat0s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orFb")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then "cat_cons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbA")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma mem_rcons *)
let mem_rcons = section_proof ["s";"y"] `!x. x <- rcons s y <=> x <- y :: s` [
   ((BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_seq1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_head *)
let mem_head = section_proof ["x";"s"] `x <- x :: s` [
   (((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma mem_last *)
let mem_last = section_proof ["x";"s"] `last x s <- x :: s` [
   (((((use_arg_then "lastI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_head")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_behead *)
let mem_behead = section_proof ["s"] `!x. x <- behead s ==> x <- s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["_"]) THEN (move ["x"]))]) THEN ((((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "in_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma mem_belast *)
let mem_belast = section_proof ["s";"y"] `!x. x <- belast y s ==> x <- y :: s` [
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ys'x"])) THEN ((((use_arg_then "lastI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_behead")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma mem_nth *)
let mem_nth = section_proof ["s";"n"] `n < sizel s ==> nth x0 s n <- s` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mem_head")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (move ["sz_s"]));
   ((((use_arg_then "mem_behead")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma mem_take *)
let mem_take = section_proof ["s";"x"] `x <- take n0 s ==> x <- s` [
   ((BETA_TAC THEN (move ["s0x"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_drop *)
let mem_drop = section_proof ["s";"x"] `x <- dropl n0 s ==> x <- s` [
   ((BETA_TAC THEN (move ["s0'x"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_rev *)
let mem_rev = section_proof ["s"] `!x. x <- rev s <=> x <- s` [
   ((THENL_FIRST) ((BETA_TAC THEN (move ["y"])) THEN ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))])) (((((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac)));
   (((((use_arg_then "rev_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_rcons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Section Filters *)
begin_section "Filters";;
(add_section_var (mk_var ("a", (`:A -> bool`))));;

(* Lemma hasP *)
let hasP = section_proof ["s"] `(?x. x <- s /\ a x) <=> has a s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   ((THENL_FIRST) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ay"])) (((use_arg_then "y") (term_tac exists_tac)) THEN (((use_arg_then "mem_head")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((THENL_ROT (-1)) ((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN ALL_TAC THEN (case THEN ((move ["x"]) THEN (case THEN ((move ["ysx"]) THEN (move ["ax"]))))))));
   (((use_arg_then "x") (term_tac exists_tac)) THEN ((((use_arg_then "mem_behead")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
   (((use_arg_then "x") (term_tac exists_tac)) THEN (((use_arg_then "ysx") (disch_tac [])) THEN (clear_assumption "ysx") THEN BETA_TAC) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y:A`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN ((simp_tac THEN TRY done_tac)) THEN (move ["xy"]));
   ((((use_arg_then "ax") (disch_tac [])) THEN (clear_assumption "ax") THEN BETA_TAC) THEN ((((use_arg_then "xy")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ay")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma hasPn *)
let hasPn = section_proof ["s"] `(!x. x <- s ==> ~(a x)) <=> ~has a s` [
   ((THENL_ROT (1)) ((split_tac) THEN (move ["not_a_s"])));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["s_x"])) THEN (((use_arg_then "not_a_s") (disch_tac [])) THEN (clear_assumption "not_a_s") THEN ((use_arg_then "contra") (disch_tac [])) THEN (clear_assumption "contra") THEN (DISCH_THEN apply_tac) THEN (move ["a_x"])));
   ((((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((use_arg_then "x") (term_tac exists_tac)) THEN (done_tac));
   ((((((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "implybF")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (case THEN ((move ["x"]) THEN (case THEN (move ["s_x"]))))) THEN (((use_arg_then "implybF")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "not_a_s") (disch_tac [])) THEN (clear_assumption "not_a_s") THEN (exact_tac)) THEN (done_tac));
];;

(* Lemma allP *)
let allP = section_proof ["s"] `(!x. x <- s ==> a x) <=> (all a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((THENL_ROT (-1)) (((((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   (BETA_TAC THEN (case THEN ((move ["h"]) THEN (move ["ax"]))) THEN (move ["y"]) THEN ((THENL) case [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))); (move ["ys"])]));
   (((use_arg_then "h") (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
   (BETA_TAC THEN (move ["h"]));
   ((THENL_FIRST) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) (BETA_TAC THEN (move ["ax"])));
   ((((((use_arg_then "ax")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (move ["y"]) THEN (move ["ys"])) THEN (((use_arg_then "h") (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac)) THEN (done_tac));
   (((use_arg_then "h") (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma allPn *)
let allPn = section_proof ["s"] `(?x. x <- s /\ ~a x) <=> ~all a s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "in_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_and")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   (BETA_TAC THEN (case THEN ((move ["y"]) THEN (case THEN ((move ["ay"]) THEN ((THENL) case [(move ["eq"]); (move ["mem"])]))))));
   ((((use_arg_then "ay") (disch_tac [])) THEN (clear_assumption "ay") THEN BETA_TAC) THEN ((((use_arg_then "eq")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((DISJ2_TAC) THEN ((use_arg_then "y") (term_tac exists_tac)) THEN (done_tac));
   ((THENL_FIRST) ((THENL) case [(move ["nax"]); (case THEN ((move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["nay"])))))]) ((((use_arg_then "x") (term_tac exists_tac)) THEN (simp_tac)) THEN (done_tac)));
   (((use_arg_then "y") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma mem_filter *)
let mem_filter = section_proof ["x";"s"] `(x <- filter a s) <=> (a x /\ x <- s)` [
   ((((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "MEM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((use_arg_then "fun_if")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(a:A->bool) y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ay"])) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y:A`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN ((simp_tac THEN TRY done_tac))) THEN (done_tac));
];;

(* Finalization of the section Filters *)
let hasP = finalize_theorem hasP;;
let hasPn = finalize_theorem hasPn;;
let allP = finalize_theorem allP;;
let allPn = finalize_theorem allPn;;
let mem_filter = finalize_theorem mem_filter;;
end_section "Filters";;

(* Lemma eq_in_filter *)
let eq_in_filter = section_proof ["a1";"a2";"s"] `(!x. x <- s ==> a1 x = a2 x) ==> filter a1 s = filter a2 s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (move ["eq_a"])));
   (((((use_arg_then "eq_a")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "mem_head")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["s_y"]));
   ((((use_arg_then "eq_a") (disch_tac [])) THEN (clear_assumption "eq_a") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "mem_behead")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma eq_has_r *)
let eq_has_r = section_proof ["s1";"s2"] `(!x. x <- s1 <=> x <- s2) ==> (!a. has a s1 <=> has a s2)` [
   (BETA_TAC THEN (move ["Es12"]) THEN (move ["a"]));
   ((split_tac) THEN ((repeat_tactic 1 9 (((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ((move ["x"]) THEN (case THEN ((move ["Hx"]) THEN (move ["Hax"])))))));
   (((use_arg_then "x") (term_tac exists_tac)) THEN (((use_arg_then "Es12")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((use_arg_then "x") (term_tac exists_tac)) THEN (((use_arg_then "Es12")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma eq_all_r *)
let eq_all_r = section_proof ["s1";"s2"] `(!x. x <- s1 <=> x <- s2) ==> (!a. all a s1 = all a s2)` [
   ((BETA_TAC THEN (move ["Es12"]) THEN (move ["a"])) THEN (repeat_tactic 1 9 (((use_arg_then "allP")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((split_tac) THEN (move ["Hs"]) THEN (move ["x"]) THEN (move ["Hx"])));
   ((((use_arg_then "Hs") (disch_tac [])) THEN (clear_assumption "Hs") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "Es12")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then "Hs") (disch_tac [])) THEN (clear_assumption "Hs") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "Es12")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_sym *)
let has_sym = section_proof ["s1";"s2"] `has (\x. x <- s1) s2 = has (\x. x <- s2) s1` [
   (((repeat_tactic 1 9 (((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_pred1 *)
let has_pred1 = section_proof ["x";"s"] `has (pred1 x) s <=> x <- s` [
   (((((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((THENL) (split_tac) [((case THEN ((move ["y"]) THEN (case THEN ((move ["ys"]) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))))))) THEN ((TRY done_tac))); (move ["xs"])]));
   (((use_arg_then "x") (term_tac exists_tac)) THEN (done_tac));
];;
let constant = define `constant [] = T /\ constant (CONS x s') = all (pred1 x) s'`;;

(* Lemma all_pred1P *)
let all_pred1P = section_proof ["x";"s"] `(s = nseq (sizel s) x) <=> (all (pred1 x) s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "eqseq_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((THENL_ROT (-1)) ((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [(((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))); (move ["ne_xy"])]));
   (((((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((((use_arg_then "ne_xy")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "andFb")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   (((((use_arg_then "pred1")(thm_tac (new_rewrite [1] [])))) THEN (simp_tac) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ncons")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_pred1_constant *)
let all_pred1_constant = section_proof ["x";"s"] `all (pred1 x) s ==> constant s` [
   ((((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) THEN ((((use_arg_then "constant")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma all_pred1_nseq *)
let all_pred1_nseq = section_proof ["x";"y";"n"] `all (pred1 x) (nseq n y) <=> (n = 0 \/ x = y)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((simp_tac THEN TRY done_tac))));
   (((((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`y = x`)])))) THEN (((use_arg_then "eqS0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orFb")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "andb_idr") (disch_tac [])) THEN (clear_assumption "andb_idr") THEN (DISCH_THEN apply_tac) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma constant_nseq *)
let constant_nseq = section_proof ["n";"x"] `constant (nseq n x)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN case) [ALL_TAC; (move ["n"])]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "constant")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "ncons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nseq")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "all_pred1_nseq")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma constantP *)
let constantP = section_proof ["s"] `(?x. s = nseq (sizel s) x) <=> (constant s)` [
   ((THENL_FIRST) ((THENL) (split_tac) [(case THEN ((move ["x"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))); ALL_TAC]) ((((use_arg_then "constant_nseq")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((THENL_FIRST) (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN case) [ALL_TAC; ((move ["x"]) THEN (move ["s"]))]) THEN ((((use_arg_then "constant")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac))) ((EXISTS_TAC `x0:A`) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac)));
   (((((use_arg_then "all_pred1P")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["def_s"])) THEN ((use_arg_then "x") (term_tac exists_tac)));
   ((((use_arg_then "def_s")(thm_tac (new_rewrite [1] [])))) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;
let uniq = define `uniq [] = T /\ (uniq (x :: s') <=> ~(MEM x s') /\ uniq s')`;;

(* Lemma nil_uniq *)
let nil_uniq = section_proof [] `uniq ([]:(A)list)` [
   ((((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma cons_uniq *)
let cons_uniq = section_proof ["x";"s"] `uniq (x :: s) <=> ~(x <- s) /\ uniq s` [
   ((((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma cat_uniq *)
let cat_uniq = section_proof ["s1";"s2"] `uniq (s1 ++ s2) <=> uniq s1 /\ ~ has (\x. x <- s1) s2 /\ uniq s2` [
   ((THENL_FIRST) ((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) (((((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "pred0")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_pred0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat0s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "nil_uniq")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then "has_sym")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_cons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "negb_or")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_sym")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "andbA")(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   ((((use_arg_then "andbAC")(thm_tac (new_rewrite [] [(`_ /\ uniq s1`)])))) THEN (done_tac));
];;

(* Lemma uniq_catC *)
let uniq_catC = section_proof ["s1";"s2"] `uniq (s1 ++ s2) = uniq (s2 ++ s1)` [
   (((repeat_tactic 1 9 (((use_arg_then "cat_uniq")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_sym")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbCA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma uniq_catCA *)
let uniq_catCA = section_proof ["s1";"s2";"s3"] `uniq (s1 ++ s2 ++ s3) = uniq (s2 ++ s1 ++ s3)` [
   (repeat_tactic 1 9 (((use_arg_then "catA")(thm_tac (new_rewrite [] [])))));
   (((repeat_tactic 1 9 (((use_arg_then "uniq_catC")(gsym_then (thm_tac (new_rewrite [] [(`uniq (cat _ s3)`)])))))) THEN (repeat_tactic 1 9 (((use_arg_then "cat_uniq")(thm_tac (new_rewrite [] [(`uniq (cat s3 _)`)]))))) THEN (((use_arg_then "uniq_catC")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "has_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "orbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rcons_uniq *)
let rcons_uniq = section_proof ["s";"x"] `uniq (rcons s x) <=> (~(x <- s) /\ uniq s)` [
   (((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "uniq_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat0s")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma filter_uniq *)
let filter_uniq = section_proof ["s";"a"] `uniq s ==> uniq (filter a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((THENL_ROT (-1)) (((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (simp_tac)); (move ["nax"])]) THEN (BETA_TAC THEN (case THEN ((move ["Hx"]) THEN (move ["Hs"]))))));
   (((((use_arg_then "nax")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN (exact_tac)) THEN (done_tac));
   ((((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then "mem_filter")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then "negbTE") (fun fst_arg -> (use_arg_then "Hx") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbF")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rot_uniq *)
let rot_uniq = section_proof ["s"] `uniq (rot n0 s) = uniq s` [
   (((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "uniq_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rev_uniq *)
let rev_uniq = section_proof ["s"] `uniq (rev s) = uniq s` [
   ((THENL_FIRST) ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) (((((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (done_tac)));
   (((((use_arg_then "rev_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "cat_uniq")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "nil_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_or")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_rev")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma count_uniq_mem *)
let count_uniq_mem = section_proof ["s";"x"] `uniq s ==> count (pred1 x) s = if (x <- s) then 1 else 0` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   ((((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["Hy"]))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`y = x`)])))));
   (((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (simp_tac)); ALL_TAC]) THEN ((((use_arg_then "Hy")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "addn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((use_arg_then "add0n")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;
let undup = define `undup [] = [] /\ 
	undup (x :: s') = if x <- s' then undup s' else x :: undup s'`;;

(* Lemma size_undup *)
let size_undup = section_proof ["s"] `sizel (undup s) <= sizel s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "undup")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "leqnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x <- s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltnW")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_undup *)
let mem_undup = section_proof ["s"] `!x. x <- undup s <=> x <- s` [
   ((BETA_TAC THEN (move ["x"])) THEN ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "undup")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y <- s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["Hy"])) THEN ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "MEM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma undup_uniq *)
let undup_uniq = section_proof ["s"] `uniq (undup s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "undup")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x <- s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) THEN (((simp_tac THEN TRY done_tac)) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_undup")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma undup_id *)
let undup_id = section_proof ["s"] `uniq s ==> undup s = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((((use_arg_then "undup")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((simp_tac THEN TRY done_tac))) THEN ALL_TAC THEN (case THEN ((move ["Hx"]) THEN (move ["Hs"])))));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma ltn_size_undup *)
let ltn_size_undup = section_proof ["s"] `(sizel (undup s) < sizel s) <=> ~ uniq s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "undup")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x <- s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) THEN (((simp_tac THEN TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_undup")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let index = new_definition `indexl x = find (pred1 x)`;;

(* Lemma index_size *)
let index_size = section_proof ["x";"s"] `indexl x s <= sizel s` [
   (((((use_arg_then "index")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "find_size")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma index_mem *)
let index_mem = section_proof ["x";"s"] `(indexl x s < sizel s) <=> (x <- s)` [
   (((((use_arg_then "has_pred1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "index")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_find")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_index *)
let nth_index = section_proof ["x";"s"] `x <- s ==> nth x0 s (indexl x s) = x` [
   ((((use_arg_then "has_pred1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (fun arg_tac -> (use_arg_then "nth_find") (fun fst_arg -> (use_arg_then "x0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN ((((use_arg_then "index")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma index_cat *)
let index_cat = section_proof ["x";"s1";"s2"] `indexl x (s1 ++ s2) = if x <- s1 then indexl x s1 else sizel s1 + indexl x s2` [
   (((((use_arg_then "index")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "find_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_pred1")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma index_uniq *)
let index_uniq = section_proof ["i";"s"] `i < sizel s ==> uniq s ==> indexl (nth x0 s i) s = i` [
   (((THENL) (((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN ((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]));
   (((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "index")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] []))))) THEN (move ["lt_i_s"]) THEN (case THEN (move ["not_s_x"])));
   (((DISCH_THEN (fun snd_th -> (fun arg_tac -> (fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "lt_i_s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "index")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (simp_tac)));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = nth x0 s i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["x_eq"]));
   (((fun arg_tac -> (use_arg_then "mem_nth") (fun fst_arg -> (use_arg_then "lt_i_s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then "x_eq")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "negbTE") (fun fst_arg -> (use_arg_then "not_s_x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma index_head *)
let index_head = section_proof ["x";"s"] `indexl x (x :: s) = 0` [
   (((((use_arg_then "index")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma index_last *)
let index_last = section_proof ["x";"s"] `uniq (x :: s) ==> indexl (last x s) (x :: s) = sizel s` [
   ((((use_arg_then "lastI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rcons_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "index_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_belast")(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`last x s <- belast x s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac));
   (((((use_arg_then "index")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "addn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_uniq *)
let nth_uniq = section_proof ["s";"i";"j"] `i < sizel s ==> j < sizel s ==> uniq s ==> (nth x0 s i = nth x0 s j) = (i = j)` [
   ((BETA_TAC THEN (move ["lt_i_s"]) THEN (move ["lt_j_s"]) THEN (move ["Us"])) THEN ((THENL) (split_tac) [(move ["eq_sij"]); ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))]));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then "index_uniq") (fun fst_arg -> (use_arg_then "lt_i_s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "Us") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "eq_sij")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "index_uniq")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_rot *)
let mem_rot = section_proof ["s"] `!x. x <- rot n0 s <=> x <- s` [
   ((BETA_TAC THEN (move ["x"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [2] [(`s`)]))))) THEN (((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "orbC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eqseq_rot *)
let eqseq_rot = section_proof ["s1";"s2"] `(rot n0 s1 = rot n0 s2) <=> (s1 = s2)` [
   (((THENL) (split_tac) [ALL_TAC; ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))]) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "rot_inj") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma rot_to *)
let rot_to = section_proof ["s";"x"] `x <- s ==> ?i s'. rot i s = x :: s'` [
   ((BETA_TAC THEN (move ["s_x"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`indexl (x:A) s`))) (term_tac (set_tac "i"))));
   (((use_arg_then "i") (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`dropl (SUC i) s ++ take i s`))) (term_tac exists_tac)));
   (((((use_arg_then "cat_cons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "i_def")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((fun arg_tac -> arg_tac (Arg_term (`take _1 _2`))) (term_tac (set_tac "r"))));
   (((use_arg_then "r_def") (disch_tac [])) THEN (clear_assumption "r_def") THEN ((use_arg_then "i_def") (disch_tac [])) THEN (clear_assumption "i_def") THEN BETA_TAC THEN (move ["_"]) THEN (move ["_"]));
   (((THENL) (((use_arg_then "s_x") (disch_tac [])) THEN (clear_assumption "s_x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((repeat_tactic 0 10 (((use_arg_then "in_nil")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)));
   ((((use_arg_then "index_head")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "drop0")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((((use_arg_then "index")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "pred1")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "index")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "drop_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (move ["_"])) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section EqSeq *)
let eqseq_cons = finalize_theorem eqseq_cons;;
let eqseq_cat = finalize_theorem eqseq_cat;;
let eqseq_rcons = finalize_theorem eqseq_rcons;;
let has_filter = finalize_theorem has_filter;;
let size_eq0 = finalize_theorem size_eq0;;
let in_cons = finalize_theorem in_cons;;
let in_nil = finalize_theorem in_nil;;
let mem_seq1 = finalize_theorem mem_seq1;;
let mem_seq2 = finalize_theorem mem_seq2;;
let mem_seq3 = finalize_theorem mem_seq3;;
let mem_seq4 = finalize_theorem mem_seq4;;
let mem_cat = finalize_theorem mem_cat;;
let mem_rcons = finalize_theorem mem_rcons;;
let mem_head = finalize_theorem mem_head;;
let mem_last = finalize_theorem mem_last;;
let mem_behead = finalize_theorem mem_behead;;
let mem_belast = finalize_theorem mem_belast;;
let mem_nth = finalize_theorem mem_nth;;
let mem_take = finalize_theorem mem_take;;
let mem_drop = finalize_theorem mem_drop;;
let mem_rev = finalize_theorem mem_rev;;
let hasP = finalize_theorem hasP;;
let hasPn = finalize_theorem hasPn;;
let allP = finalize_theorem allP;;
let allPn = finalize_theorem allPn;;
let mem_filter = finalize_theorem mem_filter;;
let eq_in_filter = finalize_theorem eq_in_filter;;
let eq_has_r = finalize_theorem eq_has_r;;
let eq_all_r = finalize_theorem eq_all_r;;
let has_sym = finalize_theorem has_sym;;
let has_pred1 = finalize_theorem has_pred1;;
let all_pred1P = finalize_theorem all_pred1P;;
let all_pred1_constant = finalize_theorem all_pred1_constant;;
let all_pred1_nseq = finalize_theorem all_pred1_nseq;;
let constant_nseq = finalize_theorem constant_nseq;;
let constantP = finalize_theorem constantP;;
let nil_uniq = finalize_theorem nil_uniq;;
let cons_uniq = finalize_theorem cons_uniq;;
let cat_uniq = finalize_theorem cat_uniq;;
let uniq_catC = finalize_theorem uniq_catC;;
let uniq_catCA = finalize_theorem uniq_catCA;;
let rcons_uniq = finalize_theorem rcons_uniq;;
let filter_uniq = finalize_theorem filter_uniq;;
let rot_uniq = finalize_theorem rot_uniq;;
let rev_uniq = finalize_theorem rev_uniq;;
let count_uniq_mem = finalize_theorem count_uniq_mem;;
let size_undup = finalize_theorem size_undup;;
let mem_undup = finalize_theorem mem_undup;;
let undup_uniq = finalize_theorem undup_uniq;;
let undup_id = finalize_theorem undup_id;;
let ltn_size_undup = finalize_theorem ltn_size_undup;;
let index_size = finalize_theorem index_size;;
let index_mem = finalize_theorem index_mem;;
let nth_index = finalize_theorem nth_index;;
let index_cat = finalize_theorem index_cat;;
let index_uniq = finalize_theorem index_uniq;;
let index_head = finalize_theorem index_head;;
let index_last = finalize_theorem index_last;;
let nth_uniq = finalize_theorem nth_uniq;;
let mem_rot = finalize_theorem mem_rot;;
let eqseq_rot = finalize_theorem eqseq_rot;;
let rot_to = finalize_theorem rot_to;;
end_section "EqSeq";;

(* Section NseqthTheory *)
begin_section "NseqthTheory";;
(add_section_type (mk_var ("s", (`:(A)list`))));;

(* Lemma nthP *)
let nthP = section_proof ["s";"x";"x0"] `(?i. i < sizel s /\ nth x0 s i = x) <=> (x <- s)` [
   ((THENL_FIRST) ((THENL) (split_tac) [(case THEN ((move ["n"]) THEN (case THEN ((move ["Hn"]) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))))))); (move ["Hx"])]) ((((use_arg_then "mem_nth") (disch_tac [])) THEN (clear_assumption "mem_nth") THEN (DISCH_THEN apply_tac)) THEN (done_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`indexl x s`))) (term_tac exists_tac)) THEN ((((use_arg_then "index_mem")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hx")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andTb")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nth_index") (disch_tac [])) THEN (clear_assumption "nth_index") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma has_nthP *)
let has_nthP = section_proof ["a";"s";"x0"] `(?i. i < sizel s /\ a (nth x0 s i)) <=> (has a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "andFb")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ax"]));
   (((fun arg_tac -> arg_tac (Arg_term (`0`))) (term_tac exists_tac)) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0Sn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((THENL_ROT (-1)) ((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [(case THEN ALL_TAC); (case THEN (move ["i"]))])));
   ((BETA_TAC THEN (case THEN ((move ["i_s"]) THEN (move ["anth"])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`SUC i`))) (term_tac exists_tac)) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltSS")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((THENL_FIRST) (((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) ((((use_arg_then "ax")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac)));
   ((((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ((move ["i_s"]) THEN (move ["anth"])))) THEN ((use_arg_then "i") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma all_nthP *)
let all_nthP = section_proof ["a";"s";"x0"] `(!i. i < sizel s ==> a (nth x0 s i)) <=> (all a s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ax"])));
   ((((use_arg_then "NOT_FORALL_THM")(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`0`))) (term_tac exists_tac)) THEN ((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltn0Sn")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN (move ["IH"]) THEN (move ["i"]) THEN (move ["i_s"])));
   ((((fun arg_tac -> (use_arg_then "IH") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`SUC i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (exact_tac) THEN (done_tac));
   (((THENL) (((use_arg_then "i_s") (disch_tac [])) THEN (clear_assumption "i_s") THEN ((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN elim) [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IH") (disch_tac [])) THEN (clear_assumption "IH") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Finalization of the section NseqthTheory *)
let nthP = finalize_theorem nthP;;
let has_nthP = finalize_theorem has_nthP;;
let all_nthP = finalize_theorem all_nthP;;
end_section "NseqthTheory";;

(* Lemma set_nth_default *)
let set_nth_default = section_proof ["s";"y0";"x0";"n"] `n < sizel s ==> nth (x0:A) s n = nth y0 s n` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s'"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (done_tac));
];;

(* Lemma headI *)
let headI = section_proof ["s";"x"] `rcons s x = headl x s :: behead (rcons s (x:A))` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["s"]) THEN (move ["x"]) THEN (move ["_"]))]) THEN ((((use_arg_then "rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "head")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;
let incr_nth = define `incr_nth (n :: v') (SUC i) = n :: incr_nth v' i /\
	incr_nth (n :: v') 0 = SUC n :: v' /\
	incr_nth [] i = ncons i 0 [1]`;;

(* Lemma nth_incr_nth *)
let nth_incr_nth = section_proof ["v";"i";"j"] `nth 0 (incr_nth v i) j = (if (i = j) then 1 else 0) + nth 0 v j` [
   (((THENL) (((use_arg_then "j") (disch_tac [])) THEN (clear_assumption "j") THEN ((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "v") (disch_tac [])) THEN (clear_assumption "v") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["v"]) THEN (move ["IHv"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["j"]) THEN (move ["_"]))]) THEN ((((use_arg_then "incr_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "addn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "eqS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add1n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (arith_tac);
   (((THENL) (((use_arg_then "j") (disch_tac [])) THEN (clear_assumption "j") THEN ((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN elim) [ALL_TAC; ((move ["i"]) THEN (move ["IHv"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["j"]) THEN (move ["_"]))]) THEN ((((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   (arith_tac);
   (arith_tac);
   (((((use_arg_then "IHv")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`0 = SUC j`)])))) THEN (((use_arg_then "eqS0")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "add0n")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then "IHv")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_incr_nth *)
let size_incr_nth = section_proof ["v";"i"] `sizel (incr_nth v i) = if i < sizel v then sizel v else SUC i` [
   (((THENL) (((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "v") (disch_tac [])) THEN (clear_assumption "v") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["v"]) THEN (move ["IHv"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN ((((use_arg_then "incr_nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "ONE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "addn1")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then "ltn0Sn")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then "IHv")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] [])))));
   (((use_arg_then "fun_if") (thm_tac apply_tac)) THEN (done_tac));
];;

(* Section PermSeq *)
begin_section "PermSeq";;
(add_section_type (mk_var ("s", (`:(A)list`))); add_section_type (mk_var ("s1", (`:(A)list`))));;
let same_count1 = new_definition `same_count1 s1 s2 x <=> (count (pred1 x) s1 = count (pred1 x) s2)`;;
let perm_eq = new_definition `perm_eq s1 s2 = all (same_count1 s1 s2) (s1 ++ s2)`;;

(* Lemma perm_eqP *)
let perm_eqP = section_proof ["s1";"s2"] `perm_eq s1 s2 <=> (!a. count a s1 = count a s2)` [
   ((THENL_LAST) (((((use_arg_then "perm_eq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "allP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "same_count1")(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [((move ["eq_cnt1"]) THEN (move ["a"])); ((move ["eq_cnt"]) THEN (move ["x"]) THEN (move ["_"]))])) (exact_tac));
   ((((fun arg_tac -> (use_arg_then "ltnSn") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`count a (s1 ++ s2)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN ((use_arg_then "a") (disch_tac [1; 3; 4])) THEN (clear_assumption "a") THEN ((fun arg_tac -> arg_tac (Arg_term (`SUC _`))) (disch_tac [])) THEN elim) THEN (((repeat_tactic 0 10 (((use_arg_then "ltn0")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (move ["n"]) THEN (move ["IHn"]) THEN (move ["a"]) THEN (move ["le_an"])));
   (((fun arg_tac -> (use_arg_then "posnP") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`count a (s1 ++ s2)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case);
   ((((((use_arg_then "count_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addn_eq0")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((((use_arg_then "has_count")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "hasP")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN (move ["x"])) THEN (case THEN ((move ["s12x"]) THEN (move ["a_x"])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`predD1 a x`))) (term_tac (set_tac "a'"))));
   ((fun arg_tac -> arg_tac (Arg_term (`!s. count a s = count (pred1 x) s + count a' s`))) (term_tac (have_gen_tac [](move ["cnt_a'"]))));
   (BETA_TAC THEN (move ["s"]));
   ((((use_arg_then "count_filter")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then "count_predC") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`pred1 x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 2 0 (((use_arg_then "count_filter")(thm_tac (new_rewrite [] []))))));
   ((repeat_tactic 1 9 (((use_arg_then "filter_predI")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then "count_filter")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "predC")(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`predI (\x'. ~pred1 x x') a = predD1 a x`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then "predI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predD1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "predD")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then "a'_def")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqn_addr")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "eq_count") (disch_tac [])) THEN (clear_assumption "eq_count") THEN (DISCH_THEN apply_tac) THEN (move ["y"])) THEN ((((use_arg_then "predI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((THENL) (split_tac) [(case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))); (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))]) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then "cnt_a'")(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "eq_cnt1") (fun fst_arg -> (use_arg_then "s12x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then "IHn") (fun fst_arg -> (use_arg_then "a'") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnS")(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then "le_an") (disch_tac [])) THEN (clear_assumption "le_an") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leq_trans") (disch_tac [])) THEN (clear_assumption "leq_trans") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cnt_a'")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "add1n")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leq_add2r")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ONE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_count")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "has_pred1")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_eq_refl *)
let perm_eq_refl = section_proof ["s"] `perm_eq s s` [
   ((((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma perm_eq_sym *)
let perm_eq_sym = section_proof [] `!s1 s2. perm_eq s1 s2 = perm_eq s2 s1` [
   ((BETA_TAC THEN (move ["s1"]) THEN (move ["s2"])) THEN ((repeat_tactic 1 9 (((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`!a. _ a`)]))))) THEN (done_tac));
];;

(* Lemma perm_eq_trans *)
let perm_eq_trans = section_proof [] `!s2 s1 s3. perm_eq s1 s2 ==> perm_eq s2 s3 ==> perm_eq s1 s3` [
   ((BETA_TAC THEN (move ["s2"]) THEN (move ["s1"]) THEN (move ["s3"])) THEN ((repeat_tactic 1 9 (((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] []))))) THEN (move ["eq12"]) THEN (move ["eq23"]) THEN (move ["a"])));
   (((((use_arg_then "eq12")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eq23")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_eqlP *)
let perm_eqlP = section_proof ["s1";"s2"] `perm_eq s1 s2 <=> (!s. perm_eq s1 s = perm_eq s2 s)` [
   ((THENL_LAST) ((THENL) (split_tac) [((move ["eq12"]) THEN (move ["s3"])); (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))]) ((((use_arg_then "perm_eq_refl")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((THENL_LAST) (split_tac) (((use_arg_then "perm_eq_trans") (disch_tac [])) THEN (clear_assumption "perm_eq_trans") THEN (exact_tac)));
   ((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then "perm_eq_sym") (fun fst_arg -> (use_arg_then "s3") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [(`perm_eq _ s3`)])))))) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "perm_eq_trans") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN (DISCH_THEN apply_tac) THEN (done_tac));
];;

(* Lemma perm_eqrP *)
let perm_eqrP = section_proof ["s1";"s2"] `perm_eq s1 s2 <=> (!s. perm_eq s s1 = perm_eq s s2)` [
   ((THENL_LAST) ((THENL) (split_tac) [ALL_TAC; (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))]) ((((use_arg_then "perm_eq_refl")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then "perm_eqlP")(thm_tac (new_rewrite [] [])))) THEN (move ["eq12"]) THEN (move ["s3"]));
   (((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then "perm_eq_sym") (fun fst_arg -> (use_arg_then "s3") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [(`perm_eq s3 _`)]))))) THEN (((use_arg_then "eq12")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_catC *)
let perm_catC = section_proof ["s1";"s2"] `!s. perm_eq (s1 ++ s2) s = perm_eq (s2 ++ s1) s` [
   ((((((use_arg_then "perm_eqlP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] []))))) THEN (move ["a"])) THEN ((repeat_tactic 1 9 (((use_arg_then "count_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "addnC")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_cat2l *)
let perm_cat2l = section_proof ["s1";"s2";"s3"] `perm_eq (s1 ++ s2) (s1 ++ s3) = perm_eq s2 s3` [
   ((repeat_tactic 1 9 (((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN (move ["eq23"]) THEN (move ["a"])));
   ((((fun arg_tac -> (use_arg_then "eq23") (fun fst_arg -> (use_arg_then "a") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "count_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "eqn_addl")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then "eq23") (fun fst_arg -> (use_arg_then "a") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "count_cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "eqn_addl")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_cons *)
let perm_cons = section_proof ["x";"s1";"s2"] `perm_eq (x :: s1) (x :: s2) = perm_eq s1 s2` [
   ((((fun arg_tac -> (use_arg_then "perm_cat2l") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`[x]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then "cat_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "cat0s")(thm_tac (new_rewrite [] [])))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_cat2r *)
let perm_cat2r = section_proof ["s1";"s2";"s3"] `perm_eq (s2 ++ s1) (s3 ++ s1) = perm_eq s2 s3` [
   ((repeat_tactic 2 0 (((((use_arg_then "perm_eq_sym")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_catC")(thm_tac (new_rewrite [] []))))))) THEN (((use_arg_then "perm_cat2l")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma perm_catAC *)
let perm_catAC = section_proof ["s1";"s2";"s3"] `!s. perm_eq ((s1 ++ s2) ++ s3) s = perm_eq ((s1 ++ s3) ++ s2) s` [
   (((((use_arg_then "perm_eqlP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "catA")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "perm_cat2l")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_eq_refl")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_catCA *)
let perm_catCA = section_proof ["s1";"s2";"s3"] `!s. perm_eq (s1 ++ s2 ++ s3) s = perm_eq (s2 ++ s1 ++ s3) s` [
   (((((use_arg_then "perm_eqlP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "catA")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "perm_cat2r")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_eq_refl")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_rcons *)
let perm_rcons = section_proof ["x";"s"] `!s2. perm_eq (rcons s x) s2 = perm_eq (x :: s) s2` [
   ((BETA_TAC THEN (move ["s2"])) THEN ((((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "perm_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat1s")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_rot *)
let perm_rot = section_proof ["n";"s"] `!s2. perm_eq (rot n s) s2 = perm_eq s s2` [
   ((BETA_TAC THEN (move ["s2"])) THEN ((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_catC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_rotr *)
let perm_rotr = section_proof ["n";"s"] `!s2. perm_eq (rotr n s) s2 = perm_eq s s2` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_filterC *)
let perm_filterC = section_proof ["a";"s"] `!s2. perm_eq (filter a s ++ filter (predC a) s) s2 = perm_eq s s2` [
   ((((use_arg_then "perm_eqlP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "perm_eq_refl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((use_arg_then "predC")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "predC")(gsym_then (thm_tac (new_rewrite [] []))))));
   (((THENL_LAST) (((fun arg_tac -> arg_tac (Arg_term (`a x`))) (disch_tac [])) THEN case THEN (simp_tac)) ((((use_arg_then "cat1s")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "perm_catCA")(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 1 9 (((use_arg_then "cat")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "perm_cons")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma perm_eq_mem *)
let perm_eq_mem = section_proof ["s1";"s2"] `perm_eq s1 s2 ==> (!x. x <- s1 <=> x <- s2)` [
   (((((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] [])))) THEN (move ["eq12"]) THEN (move ["x"])) THEN ((repeat_tactic 1 9 (((use_arg_then "has_pred1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then "has_count")(thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then "eq12")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma perm_eq_size *)
let perm_eq_size = section_proof ["s1";"s2"] `perm_eq s1 s2 ==> sizel s1 = sizel s2` [
   ((((use_arg_then "perm_eqP")(thm_tac (new_rewrite [] [])))) THEN (move ["eq12"]));
   (((repeat_tactic 1 9 (((use_arg_then "count_predT")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "eq12")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma uniq_leq_size *)
let uniq_leq_size = section_proof ["s1";"s2"] `uniq s1 ==> (!x. x <- s1 ==> x <- s2) ==> sizel s1 <= sizel s2` [
   ((THENL) ((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) [(((((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq0n")(thm_tac (new_rewrite [] []))))) THEN (done_tac)); ((((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (move ["_"]) THEN (case THEN ((move ["Hx"]) THEN (move ["Hs1"]) THEN (move ["Hs12"]))))]);
   ((((fun arg_tac -> (use_arg_then "Hs12") (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then "mem_head")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["Hxs2"])));
   (((fun arg_tac -> (use_arg_then "rot_to") (fun fst_arg -> (use_arg_then "Hxs2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["i"])) THEN (case THEN ((move ["s2'"]) THEN (move ["Ds2'"]))));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then "size_rot") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [(`sizel s2`)]))))) THEN (((use_arg_then "Ds2'")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hs1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andTb")(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["Hy"]));
   ((((fun arg_tac -> (use_arg_then "Hs12") (fun fst_arg -> (use_arg_then "y") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hy")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((fun arg_tac -> (use_arg_then "mem_rot") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Ds2'")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))));
   ((case THEN ((TRY done_tac)) THEN (move ["yx"])) THEN (((use_arg_then "Hy") (disch_tac [])) THEN (clear_assumption "Hy") THEN ((use_arg_then "Hx") (disch_tac [])) THEN (clear_assumption "Hx") THEN BETA_TAC));
   (((((use_arg_then "yx")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma leq_size_uniq *)
let leq_size_uniq = section_proof ["s1";"s2"] `uniq s1 ==> (!x. x <- s1 ==> x <- s2) ==> sizel s2 <= sizel s1 ==> uniq s2` [
   ((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [((move ["s2"]) THEN (move ["Hs1"]) THEN (move ["Hs12"])); ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]) THEN (move ["s2"]) THEN (move ["Hs1"]) THEN (move ["Hs12"]))]);
   (((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((repeat_tactic 0 10 (((use_arg_then "nil_uniq")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_nil")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltn0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then "Hs12") (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then "mem_head")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["Hxs2"])));
   (((fun arg_tac -> (use_arg_then "rot_to") (fun fst_arg -> (use_arg_then "Hxs2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["i"])) THEN (case THEN ((move ["s2'"]) THEN (move ["Ds2'"]))));
   (((((fun arg_tac -> (use_arg_then "size_rot") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "rot_uniq") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Ds2'")(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x <- s2'`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["Hs2'"])));
   ((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hs2'")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((fun arg_tac -> (use_arg_then "size_cons") (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((fun arg_tac -> (use_arg_then "uniq_leq_size") (fun fst_arg -> (use_arg_then "Hs1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac) THEN ((move ["y"]) THEN (move ["Hy"])));
   ((((fun arg_tac -> (use_arg_then "Hs12") (fun fst_arg -> (use_arg_then "Hy") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then "mem_rot") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Ds2'")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (case THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then "Hs1") (disch_tac [])) THEN (clear_assumption "Hs1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ((move ["Hx"]) THEN (move ["Hs1"])))) THEN ((((use_arg_then "Hs2'")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "leqSS")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "Hs1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac) THEN ((move ["y"]) THEN (move ["Hy"])));
   (((fun arg_tac -> (use_arg_then "Hs12") (fun fst_arg -> (use_arg_then "y") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hy")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((fun arg_tac -> (use_arg_then "mem_rot") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Ds2'")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (case THEN ((TRY done_tac)) THEN (move ["yx"])));
   ((((use_arg_then "Hx") (disch_tac [])) THEN (clear_assumption "Hx") THEN ((use_arg_then "Hy") (disch_tac [])) THEN (clear_assumption "Hy") THEN BETA_TAC) THEN ((((use_arg_then "yx")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma uniq_size_uniq *)
let uniq_size_uniq = section_proof ["s1";"s2"] `uniq s1 ==> (!x. x <- s1 <=> x <- s2) ==> (uniq s2 = (sizel s2 = sizel s1))` [
   (BETA_TAC THEN (move ["Us1"]) THEN (move ["Es12"]));
   ((((use_arg_then "eqn_leq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbC")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "uniq_leq_size")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "Us1")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "Es12")(thm_tac (new_rewrite [] []))))) THEN ((simp_tac THEN TRY done_tac)));
   ((THENL_FIRST) ((THENL) (split_tac) [(move ["Hs2"]); ALL_TAC]) (((((use_arg_then "uniq_leq_size")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Es12")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac)));
   ((((use_arg_then "leq_size_uniq") (disch_tac [])) THEN (clear_assumption "leq_size_uniq") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then "Us1")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Es12")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma leq_size_perm *)
let leq_size_perm = section_proof ["s1";"s2"] `uniq s1 ==> (!x. x <- s1 ==> x <- s2) ==> sizel s2 <= sizel s1 ==>
  (!x. x <- s1 <=> x <- s2) /\ sizel s1 = sizel s2` [
   ((BETA_TAC THEN (move ["Us1"]) THEN (move ["Hs1"]) THEN (move ["Hs12"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`uniq s2`))) (term_tac (have_gen_tac [](move ["Us2"])))));
   ((((fun arg_tac -> (use_arg_then "leq_size_uniq") (fun fst_arg -> (use_arg_then "Us1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`!x. x <- s1 <=> x <- s2`))) (term_tac (have_gen_tac []ALL_TAC))));
   ((BETA_TAC THEN (move ["h"])) THEN ((split_tac) THEN ((TRY done_tac))) THEN (((use_arg_then "uniq_size_uniq")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (BETA_TAC THEN (move ["x"]));
   ((THENL) ((THENL) (split_tac) [ALL_TAC; (move ["Hxs2"])]) [((((use_arg_then "Hs1") (disch_tac [])) THEN (clear_assumption "Hs1") THEN (DISCH_THEN apply_tac)) THEN (done_tac)); (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x <- s1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN ((TRY done_tac)) THEN (move ["Hxs1"]))]);
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`sizel (x :: s1) <= sizel s2`))) (term_tac (have_gen_tac []ALL_TAC))));
   (((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hs12")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then "uniq_leq_size") (disch_tac [])) THEN (clear_assumption "uniq_leq_size") THEN (DISCH_THEN apply_tac)) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN ((THENL) case [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))); (move ["Hy"])]) THEN (((use_arg_then "Hs1") (disch_tac [])) THEN (clear_assumption "Hs1") THEN (exact_tac)));
];;

(* Lemma perm_uniq *)
let perm_uniq = section_proof ["s1";"s2"] `(!x. x <- s1 <=> x <- s2) ==> 
	sizel s1 = sizel s2 ==> uniq s1 = uniq s2` [
   ((BETA_TAC THEN (move ["Es12"]) THEN (move ["Hs12"])) THEN ((split_tac) THEN (move ["Us"])));
   (((((fun arg_tac -> (use_arg_then "uniq_size_uniq") (fun fst_arg -> (use_arg_then "Us") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "Hs12")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((((fun arg_tac -> (use_arg_then "uniq_size_uniq") (fun fst_arg -> (use_arg_then "Us") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "Hs12")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma perm_eq_uniq *)
let perm_eq_uniq = section_proof ["s1";"s2"] `perm_eq s1 s2 ==> uniq s1 = uniq s2` [
   (((THENL) ((BETA_TAC THEN (move ["eq_s12"])) THEN (((use_arg_then "perm_uniq") (disch_tac [])) THEN (clear_assumption "perm_uniq") THEN (DISCH_THEN apply_tac)) THEN (split_tac)) [(((use_arg_then "perm_eq_mem") (disch_tac [])) THEN (clear_assumption "perm_eq_mem") THEN (exact_tac)); (((use_arg_then "perm_eq_size") (disch_tac [])) THEN (clear_assumption "perm_eq_size") THEN (exact_tac))]) THEN (done_tac));
];;

(* Lemma uniq_perm_eq *)
let uniq_perm_eq = section_proof ["s1";"s2"] `uniq s1 ==> uniq s2 ==> 
	(!x. x <- s1 <=> x <- s2) ==> perm_eq s1 s2` [
   ((BETA_TAC THEN (move ["Us1"]) THEN (move ["Us2"]) THEN (move ["eq12"])) THEN (((((use_arg_then "perm_eq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "allP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "same_count1")(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then "count_uniq_mem")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "eq12")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma count_mem_uniq *)
let count_mem_uniq = section_proof ["s"] `(!x. count (pred1 x) s = if (x <- s) then 1 else 0) ==> uniq s` [
   ((BETA_TAC THEN (move ["count1_s"])) THEN ((fun arg_tac -> (use_arg_then "undup_uniq") (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["Uus"]))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`perm_eq s (undup s)`))) (term_tac (have_gen_tac []ALL_TAC)))) (((DISCH_THEN (fun snd_th -> (use_arg_then "perm_eq_uniq") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then "perm_eq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "allP")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "same_count1")(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["_"]));
   (((((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then "count_uniq_mem") (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "Uus") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_undup")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section PermSeq *)
let perm_eqP = finalize_theorem perm_eqP;;
let perm_eq_refl = finalize_theorem perm_eq_refl;;
let perm_eq_sym = finalize_theorem perm_eq_sym;;
let perm_eq_trans = finalize_theorem perm_eq_trans;;
let perm_eqlP = finalize_theorem perm_eqlP;;
let perm_eqrP = finalize_theorem perm_eqrP;;
let perm_catC = finalize_theorem perm_catC;;
let perm_cat2l = finalize_theorem perm_cat2l;;
let perm_cons = finalize_theorem perm_cons;;
let perm_cat2r = finalize_theorem perm_cat2r;;
let perm_catAC = finalize_theorem perm_catAC;;
let perm_catCA = finalize_theorem perm_catCA;;
let perm_rcons = finalize_theorem perm_rcons;;
let perm_rot = finalize_theorem perm_rot;;
let perm_rotr = finalize_theorem perm_rotr;;
let perm_filterC = finalize_theorem perm_filterC;;
let perm_eq_mem = finalize_theorem perm_eq_mem;;
let perm_eq_size = finalize_theorem perm_eq_size;;
let uniq_leq_size = finalize_theorem uniq_leq_size;;
let leq_size_uniq = finalize_theorem leq_size_uniq;;
let uniq_size_uniq = finalize_theorem uniq_size_uniq;;
let leq_size_perm = finalize_theorem leq_size_perm;;
let perm_uniq = finalize_theorem perm_uniq;;
let perm_eq_uniq = finalize_theorem perm_eq_uniq;;
let uniq_perm_eq = finalize_theorem uniq_perm_eq;;
let count_mem_uniq = finalize_theorem count_mem_uniq;;
end_section "PermSeq";;

(* Section RotrLemmas *)
begin_section "RotrLemmas";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;

(* Lemma size_rotr *)
let size_rotr = section_proof ["s"] `sizel (rotr n0 s) = sizel s` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mem_rotr *)
let mem_rotr = section_proof ["s"] `!x. x <- rotr n0 s <=> x <- s` [
   ((BETA_TAC THEN (move ["x"])) THEN ((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mem_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rotr_size_cat *)
let rotr_size_cat = section_proof ["s1";"s2"] `rotr (sizel s2) (s1 ++ s2) = s2 ++ s1` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addnK")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_size_cat")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rotr1_rcons *)
let rotr1_rcons = section_proof ["x";"s"] `rotr 1 (rcons s x) = x :: s` [
   (((((use_arg_then "rot1_cons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rotK")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_rotr *)
let has_rotr = section_proof ["a";"s"] `has a (rotr n0 s) = has a s` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "has_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rotr_uniq *)
let rotr_uniq = section_proof ["s"] `uniq (rotr n0 s) = uniq s` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_uniq")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rotrK *)
let rotrK = section_proof [] `!s. rot n0 (rotr n0 s) = s` [
   (BETA_TAC THEN (move ["s"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then "ltnP") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ((THENL) case [(move ["lt_n0s"]); (move ["ge_n0s"])])));
   (((((fun arg_tac -> (use_arg_then "subKn") (fun fst_arg -> (fun arg_tac -> (use_arg_then "ltnW") (fun fst_arg -> (use_arg_then "lt_n0s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then "size_rotr")(gsym_then (thm_tac (new_rewrite [1] [(`sizel s`)]))))) THEN (((use_arg_then "rotr")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rotr")(thm_tac (new_rewrite [] [(`rotr n0 _`)])))) THEN (((use_arg_then "rotK")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then "rot_oversize") (fun fst_arg -> (use_arg_then "ge_n0s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [2] []))))) THEN (((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "subn_eq0") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then "ge_n0s")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "rot0")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rotr_inj *)
let rotr_inj = section_proof ["s1";"s2"] `rotr n0 (s1:(A)list) = rotr n0 s2 ==> s1 = s2` [
   (BETA_TAC THEN (move ["h"]));
   (((((use_arg_then "rotrK")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "h")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rotrK")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rev_rot *)
let rev_rot = section_proof ["s"] `rev (rot n0 s) = rotr n0 (rev s)` [
   ((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rev")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [3] [(`s`)]))))) THEN (((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "rev_cat")(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then "size_drop")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_rev")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rot_size_cat")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma rev_rotr *)
let rev_rotr = section_proof ["s"] `rev (rotr n0 s) = rot n0 (rev s)` [
   (((((use_arg_then "rotrK")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rotrK")(gsym_then (thm_tac (new_rewrite [] [(`rot n0 (rev s)`)])))))) THEN (AP_TERM_TAC) THEN (((use_arg_then "rotK")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rev")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "rot")(thm_tac (new_rewrite [] [(`rot _ s`)])))) THEN (((use_arg_then "rev_cat")(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`sizel s - n0`))) (term_tac (set_tac "m")));
   ((THENL_ROT (-1)) (((fun arg_tac -> (fun arg_tac -> (use_arg_then "size_takel") (fun fst_arg -> (use_arg_then "m") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))));
   (((((use_arg_then "size_rev")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rot_size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rev_cat")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then "m_def")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leq_subr")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section RotrLemmas *)
let size_rotr = finalize_theorem size_rotr;;
let mem_rotr = finalize_theorem mem_rotr;;
let rotr_size_cat = finalize_theorem rotr_size_cat;;
let rotr1_rcons = finalize_theorem rotr1_rcons;;
let has_rotr = finalize_theorem has_rotr;;
let rotr_uniq = finalize_theorem rotr_uniq;;
let rotrK = finalize_theorem rotrK;;
let rotr_inj = finalize_theorem rotr_inj;;
let rev_rot = finalize_theorem rev_rot;;
let rev_rotr = finalize_theorem rev_rotr;;
end_section "RotrLemmas";;

(* Section RotCompLemmas *)
begin_section "RotCompLemmas";;
(add_section_type (mk_var ("s", (`:(A)list`))));;

(* Lemma rot_addn *)
let rot_addn = section_proof ["m";"n";"s"] `m + n <= sizel s ==> rot (m + n) s = rot m (rot n s)` [
   ((BETA_TAC THEN (move ["sz_s"])) THEN ((((use_arg_then "rot")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [(`take _ s`)])))))));
   ((((use_arg_then "catA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_size_cat")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catA")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_size_cat")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "catA")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then "size_drop")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "size_takel")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "leq_addl")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "addnK")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma rotS *)
let rotS = section_proof ["n";"s"] `n < sizel s ==> rot (SUC n) s = rot 1 (rot n s)` [
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "add1n")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "rot_addn") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma rot_add_mod *)
let rot_add_mod = section_proof ["m";"n";"s"] `n <= sizel s ==> m <= sizel s ==>
  rot m (rot n s) = rot (if m + n <= sizel s then m + n else (m + n) - sizel s) s` [
   ((THENL) ((BETA_TAC THEN (move ["Hn"]) THEN (move ["Hm"])) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`m + n <= sizel s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac))) [((DISCH_THEN (fun snd_th -> (use_arg_then "rot_addn") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))); BETA_TAC]);
   (((((use_arg_then "ltnNge")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "ltnW") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["Hmn"])) THEN (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [])))));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then "rotK") (fun fst_arg -> (use_arg_then "n") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [2] [(`s`)]))))) THEN (((use_arg_then "rotr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_addn")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addn_subA")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "subnK")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "addnK")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma rot_rot *)
let rot_rot = section_proof ["m";"n";"s"] `rot m (rot n s) = rot n (rot m s)` [
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then "ltnP") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "m") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["Hm"]));
   (((repeat_tactic 1 9 (((use_arg_then "rot_oversize")(thm_tac (new_rewrite [] [(`rot m _`)]))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_rot")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 1 (((use_arg_then "ltnW")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then "ltnP") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sizel s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "n") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["Hn"]));
   (((repeat_tactic 1 9 (((use_arg_then "rot_oversize")(thm_tac (new_rewrite [] [(`rot n _`)]))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_rot")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 1 (((use_arg_then "ltnW")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then "rot_add_mod")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 1 (((use_arg_then "addnC")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma rot_rotr *)
let rot_rotr = section_proof ["m";"n";"s"] `rot m (rotr n s) = rotr n (rot m s)` [
   (((((use_arg_then "rotr")(thm_tac (new_rewrite [] [(`rotr n (rot m s)`)])))) THEN (((use_arg_then "size_rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rot_rot")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rotr")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma rotr_rotr *)
let rotr_rotr = section_proof ["m";"n";"s"] `rotr m (rotr n s) = rotr n (rotr m s)` [
   (((repeat_tactic 1 9 (((use_arg_then "rotr")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "size_rot")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rot_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section RotCompLemmas *)
let rot_addn = finalize_theorem rot_addn;;
let rotS = finalize_theorem rotS;;
let rot_add_mod = finalize_theorem rot_add_mod;;
let rot_rot = finalize_theorem rot_rot;;
let rot_rotr = finalize_theorem rot_rotr;;
let rotr_rotr = finalize_theorem rotr_rotr;;
end_section "RotCompLemmas";;

(* Section Mask *)
begin_section "Mask";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_type (mk_var ("m", (`:(bool)list`))));;
(add_section_type (mk_var ("s", (`:(A)list`))); add_section_type (mk_var ("s1", (`:(A)list`))));;
let mask = define `mask [] s' = [] /\ mask m' [] = [] /\
	mask (b :: m') (x :: s') = if b then x :: mask m' s' else mask m' s'`;;

(* Lemma mask_false *)
let mask_false = section_proof ["s";"n"] `mask (nseq n F) s = []` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then "ncons")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "nseq")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;

(* Lemma mask_true *)
let mask_true = section_proof ["s";"n"] `sizel s <= n ==> mask (nseq n T) s = s` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ncons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nseq")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mask0 *)
let mask0 = section_proof ["m"] `mask m [] = []` [
   (((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["_"]))]) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma mask1 *)
let mask1 = section_proof ["b";"x"] `mask [b] [x] = nseq (if b then 1 else 0) x` [
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case THEN (simp_tac)) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ONE")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma mask_cons *)
let mask_cons = section_proof ["b";"m";"x";"s"] `mask (b :: m) (x :: s) = nseq (if b then 1 else 0) x ++ mask m s` [
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ONE")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "cat1s")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat0s")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma size_mask *)
let size_mask = section_proof ["m";"s"] `sizel m = sizel s ==> sizel (mask m s) = count I m` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["b"]) THEN (move ["m"]) THEN (move ["IHm"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "eqS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "eqSS")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "I_THM")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case THEN (simp_tac) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHm") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 0 10 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "add1n")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "add0n")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mask_cat *)
let mask_cat = section_proof ["m1";"s1";"m2";"s2"] `sizel m1 = sizel s1 ==>
       mask (m1 ++ m2) (s1 ++ s2) = mask m1 s1 ++ mask m2 s2` [
   (BETA_TAC THEN (move ["Hm1"]));
   (((THENL) (((use_arg_then "Hm1") (disch_tac [])) THEN (clear_assumption "Hm1") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN ((use_arg_then "m1") (disch_tac [])) THEN (clear_assumption "m1") THEN elim) [ALL_TAC; ((move ["b1"]) THEN (move ["m1"]) THEN (move ["IHm"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x1"]) THEN (move ["s1"]) THEN (move ["_"]))]) THEN ((repeat_tactic 0 10 (((use_arg_then "mask0")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "cat0s")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 0 10 (((use_arg_then "size_nil")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`0 = _`)]))))) THEN (repeat_tactic 0 10 (((use_arg_then "eqS0")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "cat_cons")(thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHm") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "b1") (disch_tac [])) THEN (clear_assumption "b1") THEN case THEN (simp_tac)) THEN (((use_arg_then "cat_cons")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma has_mask_cons *)
let has_mask_cons = section_proof ["a";"b";"m";"x";"s"] `has a (mask (b :: m) (x :: s)) <=> b /\ a x \/ has a (mask m s)` [
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma mask_rot *)
let mask_rot = section_proof ["m";"s"] `sizel m = sizel s ==>
   mask (rot n0 m) (rot n0 s) = rot (count I (take n0 m)) (mask m s)` [
   (BETA_TAC THEN (move ["Hs"]));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`sizel (take n0 m) = sizel (take n0 s)`))) (term_tac (have_gen_tac [](move ["Hsn0"])))) (((repeat_tactic 1 9 (((use_arg_then "size_take")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Hs")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((fun arg_tac -> (use_arg_then "size_mask") (fun fst_arg -> (use_arg_then "Hsn0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 2 0 (((use_arg_then "rot")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mask_cat")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "size_drop")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "Hs")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "m") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [4] [(`m`)]))))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [4] [(`s`)]))))) THEN (((use_arg_then "mask_cat")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then "rot_size_cat")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Finalization of the section Mask *)
let mask_false = finalize_theorem mask_false;;
let mask_true = finalize_theorem mask_true;;
let mask0 = finalize_theorem mask0;;
let mask1 = finalize_theorem mask1;;
let mask_cons = finalize_theorem mask_cons;;
let size_mask = finalize_theorem size_mask;;
let mask_cat = finalize_theorem mask_cat;;
let has_mask_cons = finalize_theorem has_mask_cons;;
let mask_rot = finalize_theorem mask_rot;;
end_section "Mask";;

(* Section EqMask *)
begin_section "EqMask";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;
(add_section_type (mk_var ("m", (`:(bool)list`))));;

(* Lemma mem_mask_cons *)
let mem_mask_cons = section_proof ["x";"b";"m";"y";"s"] `(x <- mask (b :: m) (y :: s)) <=> b /\ (x = y) \/ (x <- mask m s)` [
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "in_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma mem_mask *)
let mem_mask = section_proof ["x";"m";"s"] `x <- mask m s ==> x <- s` [
   (((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["p"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["m"]) THEN (move ["_"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then "in_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   ((((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN case THEN (simp_tac)) THEN (repeat_tactic 0 10 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_term (`x = y`))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma mask_uniq *)
let mask_uniq = section_proof ["s"] `uniq s ==> !m. uniq (mask m s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((repeat_tactic 0 10 (((use_arg_then "mask0")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "nil_uniq")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "cons_uniq")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ((move ["Hx"]) THEN (move ["Hs"])))) THEN ((THENL) elim [ALL_TAC; ((move ["b"]) THEN (move ["m"]) THEN (move ["_"]))]));
   (((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nil_uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "b") (disch_tac [])) THEN (clear_assumption "b") THEN case) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "Hs") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "m") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac))));
   ((((use_arg_then "Hx") (disch_tac [])) THEN (clear_assumption "Hx") THEN BETA_TAC) THEN (((use_arg_then "contra") (disch_tac [])) THEN (clear_assumption "contra") THEN (DISCH_THEN apply_tac) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "mem_mask") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma mem_mask_rot *)
let mem_mask_rot = section_proof ["m";"s"] `sizel m = sizel s ==>
  (!x. x <- mask (rot n0 m) (rot n0 s) <=> x <- mask m s)` [
   ((BETA_TAC THEN (move ["Hm"]) THEN (move ["x"])) THEN ((((use_arg_then "mask_rot")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "mem_rot")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section EqMask *)
let mem_mask_cons = finalize_theorem mem_mask_cons;;
let mem_mask = finalize_theorem mem_mask;;
let mask_uniq = finalize_theorem mask_uniq;;
let mem_mask_rot = finalize_theorem mem_mask_rot;;
end_section "EqMask";;

(* Section Subseq *)
begin_section "Subseq";;
(add_section_type (mk_var ("s", (`:(A)list`))); add_section_type (mk_var ("s1", (`:(A)list`))));;
let subseq = define `subseq (x :: s1) (y :: s2) = subseq (if x = y then s1 else x :: s1) s2 /\
	subseq [] s2 = T /\ subseq (x :: s1) [] = F`;;

(* Lemma sub0seq *)
let sub0seq = section_proof ["s"] `subseq [] s` [
   ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma subseq0 *)
let subseq0 = section_proof ["s"] `subseq s [] = (s = [])` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;

(* Lemma subseqP *)
let subseqP = section_proof ["s1";"s2"] `subseq s1 s2 <=> (?m. sizel m = sizel s2 /\ s1 = mask m s2)` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN ((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s2"]) THEN (move ["IHs2"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["_"]))]) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`[]:(bool)list`))) (term_tac exists_tac)) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   (((((use_arg_then "NOT_EXISTS_THM")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_and")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mask0")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nseq (SUC (sizel s2)) F`))) (term_tac exists_tac)) THEN ((((use_arg_then "size_nseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mask_false")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then "IHs2")(thm_tac (new_rewrite [] [])))) THEN ((split_tac) THEN ALL_TAC THEN (case THEN (move ["n"])) THEN (case THEN ((move ["sz_m"]) THEN (move ["def_s1"])))) THEN (((use_arg_then "IHs2") (disch_tac [])) THEN (clear_assumption "IHs2") THEN BETA_TAC THEN (move ["_"])));
   (((fun arg_tac -> arg_tac (Arg_term (`(x = y) :: n`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "sz_m")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then "def_s1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (done_tac));
   ((THENL_ROT (-1)) ((THENL) (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) [(BETA_TAC THEN (move ["_"])); (BETA_TAC THEN (move ["ne_xy"]))]));
   (((THENL) (((use_arg_then "sz_m") (disch_tac [])) THEN (clear_assumption "sz_m") THEN ((use_arg_then "def_s1") (disch_tac [])) THEN (clear_assumption "def_s1") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN case) [ALL_TAC; ((case THEN ALL_TAC) THEN (move ["m"]))]) THEN (((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "eqSS")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (move ["eq"]) THEN (move ["seq"])));
   ((((use_arg_then "eq") (disch_tac [])) THEN (clear_assumption "eq") THEN BETA_TAC) THEN ((((use_arg_then "eqseq_cons")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (done_tac));
   (((use_arg_then "m") (term_tac exists_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`indexl T n`))) (term_tac (set_tac "i")));
   ((fun arg_tac -> arg_tac (Arg_term (`take i n = nseq (sizel (take i n)) F`))) (term_tac (have_gen_tac [](move ["def_m_i"]))));
   (((((use_arg_then "all_pred1P")(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then "all_nthP") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`pred1 F`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`take i n`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`T`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["j"]));
   (((((use_arg_then "size_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "minn")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leq_minl")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_or")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnNge")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (case THEN (move ["lt_j_i"]) THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then "nth_take") (fun fst_arg -> (use_arg_then "lt_j_i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "lt_j_i") (disch_tac [])) THEN (clear_assumption "lt_j_i") THEN BETA_TAC) THEN (((((use_arg_then "i_def")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "index")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "before_find") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`T`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   (((repeat_tactic 1 9 (((use_arg_then "pred1")(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`i < sizel n`))) (term_tac (have_gen_tac [](move ["lt_i_m"]))));
   ((((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN ((((fun arg_tac -> arg_tac (Arg_theorem (TAUT `!P. (P ==> F) <=> ~P`)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["le_m_i"])));
   ((((use_arg_then "def_s1") (disch_tac [])) THEN (clear_assumption "def_s1") THEN ((use_arg_then "def_m_i") (disch_tac [])) THEN (clear_assumption "def_m_i") THEN BETA_TAC) THEN (((((use_arg_then "take_oversize")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mask_false")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "def_m_i") (disch_tac [])) THEN (clear_assumption "def_m_i") THEN BETA_TAC) THEN (((((use_arg_then "size_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "lt_i_m")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["def_m_i"])));
   (((fun arg_tac -> arg_tac (Arg_term (`take i n ++ dropl (SUC i) n`))) (term_tac exists_tac)) THEN (split_tac));
   ((((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_drop")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "lt_i_m")(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then "lt_i_m") (disch_tac [])) THEN (clear_assumption "lt_i_m") THEN BETA_TAC) THEN (((((use_arg_then "sz_m")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "subnKC") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addSn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "congr1") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`behead`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "def_s1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [(`s2`)]))))) THEN (((fun arg_tac -> (use_arg_then "cat_take_drop") (fun fst_arg -> (use_arg_then "i") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] [(`n`)]))))) THEN (((use_arg_then "def_m_i")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_cons")(gsym_then (thm_tac (new_rewrite [] []))))));
   ((fun arg_tac -> arg_tac (Arg_term (`sizel (take i s2) = i`))) (term_tac (have_gen_tac [](move ["sz_i_s2"]))));
   ((((use_arg_then "size_takel") (disch_tac [])) THEN (clear_assumption "size_takel") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "lt_i_m") (disch_tac [])) THEN (clear_assumption "lt_i_m") THEN BETA_TAC) THEN ((((use_arg_then "sz_m")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then "lastI")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat_rcons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "mask_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_nseq")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_belast")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "mask_false")(thm_tac (new_rewrite [] []))))) THEN ((simp_tac THEN TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then "cat0s")(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then "drop_nth") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`T`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "i_def")(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then "nth_index")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "index_mem")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then "i_def")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma subseq_trans *)
let subseq_trans = section_proof ["s1";"s2";"s3"] `subseq s1 s2 ==> subseq s2 s3 ==> subseq s1 s3` [
   (((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m2"])) THEN (case THEN ((move ["_"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) THEN ((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m1"])) THEN (case THEN ((move ["_"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))));
   ((THENL_FIRST) ((THENL) (((use_arg_then "m1") (disch_tac [])) THEN (clear_assumption "m1") THEN ((use_arg_then "m2") (disch_tac [])) THEN (clear_assumption "m2") THEN ((use_arg_then "s3") (disch_tac [])) THEN (clear_assumption "s3") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) (((repeat_tactic 1 9 (((use_arg_then "mask0")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "subseq0")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (BETA_TAC THEN (move ["m2"]) THEN (move ["m1"]));
   (((THENL) (((use_arg_then "m1") (disch_tac [])) THEN (clear_assumption "m1") THEN case) [ALL_TAC; ((case THEN ALL_TAC) THEN (move ["m1"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mask0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((THENL) (((use_arg_then "m2") (disch_tac [])) THEN (clear_assumption "m2") THEN case) [ALL_TAC; ((case THEN ALL_TAC) THEN (move ["m2"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "IHs")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "m2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "m1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "subseqP")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["sz_m"]) THEN (move ["def_s"])))));
   (((fun arg_tac -> arg_tac (Arg_term (`F :: m`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "sz_m")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "def_s")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "IHs") (fun fst_arg -> (use_arg_then "m2") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "m1") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "subseqP")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["sz_m"]) THEN (move ["def_s"])))));
   (((fun arg_tac -> arg_tac (Arg_term (`F :: m`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "sz_m")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "def_s")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma subseq_refl *)
let subseq_refl = section_proof ["s"] `subseq s s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma subseq_cat *)
let subseq_cat = section_proof ["s1";"s2";"s3";"s4"] `subseq s1 s3 ==> subseq s2 s4 ==> subseq (s1 ++ s2) (s3 ++ s4)` [
   ((repeat_tactic 1 9 (((use_arg_then "subseqP")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["m1"])) THEN (case THEN ((move ["sz_m1"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN (case THEN (move ["m2"])) THEN (case THEN ((move ["sz_m2"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((fun arg_tac -> arg_tac (Arg_term (`m1 ++ m2`))) (term_tac exists_tac)) THEN ((repeat_tactic 0 10 (((use_arg_then "size_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "mask_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "sz_m1")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "sz_m2")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma mem_subseq *)
let mem_subseq = section_proof ["s1";"s2"] `subseq s1 s2 ==> (!x. x <- s1 ==> x <- s2)` [
   (((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["_"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN (move ["x"])) THEN (((use_arg_then "mem_mask") (disch_tac [])) THEN (clear_assumption "mem_mask") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma subseq_seq1 *)
let subseq_seq1 = section_proof ["x";"s"] `subseq [x] s <=> x <- s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "MEM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   ((((fun arg_tac -> (use_arg_then "orbN") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma size_subseq *)
let size_subseq = section_proof ["s1";"s2"] `subseq s1 s2 ==> sizel s1 <= sizel s2` [
   ((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["sz_m"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then "size_mask")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "sz_m")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "count_size")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma size_subseq_leqif *)
let size_subseq_leqif = section_proof ["s1";"s2"] `subseq s1 s2 ==> leqif (sizel s1) (sizel s2) (s1 = s2)` [
   ((THENL_FIRST) ((BETA_TAC THEN (move ["sub12"])) THEN (((use_arg_then "leqif")(thm_tac (new_rewrite [] [])))) THEN (split_tac)) (((use_arg_then "size_subseq") (disch_tac [])) THEN (clear_assumption "size_subseq") THEN (exact_tac)));
   (((THENL) (split_tac) [ALL_TAC; ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))]) THEN (((use_arg_then "sub12") (disch_tac [])) THEN (clear_assumption "sub12") THEN BETA_TAC) THEN ((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["sz_m"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))));
   ((((use_arg_then "size_mask")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "sz_m")(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "all_count")(gsym_then (thm_tac (new_rewrite [] []))))));
   ((fun arg_tac -> arg_tac (Arg_term (`all I m = all (pred1 T) m`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then "eq_all") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`I:bool->bool`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`pred1 T`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((((use_arg_then "pred1")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "I_THM")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   (((((use_arg_then "all_pred1P")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "sz_m")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mask_true")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "leqnn")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma subseq_cons *)
let subseq_cons = section_proof ["s";"x"] `subseq s (x :: s)` [
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then "subseq_cat") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`[]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`[x]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "s") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((((use_arg_then "subseq_refl")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat0s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cat1s")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma subseq_rcons *)
let subseq_rcons = section_proof ["s";"x"] `subseq s (rcons s x)` [
   (((((use_arg_then "cats0")(gsym_then (thm_tac (new_rewrite [1] [(`s`)]))))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "subseq_cat")(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "subseq_refl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;

(* Lemma subseq_uniq *)
let subseq_uniq = section_proof ["s1";"s2"] `subseq s1 s2 ==> uniq s2 ==> uniq s1` [
   (((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["_"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN (move ["Us2"])) THEN (((use_arg_then "mask_uniq")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Finalization of the section Subseq *)
let sub0seq = finalize_theorem sub0seq;;
let subseq0 = finalize_theorem subseq0;;
let subseqP = finalize_theorem subseqP;;
let subseq_trans = finalize_theorem subseq_trans;;
let subseq_refl = finalize_theorem subseq_refl;;
let subseq_cat = finalize_theorem subseq_cat;;
let mem_subseq = finalize_theorem mem_subseq;;
let subseq_seq1 = finalize_theorem subseq_seq1;;
let size_subseq = finalize_theorem size_subseq;;
let size_subseq_leqif = finalize_theorem size_subseq_leqif;;
let subseq_cons = finalize_theorem subseq_cons;;
let subseq_rcons = finalize_theorem subseq_rcons;;
let subseq_uniq = finalize_theorem subseq_uniq;;
end_section "Subseq";;

(* Section Map *)
begin_section "Map";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_var (mk_var ("x1", (`:A`))));;
(add_section_var (mk_var ("x2", (`:B`))));;
(add_section_var (mk_var ("f", (`:A -> B`))));;
let map = define `map f (x :: s) = f x :: map f s /\ map f [] = []`;;

(* Lemma map_MAP *)
let map_MAP = section_proof [] `map = MAP` [
   ((((use_arg_then "EQ_EXT") (thm_tac apply_tac)) THEN (move ["f"])) THEN (((use_arg_then "EQ_EXT") (thm_tac apply_tac)) THEN (move ["s"])));
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "MAP")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma map_cons *)
let map_cons = section_proof ["x";"s"] `map f (x :: s) = f x :: map f s` [
   ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma map_nseq *)
let map_nseq = section_proof ["x"] `map f (nseq n0 x) = nseq n0 (f x)` [
   (((THENL) (((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "ncons")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "nseq")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))));
   ((((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma map_cat *)
let map_cat = section_proof ["s1";"s2"] `map f (s1 ++ s2) = map f s1 ++ map f s2` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (done_tac));
];;

(* Lemma size_map *)
let size_map = section_proof ["s"] `sizel (map f s) = sizel s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma behead_map *)
let behead_map = section_proof ["s"] `behead (map f s) = map f (behead s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "behead")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_map *)
let nth_map = section_proof ["n";"s"] `n < sizel s ==> nth x2 (map f s) n = f (nth x1 s n)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma map_rcons *)
let map_rcons = section_proof ["s";"x"] `map f (rcons s x) = rcons (map f s) (f x)` [
   (((repeat_tactic 1 9 (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "map_cat")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma last_map *)
let last_map = section_proof ["s";"x"] `last (f x) (map f s) = f (last x s)` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma belast_map *)
let belast_map = section_proof ["s";"x"] `belast (f x) (map f s) = map f (belast x s)` [
   (((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]) THEN (move ["x"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "belast")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (done_tac));
];;
let preim = new_definition `preim (f:A->B) (a:B->bool) = (\x. a (f x))`;;

(* Lemma filter_map *)
let filter_map = section_proof ["a";"s"] `filter a (map f s) = map f (filter (preim f a) s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "preim")(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a (f x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["_"])) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma find_map *)
let find_map = section_proof ["a";"s"] `find a (map f s) = find (preim f a) s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "preim")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_map *)
let has_map = section_proof ["a";"s"] `has a (map f s) = has (preim f a) s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "has")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "preim")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma all_map *)
let all_map = section_proof ["a";"s"] `all a (map f s) = all (preim f a) s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "preim")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma count_map *)
let count_map = section_proof ["a";"s"] `count a (map f s) = count (preim f a) s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "count")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "preim")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_take *)
let map_take = section_proof ["s"] `map f (take n0 s) = take n0 (map f s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma map_drop *)
let map_drop = section_proof ["s"] `map f (dropl n0 s) = dropl n0 (map f s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "n0") (disch_tac [])) THEN (clear_assumption "n0") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "drop")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma map_rot *)
let map_rot = section_proof ["s"] `map f (rot n0 s) = rot n0 (map f s)` [
   (((repeat_tactic 1 9 (((use_arg_then "rot")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "map_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "map_take")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "map_drop")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_rotr *)
let map_rotr = section_proof ["s"] `map f (rotr n0 s) = rotr n0 (map f s)` [
   (((fun arg_tac -> (use_arg_then "rot_inj") (fun fst_arg -> (use_arg_then "n0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac apply_tac)) THEN ((((use_arg_then "rotrK")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "map_rot")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "rotrK")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_rev *)
let map_rev = section_proof ["s"] `map f (rev s) = rev (map f s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rev_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map_rcons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma map_mask *)
let map_mask = section_proof ["m";"s"] `map f (mask m s) = mask m (map f s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((case THEN ALL_TAC) THEN (move ["m"]) THEN (move ["IHm"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["p"]) THEN (move ["_"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "map_cons")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "IHm")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma inj_map *)
let inj_map = section_proof [] `(!x y. f x = f y ==> x = y) ==> (!s1 s2. map f s1 = map f s2 ==> s1 = s2)` [
   ((BETA_TAC THEN (move ["injf"])) THEN ((THENL) elim [ALL_TAC; ((move ["y1"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y2"]) THEN (move ["s2"]) THEN (move ["_"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (repeat_tactic 0 10 (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`[] = CONS _1 _2`)]))))) THEN ((((use_arg_then "NOT_CONS_NIL")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "eqseq_cons")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "injf") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) THEN (done_tac));
];;

(* Finalization of the section Map *)
let map_MAP = finalize_theorem map_MAP;;
let map_cons = finalize_theorem map_cons;;
let map_nseq = finalize_theorem map_nseq;;
let map_cat = finalize_theorem map_cat;;
let size_map = finalize_theorem size_map;;
let behead_map = finalize_theorem behead_map;;
let nth_map = finalize_theorem nth_map;;
let map_rcons = finalize_theorem map_rcons;;
let last_map = finalize_theorem last_map;;
let belast_map = finalize_theorem belast_map;;
let filter_map = finalize_theorem filter_map;;
let find_map = finalize_theorem find_map;;
let has_map = finalize_theorem has_map;;
let all_map = finalize_theorem all_map;;
let count_map = finalize_theorem count_map;;
let map_take = finalize_theorem map_take;;
let map_drop = finalize_theorem map_drop;;
let map_rot = finalize_theorem map_rot;;
let map_rotr = finalize_theorem map_rotr;;
let map_rev = finalize_theorem map_rev;;
let map_mask = finalize_theorem map_mask;;
let inj_map = finalize_theorem inj_map;;
end_section "Map";;

(* Lemma filter_mask *)
let filter_mask = section_proof ["a";"s"] `filter (a:A->bool) s = mask (map a s) s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac)) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN ((((use_arg_then "mask")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (done_tac));
];;

(* Section FilterSubseq *)
begin_section "FilterSubseq";;
(add_section_type (mk_var ("s", (`:(A)list`))); add_section_type (mk_var ("s1", (`:(A)list`))));;
(add_section_type (mk_var ("a", (`:A -> bool`))));;

(* Lemma filter_subseq *)
let filter_subseq = section_proof ["a";"s"] `subseq (filter a s) s` [
   ((((use_arg_then "subseqP")(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`map a s`))) (term_tac exists_tac)) THEN ((((use_arg_then "size_map")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "filter_mask")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma subseq_filter *)
let subseq_filter = section_proof ["s1";"s2";"a"] `subseq s1 (filter a s2) <=> all a s1 /\ subseq s1 s2` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN ((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s2"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["_"]))]) THEN ((((use_arg_then "filter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "all")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ax"])) THEN (((use_arg_then "subseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y = x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["yx"])) THEN ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "all_cons")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma subseq_uniqP *)
let subseq_uniqP = section_proof ["s1";"s2"] `uniq s2 ==> (subseq s1 s2 <=> s1 = filter (\x. x <- s1) s2)` [
   ((THENL_LAST) ((BETA_TAC THEN (move ["uniq_s2"])) THEN ((THENL) (split_tac) [(move ["ss12"]); (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))])) ((((use_arg_then "filter_subseq")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`subseq s1 (filter (\x. x <- s1) s2)`))) (term_tac (have_gen_tac []ALL_TAC)));
   (((((use_arg_then "subseq_filter")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "allP")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((DISCH_THEN (fun snd_th -> (use_arg_then "size_subseq_leqif") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then "leqif_imp_eq") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "perm_eq_size") (disch_tac [])) THEN (clear_assumption "perm_eq_size") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then "uniq_perm_eq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "filter_uniq")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then "subseq_uniq") (fun fst_arg -> (use_arg_then "ss12") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((((use_arg_then "mem_filter")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["x"])) THEN ((((use_arg_then "andb_idr")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((fun arg_tac -> (use_arg_then "mem_subseq") (fun fst_arg -> (use_arg_then "ss12") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Finalization of the section FilterSubseq *)
let filter_subseq = finalize_theorem filter_subseq;;
let subseq_filter = finalize_theorem subseq_filter;;
let subseq_uniqP = finalize_theorem subseq_uniqP;;
end_section "FilterSubseq";;

(* Section EqMap *)
begin_section "EqMap";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_var (mk_var ("x1", (`:A`))));;
(add_section_var (mk_var ("x2", (`:B`))));;
(add_section_var (mk_var ("f", (`:A -> B`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;

(* Lemma map_f *)
let map_f = section_proof ["s";"x"] `x <- s ==> f x <- map f s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((THENL) case [((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))); (move ["Hx"])]) THEN (DISJ2_TAC) THEN (((use_arg_then "IHs") (disch_tac [])) THEN (clear_assumption "IHs") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma mapP *)
let mapP = section_proof ["s";"y"] `(y <- map f s) <=> (?x. x <- s /\ y = f x)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "andFb")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "NOT_EXISTS_THM")(thm_tac (new_rewrite [] [])))) THEN (move ["x"])) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y = f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["Hxy"])));
   (((use_arg_then "x") (term_tac exists_tac)) THEN (done_tac));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN ((THENL) (split_tac) [(case THEN ((move ["x'"]) THEN (case THEN ((move ["Hx'"]) THEN (move ["eq"]))))); (case THEN ((move ["x'"]) THEN (case THEN ((move ["Hx'"]) THEN (move ["Dy"])))))]));
   (((use_arg_then "x'") (term_tac exists_tac)) THEN (done_tac));
   ((THENL) (((use_arg_then "Hx'") (disch_tac [])) THEN (clear_assumption "Hx'") THEN case THEN (move ["Hx'"])) [BETA_TAC; (((use_arg_then "x'") (term_tac exists_tac)) THEN ((TRY done_tac)))]);
   (((use_arg_then "x") (term_tac exists_tac)) THEN (((use_arg_then "Hxy") (disch_tac [])) THEN (clear_assumption "Hxy") THEN BETA_TAC) THEN ((((use_arg_then "Dy")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hx'")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_uniq *)
let map_uniq = section_proof ["s"] `uniq (map f s) ==> uniq s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN ALL_TAC THEN (case THEN (move ["not_sfx"]))));
   (((DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "andbT")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "not_sfx") (disch_tac [])) THEN (clear_assumption "not_sfx") THEN ((use_arg_then "contra") (disch_tac [])) THEN (clear_assumption "contra") THEN (DISCH_THEN apply_tac) THEN (move ["sx"])) THEN (((use_arg_then "mapP")(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then "x") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma map_inj_in_uniq *)
let map_inj_in_uniq = section_proof ["s"] `(!x y. x <- s ==> y <- s ==> (f x = f y ==> x = y)) ==>
	uniq (map f s) = uniq s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (((((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN (move ["injf"])));
   (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))));
   (BETA_TAC THEN (move ["a"]) THEN (move ["b"]) THEN (case THEN ((case THEN ((move ["Ha"]) THEN (move ["Hb"]))) THEN (move ["fab"]))));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "injf") (fun fst_arg -> (use_arg_then "a") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "b") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Ha")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hb")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "fab")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((congr_tac (`_ /\ _`)) THEN ((TRY done_tac)));
   (((((use_arg_then "mapP")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "NOT_EXISTS_THM")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "negb_and")(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN BETA_TAC THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["Hx"]) THEN (move ["y"]));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y <- s`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["Hy"]));
   ((((fun arg_tac -> arg_tac (Arg_theorem (TAUT `~A <=> (A ==> F)`)))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (move ["fxy"]));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then "injf") (fun fst_arg -> (use_arg_then "x") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then "y") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "Hy")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "fxy")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN ((TRY done_tac)) THEN (move ["xy"]));
   ((((use_arg_then "Hx") (disch_tac [])) THEN (clear_assumption "Hx") THEN ((use_arg_then "Hy") (disch_tac [])) THEN (clear_assumption "Hy") THEN BETA_TAC) THEN (((use_arg_then "xy")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma map_subseq *)
let map_subseq = section_proof ["s1";"s2"] `subseq s1 s2 ==> subseq (map f s1) (map f s2)` [
   ((repeat_tactic 1 9 (((use_arg_then "subseqP")(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["m"])) THEN (case THEN ((move ["sz_m"]) THEN (move ["eq"]))));
   (((use_arg_then "m") (term_tac exists_tac)) THEN ((((use_arg_then "eq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_map")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "map_mask")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section EqMap *)
let map_f = finalize_theorem map_f;;
let mapP = finalize_theorem mapP;;
let map_uniq = finalize_theorem map_uniq;;
let map_inj_in_uniq = finalize_theorem map_inj_in_uniq;;
let map_subseq = finalize_theorem map_subseq;;
end_section "EqMap";;

(* Section EqMap2 *)
begin_section "EqMap2";;
(add_section_var (mk_var ("n0", (`:num`))));;
(add_section_var (mk_var ("x1", (`:A`))));;
(add_section_var (mk_var ("x2", (`:B`))));;
(add_section_var (mk_var ("f", (`:A -> B`))));;
(add_section_type (mk_var ("s", (`:(A)list`))));;
(add_section_hyp "Hf" (`!x y. f x = f y ==> x = y`));;

(* Lemma inj_eq *)
let inj_eq = section_proof ["x";"y"] `(f x = f y <=> x = y)` [
   (((THENL) (split_tac) [(DISCH_THEN (fun snd_th -> (use_arg_then "Hf") (thm_tac (match_mp_then snd_th MP_TAC)))); (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))]) THEN (done_tac));
];;

(* Lemma mem_map *)
let mem_map = section_proof ["s";"x"] `(f x <- map f s) = (x <- s)` [
   ((((use_arg_then "mapP")(thm_tac (new_rewrite [] [])))) THEN ((THENL) (split_tac) [((case THEN ((move ["y"]) THEN (case THEN ((move ["Hy"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "Hf") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) THEN ((TRY done_tac))); (move ["Hx"])]) THEN ((use_arg_then "x") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma index_map *)
let index_map = section_proof ["s";"x"] `indexl (f x) (map f s) = indexl x s` [
   ((repeat_tactic 1 9 (((use_arg_then "index")(thm_tac (new_rewrite [] []))))) THEN ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "find")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "pred1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)));
   (((((use_arg_then "inj_eq")(gsym_then (thm_tac (new_rewrite [] [(`y = x`)]))))) THEN (repeat_tactic 1 9 (((use_arg_then "pred1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_inj_uniq *)
let map_inj_uniq = section_proof ["s"] `uniq (map f s) = uniq s` [
   ((((use_arg_then "map_inj_in_uniq") (disch_tac [])) THEN (clear_assumption "map_inj_in_uniq") THEN (DISCH_THEN apply_tac) THEN (move ["x"]) THEN (move ["y"]) THEN (move ["_"]) THEN (move ["_"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "Hf") (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Finalization of the section EqMap2 *)
let inj_eq = finalize_theorem inj_eq;;
let mem_map = finalize_theorem mem_map;;
let index_map = finalize_theorem index_map;;
let map_inj_uniq = finalize_theorem map_inj_uniq;;
end_section "EqMap2";;

(* Section MapComp *)
begin_section "MapComp";;

(* Lemma map_id *)
let map_id = section_proof ["s"] `map I (s:(A)list) = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "I_THM")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma eq_map *)
let eq_map = section_proof ["f1";"f2"] `(!x. (f1:A->B) x = f2 x) ==> map f1 = map f2` [
   (((((use_arg_then "eq_ext")(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma map_comp *)
let map_comp = section_proof ["f1";"f2";"s"] `map (f1 o f2) s = map (f1:B->C) (map (f2:A->B) s)` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (repeat_tactic 1 9 (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "o_THM")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma mapK *)
let mapK = section_proof ["f1";"f2"] `(!x. (f2:B->A) ((f1:A->B) x) = x) ==> (!s. map f2 (map f1 s) = s)` [
   ((BETA_TAC THEN (move ["eq_f12"])) THEN ((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (repeat_tactic 1 9 (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Finalization of the section MapComp *)
let map_id = finalize_theorem map_id;;
let eq_map = finalize_theorem eq_map;;
let map_comp = finalize_theorem map_comp;;
let mapK = finalize_theorem mapK;;
end_section "MapComp";;

(* Lemma eq_in_map *)
let eq_in_map = section_proof ["f1";"f2";"s"] `(!x. x <- s ==> (f1:A->B) x = f2 x) ==> map f1 s = map f2 s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]) THEN (move ["eqf12"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "eqf12")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["sy"]));
   (((((use_arg_then "eqf12")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma map_id_in *)
let map_id_in = section_proof ["f";"s"] `(!x. x <- s ==> f x = (x:A)) ==> map f s = s` [
   ((DISCH_THEN (fun snd_th -> (use_arg_then "eq_in_map") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))));
   (((use_arg_then "map_id")(gsym_then (thm_tac (new_rewrite [2] [(`s`)])))));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then "eq_map") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(\x. x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`I`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then "I_THM")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
let iota = define `iota m (SUC n) = m :: iota (SUC m) n /\ iota m 0 = []`;;

(* Lemma size_iota *)
let size_iota = section_proof ["m";"n"] `sizel (iota m n) = n` [
   (((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]) THEN (move ["m"]))]) THEN ((((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma iota_add *)
let iota_add = section_proof ["m";"n1";"n2"] `iota m (n1 + n2) = iota m n1 ++ iota (m + n1) n2` [
   (((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN ((use_arg_then "n1") (disch_tac [])) THEN (clear_assumption "n1") THEN elim) [ALL_TAC; ((move ["n1"]) THEN (move ["IHn1"]))]) THEN ((((use_arg_then "addn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat0s")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "addSnnS")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "addSn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "IHn1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "addSn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma iota_addl *)
let iota_addl = section_proof ["m1";"m2";"n"] `iota (m1 + m2) n = map ((+) m1) (iota m2 n)` [
   (((THENL) (((use_arg_then "m2") (disch_tac [])) THEN (clear_assumption "m2") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]) THEN (move ["m2"]))]) THEN ((((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   (((((use_arg_then "addnS")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_iota *)
let nth_iota = section_proof ["m";"n";"i"] `i < n ==> nth 0 (iota m n) i = m + i` [
   (((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "subnKC") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then "addSnnS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "iota_add")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "nth_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_iota")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnn")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "subnn")(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma mem_iota *)
let mem_iota = section_proof ["m";"n";"i"] `(i <- iota m n) <=> (m <= i) /\ (i < m + n)` [
   ((((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN (move ["m"])) THEN ((((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "addn0")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andbN")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then "addSnnS")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "leq_eqVlt")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`i = m`)])))));
   (((fun arg_tac -> (use_arg_then "EXCLUDED_MIDDLE") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`m = i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac));
   (((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addSn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_addr")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma iota_uniq *)
let iota_uniq = section_proof ["m";"n"] `uniq (iota m n)` [
   (((THENL) (((use_arg_then "m") (disch_tac [])) THEN (clear_assumption "m") THEN ((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]) THEN (move ["m"]))]) THEN ((((use_arg_then "iota")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "uniq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   (((((use_arg_then "mem_iota")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltE")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ltnn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "andFb")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Section MakeSeq *)
begin_section "MakeSeq";;
(add_section_var (mk_var ("x0", (`:A`))));;
let mkseq = new_definition `mkseq f n = map f (iota 0 n)`;;

(* Lemma size_mkseq *)
let size_mkseq = section_proof ["f";"n"] `sizel (mkseq f n) = n` [
   (((((use_arg_then "mkseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_map")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_iota")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma eq_mkseq *)
let eq_mkseq = section_proof ["f";"g"] `(!x. f x = g x) ==> mkseq f = mkseq g` [
   ((((((use_arg_then "eq_ext")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "mkseq")(thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "eq_map") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_mkseq *)
let nth_mkseq = section_proof ["f";"n";"i"] `i < n ==> nth x0 (mkseq f n) i = f i` [
   ((BETA_TAC THEN (move ["Hi"])) THEN (((use_arg_then "mkseq")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "nth_map")(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`0`))) (term_tac exists_tac)) THEN (((((use_arg_then "size_iota")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hi")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["_"])));
   (((((use_arg_then "nth_iota")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "add0n")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma mkseq_nth *)
let mkseq_nth = section_proof ["s"] `mkseq (nth x0 s) (sizel s) = s` [
   ((((fun arg_tac -> (use_arg_then "eq_from_nth") (fun fst_arg -> (use_arg_then "x0") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (((((use_arg_then "size_mkseq")(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["i"]) THEN (move ["Hi"])) THEN (((use_arg_then "nth_mkseq")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Finalization of the section MakeSeq *)
let size_mkseq = finalize_theorem size_mkseq;;
let eq_mkseq = finalize_theorem eq_mkseq;;
let nth_mkseq = finalize_theorem nth_mkseq;;
let mkseq_nth = finalize_theorem mkseq_nth;;
end_section "MakeSeq";;

(* Lemma mkseq_uniq *)
let mkseq_uniq = section_proof ["f";"n"] `(!x y. f x = f y ==> x = y) ==> uniq (mkseq f n)` [
   ((DISCH_THEN (fun snd_th -> (use_arg_then "map_inj_uniq") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (move ["Hs"]));
   (((((use_arg_then "mkseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "Hs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "iota_uniq")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Section FoldRight *)
begin_section "FoldRight";;
(add_section_var (mk_var ("f", (`:A -> B -> B`))));;
(add_section_var (mk_var ("z0", (`:B`))));;
let foldr = define `foldr f z0 (x :: s) = f x (foldr f z0 s) /\ foldr f z0 [] = z0`;;

(* Finalization of the section FoldRight *)
end_section "FoldRight";;

(* Section FoldRightComp *)
begin_section "FoldRightComp";;
(add_section_var (mk_var ("h", (`:A->B`))));;
(add_section_var (mk_var ("f", (`:B->R->R`))));;
(add_section_var (mk_var ("z0", (`:R`))));;

(* Lemma foldr_cat *)
let foldr_cat = section_proof ["s1";"s2"] `foldr f z0 (s1 ++ s2) = foldr f (foldr f z0 s2) s1` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma foldr_map *)
let foldr_map = section_proof ["s"] `foldr f z0 (map h s) = foldr (\x z. f (h x) z) z0 s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Finalization of the section FoldRightComp *)
let foldr_cat = finalize_theorem foldr_cat;;
let foldr_map = finalize_theorem foldr_map;;
end_section "FoldRightComp";;
let sumn = new_definition `sumn = foldr (+) 0`;;

(* Lemma sumn0 *)
let sumn0 = section_proof [] `sumn [] = 0` [
   (((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma sumn_nseq *)
let sumn_nseq = section_proof ["x";"n"] `sumn (nseq n x) = x * n` [
   ((((use_arg_then "mulnC")(thm_tac (new_rewrite [] [])))) THEN ((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mul0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "sumn")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "ncons")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "nseq")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mulSn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma sumn_cat *)
let sumn_cat = section_proof ["s1";"s2"] `sumn (s1 ++ s2) = sumn s1 + sumn s2` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "add0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "IHs")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "addnA")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma natnseq0P *)
let natnseq0P = section_proof ["s"] `sumn s = 0 <=> s = nseq (sizel s) 0` [
   ((THENL_LAST) ((THENL) (split_tac) [ALL_TAC; (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))]) (((((use_arg_then "sumn_nseq")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mul0n")(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((THENL_FIRST) ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) (((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac)));
   ((((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "addn_eq0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nseq")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "iter")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ncons")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "nseq")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN ALL_TAC THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))))) THEN (done_tac));
];;

(* Section FoldLeft *)
begin_section "FoldLeft";;
(add_section_var (mk_var ("f", (`:R->A->R`))));;
let foldl = define `foldl f z (x :: s) = foldl f (f z x) s /\ foldl f z [] = z`;;

(* Lemma foldl_rev *)
let foldl_rev = section_proof ["z";"s"] `foldl f z (rev s) = foldr (\x z0. f z0 x) z s` [
   ((((use_arg_then "z") (disch_tac [])) THEN (clear_assumption "z") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((fun arg_tac -> arg_tac (Arg_theorem (REWRITE_RULE[IMP_IMP] last_ind))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (((THENL) (split_tac) [ALL_TAC; ((move ["s"]) THEN (move ["x"]) THEN (move ["IHs"]))]) THEN (move ["z"])));
   (((((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "rev_rcons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "foldr_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(gsym_then (thm_tac (new_rewrite [] []))))));
   (((repeat_tactic 1 9 (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "foldl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma foldl_cat *)
let foldl_cat = section_proof ["z";"s1";"s2"] `foldl f z (s1 ++ s2) = foldl f (foldl f z s1) s2` [
   (((((fun arg_tac -> (use_arg_then "revK") (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`s1 ++ s2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "foldl_rev")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "rev_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "foldr_cat")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "foldl_rev")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then "revK")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Finalization of the section FoldLeft *)
let foldl_rev = finalize_theorem foldl_rev;;
let foldl_cat = finalize_theorem foldl_cat;;
end_section "FoldLeft";;

(* Section Scan *)
begin_section "Scan";;
(add_section_var (mk_var ("x1", (`:A`))));;
(add_section_var (mk_var ("x2", (`:B`))));;
(add_section_var (mk_var ("f", (`:A -> A -> B`))));;
(add_section_var (mk_var ("g", (`:A -> B -> A`))));;
let pairmap = define `pairmap f x (y :: s) = f x y :: pairmap f y s /\ pairmap f x [] = []`;;

(* Lemma size_pairmap *)
let size_pairmap = section_proof ["x";"s"] `sizel (pairmap f x s) = sizel s` [
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (move ["x"])) THEN ((((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma pairmap_cat *)
let pairmap_cat = section_proof ["x";"s1";"s2"] `pairmap f x (s1 ++ s2) = pairmap f x s1 ++ pairmap f (last x s1) s2` [
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["IHs1"]))]) THEN (move ["x"])) THEN ((((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "last")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "IHs1")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_pairmap *)
let nth_pairmap = section_proof ["s";"n"] `n < sizel s ==>
  !x. nth x2 (pairmap f x s) n = f (nth x1 (x :: s) n) (nth x1 s n)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["Hn"]) THEN (move ["x"])) THEN (done_tac));
];;
let scanl = define `scanl g x (y :: s) = g x y :: scanl g (g x y) s /\ scanl g x [] = []`;;

(* Lemma size_scanl *)
let size_scanl = section_proof ["x";"s"] `sizel (scanl g x s) = sizel s` [
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (move ["x"])) THEN ((((use_arg_then "scanl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma scanl_cat *)
let scanl_cat = section_proof ["x";"s1";"s2"] `scanl g x (s1 ++ s2) = scanl g x s1 ++ scanl g (foldl g x s1) s2` [
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s1"]) THEN (move ["IHs1"]))]) THEN (move ["x"])) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "scanl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma nth_scanl *)
let nth_scanl = section_proof ["s";"n"] `n < sizel s ==>
  !x. nth x1 (scanl g x s) n = foldl g x (take (SUC n) s)` [
   (((THENL) (((use_arg_then "n") (disch_tac [])) THEN (clear_assumption "n") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["n"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "scanl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "take")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (repeat_tactic 1 9 (((use_arg_then "foldl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((((((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltSS")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["Hn"])) THEN (done_tac));
];;

(* Lemma scanlK *)
let scanlK = section_proof [] `(!x y. f x (g x y) = y) ==> (!x s. pairmap f x (scanl g x s) = s)` [
   (BETA_TAC THEN (move ["Hfg"]) THEN (move ["x"]) THEN (move ["s"]));
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (move ["x"])) THEN ((((use_arg_then "scanl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma pairmapK *)
let pairmapK = section_proof [] `(!x y. g x (f x y) = y) ==> (!x s. scanl g x (pairmap f x s) = s)` [
   (BETA_TAC THEN (move ["Hgf"]) THEN (move ["x"]) THEN (move ["s"]));
   ((((THENL) (((use_arg_then "x") (disch_tac [])) THEN (clear_assumption "x") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["y"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN (move ["x"])) THEN ((((use_arg_then "pairmap")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "scanl")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Finalization of the section Scan *)
let size_pairmap = finalize_theorem size_pairmap;;
let pairmap_cat = finalize_theorem pairmap_cat;;
let nth_pairmap = finalize_theorem nth_pairmap;;
let size_scanl = finalize_theorem size_scanl;;
let scanl_cat = finalize_theorem scanl_cat;;
let nth_scanl = finalize_theorem nth_scanl;;
let scanlK = finalize_theorem scanlK;;
let pairmapK = finalize_theorem pairmapK;;
end_section "Scan";;

(* Section Zip *)
begin_section "Zip";;
let zip = define `zip (x :: s) (y :: t) = (x, y) :: zip s t /\
	zip [] t = [] /\ zip s [] = []`;;
let unzip1 = new_definition `unzip1 = map FST`;;
let unzip2 = new_definition `unzip2 = map SND`;;

(* Lemma zip_unzip *)
let zip_unzip = section_proof ["s"] `zip (unzip1 s) (unzip2 s) = s` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "unzip1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "unzip2")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "PAIR")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "unzip1")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "unzip2")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma unzip1_zip *)
let unzip1_zip = section_proof ["s";"t"] `sizel s <= sizel t ==> unzip1 (zip s t) = s` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "unzip1")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "unzip1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma unzip2_zip *)
let unzip2_zip = section_proof ["s";"t"] `sizel t <= sizel s ==> unzip2 (zip s t) = t` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "unzip2")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then "unzip2")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size1_zip *)
let size1_zip = section_proof ["s";"t"] `sizel s <= sizel t ==> sizel (zip s t) = sizel s` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((repeat_tactic 1 9 (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size2_zip *)
let size2_zip = section_proof ["s";"t"] `sizel t <= sizel s ==> sizel (zip s t) = sizel t` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((((((use_arg_then "ltE")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma size_zip *)
let size_zip = section_proof ["s";"t"] `sizel (zip s t) = minn (sizel s) (sizel t)` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["t2"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "minn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "gtS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltS0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "minn")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "add1n")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "addn_minr")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "add1n")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma zip_cat *)
let zip_cat = section_proof ["s1";"s2";"t1";"t2"] `sizel s1 = sizel t1 ==> zip (s1 ++ s2) (t1 ++ t2) = zip s1 t1 ++ zip s2 t2` [
   (((THENL) (((use_arg_then "t1") (disch_tac [])) THEN (clear_assumption "t1") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((repeat_tactic 0 10 (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`0 = _`)]))))) THEN (repeat_tactic 0 10 (((use_arg_then "eqS0")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHs") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_zip *)
let nth_zip = section_proof ["x";"y";"s";"t";"i"] `sizel s = sizel t ==> nth (x, y) (zip s t) i = (nth x s i, nth y t i)` [
   (((THENL) (((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN elim) [ALL_TAC; ((move ["i"]) THEN (move ["IHi"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y1"]) THEN (move ["s1"]) THEN (move ["_"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y2"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))) THEN ((repeat_tactic 0 10 (((use_arg_then "size_nil")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then "eq_sym")(thm_tac (new_rewrite [] [(`0 = _`)]))))) THEN (repeat_tactic 0 10 (((use_arg_then "eqS0")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then "eqSS")(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then "IHi") (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_zip_cond *)
let nth_zip_cond = section_proof ["p";"s";"t";"i"] `nth p (zip s t) i
     = (if i < sizel (zip s t) then (nth (FST p) s i, nth (SND p) t i) else p)` [
   ((((use_arg_then "size_zip")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "ltnNge")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_minl")(thm_tac (new_rewrite [] [])))));
   (((THENL) (((use_arg_then "i") (disch_tac [])) THEN (clear_assumption "i") THEN ((use_arg_then "t") (disch_tac [])) THEN (clear_assumption "t") THEN ((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["y"]) THEN (move ["t"]) THEN (move ["_"]))]) THEN ((THENL) elim [ALL_TAC; ((move ["i"]) THEN (move ["_"]))]) THEN ((((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then "leqnn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "nth")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "leq0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then "ltE")(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then "leqSS")(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma zip_rcons *)
let zip_rcons = section_proof ["s1";"s2";"z1";"z2"] `sizel s1 = sizel s2 ==>
  zip (rcons s1 z1) (rcons s2 z2) = rcons (zip s1 s2) (z1, z2)` [
   ((BETA_TAC THEN (move ["eq_sz"])) THEN ((repeat_tactic 1 9 (((use_arg_then "cats1")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "zip_cat")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (repeat_tactic 1 9 (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma rev_zip *)
let rev_zip = section_proof ["s1";"s2"] `sizel s1 = sizel s2 ==> rev (zip s1 s2) = zip (rev s1) (rev s2)` [
   ((((THENL) (((use_arg_then "s2") (disch_tac [])) THEN (clear_assumption "s2") THEN ((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((THENL) case [ALL_TAC; ((move ["y"]) THEN (move ["s2"]))])) THEN (TRY ((((((use_arg_then "rev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "catrev")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac)))));
   (((repeat_tactic 1 9 (((use_arg_then "size_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "eqSS")(thm_tac (new_rewrite [] []))))) THEN (move ["eq_sz"]));
   (((repeat_tactic 1 9 (((use_arg_then "rev_cons")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "zip_rcons")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "size_rev")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN ((((use_arg_then "zip")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "rev_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (done_tac));
];;

(* Finalization of the section Zip *)
let zip_unzip = finalize_theorem zip_unzip;;
let unzip1_zip = finalize_theorem unzip1_zip;;
let unzip2_zip = finalize_theorem unzip2_zip;;
let size1_zip = finalize_theorem size1_zip;;
let size2_zip = finalize_theorem size2_zip;;
let size_zip = finalize_theorem size_zip;;
let zip_cat = finalize_theorem zip_cat;;
let nth_zip = finalize_theorem nth_zip;;
let nth_zip_cond = finalize_theorem nth_zip_cond;;
let zip_rcons = finalize_theorem zip_rcons;;
let rev_zip = finalize_theorem rev_zip;;
end_section "Zip";;

(* Section Flatten *)
begin_section "Flatten";;
(add_section_type (mk_var ("s", (`:(A)list`))));;
(add_section_type (mk_var ("ss", (`:((A)list)list`))));;
let flatten = new_definition `flatten = foldr cat []`;;
let shape = new_definition `shape = map sizel`;;
let reshape = define `reshape (n :: sh) s = take n s :: reshape sh (dropl n s) /\
	reshape [] s = []`;;

(* Lemma flatten0 *)
let flatten0 = section_proof [] `flatten [] = []` [
   (((((use_arg_then "flatten")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma flatten_cons *)
let flatten_cons = section_proof ["s";"ss"] `flatten (s :: ss) = s ++ flatten ss` [
   (((((use_arg_then "flatten")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma size_flatten *)
let size_flatten = section_proof ["ss"] `sizel (flatten ss) = sumn (shape ss)` [
   (((THENL) (((use_arg_then "ss") (disch_tac [])) THEN (clear_assumption "ss") THEN elim) [ALL_TAC; ((move ["s"]) THEN (move ["ss"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "flatten")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "shape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "flatten")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "shape")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma flatten_cat *)
let flatten_cat = section_proof ["ss1";"ss2"] `flatten (ss1 ++ ss2) = flatten ss1 ++ flatten ss2` [
   (((THENL) (((use_arg_then "ss1") (disch_tac [])) THEN (clear_assumption "ss1") THEN elim) [ALL_TAC; ((move ["s"]) THEN (move ["ss1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "flatten0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "flatten_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "catA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma flattenK *)
let flattenK = section_proof ["ss"] `reshape (shape ss) (flatten ss) = ss` [
   (((THENL) (((use_arg_then "ss") (disch_tac [])) THEN (clear_assumption "ss") THEN elim) [ALL_TAC; ((move ["s"]) THEN (move ["ss"]) THEN (move ["IHss"]))]) THEN ((((use_arg_then "flatten")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "shape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "reshape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "take_size_cat")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "drop_size_cat")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then "flatten")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "shape")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHss")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma reshapeKr *)
let reshapeKr = section_proof ["sh";"s"] `sizel s <= sumn sh ==> flatten (reshape sh s) = s` [
   ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "sh") (disch_tac [])) THEN (clear_assumption "sh") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["sh"]) THEN (move ["IHsh"]) THEN (move ["s"]) THEN (move ["sz_s"]))]);
   (((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "reshape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "flatten0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then "sumn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_cons")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "ltE")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (((use_arg_then "ltn0")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "reshape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "flatten")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "flatten")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))));
   (((((use_arg_then "IHsh")(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then "cat_take_drop")(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then "size_drop")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_sub_add")(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "sz_s") (disch_tac [])) THEN (clear_assumption "sz_s") THEN BETA_TAC));
   (((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma reshapeKl *)
let reshapeKl = section_proof ["sh";"s"] `sumn sh <= sizel s ==> shape (reshape sh s) = sh` [
   ((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN ((use_arg_then "sh") (disch_tac [])) THEN (clear_assumption "sh") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["sh"]) THEN (move ["IHsh"]) THEN (move ["s"]) THEN (move ["sz_s"]))]);
   (((THENL) elim [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["_"]))]) THEN ((((use_arg_then "reshape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "shape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((((use_arg_then "sz_s") (disch_tac [])) THEN (clear_assumption "sz_s") THEN BETA_TAC) THEN (((((use_arg_then "sumn")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "sumn")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (move ["sz_s"])));
   (((((use_arg_then "reshape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "shape")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "map")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "shape")(gsym_then (fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))))) THEN (((use_arg_then "size_takel")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "sz_s") (disch_tac [])) THEN (clear_assumption "sz_s") THEN ((use_arg_then "leq_trans") (disch_tac [])) THEN (clear_assumption "leq_trans") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then "leq_addr")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((((use_arg_then "IHsh")(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then "leq_add2l") (fun fst_arg -> (use_arg_then "n") (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "size_drop")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "add_sub_maxn")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "leq_maxr")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "sz_s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "orbT")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section Flatten *)
let flatten0 = finalize_theorem flatten0;;
let flatten_cons = finalize_theorem flatten_cons;;
let size_flatten = finalize_theorem size_flatten;;
let flatten_cat = finalize_theorem flatten_cat;;
let flattenK = finalize_theorem flattenK;;
let reshapeKr = finalize_theorem reshapeKr;;
let reshapeKl = finalize_theorem reshapeKl;;
end_section "Flatten";;

(* Section AllPairs *)
begin_section "AllPairs";;
(add_section_var (mk_var ("f", (`:S->T->R`))));;
(add_section_type (mk_var ("s", (`:(S)list`))));;
(add_section_type (mk_var ("t", (`:(T)list`))));;
let allpairs = new_definition `allpairs f s t = foldr (\x. cat (map (f x) t)) [] s`;;

(* Lemma size_allpairs *)
let size_allpairs = section_proof ["s";"t"] `sizel (allpairs f s t) = sizel s * sizel t` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "allpairs")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "size_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "mul0n")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "size_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "allpairs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_map")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "size_cons")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mulSn")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma allpairs_cat *)
let allpairs_cat = section_proof ["s1";"s2";"t"] `allpairs f (s1 ++ s2) t = allpairs f s1 t ++ allpairs f s2 t` [
   (((THENL) (((use_arg_then "s1") (disch_tac [])) THEN (clear_assumption "s1") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s1"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "allpairs")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "cat")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((repeat_tactic 1 9 (((use_arg_then "allpairs")(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "catA")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section AllPairs *)
let size_allpairs = finalize_theorem size_allpairs;;
let allpairs_cat = finalize_theorem allpairs_cat;;
end_section "AllPairs";;

(* Section EqAllPairs *)
begin_section "EqAllPairs";;
(add_section_var (mk_var ("f", (`:S->T->R`))));;
(add_section_type (mk_var ("s", (`:(S)list`))));;
(add_section_type (mk_var ("t", (`:(T)list`))));;

(* Lemma allpairsP *)
let allpairsP = section_proof ["s";"t";"z"] `(z <- allpairs f s t) <=> (?p. FST p <- s /\ SND p <- t /\ z = f (FST p) (SND p))` [
   (((THENL) (((use_arg_then "s") (disch_tac [])) THEN (clear_assumption "s") THEN elim) [ALL_TAC; ((move ["x"]) THEN (move ["s"]) THEN (move ["IHs"]))]) THEN ((((use_arg_then "allpairs")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "foldr")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then "in_nil")(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then "allpairs")(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "mapP")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "IHs")(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((THENL_FIRST) ((THENL) case [((case THEN (move ["y"])) THEN (case THEN ((move ["Hy"]) THEN (move ["eq"])))); ((case THEN (move ["p"])) THEN (case THEN ((move ["p1"]) THEN (case THEN ((move ["p2"]) THEN (move ["eq"]))))))]) ((((fun arg_tac -> arg_tac (Arg_term (`(x, y)`))) (term_tac exists_tac)) THEN (simp_tac)) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then "p") (term_tac exists_tac)) THEN (((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then "in_cons")(thm_tac (new_rewrite [] [])))) THEN (BETA_TAC THEN (case THEN (move ["p"])) THEN (case THEN (case THEN (move ["p_s"]))) THEN (case THEN ((move ["p_t"]) THEN (move ["eq"])))));
   ((DISJ1_TAC) THEN ((fun arg_tac -> arg_tac (Arg_term (`SND p`))) (term_tac exists_tac)) THEN (done_tac));
   ((DISJ2_TAC) THEN ((use_arg_then "p") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma mem_allpairs *)
let mem_allpairs = section_proof ["s1";"t1";"s2";"t2"] `(!x. x <- s1 <=> x <- s2) ==> (!y. y <- t1 <=> y <- t2) 
	==> (!p. p <- allpairs f s1 t1 <=> p <- allpairs f s2 t2)` [
   (BETA_TAC THEN (move ["eq_s"]) THEN (move ["eq_t"]) THEN (move ["z"]));
   ((repeat_tactic 1 9 (((use_arg_then "allpairsP")(thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN ALL_TAC THEN (case THEN (move ["p"]))) THEN (((((use_arg_then "eq_s")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "eq_t")(thm_tac (new_rewrite [] []))))) THEN (move ["fpz"])));
   (((use_arg_then "p") (term_tac exists_tac)) THEN (done_tac));
   (((use_arg_then "p") (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma allpairs_catr *)
let allpairs_catr = section_proof ["s";"t1";"t2"] `!p. p <- allpairs f s (t1 ++ t2) <=> p <- allpairs f s t1 ++ allpairs f s t2` [
   ((BETA_TAC THEN (move ["z"])) THEN (((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then "allpairsP")(thm_tac (new_rewrite [] [])))) THEN ((THENL) (split_tac) [(case THEN ((move ["p"]) THEN (case THEN (move ["sP1"])))); ALL_TAC]));
   (((THENL) ((((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((case THEN (move ["H"])) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) [(DISJ1_TAC); (DISJ2_TAC)]) THEN (((use_arg_then "allpairsP")(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then "p") (term_tac exists_tac)) THEN (done_tac));
   (case THEN ((((use_arg_then "allpairsP")(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["p"])) THEN (case THEN (move ["sp1"])) THEN (case THEN ((move ["sp2"]) THEN (move ["eq"])))) THEN ((use_arg_then "p") (term_tac exists_tac)) THEN ((((use_arg_then "mem_cat")(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then "sp2")(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section EqAllPairs *)
let allpairsP = finalize_theorem allpairsP;;
let mem_allpairs = finalize_theorem mem_allpairs;;
let allpairs_catr = finalize_theorem allpairs_catr;;
end_section "EqAllPairs";;
