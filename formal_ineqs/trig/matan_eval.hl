needs "trig/matan.hl";;

(*
module type Matan_eval_sig =
  sig
    val float_interval_matan : int -> thm -> thm
    val float_interval_dmatan : int -> thm -> thm
    val float_interval_ddmatan : int -> thm -> thm
  end;;

module Matan_eval : Matan_eval_sig = struct
*)

open Misc_functions;;
open Float_atn;;
open Float_theory;;
open Interval_arith;;
open More_float;;
open Arith_float;;
open Matan;;
open Misc_vars;;

prioritize_real();;

(* Creates an interval approximation of the given decimal term *)
let mk_float_interval_decimal =
  let DECIMAL' = SPEC_ALL DECIMAL in
    fun pp decimal_tm ->
      let n_tm, d_tm = dest_binary "DECIMAL" decimal_tm in
      let n, d = dest_numeral n_tm, dest_numeral d_tm in
      let n_int, d_int = mk_float_interval_num n, mk_float_interval_num d in
      let int = float_interval_div pp n_int d_int in
      let eq_th = INST[n_tm, x_var_num; d_tm, y_var_num] DECIMAL' in
	norm_interval int eq_th;;


(* Theorems for computations *)

mk_float_interval_decimal 10 `#0.9`;;

let th_rule = UNDISCH_ALL o PURE_REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL;;

let one_interval = mk_float_interval_small_num 1 and
    three_interval = mk_float_interval_small_num 3 and
    five_interval = mk_float_interval_small_num 5 and
    seven_float = mk_float 7 0 and
    two_float = mk_float 2 0 and
    one_float = mk_float 1 0;;

let interval_09 = mk_float_interval_decimal 10 `#0.9`;;
let interval_1e8 = mk_float_interval_decimal 10 `#0.00000001`;;
let float_1e8 = (fst o dest_pair o snd o dest_interval_arith o concl) interval_1e8;;

(* matan *)

let matan_gt0 = (th_rule o prove)(
  `!x. (&0 < x <=> T) /\ interval_arith (atn (sqrt x) / sqrt x) bounds
    ==> interval_arith (matan x) bounds`,
  REPEAT STRIP_TAC THEN REWRITE_TAC[matan] THEN
    ASM_SIMP_TAC[REAL_ARITH `&0 < x ==> ~(x = &0) /\ x > &0`]);;

let matan_abs1 = (th_rule o PURE_REWRITE_RULE[SYM (FLOAT_TO_NUM_CONV seven_float)] o prove)(
  `!x. 
    interval_arith x (lo, hi) /\
    interval_arith ((&1 - x / &3) + (x * x) / &5) (a, b) /\
    iabs (lo, hi) = u /\
    u <= #0.9 /\
    u * u <= u2 /\
    u2 * u <= u3 /\
    r1 <= &1 - u /\
    r2 <= &7 * r1 /\ (&0 < r2 <=> T) /\
    u3 / r2 <= e /\
    low <= a - e /\
    b + e <= high 
    ==> interval_arith (matan x) (low, high)`,
   REWRITE_TAC[interval_arith; GSYM IMP_IMP; iabs] THEN GEN_TAC THEN REPEAT DISCH_TAC THEN
     SUBGOAL_THEN `abs x <= u` (LABEL_TAC "u") THENL [
       REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     MP_TAC (SPECL[`2`; `x:real`] matan_abs1_bound) THEN ANTS_TAC THENL [
       REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REWRITE_TAC[TWO; ONE; SUM_CLAUSES_NUMSEG] THEN
     CONV_TAC NUM_REDUCE_CONV THEN
     REWRITE_TAC[real_pow; REAL_POW_1; REAL_POW_2] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
     MATCH_MP_TAC (REAL_ARITH `low <= s - r /\ s + r <= high ==> (abs (m - s) <= r ==> low <= m /\ m <= high)`) THEN
     ABBREV_TAC `e2 = abs x pow 3 / (&7 * (&1 - abs x))` THEN
     REWRITE_TAC[REAL_ARITH `(&1 + -- &1 / &3 * x) + &1 / &5 * x * x = &1 - x / &3 + (x * x) / &5`] THEN
     SUBGOAL_THEN `e2 <= e:real` ASSUME_TAC THENL [
       MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `u3 / r2:real` THEN ASM_REWRITE_TAC[] THEN
	 EXPAND_TAC "e2" THEN
	 SUBGOAL_THEN `&0 < &7 * (&1 - abs x)` ASSUME_TAC THENL [
	   MATCH_MP_TAC REAL_LT_MUL THEN
	     REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC;
	   ALL_TAC
	 ] THEN
	 ASM_SIMP_TAC[RAT_LEMMA4] THEN
	 MATCH_MP_TAC REAL_LE_MUL2 THEN REPEAT CONJ_TAC THENL [
	   MATCH_MP_TAC REAL_POW_LE THEN REAL_ARITH_TAC;
	   MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `u2 * u:real` THEN ASM_REWRITE_TAC[] THEN
	     REWRITE_TAC[ARITH_RULE `3 = SUC 2`; real_pow; REAL_ARITH `u2 * u = u * u2`] THEN
	     MATCH_MP_TAC REAL_LE_MUL2 THEN ASM_REWRITE_TAC[REAL_ABS_POS; REAL_LE_POW_2] THEN
	     MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `u * u:real` THEN ASM_REWRITE_TAC[] THEN
	     REWRITE_TAC[GSYM REAL_POW_2; GSYM REAL_LE_SQUARE_ABS] THEN
	     REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC;
	   MATCH_MP_TAC REAL_LT_IMP_LE THEN ASM_REWRITE_TAC[];
	   ALL_TAC
	 ] THEN
	 MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `&7 * r1` THEN ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_LMUL THEN CONJ_TAC THEN TRY REAL_ARITH_TAC THEN
	 MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC `&1 - u` THEN ASM_REWRITE_TAC[] THEN
	 ASM_REWRITE_TAC[REAL_ARITH `&1 - u <= &1 - x <=> x <= u`];
       ALL_TAC
     ] THEN
     REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);;


let float_interval_matan =
  let e_var_real = `e:real` and
      u_var_real = `u:real` and
      u2_var_real = `u2:real` and
      u3_var_real = `u3:real` and
      r1_var_real = `r1:real` and
      r2_var_real = `r2:real` in
  fun pp x_th ->
    let x_tm, bounds = dest_interval_arith (concl x_th) in
    let ltm, hi_tm = dest_comb bounds in
    let lo_tm = rand ltm in
    let flag, _ = float_prove_le lo_tm float_1e8 in
      if flag then
	(* Use series *)
	let u_eq = float_iabs bounds in
	let u_tm = rand (concl u_eq) in
	let flag, u_le_09 = float_prove_le_interval u_tm interval_09 in
	  if not flag then
	    failwith "float_interval_matan: the argument is out of range"
	  else
	    let s_th = 
	      let ( * ) = float_interval_mul pp and
		  ( / ) = float_interval_div pp and
		  ( + ) = float_interval_add pp and
		  ( - ) = float_interval_sub pp in
		(one_interval - x_th / three_interval) + (x_th * x_th) / five_interval in
	    let a_tm, b_tm = dest_pair (rand (concl s_th)) in
	    let uu_le_u2 = float_mul_hi pp u_tm u_tm in
	    let u2_tm = rand (concl uu_le_u2) in
	    let u2u_le_u3 = float_mul_hi pp u2_tm u_tm in
	    let u3_tm = rand (concl u2u_le_u3) in
	    let r1_le_1u = float_sub_lo pp one_float u_tm in
	    let r1_tm = rand (rator (concl r1_le_1u)) in
	    let r2_le_7r1 = float_mul_lo pp seven_float r1_tm in
	    let r2_tm = rand (rator (concl r2_le_7r1)) in
	    let u3r2_le_e = float_div_hi pp u3_tm r2_tm in
	    let e_tm = rand (concl u3r2_le_e) in
	    let low_le = float_sub_lo pp a_tm e_tm and
		high_ge = float_add_hi pp b_tm e_tm in
	    let low_tm = rand (rator (concl low_le)) and
		high_tm = rand (concl high_ge) in
	    let r2_gt0 = float_gt0 r2_tm in
	    let th0 = INST[x_tm, x_var_real; lo_tm, lo_var_real; hi_tm, hi_var_real;
			   a_tm, a_var_real; b_tm, b_var_real; e_tm, e_var_real;
			   u_tm, u_var_real; u2_tm, u2_var_real; u3_tm, u3_var_real;
			   r1_tm, r1_var_real; r2_tm, r2_var_real;
			   low_tm, low_var_real; high_tm, high_var_real] matan_abs1 in
	      itlist MY_PROVE_HYP [x_th; s_th; u_eq; u_le_09; uu_le_u2; u2u_le_u3;
				   r1_le_1u; r2_le_7r1; u3r2_le_e;
				   low_le; high_ge; r2_gt0] th0
      else
	(* atn (sqrt x) / (sqrt x) *)
	let r = float_interval_sqrt pp x_th in
	let atn_r = float_interval_atn pp r in
	  float_interval_div pp atn_r r;;
  


let float_interval_dmatan pp x_th =
  failwith "dmatan: Unimplemented";;

let float_interval_ddmatan pp x_th =
  failwith "ddmatan: Unimplemented";;


;;
search[`a pow 2 <= b pow 2`];;
search[`&0 <= x pow 2`];;
search[`a / b <= c / d`];;
RAT_LEMMA4;;
REAL_LE_LDIV_EQ;;

let pi_th = pi_approx_array.(3);;
float_iabs (rand (concl pi_th));;

    
mk_float_interval_small_num 1;;


(*end;;*)
