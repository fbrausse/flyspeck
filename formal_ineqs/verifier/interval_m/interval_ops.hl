(* =========================================================== *)
(* OCaml interval arithmetic                                   *)
(* Author: Thomas C. Hales                                     *)
(* Date: 2011-08-21                                            *)
(* =========================================================== *)

(* port of interval.cc,

This file gives a simple implementation of interval arithmetic,
together with the basic arithmetic operations on intervals.

It has been incompletely implemented.

For now, I am not implementing directed roundings.
However, McLaughlin implemented directed rounding several years ago:
See http://perso.ens-lyon.fr/nathalie.revol/mpfi.html
 ~/Library/McLaughlinOCAML/ocaml/src/extensions/ocaml-mpfi/

 *)

#directory "/home/alexey/Work/HOL/flyspeck-rw/formal_ineqs/verifier/interval_m/INTERVAL";;
 
module Interval_ops = struct

open Interval;;

exception Unstable;;

let mk_interval (a,b) = { low = a; high = b; };;

let string_of_interval x = Printf.sprintf "[%.20e;%.20e]" x.low x.high;;

(* let izero = mk_interval(0.0,0.0);; *)
let zero = mk_interval(0.0,0.0);;
let one = mk_interval(1.0,1.0);;
let two = mk_interval(2.0,2.0);;
let four = mk_interval(4.0,4.0);;

let is_zero x = (x.low = 0.0) && (x.high = 0.0);;

let pos x = if (x.low >= 0.0) then x else
   mk_interval(0.0,  if (x.high < 0.0) then 0.0 else x.high);;

let imax (x,y) = let t = max x.high y.high in mk_interval(t,t);;

let imin (x,y) = let t = min x.low y.low in mk_interval(t,t);;

let imin3(x,y,z) = imin(x,imin(y,z));;

let imax3(x,y,z) = imax(x,imax(y,z));;

let imax4(w,x,y,z) = imax(imax(w,x),imax(y,z));;

let sup x = x.high;;

let inf x = x.low;;

let iabs x = max x.high (~-. (x.low));;

let ilt x y = (x.high < y.low);;

let igt x y = (x.low > y.high);;

let ieq x y = (x.low = y.low && x.high = y.high);;

(* need rounding modes -- BUG *)


(*
(* start of bug section *)

let up() = (  (* bug *) );;
let down() = ( (* bug *) );;
let nearest() = ( (* bug *) );;
let upadd x y = ( x +. y);;  (* bug *)
let upmul x y = (x *. y);;
let updiv x y = (x /. y);;
let upsub x y = (x -. y);;
let downadd x y = (x +. y);;
let downmul x y = (x *. y);;
let downdiv x y = (x /. y);;
let downsub x y = (x -. y);;

(* end of bug section *)
*)


let interval_of_string =
  let dbl_min =1.0e-300 in
    fun (s1,s2) ->
      let ( - ) = Fpu.fsub_low in
      let lo = float_of_string s1 - dbl_min in
      let ( + ) = Fpu.fadd_high in
      let hi = float_of_string s2 + dbl_min in
	mk_interval(lo,hi);;

let interval_of_single s = interval_of_string (s,s);;

let ineg = ( ~-$ );;

let iadd = ( +$ );;

let imul = ( *$ );;

let isub = ( -$ );;

let isqrt x =
  let low = if x.low <= 0.0 then 0.0 else Fpu.fsqrt_low x.low in
  let high = if x.high <= 0.0 then 0.0 else Fpu.fsqrt_high x.high in
    mk_interval(low,high);;

let isin = sin_I;;

let icos = cos_I;;

let iatan = atan_I;;

let iacos x = 
  try acos_I x with Failure _ -> raise Unstable;;

let iasin x =
  try asin_I x with Failure _ -> raise Unstable;;

let combine x y = mk_interval(inf(imin(x,y)),sup(imax(x,y)));;

let rand01 =
  let random_int_seed = 81757 in
  let _ = Random.init(random_int_seed) in
    fun () -> Random.float(1.0);;

let bounded_from_zero  =
(*  let  dbl_epsilon = 1.0e-8 in *)
  let dbl_epsilon = 1.0e-16 in
    fun x -> (x.high < ~-. dbl_epsilon or x.low > dbl_epsilon);;

let idiv x y = 
  if bounded_from_zero y then
    x /$ y
  else
    raise Unstable;;
  
(* overload arithmetic ops *)

(*
let (+) = iadd;;
let (-) = isub;;
let (/) = idiv;;
let (~-) = ineg;;
*)
		   
end;;
