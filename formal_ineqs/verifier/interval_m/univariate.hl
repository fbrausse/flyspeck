(* =========================================================== *)
(* OCaml univariate functions                                  *)
(* Author: Thomas C. Hales                                     *)
(* Date: 2011-08-21                                            *)
(* =========================================================== *)

(* port of univariate.cc
   a univariate represents a function u:real->real.
   its first derivative du:real->real
   and its second derivative ddu;real->real.

   For example, if the function is x |-> x,
   its derivative is x |-> 1,
   and second derivative is x |-> 0,
   which is implemented as ux1.

   We give a few other examples, sqrt,  1/x, atan.

 *)

needs "verifier/interval_m/interval_ops.hl";;
 
module Univariate = struct

open Interval_ops;;

type univariate = {
  u : Interval.interval -> Interval.interval;
  du : Interval.interval -> Interval.interval;
  ddu : Interval.interval -> Interval.interval;
};;

let eval uni x  = function 
  | 0 -> uni.u x
  | 1 -> uni.du x
  | _ -> uni.ddu x;;

let mk_univariate (u1,du1,ddu1) = { u = u1; du = du1; ddu = ddu1; };;

let raise_zero x = bounded_from_zero x or raise Unstable ;;

(* here are a couple of examples *)

let ux1 =
  mk_univariate(
    (fun x -> x),
    (fun x -> one),
    (fun x-> zero)
  );;

let usqrt = 
  let ( / ) = idiv in
  let ( * ) = imul in
    mk_univariate(
      isqrt,

      (fun x -> 
	let _ = raise_zero x in
	  one / (two * isqrt x)),

      (fun x ->
	 let _ = raise_zero x in
	   ineg (one / ((two * isqrt x) * (two * x))))
);;

let uinv = 
  let ( / ) = idiv in
  let ( * ) = imul in
    mk_univariate(
      (fun x ->
	 let _ = raise_zero x in
	   one / x),

      (fun x ->
	 let _ = raise_zero x in
	   ineg (one / ( x * x))),

      (fun x ->
	 let _ = raise_zero x in
	    two / ( x * (x * x)))
    );;


let umatan =
  let one = mk_interval (1.0, 1.0) and
      two = mk_interval (2.0, 2.0) and
      three = mk_interval (3.0, 3.0) and
      five = mk_interval (5.0, 5.0) and
      seven = mk_interval (7.0, 7.0) in
  let ( * ) = imul and
      ( / ) = idiv and
      ( + ) = iadd and
      ( - ) = isub in
  mk_univariate(
    (fun x ->
(*       if x.low < 1.0e-16 then *)
       if x.low <= 1.0e-8 then
	 let u = iabs x in
	 if not (u <= 0.9) then
	   raise Unstable 
	 else
	   let x2 = x * x in
(*	   let ax = imax (x, ineg x) in
	   let error = x * x2 / (seven * (one - ax)) in
	     one - x / three + x2 / five + combine error (ineg error) *)
	   let s = (one - x / three) + x2 / five in
	   let u3 = Fpu.fmul_high u (Fpu.fmul_high u u) in
	   let r1 = Fpu.fsub_low 1.0 u in
	   let r2 = Fpu.fmul_low 7.0 r1 in
	   let err = Fpu.fdiv_high u3 r2 in
	   let low = Fpu.fsub_low s.low err and
	       high = Fpu.fadd_high s.high err in
	     mk_interval (low, high)
       else
	 let r = isqrt x in
	   iatan r / r),

    (fun x ->
       if x.low <= 1.0e-8 then
	 let u = iabs x in
	 if not (u <= 0.9) then
	   raise Unstable
	 else
(*	   let x2 = x * x in
	   let ax = imax (x, ineg x) in
	   let error = x2 / (two * (one - ax)) in
	     ineg (one / three) + two * x / five + combine error (ineg error) *)
	   let s = two * (x / five) - one / three in
	   let u2 = Fpu.fmul_high u u in
	   let r1 = Fpu.fsub_low 1.0 u in
	   let r2 = Fpu.fmul_low 2.0 r1 in
	   let err = Fpu.fdiv_high u2 r2 in
	   let low = Fpu.fsub_low s.low err and
	       high = Fpu.fadd_high s.high err in
	     mk_interval (low, high)
       else
	 let r = isqrt x in
	 let two_x = two * x in
	   one / (two_x * (x + one)) - iatan r / (two_x * r)),

    (fun x ->
       if x.low < -0.2 then
	 raise Unstable
       else
	 mk_interval (-0.65, 0.65))
    );;
	 

let ucos = 
  mk_univariate(
      icos,

      (fun x -> 
	 ineg (isin x)),

      (fun x ->
	 ineg (icos x))
    );;

let usin = 
  mk_univariate(
      isin,

      (fun x -> 
	 icos x),

      (fun x ->
	 ineg (isin x))
    );;


let uatan = 
  let ( / ) = idiv in
  let ( * ) = imul in
  let ( + ) = iadd in
    mk_univariate(
      iatan,

      (fun x ->
	 one / (one + x * x)),

      (fun x ->
	 let t = one / (one + x * x) in
	   (ineg two * x) * (t * t))
    );;


let uasin =
  let ( / ) = idiv in
  let ( * ) = imul in
  let ( - ) = isub in
    mk_univariate(
      iasin,
      (fun x ->
	 one / isqrt (one - x * x)),
      (fun x ->
	 let t = one - x * x in
	   x / isqrt (t * t * t))
    );;

let uacos =
  let ( / ) = idiv in
  let ( * ) = imul in
  let ( - ) = isub in
    mk_univariate(
      iacos,
      (fun x ->
	 ineg (one / isqrt (one - x * x))),
      (fun x ->
	 let t = one - x * x in
	 ineg (x / isqrt (t * t * t)))
    );;

end;;
