(* port of recurse.cc *)

flyspeck_needs "../port_interval/types.hl";;
flyspeck_needs "../port_interval/report.hl";;
flyspeck_needs "../port_interval/interval.hl";;
flyspeck_needs "../port_interval/univariate.hl";;
flyspeck_needs "../port_interval/line_interval.hl";;
flyspeck_needs "../port_interval/taylor.hl";;

module Recurse = struct

open Interval;;
open Univariate;;
open Line_interval;;
open Taylor;;

type cellOption = {
  only_check_deriv1_negative : bool;
  is_using_dihmax : bool;
  is_using_bigface126 : bool;
  width_cutoff : float;
  allow_sharp : bool;
  allow_derivatives : bool;
  mutable iteration_count : int;
  iteration_limit : int;
  recursion_depth : int;
};;

(* cell verification is complex, and we use exceptions to
    exit as soon as the status has been determined.   *)

type  cell_status = 
  | Cell_pass 
  | Cell_counterexample 
  | Cell_inconclusive of (float list * float list * float list * float list * taylor_function list);;

exception Return of  cell_status;;

let return c = raise (Return c);;


(* error checking and reporting functions *)

let string_of_domain x =
  let n = mth in
  Printf.sprintf "{%f, %f, %f, %f, %f, %f}" (n x 0) (n x 1) (n x 2) (n x 3) (n x 4) (n x 5);;

let string3 (x,z,s) =  (string_of_domain x ^"\n"^ string_of_domain z ^ "\n" ^ s);;

let boolify _ = true;;

let report_current = boolify o Report.report_timed o string3;;

let report_error = boolify o Report.report_error o string3;;

let report_fatal = boolify o Report.report_fatal o string3;;

(* let t = [0.1;0.2;0.3;0.4;0.5;0.6] in report_error (t,t,"ok");; *)

let periodic_count = 
  let end_count = ref 0 in
    fun () ->
      let _ = end_count := !end_count + 1 in
	(0 = ( !end_count mod 80000));;

let check_limit opt depth = 
  let _ = opt.iteration_count <- opt.iteration_count + 1 in
   ( opt.iteration_count < opt.iteration_limit or opt.iteration_limit = 0 ) &&
     (depth < opt.recursion_depth);;

(* general utilities *)

  

(* move this somewhere else! *)

let deltainf = 
  let ( * ) =  downmul in
  let ( + ) = downadd  in
  let  ( - ) = downsub in
  let ( ~- ) = ( ~-. ) in
    fun x1 x2 x3 x4 x5 x6 ->
      (down();
         ((~- x2)*x3)*x4 +((~-  x1)*x3)*x5 +((~-  x1)*x2)*x6 +((~-  x4)*x5)*x6 +
   x3*(x1 + x2 + x4 + x5)*x6 +  (x3*(~- x3- x6))*x6 +
   x2*x5*(x1 + x3 + x4 + x6) + x2*(x5*(~- x2-x5)) +
        x1*x4*(x2 + x3 + x5 + x6)+ x1*(x4*(~- x1-x4)));;

let sgn x = if (x.lo > 0.0) then 1 else if (x.hi < 0.0) then -1 else 0;;

let rec same_sgn x y = (x = []) or (sgn (hd x) = sgn (hd y) && same_sgn (tl x) (tl y));;


(* a bit tricky because unstable exceptions are common early on,
    and evaluations are very expensive. *)

let rec set_targets (x,z,x0,z0,tf,tis,opt,maxwidth,has_unstable) =
    try (
      if (tf = []) then
	let _ = not(has_unstable) or return (Cell_inconclusive (x,z,x0,z0,map snd tis)) in
	  List.rev tis
      else (
	let target = evalf (hd tf)  x z in

	let _ =  not( opt.only_check_deriv1_negative) or return
	  (if upper_partial target 0 < 0.0 then   Cell_pass
	   else if  lower_partial target 0 > 0.0 then Cell_counterexample
	   else Cell_inconclusive(x,z,x0,z0,tf)) in
	  
	let _ =  upper_bound target >= 0.0 or return Cell_pass in
	  
	  set_targets(x,z,x0,z0,tl tf,(target,hd tf)::tis,opt,maxwidth,has_unstable));	
    )
    with Unstable -> (
      if (2.0 *. maxwidth > opt.width_cutoff) 
      then set_targets(x,z,x0,z0,tl tf,tis,opt,maxwidth,true)  (* proclaim unstable *)
      else set_targets(x,z,x0,z0,tl tf,tis,opt,maxwidth,has_unstable) (* drop silently *);
    );
;;

let rec delete_false acc tis =
  if (tis=[]) then List.rev acc 
  else if (lower_bound (fst (hd tis)) > 0.0) then delete_false acc (tl tis) 
  else delete_false (hd tis::acc) (tl tis);;

let rec has_monotone tis x z x0 z0 is found  = match is with
  | [] -> (x,z,x0,z0,found)
  | j::js -> 
    let allpos = List.fold_left (fun a ti -> a && lower_partial (fst ti) j >= 0.0) true tis in
    let allneg = List.fold_left (fun a ti -> a && upper_partial (fst ti) j < 0.0) true tis in
    if (allpos) then
      let _ = (mth z j >= mth z0 j) or return Cell_pass in
      let setj u = table (fun i -> (if i=j then mth z j else mth u i))  in
	has_monotone tis  (setj x) (setj z) (setj x0) (setj z0) js true
    else if (allneg) then
      let _ = (mth x j <= mth x0 j) or  return Cell_pass in
      let setj u = table (fun i -> (if i=j then mth x j else mth u i))  in
	has_monotone tis  (setj x) (setj z) (setj x0) (setj z0) js true
    else has_monotone tis x z x0 z0 js found;;

let rec going_strong(x,z,x0,z0,tf,opt) =
  let (y,w) = center_form (x,z) in
  let maxwidth = maxl w in
  let tis = set_targets(x,z,x0,z0,tf,[],opt,maxwidth,false) in
  let epsilon_width = 1.0e-8 in
  let _ = (maxwidth >= epsilon_width) or return
	(if (opt.allow_sharp) then (Report.inc_corner_count(); Cell_pass) 
				   else Cell_counterexample) in
  let tis = delete_false [] tis in
  let _ = (List.length tis > 0) or return Cell_counterexample in
  let (x0,z0) = if (List.length tis < List.length tf) then (x,z)  else (x0,z0) in
  let (x,z,x0,z0,strong) = 
    if (opt.allow_derivatives) then has_monotone tis  x z x0 z0 iter6 false 
    else (x,z,x0,z0,false) in
    if (strong) then going_strong(x,z,x0,z0,map snd tis,opt) else (x,z,x0,z0,maxwidth,tis);;

let guess_optimal_corners (x,z,ti,tf) = 
  let mixedsign = List.fold_left (fun a i -> a or (sgn(mth ti.l.df i)=0)) false iter6 in
  let yyn = table (fun i-> mth (if sgn (mth  ti.l.df i) >0 then x else z) i)  in
  let yyu = table (fun i-> mth (if sgn (mth  ti.l.df i) >0 then z else x) i)  in
  let cn = line_estimate tf yyn in
  let cu = line_estimate tf yyu in
    (mixedsign,yyn,yyu,cn,cu);;

let rec drop_numerically_false acc (x,z,x0,z0,tis) =
    match tis with 
      | [] -> (x0,z0,List.rev tis)
      | (ti,tf) :: tiss -> 
	  if (ti.l.f.lo <= 0.0) then drop_numerically_false ((ti,tf)::acc) (x,z,x0,z0,tiss)
	  else 
	    let (mixedsign,yyn,yyu,cn,cu)= guess_optimal_corners(x,z,ti,tf) in
	      if (mixedsign) then drop_numerically_false ((ti,tf)::acc) (x,z,x0,z0,tiss)
	      else if (min cn.f.lo cu.f.lo > 0.0 && 
			 same_sgn ti.l.df cn.df && same_sgn ti.l.df cu.df) 
	      then drop_numerically_false acc (x,z,x,z,tiss)
	      else drop_numerically_false ((ti,tf)::acc) (x,z,x0,z0,tiss);;

let rec keep_numerically_true best (x,z,x0,z0,tis,evalue) = match tis with
  | [] -> 
       if (evalue < 0.0 && List.length best >0) then (x,z,best)
       else (x0,z0,tis)
  | (ti,tf)::tiss ->
      if (ti.l.f.hi > 0.0) then keep_numerically_true best (x,z,x0,z0,tiss,evalue)
      else
	let (mixedsign,yyn,yyu,cn,cu) = guess_optimal_corners(x,z,ti,tf) in
	let evalue' = max cn.f.hi cu.f.hi  in
	  if ((evalue' < evalue) &&
		same_sgn ti.l.df cn.df && same_sgn ti.l.df cu.df && not(mixedsign)) then
	    keep_numerically_true [(ti,tf)] (x,z,x0,z0,tiss,evalue')
	  else keep_numerically_true best (x,z,x0,z0,tiss,evalue);;    

let rec verify_cell (x,z,x0,z0,tf,opt) =
  try (
  let _ = not(periodic_count ()) or report_current (x,z,"periodic report") in
  let _ = not(opt.only_check_deriv1_negative) or (List.length tf <= 1) or 
	     failwith "verify_cell: incompatible options" in
	(* XX skip rad2, delta126, delta135 *)
  let (x,z,x0,z0,maxwidth,tis) = going_strong(x,z,x0,z0,tf,opt) in
  let (x0,z0,tis) =   if (maxwidth < opt.width_cutoff && opt.allow_derivatives)  
  then  drop_numerically_false [] (x,z,x0,z0,tis)   else (x0,z0,tis) in
  let _ = (List.length tis >0) or return Cell_counterexample in
  let (x0,z0,tis) = 
    if ((maxwidth<opt.width_cutoff)&&(List.length tis >1) && opt.allow_derivatives) 
    then keep_numerically_true [] (x,z,x0,z0,tis,0.0) else (x0,z0,tis) in
    Cell_inconclusive (x,z,x0,z0,map snd tis);
  )
  with Return c -> c;;

let rec recursive_verifier (depth,x,z,x0,z0,tf,opt) = 
  let _ = check_limit opt depth or report_fatal(x,z,Printf.sprintf "depth %d" depth) in
    match verify_cell(x,z,x0,z0,tf,opt)  with
      | Cell_counterexample -> false
      | Cell_pass -> true
      | Cell_inconclusive(x,z,x0,z0,tf) ->
	  (up();
	   let w = map (fun (z1,x1) -> upsub z1  x1) (zip z x) in
	   let wmax = maxl w in
	   let j_wide =   find (fun i -> mth w i = wmax) iter6 in
	   let y = updiv (upadd (mth x j_wide) ( mth z j_wide))  2.0 in
	   let delta b v =table (fun i-> if (i=j_wide && b) then y else mth v i) in
           recursive_verifier(depth+1, delta false x ,delta true z ,x0,z0,tf,opt) &&
           recursive_verifier(depth+1, delta true x ,delta false z ,x0,z0,tf,opt));;


end;;
