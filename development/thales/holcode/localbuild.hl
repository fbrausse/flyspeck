(* Nov 2010 *)

1;;


(* Desktop init.                                *)
let desktop_init _ = 
  let _ = load_path := 
     "/Users/thomashales/Desktop/googlecode/flyspeck/text_formalization/" :: 
       !load_path in
   needs "strictbuild.hl";;

desktop_init();;
(* #load "unix.cma";; (* dynamic loading not supported *) *)

let open_search =
  let _ = flyspeck_needs "general/tactics.hl" in
  let _ = flyspeck_needs "usr/thales/search_tac.hl" in
    reneeds "usr/thales/search_tac.hl";;

open Searching;;

(* laptop/desktop init *)
reneeds "build.hl";;
reneeds "strictbuild.hl";;


build_silent();;
build_and_report();;


(* END LOCAL BUILD *)

(* RUNNING LINEAR PROGRAMS, see build_lp.hl.  *)

(* START NONLINEAR INEQS *)
(* reneeds "nonlinear/ineqdata3q1h.hl";; *)
(* reneeds "nonlinear/strongdodec_ineq.hl";; *)


flyspeck_needs "leg/enclosed_def.hl";;
flyspeck_needs "general/sphere.hl";;
flyspeck_needs "nonlinear/parse_ineq.hl";;
flyspeck_needs "nonlinear/optimize.hl";;
reneeds "nonlinear/ineq.hl";;
reneeds "nonlinear/tame_table_ineq.hl";;
reneeds "nonlinear/parse_ineq.hl";;
reneeds "nonlinear/optimize.hl";;

let maybe i = (mem Tame_table_d i.tags);;
let maybes = Parse_ineq.nub (map (fun t -> t.idv) (filter maybe (!Ineq.ineqs)));;

let all_cases = 
  Parse_ineq.nub (map (fun t -> t.idv) (!Ineq.ineqs));;
List.length  all_cases;;

let finished_cases = 
  let split_sp=  Str.split (Str.regexp "\n") in
  let p = process_to_string ("cat "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			     ^"| sed  's/^.*ineq./\"/' " 
                             ^"| sed 's/., secs.*$/\";/'   "
			     ^"| sed 's/ split.*$//g' " 
                             ^"| sed 's/\"//g' "
			     ^" | sed 's/;//g' ") in
    Parse_ineq.nub (split_sp p);;
List.length finished_cases;;

let unfinished_cases = subtract all_cases finished_cases;;
List.length unfinished_cases;;


(*
let finished_splits = 
  let split_sp = Str.split(Str.regexp "\n") in
  let p = process_to_string("grep split "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			     ^"| sed  's/^.*ineq./\"/' " 
                             ^"| sed 's/., secs.*$/\";/'   "
			     ^"| sed 's/ split.*$//g' " 
                             ^"| sed 's/\"//g' "
			     ^" | sed 's/;//g' ") in
    Parse_ineq.nub (split_sp p);;


let hassplit =  
  let a = filter (fun t -> List.length (get_split t) > 0)  !Ineq.ineqs in 
  let a' = filter (fun t -> mem t.id  unfinished_cases) a in
    map (fun t-> t.id) a';;
List.length hassplit;;

*)




(* lists of inequality ids *)

let ignore = 
   [
"9563139965D"; (* derived lp, ignore it *)
  ] ;;

let testids = ref[];;
List.length !testids;;
let view nth = hd (Ineq.getexact (List.nth !testids nth));;
strip_idq(view 0);;
view 1;;

(* nub (map (fun t -> t.idv) (Ineq.getprefix "6941549865"));; *)

let thackmac=["QITNPEA 5653753305"; (* no longer generates *)];;

let malt = [ "QITNPEA 4003532128 b sym"; ];;

testids:= List.rev ( (subtract (intersect maybes unfinished_cases)  (ignore)));;
testids:=ignore;;
testids:=thackmac;;
testids:=   malt;;

let mm = (intersect maybes unfinished_cases);;
maybes;;
!testids;;

(* running one id *)
let testid = hd(!testids);;
Optimize.testsplit true testid;;
map (Optimize.testsplit true) !testids;;

(* goal *)

open Optimize;;

let (id,tags,case) = 
  let idq =  (hd(Ineq.getexact testid)) in
  let (s,tags,ineq) = Optimize.strip_idq idq in
  let ls = Optimize.get_split idq in
   if (ls=[]) then (s,tags,ineq) else
     let cases = Optimize.split_all_h0 [(ineq,ls)] in 
       (s^" case0",tags,hd cases);;

g (mk_imp (`NONLIN`,case));;
e(PRELIM_TAC);;
if (is_branch tags ) then e(BRANCH_TAC) else e(ALL_TAC);; 
if (is_xconvert tags) then e (X_OF_Y_TAC) else e(ALL_TAC);;
if (is_branch tags && not(is_xconvert tags)) then e(SERIES3Q1H_5D_TAC) else e(ALL_TAC);;
e (STYLIZE_TAC);;
e (WRAPUP_TAC);;




(* TESTING CFSQP *)

let cfsqp t = Parse_ineq.execute_cfsqp (hd(Ineq.getexact t));;
cfsqp (hd !testids);;
cfsqp "3862621143 a";
map cfsqp !testids;;
map Parse_ineq.execute_cfsqp (map (hd o Ineq.getexact) maybes);;


(* Parse_ineq.trialcount:= 500;; *)


(* SCRIPT *)
let svnstring = 
  "svn commit -m \"\" /Users/thomashales/Desktop/googlecode/flyspeck";;
let svn_commit() = Sys.command(svnstring);;

let test_and_commit t = (let _ = testsplit true t in svn_commit());;

!testids;;


let weekend_jan28() = map test_and_commit ( !testids);;

(*
weekend_jan28();;
*)


Sys.command("svn /Users/Users/thomashales/Desktop/googlecode/flyspeck");
flyspeck_needs "general/sphere.hl";;
reneeds "nonlinear/ineq.hl";;
reneeds "nonlinear/parse_ineq.ml";;
reneeds "nonlinear/optimize.hl";;
map (testsplit_report true) ( !testids);;

(* Timing *)

let finished_times,finished_rejects = 
  let split_sp = Str.split (Str.regexp "\n") in
  let split_semi = Str.split (Str.regexp ";") in
  let int_s [x;y] = (x,int_of_string y) in
  let p = process_to_string ("cat "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			      ^"| sed 's!^//.*$!!'"
			     ^"| sed  's/^.*ineq(//' " 
                             ^"| sed 's/., svn.*$//'   "
			      ^"| sed 's/., secs./;/' "
                             ) in
  let (accept,rejects) = partition (fun t -> List.length t =2)  
		 (map split_semi (split_sp p)) in
     (map int_s accept,Parse_ineq.nub rejects);;

let rec finalize = function (* use time from most recent verification *)
  | [] -> []
  | (x,t)::vs -> if (exists (fun (x',_) -> (x'=x)) vs) then finalize vs
    else  (x,t)::(finalize vs);;

let times =   
  let ft = finalize finished_times in
  let split = Str.split(Str.regexp " +split") in
  let fti = filter (fun (x,_) -> mem (hd (split x)) all_cases) ft in
    sort (fun (_,y) (_,y') -> (y>y')) fti;;

let total r = 
  let rr = map snd r in
    end_itlist (+) rr;;

let hour r = float_of_int r /. (60.0 *. 60.0);;

hour (total times);;

(filter (fun (_,t) -> t>2500) times);;

