
(* PROJECT BUILD *)


(* USEFUL CONSTRUCTS *)

let report s =
  Format.print_string s; Format.print_newline();;

let scriptfile = ref "";;


let outlog = ref "/Users/thomashales/Dropbox/thacklog.hl";;
let errlog = ref "/Users/thomashales/Dropbox/thackerrory.hl";;
let sleep = ref (6);;
let emsg = ref "/";;
let msg = ref ".";;
scriptfile;;

let doubleout fl s = 
      let _ =       report s in
      let _ = Parse_ineq.output_filestring fl s in
	();;

doubleout !errlog "err";;
doubleout !outlog "ok";;

let rec loop () = 
  let _ = try ( loadt (!scriptfile)) 
  with _ -> (doubleout (!errlog) (!emsg)) in
  let _ = Unix.sleep(!sleep) in
  let _ = doubleout (!outlog) (!msg) in
    loop();;


loadt (!scriptfile);;
loop();;

g `?(x:A) . f A`

let (EXISTSv_TAC :string -> tactic) = 
   fun s (asl,g) ->
     let (v,_) = dest_binder "?" g in 
     let (_,ty) = dest_var v in
       EXISTS_TAC (mk_var(s,ty)) (asl,g);;

(* generalize *)

let ( TYPE_VAR :string -> (term -> tactic) -> tactic) = 
    fun s tm_tactic (asl,g) ->
      let (_,r) = dest_comb g in
      let (v,_) = dest_abs r in
      let (_,ty) = dest_var v in
	tm_tactic (mk_var(s,ty)) (asl,g);;

TYPE_VAR "x" EXISTS_TAC;
;;
Format.print_flush();;
FINITE_EMPTY;;

searcht 10 [`eulerA_hexall_x`];;

Sphere.num_combo1;;

(*
process_to_string "cat qed_log.txt | sed  's/^.*ineq./\"/' | sed 's/., secs.*$/\";/'  "

cat qed_log.txt | sed  's/^.*ineq./"/' | sed 's/., secs.*$/";/' | sort -u | wc  

(*
let _ = Sys.command("cat "^flyspeck_dir^"/../interval_code/qed_log.txt");;
*)
*)


let ee () = 
  let b = (false or (let _ = Sys.command("date") in failwith "h")) in b;;


suggest();;

EXISTSv_TAC "y";

dest_binder "?" (`?(x:A). f A`);;

(*

let searchl = sortlength_thml o search;;
let take = Lib_ext.take;;
let searcht r = take 0 5 (searchl r);;
let searchtake i j r = take i j (searchl r);;

*)
term_match;;
INSTANTIATE;;
  open Searching;;

definitions();;
State_manager.neutralize_state();;
let vv = (eval("1+1")) + 3;;
let vv = (eval("REFL `T`"));;
concl vv;;

prefixes();;
rev(infixes());;
binders();;
unparse_as_infix;;
map (List.nth (infixes())) (95--131);;
unparse_as_binder "!";;
binders();;

sort (<) [`y3:real`;`y2:real`];;

Sphere.all_forall `(y1 + y3 + y2  = y0 + y7)`;;

REAL_FIELD `x > &0 /\ y > &0 ==> x * y > &0`;;

find_path ((=) `4`) `(sum (3..4) f)`;;  (* lrr *)

help "MK_CONJ";;
Temp_in.generate_ineq_datum_p;;
List.length !theorems;;

let kill_process n = Sys.command (Printf.sprintf "sudo kill -9 %d" n);;

search [`min`];;
type_of `max`;;

help_grep "conj";;
help "list_mk_conj";;
 end_itlist;;

FROZEN_REWRITE_TAC [REAL_ARITH `b + d = d - (--b)`];;

Print_types.goal_types();;
Print_types.print_term_types `#2`;;
Print_types.print_thm_types (REFL `1`);;


edge_flat_x;;
Print_types.print_term_types 
`dih_hexall_x x14 x12 x23 x1 x2 x3 x4 x5 (x6:real) = 
   dih_x x1 x2 x4 ((&2 * h0) pow 2) x14 x12 - dih_x x1 x3 x4 x5 x14 (edge_flat2_x x2 x1 x3 (&0)    x23 x12)`;;


(*
(* parsing printing *)
let pterm = Print_types.print_term_types;;
let tterm = Print_types.print_thm_types;;

#install_printer print_qterm;;


#install_printer Goal_printer.print_goal_hashed;;
#install_printer Goal_printer.print_goalstack_hashed;;

#remove_printer Goal_printer.print_goal_hashed;;
#remove_printer Goal_printer.print_goalstack_hashed;;

#print_length 1000;;
*)

search[`f (x:A) (g (y:A) z) = f (g x y) z`];; (* min, max, + /\, \/ *, compose, monoidal ops,
   APPEND, a - (b + c) = a - b - c /\ a - (b - c) = a - b + c),
    p ==> q ==> r <=> p /\ q ==> r);; *)

find_term  ( can (term_match[ `r a (r y z) = r (r x y) z`])) (concl IMP_IMP);;

filter_pred;;
can (term_match[]);;
type_of;;

constant_of_regexp "at.*[gn]$";;

constant_of_regexp "FILTER";;
searcht 15 [`cos`];;
def_of_string "FILTER";;

def_of_string "fan";;
conjuncts `!a b c. (u /\ v /\ (!c. w /\ r) /\ (!x y. r2 /\ r3))`;;


help "dest_forall";;
List.nth !theorems 0;;

help_grep ".*TAC$";;

INFINITE_DIFF_FINITE;;
search[`INFINITE`;`DIFF`];;

Tame_general.sol0_over_pi_EQ_const1;;
Tame_general.sol0_POS;;
def_of_string "dih_x";;
search[name "SQRT_MUL_POW_2"];;

search[`sqrt x = sqrt y`];;
search[`sqrt x = y`;`x = y pow 2`];;
search[`sqrt (x * y) = sqrt x * sqrt y`];;
search[`&0 <= a*a `];;
searcht 5 [`x <= y`;`y >= x`];;
search[`sqrt x * sqrt x`];;
search [`&0 pow 2`];;

type_of `bn_facesAt`;;


flyspeck_needs "hypermap/bauer_nipkow.hl";;
search[name "ACS_2"];;


Format.set_max_boxes 100;;
let tt = hol_of_smalllist (1--300);;
string_of_my_term tt;;



let hel i = help (List.nth  tacsss i );;

hel 1;;

constant_of_regexp "sol";;

apropos;;
suggest;;


(* get all word counts in HOL LIGHT and FLYSPECK *)

let match_mp_strip =
  fun th ->
          let tm = concl th in
          let avs,bod = strip_forall tm in
          let ant,con = dest_imp bod in
          let th1 = SPECL avs (ASSUME tm) in
          let th2 = UNDISCH th1 in
          let evs = filter (fun v -> vfree_in v ant & not (vfree_in v con))
                           avs in
          let th3 = itlist SIMPLE_CHOOSE evs (DISCH tm th2) in
          let tm3 = hd(hyp th3) in
            MP (DISCH tm (GEN_ALL (DISCH tm3 (UNDISCH th3)))) th;;

let mp_short_list = 
  let u = fst(chop_list 50 (trigger_counts "MATCH_MP_TAC")) in
  let sl = map fst !theorems in
  let f1 = filter (fun (t,_) -> mem t sl ) u in
  let f2 = map (fun (s,n) -> (s,n,assoc s !theorems)) f1 in
    filter (fun (_,_,t) -> can  match_mp_strip t) f2;;


let relevant_match_mp r = 
  filter (fun (_,_,t) -> can (MATCH_MP_TAC t) r) mp_short_list;;

let suggest_match_mp () = relevant_match_mp (top_realgoal());;

mp_short_list;;

tachy"rep";;

tcs;;

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/ .*$//g'


let recent_search = ref [""];;

let refcount = ref [("",0)];;

trigger_counts "MATCH_MP_TAC";;

EQ_EXT;;
FINITE_SUBSET;;
search[regexp "EQ_SYM"];;
tachy "amt";;
tachy "asmcase";;

(* to get tacticals as well *)
(* grep "TYPE.*tactic" -i *.doc -l | sed 's/.doc//g' *)

List.length tactic_list;;
List.length(tachy "");;
subtract tactic_list (tachy "");;
tachy "bool";;

help "SUBST1_TAC";;

let typesss ss = 
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; grep TYPE "^ss^".doc | sed 's/TYPE[^{]*//g' )") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

typesss "ALL_TAC";;
help "SUBST1_TAC";;

(*
let MP_TAC_BAK = MP_TAC;;
let MATCH_MP_TAC_BAK = MATCH_MP_TAC;;
*)


let mp_theorems = ref[];;
let incr1 thm = (mp_theorems:= thm::!mp_theorems);;

let MP_TAC_COUNT t  = 
  let _ = incr1 t in MP_TAC_BAK t;;

let MP_TAC = MP_TAC_COUNT ;;

let MATCH_MP_TAC_COUNT t  = 
  let _ = incr1 t in MATCH_MP_TAC_BAK t;;

let MATCH_MP_TAC = MATCH_MP_TAC_COUNT ;;
let MATCH_MP_TAC = MATCH_MP_TAC_BAK ;;


reneeds "trigonometry/trig2.hl";;

let thm_hash = Hashtbl.create 1000;;
map (fun (x,y) -> Hashtbl.add thm_hash y x) (!theorems);;

let find_name th = 
  try (Hashtbl.find thm_hash th) with Not_found -> "ANONYMOUS";;

PI_POS;;
List.length !mp_theorems;;
 filter (fun s -> not (s="ANONYMOUS"))  (map find_name (!mp_theorems));;

SIN_COS_SQRT;; 
COS_INJ_PI;;
REAL_LT_MUL;;
HULL_INC;;
Real_ext.REAL_PROP_NN_SQRT;;
stactics;;
help "ASM_CASES_TAC";;
help "BOOL_CASES_TAC";;
ignore;;

List.length (search[`x:A`]);;

List.length (search[`x > (y:real)`]);; (* 111 *)

List.length (search[`x > &0`]);; (* 67 *)
 (search[`x > y`; omit `x > &0`]);; (* complicated thing > simple thing. *)
List.length (search[`x < y`]);; (* 1438 *)

List.length (search[`x >= &0`]);; (* 11 *)
List.length (search[`x <= (y:real)`]);; (* 1830 *)
List.length (search[`x >= y`; omit `x >= &0`]);; (* 85, complicated thing > simple thing. *)


(* IN -- no rhyme or reason. *)
List.length(search[`(IN)`])  (* 3455 *);;
List.length(search[`SETSPEC`]);;  (* 1071 *);;
List.length(search[`SETSPEC`;`(IN)`]);;  (* 568 *)
dest_comb `{x | T} y`;;
List.length (search[`y IN (GSPEC f)`]);; (* 23 *)
 (search[`y IN {u | f}`]);; (* 14 *)
(search[`{u | f} y`]);; (* 3 *)
(searcht 40 [`(IN)`;omit `SETSPEC`]);;  

dest_comb `{x | x > 0}`;;

List.length (search[`x < y`]);; (* 1438 *)

search[`cross`;`collinear`];;
search[`(a cross b) cross c`];;
search[`c cross (a cross b) `];;

search[`sqrt(x) = y`];;

(* search, what is the arc cosine called?  acs *)

`(?x. a) /\ b ==> c`;;
STRIP_TAC;;

search[];;
searcht 15 [`inv`];;
search[rewrite `inv`;`( / )`];;
searcht 5 [rewrite `inv`;`a*b`];;
search [regexp "[dD]iff"];;
is_rewrite "inv" ("",REAL_INV_MUL);;
heads (snd(dest_thm(REAL_INV_MUL)));;

288. /. 32.;;
Toploop.execute_phrase;;


types();;

constants();;
heads(concl(hd(definitions())));;




(* experiments *)

let _ = 
  let dds = map fst def_assoc in
    sort (fun (_,a) (_,b) -> a > b) (map (fun t-> (t,stm_depth t)) dds);;




let thm_depthnth n =
  let (s,th) = List.nth !theorems n in
  let d = thm_depth th in (s,d,th);;


tm_depth `!a b.  (&2 <= a /\ a <= #2.52) /\ &2 <= b /\ b <= #2.52
         ==>( ((\x. -- (&4 + a pow 2 - x pow 2)/(a * sqrt(ups_x (a pow 2) (b pow 2) (&4)))) has_real_derivative
              (&32 * a * b /( (sqrt (ups_x (a pow 2) (b pow 2) (&4))) pow 3)))
             (atreal b within real_interval [&2,#2.52]))`;;

let depth_filter n = filter (fun (_,t)-> 
	  let (_,c) = hd (thm_depth t) in (c <= n));;

searcht 10 [`has_real_derivative`;`real_div`];;
(* now distance between constants *)

help_grep_flags "rat" "i";;

help "REAL_RAT_REDUCE_CONV";;
stm_depth "pi";;
stm_depth "cos";;
stm_depth "sin";;
assoc "pi" def_assoc;;

thm_depthnth 1000;;

stm_depth "?";;
stm_depth "!";;
stm_depth "hull";;
stm_depth "uniformly_continuous_on";;
stm_depth "real_add";;
stm_depth "treal_add";;
stm_depth "hreal_add";;
stm_depth "nadd_eq";;
stm_depth "dist";;
stm_depth "-";;
stm_depth "PRE";;
stm_depth "_0";;
assoc "_0" def_assoc;;

dest_const `(+)`;;
s_depth "arclength";;

c_depth `acs`;;
c_depth `(@)`;;
assoc `T` def_assoc;;

rho_node;;

c_of [] `sin(cos (x + y))`;;

searcht 5 [`a/b + c/d`];;

let ratform  = new_definition `ratform p r a b = (p ==> ~(b = &0) /\ (r = a/b))`;;

let ratform_tac =   REWRITE_TAC [ratform] THEN
    REPEAT STRIP_TAC THENL
    [ASM_MESON_TAC[REAL_ENTIRE] ;
    REPEAT (FIRST_X_ASSUM (fun t -> MP_TAC t THEN ANTS_TAC THEN ASM_REWRITE_TAC[])) THEN 
    REPEAT STRIP_TAC THEN 
    ASM_REWRITE_TAC[] THEN 
    REPEAT (POP_ASSUM MP_TAC) THEN 
    CONV_TAC REAL_FIELD];;

let REAL_POW_NEQ_0 = prove_by_refinement(
  `!x n. ~(x pow n = &0) <=> ~(x = &0) \/ (n = 0)`,
  (* {{{ proof *)
  [
  MESON_TAC[REAL_POW_EQ_0];
  ]);;
  (* }}} *)

let ratform_add = prove_by_refinement(
  `ratform p1 r1 a1 b1 /\ ratform p2 r2 a2 b2 ==> ratform (p1 /\ p2) (r1 + r2) (a1 * b2 + b1 * a2) (b1 * b2)`,
  (* {{{ proof *)
  [
  ratform_tac;
  ]);;
  (* }}} *)

let ratform_sub = prove_by_refinement(
  `ratform p1 r1 a1 b1 /\ ratform p2 r2 a2 b2 ==> ratform (p1 /\ p2) (r1 - r2) (a1 * b2 - b1 * a2) (b1 * b2)`,
  (* {{{ proof *)
  [
    ratform_tac;
  ]);;
  (* }}} *)


let ratform_neg = prove_by_refinement(
  `ratform p1 r1 a1 b1 ==> ratform p1 (-- r1 ) (-- a1 ) (b1)`,
  (* {{{ proof *)
  [
    ratform_tac;
  ]);;
  (* }}} *)

let ratform_mul = prove_by_refinement(
  `ratform p1 r1 a1 b1 /\ ratform p2 r2 a2 b2 ==> ratform (p1 /\ p2) (r1 * r2) (a1 * a2) (b1 * b2)`,
  (* {{{ proof *)
  [
    ratform_tac;
  ]);;
  (* }}} *)

let ratform_inv = prove_by_refinement(
  `ratform p1 r1 a1 b1 ==> ratform (p1 /\ ~(a1= &0)) (inv r1) b1 a1`,
  (* {{{ proof *)
  [
  REWRITE_TAC [ratform;];
    REPEAT STRIP_TAC;
    ASM_MESON_TAC[REAL_ENTIRE];
    REPEAT (FIRST_X_ASSUM (fun t -> MP_TAC t THEN ANTS_TAC THEN ASM_REWRITE_TAC[]));
    REPEAT STRIP_TAC;
    ASM_REWRITE_TAC[REAL_INV_DIV];
  ]);;
  (* }}} *)

let ratform_div = prove_by_refinement(
  `ratform p1 r1 a1 b1 /\ ratform p2 r2 a2 b2 ==> ratform (p1 /\ p2 /\ ~(a2 = &0)) (r1 / r2) (a1 * b2) (b1 * a2)`,
  (* {{{ proof *)
  [
  ratform_tac;
  ]);;
  (* }}} *)

let mk_ratform =
  let rf = `ratform` in
    fun p r a b -> list_mk_comb (rf ,[p;r;a;b]);;

let dest_ratform rf =
    snd(strip_comb rf);;

let trivial_ratform = prove_by_refinement(
  `!t. ratform T t t (&1)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ratform];
    REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let clean_ratform = prove_by_refinement(
  `ratform p r a b /\ (p = p') /\ (a = a') /\ (b = b') ==> ratform p' r a' b'`,
  (* {{{ proof *)
  [
  MESON_TAC[];
  ]);;
  (* }}} *)

let pre_rationalize = 
  let   binop_assoc = [(`(+)`,ratform_add);(`( * )`,
					    ratform_mul);(`( - )`,ratform_sub);
		       (`( / )`,ratform_div)] in
  let unary_assoc = [(` ( -- )`,ratform_neg);(`inv`,ratform_inv)] in
  let rec pre_rationalize tm = 
    try (
      let h = fst (strip_comb tm) in
      let bin_th = assoc h binop_assoc in
      let (x,y) = dest_binop h tm in
	MATCH_MP bin_th (CONJ (rationalize x) (rationalize y))
    )
    with _ -> (
      try (
	let (h,x) = dest_comb tm in
	let un_th = assoc h unary_assoc in
	  MATCH_MP un_th (rationalize x)
      )
      with _ -> SPEC tm trivial_ratform) in
    pre_rationalize;;

let rationalize = 
  let rc = REWRITE_CONV[REAL_POW_NEQ_0;GSYM CONJ_ASSOC;REAL_ARITH `&1 * x = x /\ x * &1 = x` ]  in
  fun tm ->
    let pr = pre_rationalize tm in
    let [p;_;a;b] = dest_ratform (concl pr) in
    let p' = rc p in
    let a' = rc a in
    let b' = rc b in
      MATCH_MP clean_ratform (end_itlist CONJ [pr;p';a';b']);;



rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;

searcht 5 [`x pow n = &0`];;

help_grep "REAL_RAT";;
    
pre_rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;

strip_comb `&1 + &2`;;
dest_comb;;




REAL_INV_DIV;;

searcht 5 [`inv`;`a/b`];;
searcht 5 [`a/b + c/d`];;
searcht 5 [

let rat_add = !p1 r1 a1 b1 p2 r2 a2 b2.  (p1 ==> ~(b1 = &0) /\ (r1 = a1/b1

