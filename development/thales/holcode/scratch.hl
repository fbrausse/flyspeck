
(* PROJECT BUILD *)


(* USEFUL CONSTRUCTS *)

let report s =
  Format.print_string s; Format.print_newline();;

g `?(x:A) . f A`

(* generalize *)

let ( TYPE_VAR :string -> (term -> tactic) -> tactic) = 
    fun s tm_tactic (asl,g) ->
      let (_,r) = dest_comb g in
      let (v,_) = dest_abs r in
      let (_,ty) = dest_var v in
	tm_tactic (mk_var(s,ty)) (asl,g);;

TYPE_VAR "x" EXISTS_TAC;
;;
Format.print_flush();;
FINITE_EMPTY;;

searcht 10 [`eulerA_hexall_x`];;

Sphere.num_combo1;;

(*
process_to_string "cat qed_log.txt | sed  's/^.*ineq./\"/' | sed 's/., secs.*$/\";/'  "

cat qed_log.txt | sed  's/^.*ineq./"/' | sed 's/., secs.*$/";/' | sort -u | wc  

(*
let _ = Sys.command("cat "^flyspeck_dir^"/../interval_code/qed_log.txt");;
*)
*)


let ee () = 
  let b = (false or (let _ = Sys.command("date") in failwith "h")) in b;;


suggest();;

EXISTSv_TAC "y";

dest_binder "?" (`?(x:A). f A`);;

(*

let searchl = sortlength_thml o search;;
let take = Lib_ext.take;;
let searcht r = take 0 5 (searchl r);;
let searchtake i j r = take i j (searchl r);;

*)
term_match;;
INSTANTIATE;;
  open Searching;;

definitions();;
State_manager.neutralize_state();;
let vv = (eval("1+1")) + 3;;
let vv = (eval("REFL `T`"));;
concl vv;;

prefixes();;
rev(infixes());;
binders();;
unparse_as_infix;;
map (List.nth (infixes())) (95--131);;
unparse_as_binder "!";;
binders();;

sort (<) [`y3:real`;`y2:real`];;

Sphere.all_forall `(y1 + y3 + y2  = y0 + y7)`;;

REAL_FIELD `x > &0 /\ y > &0 ==> x * y > &0`;;

find_path ((=) `4`) `(sum (3..4) f)`;;  (* lrr *)

help "MK_CONJ";;
Temp_in.generate_ineq_datum_p;;
List.length !theorems;;

let kill_process n = Sys.command (Printf.sprintf "sudo kill -9 %d" n);;

search [`min`];;
type_of `max`;;

help_grep "conj";;
help "list_mk_conj";;
 end_itlist;;

FROZEN_REWRITE_TAC [REAL_ARITH `b + d = d - (--b)`];;

Print_types.goal_types();;
Print_types.print_term_types `#2`;;
Print_types.print_thm_types (REFL `1`);;


edge_flat_x;;
Print_types.print_term_types 
`dih_hexall_x x14 x12 x23 x1 x2 x3 x4 x5 (x6:real) = 
   dih_x x1 x2 x4 ((&2 * h0) pow 2) x14 x12 - dih_x x1 x3 x4 x5 x14 (edge_flat2_x x2 x1 x3 (&0)    x23 x12)`;;


(*
(* parsing printing *)
let pterm = Print_types.print_term_types;;
let tterm = Print_types.print_thm_types;;

#install_printer print_qterm;;


#install_printer Goal_printer.print_goal_hashed;;
#install_printer Goal_printer.print_goalstack_hashed;;

#remove_printer Goal_printer.print_goal_hashed;;
#remove_printer Goal_printer.print_goalstack_hashed;;

#print_length 1000;;
*)

search[`f (x:A) (g (y:A) z) = f (g x y) z`];; (* min, max, + /\, \/ *, compose, monoidal ops,
   APPEND, a - (b + c) = a - b - c /\ a - (b - c) = a - b + c),
    p ==> q ==> r <=> p /\ q ==> r);; *)

find_term  ( can (term_match[ `r a (r y z) = r (r x y) z`])) (concl IMP_IMP);;

filter_pred;;
can (term_match[]);;
type_of;;

constant_of_regexp "at.*[gn]$";;

constant_of_regexp "FILTER";;
searcht 15 [`cos`];;
def_of_string "FILTER";;

def_of_string "fan";;
conjuncts `!a b c. (u /\ v /\ (!c. w /\ r) /\ (!x y. r2 /\ r3))`;;


help "dest_forall";;
List.nth !theorems 0;;

help_grep ".*TAC$";;

INFINITE_DIFF_FINITE;;
search[`INFINITE`;`DIFF`];;

Tame_general.sol0_over_pi_EQ_const1;;
Tame_general.sol0_POS;;
def_of_string "dih_x";;
search[name "SQRT_MUL_POW_2"];;

search[`sqrt x = sqrt y`];;
search[`sqrt x = y`;`x = y pow 2`];;
search[`sqrt (x * y) = sqrt x * sqrt y`];;
search[`&0 <= a*a `];;
searcht 5 [`x <= y`;`y >= x`];;
search[`sqrt x * sqrt x`];;
search [`&0 pow 2`];;

type_of `bn_facesAt`;;


flyspeck_needs "hypermap/bauer_nipkow.hl";;
search[name "ACS_2"];;


Format.set_max_boxes 100;;
let tt = hol_of_smalllist (1--300);;
string_of_my_term tt;;



let hel i = help (List.nth  tacsss i );;

hel 1;;

constant_of_regexp "sol";;

apropos;;
suggest;;


(* get all word counts in HOL LIGHT and FLYSPECK *)

let match_mp_strip =
  fun th ->
          let tm = concl th in
          let avs,bod = strip_forall tm in
          let ant,con = dest_imp bod in
          let th1 = SPECL avs (ASSUME tm) in
          let th2 = UNDISCH th1 in
          let evs = filter (fun v -> vfree_in v ant & not (vfree_in v con))
                           avs in
          let th3 = itlist SIMPLE_CHOOSE evs (DISCH tm th2) in
          let tm3 = hd(hyp th3) in
            MP (DISCH tm (GEN_ALL (DISCH tm3 (UNDISCH th3)))) th;;

let mp_short_list = 
  let u = fst(chop_list 50 (trigger_counts "MATCH_MP_TAC")) in
  let sl = map fst !theorems in
  let f1 = filter (fun (t,_) -> mem t sl ) u in
  let f2 = map (fun (s,n) -> (s,n,assoc s !theorems)) f1 in
    filter (fun (_,_,t) -> can  match_mp_strip t) f2;;


let relevant_match_mp r = 
  filter (fun (_,_,t) -> can (MATCH_MP_TAC t) r) mp_short_list;;

let suggest_match_mp () = relevant_match_mp (top_realgoal());;

mp_short_list;;

tachy"rep";;

tcs;;

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/ .*$//g'


let recent_search = ref [""];;

let refcount = ref [("",0)];;

trigger_counts "MATCH_MP_TAC";;

EQ_EXT;;
FINITE_SUBSET;;
search[regexp "EQ_SYM"];;
tachy "amt";;
tachy "asmcase";;

(* to get tacticals as well *)
(* grep "TYPE.*tactic" -i *.doc -l | sed 's/.doc//g' *)

List.length tactic_list;;
List.length(tachy "");;
subtract tactic_list (tachy "");;
tachy "bool";;

help "SUBST1_TAC";;

let typesss ss = 
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; grep TYPE "^ss^".doc | sed 's/TYPE[^{]*//g' )") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

typesss "ALL_TAC";;
help "SUBST1_TAC";;

(*
let MP_TAC_BAK = MP_TAC;;
let MATCH_MP_TAC_BAK = MATCH_MP_TAC;;
*)


let mp_theorems = ref[];;
let incr1 thm = (mp_theorems:= thm::!mp_theorems);;

let MP_TAC_COUNT t  = 
  let _ = incr1 t in MP_TAC_BAK t;;

let MP_TAC = MP_TAC_COUNT ;;

let MATCH_MP_TAC_COUNT t  = 
  let _ = incr1 t in MATCH_MP_TAC_BAK t;;

let MATCH_MP_TAC = MATCH_MP_TAC_COUNT ;;
let MATCH_MP_TAC = MATCH_MP_TAC_BAK ;;


reneeds "trigonometry/trig2.hl";;

let thm_hash = Hashtbl.create 1000;;
map (fun (x,y) -> Hashtbl.add thm_hash y x) (!theorems);;

let find_name th = 
  try (Hashtbl.find thm_hash th) with Not_found -> "ANONYMOUS";;

PI_POS;;
List.length !mp_theorems;;
 filter (fun s -> not (s="ANONYMOUS"))  (map find_name (!mp_theorems));;

SIN_COS_SQRT;; 
COS_INJ_PI;;
REAL_LT_MUL;;
HULL_INC;;
Real_ext.REAL_PROP_NN_SQRT;;
stactics;;
help "ASM_CASES_TAC";;
help "BOOL_CASES_TAC";;
ignore;;

List.length (search[`x:A`]);;

List.length (search[`x > (y:real)`]);; (* 111 *)

List.length (search[`x > &0`]);; (* 67 *)
 (search[`x > y`; omit `x > &0`]);; (* complicated thing > simple thing. *)
List.length (search[`x < y`]);; (* 1438 *)

List.length (search[`x >= &0`]);; (* 11 *)
List.length (search[`x <= (y:real)`]);; (* 1830 *)
List.length (search[`x >= y`; omit `x >= &0`]);; (* 85, complicated thing > simple thing. *)


(* IN -- no rhyme or reason. *)
List.length(search[`(IN)`])  (* 3455 *);;
List.length(search[`SETSPEC`]);;  (* 1071 *);;
List.length(search[`SETSPEC`;`(IN)`]);;  (* 568 *)
dest_comb `{x | T} y`;;
List.length (search[`y IN (GSPEC f)`]);; (* 23 *)
 (search[`y IN {u | f}`]);; (* 14 *)
(search[`{u | f} y`]);; (* 3 *)
(searcht 40 [`(IN)`;omit `SETSPEC`]);;  

dest_comb `{x | x > 0}`;;

List.length (search[`x < y`]);; (* 1438 *)

search[`cross`;`collinear`];;
search[`(a cross b) cross c`];;
search[`c cross (a cross b) `];;

search[`sqrt(x) = y`];;

(* search, what is the arc cosine called?  acs *)

`(?x. a) /\ b ==> c`;;
STRIP_TAC;;

search[];;
searcht 15 [`inv`];;
search[rewrite `inv`;`( / )`];;
searcht 5 [rewrite `inv`;`a*b`];;
search [regexp "[dD]iff"];;
is_rewrite "inv" ("",REAL_INV_MUL);;
heads (snd(dest_thm(REAL_INV_MUL)));;

288. /. 32.;;
Toploop.execute_phrase;;


types();;

constants();;
heads(concl(hd(definitions())));;




(* experiments *)

let _ = 
  let dds = map fst def_assoc in
    sort (fun (_,a) (_,b) -> a > b) (map (fun t-> (t,stm_depth t)) dds);;




let thm_depthnth n =
  let (s,th) = List.nth !theorems n in
  let d = thm_depth th in (s,d,th);;


tm_depth `!a b.  (&2 <= a /\ a <= #2.52) /\ &2 <= b /\ b <= #2.52
         ==>( ((\x. -- (&4 + a pow 2 - x pow 2)/(a * sqrt(ups_x (a pow 2) (b pow 2) (&4)))) has_real_derivative
              (&32 * a * b /( (sqrt (ups_x (a pow 2) (b pow 2) (&4))) pow 3)))
             (atreal b within real_interval [&2,#2.52]))`;;

let depth_filter n = filter (fun (_,t)-> 
	  let (_,c) = hd (thm_depth t) in (c <= n));;

searcht 10 [`has_real_derivative`;`real_div`];;
(* now distance between constants *)

help_grep_flags "rat" "i";;

help "REAL_RAT_REDUCE_CONV";;
stm_depth "pi";;
stm_depth "cos";;
stm_depth "sin";;
assoc "pi" def_assoc;;

thm_depthnth 1000;;

stm_depth "?";;
stm_depth "!";;
stm_depth "hull";;
stm_depth "uniformly_continuous_on";;
stm_depth "real_add";;
stm_depth "treal_add";;
stm_depth "hreal_add";;
stm_depth "nadd_eq";;
stm_depth "dist";;
stm_depth "-";;
stm_depth "PRE";;
stm_depth "_0";;
assoc "_0" def_assoc;;

dest_const `(+)`;;
s_depth "arclength";;

c_depth `acs`;;
c_depth `(@)`;;
assoc `T` def_assoc;;

rho_node;;

c_of [] `sin(cos (x + y))`;;

searcht 5 [`a/b + c/d`];;


searcht 5 [`x pow n = &0`];;

help_grep "REAL_RAT";;
    
pre_rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;

strip_comb `&1 + &2`;;
dest_comb;;




REAL_INV_DIV;;

searcht 5 [`inv`;`a/b`];;
searcht 5 [`a/b + c/d`];;
let (rr,_)=hd[(`(+)`,ratform_add);
		       (`( * )`,ratform_mul);(`( - )`,ratform_sub);
		       (`( / )`,ratform_div)];;
type_of rr;;
rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;
Calc_derivative.derivative_form `\q. sin(q pow 5)` `t:real` `{}:real->bool`;;
pre_rationalize `inv (w)`;;

Calc_derivative.derivative_form `(\x. --(&4 + a pow 2 - x pow 2) /       (a * sqrt (ups_x (a pow 2) (x pow 2) (&4))))` `b:real` `real_interval [&2,#2.52]`;;

searcht 5[`x pow 1`];;

search [name "HAS_REAL";name "COS"];;

search [`(within)`;`(:real)`];;

open Calc_derivative;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `\x. x pow 3 + x * x - x * -- x + x/(x + &1)`in 
      differentiate tm x s;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `(\q:real. (q  - sin(q pow 3) + q pow 7 + y)/(q pow 2  + q pow 4 *(&33 + &43 * q)) +  (q pow 3) *  ((q pow 2) / (-- (q pow 3))))` in
      differentiate tm x s;;

  let th2 = 
    let x = `x:real` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;
  
  let th3 = 
    let x = `&5` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;


(* prove rational identity modulo accumulating assumptions *)

  let   equ = `(&1 / u  - &1/v) pow 2  = inv u pow 2 - &2 * inv (u * v) + inv v pow 2`;;
  let eq0 = MATCH_MP (REAL_ARITH `u - v = &0 ==> (u=v)`);;

CONV_RULE rc (pre_rationalize `&1 / (x + y) - &1 / (x - y) - (-- &2 * y / (x pow 2 - y pow 2))`);;
  let lite_imp = MESON[] `ratform p a ;;

REAL_FIELD ` ((x - y - (x + y)) * (x pow 2 * &1 pow 2 - &1 pow 2 * y pow 2) -
      ((x + y) * (x - y)) * -- &2 * y * &1 pow 2 * &1 pow 2) = &0`;;
  
mk_neg;;
mk_binop;;

searcht 5 [`(a1 pow n / b1 pow n)`];;

let ratform_tac =   
    REWRITE_TAC [ratform] THEN
    REPEAT STRIP_TAC THENL
    [ASM_MESON_TAC[REAL_ENTIRE] ;
    REPEAT (FIRST_X_ASSUM (fun t -> MP_TAC t THEN ANTS_TAC THEN 
			     ASM_REWRITE_TAC[])) THEN 
    REPEAT STRIP_TAC THEN 
    ASM_REWRITE_TAC[] THEN 
    REPEAT (POP_ASSUM MP_TAC) THEN 
    CONV_TAC REAL_FIELD];;



let ratform_pow = prove_by_refinement(
  `ratform p1 r1 a1 b1 ==> ratform p1 (r1 pow n) (a1 pow n) (b1 pow n)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[ratform;GSYM REAL_POW_DIV];
  ratform_tac;
  ]);;
  (* }}} *)

rational_identity `&1 / (x + y) - &1 / (x - y) = -- &2 * y / (x pow 2 - y pow 2)`;;


REAL_FIELD `&2 * x * y - &2 * y * x`;;


   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) in

   let hooked_deriv hook =
     let assumed_rules = map mk_derived hook in
     let d_hyp tm  = 
       let r =        assoc tm assumed_rules in
       let _ = print_thm r in
	 r in

    let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` ) in 

differentiate_hook [`(f has_real_derivative (&17)) (atreal x within (:real))`] `\x. ((f:real->real) x) pow 2` `x:real` `(:real)`;;

  differentiate_hook [`(f has_real_derivative f') (atreal x within (:real))`] `f:real->real` `x:real` `(:real)`;;

let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` );;


mk_derived `(f has_real_derivative (&17)) (atreal x within (:real))`;;
assoc `f:real->real` [it];;
differentiate_hook;;

`(f has_real_derivative f') (atreal x within (:univ))`;;

  let d_hyp assumed_rules tm =
    snd(find (fun (r,s) -> aconv tm r) assumed_rules);;


let triv2 = prove_by_refinement(
  `f f' x s. derived_form ((f has_real_derivative f') (atreal x)) f f' x (:real)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[derived_form;WITHINREAL_UNIV];
  ]);;
  (* }}} *)


(* acceptable forms
   `!x s. p ==> (f has_real_derivative f') (atreal x within s)`
   `!x s. p ==> (f has_real_derivative f') (atreal x)`
   `!x s. derived_form f f' x s`;;
*)

let thm5 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x s.  (derived_form (p x) f (f' x) x s))) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;


let thm4 = prove_by_refinement(
  `!x s. derived_form (!x s.  (f has_real_derivative f' x) (atreal x within s)) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let thm3 = prove_by_refinement(
  `!x s. derived_form (!x.  (f has_real_derivative f' x) (atreal x)) f (f' x) x s`,
  (* {{{ proof *)
  [
   REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm2 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x. p x ==> (f has_real_derivative f' x) (atreal x) )) f (f' x) x s`,
  (* {{{ proof *)
  [
     REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm1 = prove_by_refinement(
  `! x s. derived_form (p x /\ (!x s. p x==> (f has_real_derivative f' x) (atreal x within s)))
    f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let mk_derived  = 
  let     form1 =    `!x s. p x==> (f has_real_derivative f' x) (atreal x within s)`in
  let     form2 =    `!x. p x ==> (f has_real_derivative f' x) (atreal x)` in
  let     form3 =    `!x.  (f has_real_derivative f' x) (atreal x)` in
  let     form4 =    `!x s.  (f has_real_derivative f' x) (atreal x within s)` in
  let     form5 =    `!x s.  derived_form p f f' x s` in
  let fls =  [
    (form1,thm1);(form2,thm2);(form3,thm3);(form4,thm4);(form5,thm5)] in
  let mm tm (r,s) = 
    let ins = term_match [] r tm in
      INST ((fun (_,a,_) -> a) ins) s in
    fun tm -> 
      tryfind (mm tm) fls;;




df tm4;;
search [`within`;`atreal`;`has_real_derivative`;name "HAS_REAL"];;
let tm5 = `!x u. derived_form q g g' x u`;;
let tm4 = `!x u. (x > &0) ==> (g has_real_derivative (x pow 2)) (atreal x within u)`;;
if (can (term_match [] form5) tm) then tm else ( failwith "form5");;
MATCH_MP th4 tm4;;
MATCH_MP;;
let ins =  (term_match [] form4) tm4 ;;
INST ((fun (_,a,_) -> a) ins)  thm4;;

mk_derived tm5;;

   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) ;;

 


MATCH_MP;;


  

type_of `has_real_derivative`;;
types_of `derived_form ((f has_real_deriv f') (atreal x within s))`;;



snd(top_realgoal());;
let (h1,[f;f';r]) = strip_comb (snd(top_realgoal()));;
let _ = (h1 = `(has_real_derivative)`) or 
  failwith "form 'f has_real_derivative f' atreal b within s' expected." ;;
let (h2,[atb;s1]) = strip_comb r;;
let (h3,b) = dest_comb atb;;
1;;
1;;

BETA_CONV;;

let data = 
[("    * JLIGZGS ",14);
("    * AMHFNXP ",26);
("    * WBLARHH ",3);
("    * BSXAQBQ ",16);];;

let data=[
("packing ",0);
( "   * SLTSTLO ",12);
( "   * RVFXZBU ",14);
( "   * URRPHBZ ",2);
( "   * QZYZMJC ",1);
( "   * GRUTOTI ",10);
( "   * KIZHLTL ",26);
( "   * TSKAJXY ",1);
( "   * OXLZLEZ ",7);
( "   * UPFZBZM ",16);
( "   * RDWKARC ",5);
( "   * EUSOTYP ",23);
( "   * GOTCJAH ",30);
( "   * DLWCHEM ",30);
( "   * XULJEPR ",14);];;

let data=[
(" local ",0);
( "   * EGHNAVX ",26);
( "   * XRECQNS ",15);
( "   * MHAEYJN ",46);
( "   * ZLZTHIC ",0);
( "   * EJRCFJD ",17);
( "   * NKEZBFC ",7);
( "   * BGMIFTE ",36);
( "   * WSEWPCH ",25);
];;

let data=[
("tame ",0);
( "   * FNJLBXS ",35);
( "   * FCDJDOT ",10);
( "   * KCBLRQC ",21);];;

List.fold_left (+) 0 (map snd data);;



search[`A INTER B = B INTER A`];;

search[`&0 <= x * x`];;
REAL_ENTIRE;;

time REAL_RING `a' = &2 * a /\ b' = a*a - &4 * b /\ x2 * y1 = x1 /\ y2 * y1 pow 2 = &1 - b * x1 pow 4 /\ y1 pow 2 = &1 + a * x1 pow 2 + b * x1 pow 4 /\ ~(y1 = &0) ==> y2 pow 2 = &1 - a' * x2 pow 2 + b' * x2 pow 4`;;

Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `(:real)`;;

time Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `{x | x > &0}`;;




searcht 5 [`(a,b) = (c,d)`];;
``,
    if (NULLSET X) then {} else
        (let (k,ul) = cell_params V X in set_of_list (truncate_simplex (k-1) ul))`;;

LET_TAC;;

g `!(x). (x = x) \/ (!(x:num). x = x) \/ (!(y:bool). y = y)`;;

Print_types.print_goal_var_overload();;



  let tm1 = `p /\ (q ==> r)`
  and tm2 = `p ==> q` in
  let th1,th2 = CONJ_PAIR(ASSUME tm1) in
  let th = itlist DISCH [tm1;tm2] (MP th2 (MP(ASSUME tm2) th1)) in
    th;;

help "ASM_REAL_ARITH_TAC";;

hash_of_term `p /\ q ==> r`;;

`(x:real):real`;;

`(&1):real`;;

tachy "rt";;


eval_goal `a /\ b /\ c /\ d ==> r /\ s`;;
eval_tactic_abbrev "rt/a,[TRUTH]";;

st/r,
rt/a,[];;

(!Toploop.parse_toplevel_phrase (Lexing.from_string ("let xx = `&1`;;")));;

eval_command "let xx = `(x:real) + 2`;;";;

eval_command "failwith \"hi\" ;;";;
eval_command "assocrx";;

thm_depth FACET_OF_POLYHEDRON;;
searcht 15 [`norm x = &1`];;


 let tachit s = 
   let alpha_num = Str.regexp "[a-z_A-Z]+" in
    let _ = Str.string_match alpha_num s 0 or failwith "tachit" in
    let m = Str.matched_string s in
    let ns = (break_init m s) in
    let n = if (String.length n > 0)
      el n (tachy m)   ;;
tachit "sgth";;
tachy "sgth";;

Str.regexp;;
String.escaped "/\\ ";;

Sys.command;;
Sys.command "date";;



(*
let lemma = prove_by_refinement(
  `!a b . (!t. a < t ==> b <= t) ==> (!t. a <= t ==> b <= t)`,
  (* {{{ proof *)
[
REPEAT STRIP_TAC ;
DISJ_CASES_TAC (REAL_ARITH `a< t \/ a = t \/ t < a`);
ASM_MESON_TAC [];
HASH_UNDISCH_TAC 1429 ;
DISCH_THEN DISJ_CASES_TAC;
ASM_REWRITE_TAC [REAL_ARITH `b<=t <=> (t < b ==> F)`];
DISCH_TAC ;
HASH_RULE_TAC 6466 (SPEC `(a + b)/ (&2)`);
ASM_REAL_ARITH_TAC ;
ASM_REAL_ARITH_TAC 
]
);;
  (* }}} *)
*)
*)
]
);;
  (* }}} *)


search [`polar_cycle_on`];;


  [



searcht 15 [`FINITE (x:real->bool)`;`(<)`];;
searcht 15 [`(polar_cycle_on x V = r)`];;
Trigonometry2.polar_cycle_on;;
searcht 15 [`(polar_lt x y = z)`];;
searcht 15 [`tri_itv`];;

searcht 20 [name "INDUC";];;

FINITE_INDUCT_STRONG;;


searcht 5 [`sup s IN r`];;
searcht 5 [`s DELETE r HAS_SIZE n`];;
searcht 5 [`s HAS_SIZE 0`];;
searcht 15 [`CARD (x INSERT s)`];;
searcht 5 [`{} SUBSET x`];;
searcht 5 [`x < 0`];;
searcht 5 [`{x | F}`];;
searcht 5 [`IMAGE f {}`];;


searcht 5 [`arg_diff`];;

searcht  5 [`x:complex`];;

searcht 15 [`~(x = {})`];;

search [`Arg`];;
search [`directed_angle`];;
searcht 50 [`f:num->num->num`;omit `nsum`;omit `monoidal`;omit `SUC`;omit `EVEN`;omit `((+):num->num->num)`];;
searcht 5 [`(MOD)`];;

net_of_cong (ASSUME `p ==> (r = s)`) (basic_congs());;

basic_congs();;
mk_prover;;
rand;;
rand `x = y`;;
enter;;
help "IMP_RES_THEN";;

List.length tactic_counts;;
  end_itlist (fun (_,t) (_,u) -> ("",t + u)) tactic_counts20;;

tactic_counts;;
    let total = 516794.0;;
(177618.0 +. 14899.0) /. total;;
(11965.0 +. 22441.0 +. 4993.0) /. total;;
(3591.0) /. total;;
779.0 /. total;;
assoc "INDUCT_TAC" tactic_counts;;
    let tactic_counts20 = map (fun i -> el i tactic_counts) (0--9);;

498727.0 /. total;;


37.25 +. 14.5 +. 4.0 +. 3.0 +. 2.9 +. 2.5 +. 2.3 +. 2.3 +. 3.1 +. 1.6 +. 2.6 +. 1.4;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE];
REPEAT STRIP_TAC;
ASM_MESON_TAC[FINITE_EMPTY;Misc_defs_and_lemmas.EMPTY_EXISTS;];
]);;
FINITE_EMPTY;;
INFINITE;;
FINITE_EMPTY;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE;GSYM Misc_defs_and_lemmas.EMPTY_EXISTS];
CONV_TAC (CONTRAPOS_CONV);
 THEN MESON_TAC[FINITE_EMPTY];

]);;

help "CONTRAPOS_CONV";;
FINITE_EMPTY;;
INFINITE;;
FINITE_EMPTY;;

search[`x IN {}`];;
Misc_defs_and_lemmas.EMPTY_EXISTS;;

FINITE_EMPTY;;
searcht 15 [`x IN S`;`{}`];;


(* save. find strange constants *)

let symbolic_of cnames = 
  let symbolchar = explode "=-~.,@#$%^&*|\\/?><" in
    filter (fun t -> not (intersect (explode t) symbolchar=[])) cnames;;

let symbolic_constants = symbolic_of (map fst (constants()));;
let symbolic_infixes = symbolic_of (map fst (infixes()));;


searcht 5 [name "CHAIN";`has_derivative`];;
apropos();;
help "apropos_derivative";;
Calc_derivative.differentiate;;
Calc_derivative.derived_form;;
Calc_derivative.differentiate `cos` `x:real` `(:real)`;;

help;;
help "help";;

type_of `vector`;;

type_of;;
let types_of = Print_types.print_term_types;;
let type_of_thm = Print_types.print_thm_types;;
let type_of_goal = Print_types.print_goal_types;;
help_grep "type";;

searcht 5 [`has_real_derivative`;`lift`];;
searcht 50 [`has_vector_derivative`;];;
searcht 50 [`has_derivative`;`has_real_derivative`];;
searcht 50 [`has_derivative`;`within`];;
searcht 15 [`($)`];;
help "search";;

help "apropos_types";;
types_of `($)`;;
has_derivative;;

type_of_thm HAS_DERIVATIVE_IMP_DIFFERENTIABLE;;
type_of_thm has_derivative;;
type_of_thm HAS_REAL_FRECHET_DERIVATIVE_AT;;

type_of `:1`;;
search [`x:1`];;



search [`func`];;
searcht 15 [`continuous`];;

map (fun t -> (t,type_of t)) (frees ` (!(y:real^6). p y ==> (continuous) (lift o f'') (at y within s))`);;


searcht 5 [`has_derivative`;name "CHAIN"];;
type_of_thm DIFF_CHAIN_AT;;
search[`has_derivative`];;





searcht 50 [`hypermap1_of_fanx`];;
hypermap1_of_fanx;;

Polyhedron.POLYHEDRON_FAN;;


Polyhedron.AMHFNXP;;

suggest();;
searcht 5 [`arclength`;`acs`];;
Trigonometry1.ACS_ARCLENGTH;;

let new_thm_name = prove_by_refinement(
  `3 + 4 = 7`,
  (* {{{ proof *)
  [
  ARITH_TAC
  ]);;
  (* }}} *)

help "ANTS_TAC";;

let arclength2 = prove_by_refinement(
  `!h.  (&1 <= h /\ h <= h0) ==> arclength (&2) (&2 * h) (&2) = acs(h / &2)`,
  (* {{{ proof *)
  [
  REPEAT STRIP_TAC;
  MP_TAC (SPECL [`&2`;`&2 * h`;`&2`] Trigonometry1.ACS_ARCLENGTH);
  BRANCH_A [
    ANTS_TAC ;
    MP_TAC Sphere.h0;
    ASM_REAL_ARITH_TAC;
  ];
  DISCH_THEN SUBST1_TAC;
  AP_TERM_TAC;
  UNDISCH_TAC `&1 <= h`;
  BY (CONV_TAC REAL_FIELD);
  ]);;
  (* }}} *)

Polyhedron.FLVNSME;;

Polyhedron.WBLARHH;;

Polyhedron.fchanged;;

searcht 25 [`cell_params`];;
FAN;;
search[name "JACO";name "WORK"];;
search[`jacobian`];;
matrix;;
search[`fchanged`];;
fan80;;
List.length (search[`fan80`]);;
constant_of_regexp "TET";;
apropos();;
help "apropos_searching";;
searcht 5 [`delta_x`;`vol`];;
conv0;;
def_assoc;;
def_of_regexp "critical";;
def_of_regexp "edgeX";;
def_of_regexp "VX";;
def_of_regexp "cell_params";;
def_of_regexp "barV";;
def_of_regexp "cycle";;
def_of_regexp "tri_itv";;
def;;
searcht 15 [`cw_dart_fan`];;
searcht 15 [`directed_angle`];;
searcht 15 [`cyclic_order`];;
searcht 15 [`pl_angle`];;
searcht 15 [`arg_diff`];;
searcht 15 [`tri_itv`];;
search [`Arg`];;
type_of_thm Trigonometry2.pl_angle;;
help "MESON_TAC";;
search [`FAN`;`&2 * pi`];;
usage_count `FAN`;;
1+1;;
usage_count `fan`;;
search [name "ULEK"];;
search [name "VBT"];;
search [name "W_SUBSET_SINGLETON"];;
search [`fan`];;
search [`polar_le`];;
List.length (search [`azim_cycle`;omit `local_fan`;omit `FAN`;omit `convex_local_fan`;omit `darts_of_hyp`;omit `EE`]);;
search [`wedge_ge`];;
usage_count `arg_diff`;;
usage_count `pl_angle`;;

let usage_count x = List.length (search [x]);;

(* marking *)
reset();;
show_marked();;

let marked = ref [];;
let show_marked() = map (fun t-> (t,assoc t !theorems)) (!marked);;
let mark s = 
  let th = assoc s (!theorems) in
  let _ = marked := s::!marked in
  th;;
let resetm() = marked:=[];;


term_match [] `s:C` `s:E->G`;;
frees_of_goal();;
`(r:B -> D) ((f:A->B) x) =  ((g:C->D) y)`;;
map types_of (gtypl [`f x`;`y`;`f`;`z:D`]);;
filter has_stv (setify (frees `f x`));;
apropos();;
help "apropos_types";;

 
let EZ_SOS_TAC equ =
  let lh = lhs equ in
  (REWRITE_TAC[REAL_ARITH `(x > y <=> y < x) /\ (x >= y <=> y <= x)`] THEN
    ONCE_REWRITE_TAC[REAL_ARITH `(x < y <=> &0 < y - x) /\ (x <= y <=> (&0 <= y - x))`]) THEN
let 
    fun (asl,w) -> 
      let eqthm = try    (REAL_FIELD eqn ) with _ -> failwith "sos_tac, REAL_FIELD failed" in
      let binop = 

rhs;;

searcht 5 [`x > y <=> x < y`];;

let equ = `(&1 - t) * (&1 pow 2) + t * (&1 - t) * (&1 pow 2) = (&1 - t pow 2)`;;
let lh = lhs equ;;
let (plus,adden) = strip_comb  lh;;
let _ = (plus = `(+)`) or failwith "sum expected";;
help_grep "strip";;
help "strip_comb";;

g `&1 + &1 = &2`;;
r,[];;

Str.split (Str.regexp "`") "`how `1` is it`";;
Str.split (Str.regexp "ab") "That is a better choice ab t";;
Str.split (Str.regexp "(\*") "^(* Start comment (* ( *) $";;

help_grep "dest";;
dest_pair `(a,b)`;;

map type_of [disjunct (`CARD`,`HAS_SIZE`)];;
search [disjunct (`HAS_SIZE`,`CARD`)];;
type_of `HAS_SIZE`;;
search [disjunct (`&0 < inv x`,`&0 < sqrt u`)];;
search [disjunct (`&0 < sqrt u`,`&0 < inv x`)];;
search [`&0 < sqrt u`];;

search[disjunct (`INJ`,`(f x = f y) ==> (x = y)`);disjunct(`CARD`,`HAS_SIZE`)];;

INJ_CARD;;

INJ_SURJ;;
suggest();;
searcht 5 [`x HAS_SIZE 0`];;
searcht 5 [`SUBSET`;`FINITE`];;
searcht 5 [`a IN {}`];;
type_of_thm
CARD_UNION_EQ;;
search[`INJ`;`IMAGE`];;
Misc_defs_and_lemmas.IMAGE_SURJ;;
Misc_defs_and_lemmas.BIJ_CARD;;
search [`SURJ`;`IMAGE`];;
search [disjunct (`INJ`,`(f x = f y) ==> (x = y)`);`FINITE`];;
search [`BIJ`;`INJ`];;
search [`INJ`;`SURJ`];;
search [`INJ`;`BIJ`];;
search [`BIJ`;`CARD`];;
search [`CARD a + CARD b`];;  


srch [`a IN {}`];;
r [ ?d0 ];;

mk_rewrites false (ASSUME `!s. s = t`) [];;

net_of_thm false (ASSUME `s = t`) empty_net;;

empty_net;;

p();;
!invariant_under_linear;;

type_of `rcone_gt`;;
type_of_thm PRESERVES_NORM_PRESERVES_DOT;;
srch [`linear`;`vec 0`];;
srch [`f x dot f y = x dot y`];;
srch [`di(x,vec 0)`];;
srch [`norm (f x) = norm x`;`dist`];;
;;

searcht 5 [`rcone_gt`];;
help_grep "GEOM";;
LINEAR_INVARIANTS;;
ROTATION_RIGHTWARD_LINE;;

srch [`IMAGE f (ball(x,r)) = ball(x,r)`];;
def_of_regexp "has_integral";;
def_of_regexp "measure";;
def_of_regexp "fchanged";;
searcht 15 [`fchanged`];;
search_thml (term_match []) [`ball`] (map (fun s -> ("",s)) (!invariant_under_linear));;
searcht 5 [`polyhedron (IMAGE f s)`];;
constant_of_regexp "rcone";;
type_of_thm(  end_itlist CONJ (!invariant_under_linear));;
FINITE_EMPTY;;
search[name "EMPTY_EXISTS"];;
