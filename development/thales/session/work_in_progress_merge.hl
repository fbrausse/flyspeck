flyspeck_needs "nonlinear/merge_ineq.hl";;


open Hales_tactic;;
open Searching;;
open Merge_ineq;;

let CALC_ID_TAC = Calc_derivative.CALC_ID_TAC;;



let cell3_from_ineq = `!y4 y5 y6.
   &2 <= y4 /\ &2 <= y5 /\ &2 <= y6 /\
    y4 <= &2 * sqrt(&2) /\ y5 <= &2 * sqrt(&2) /\ y6 <= &2 * sqrt(&2) /\
    eta_y (y4) (y5) (y6) < sqrt(&2) ==>
    &0 <= gamma3f y4 y5 y6 sqrt2 lmfun `;;

(* some conclusions *)

let leaf = `leaf V ul = hl ul < sqrt2 /\ ul IN barV V 2`;;

let stem = `stem ul = set_of_list (truncate_simplex 1 ul)`;;




(* ========================================================================== *)
(* COMPLETED LEMMAS  *)
(* ========================================================================== *)

(* ========================================================================== *)
(* WORK IN PROGRESS *)
(* ========================================================================== *)


(* QITNPEA4 series 3803737830.
    We assume type QX, so exclude QU (quarters).
    We use TSKAJXY to assume &0 <= gamma4fgcy.  *)

let QITNPEA4_3803737830_concl = `!y1 y2 y3 y4 y5 y6. 
  ineq [(&2 * hminus, y1, &2 * hplus);
	(&2 ,y2, sqrt8);
	(&2,y3,sqrt8);
	(&2,y4,sqrt8);
	(&2,y5,sqrt8);
	(&2,y6,sqrt8)]
  (rad2_y y1 y2 y3 y4 y5 y6 < &2 /\
   (~(y2 < &2 * hmin /\ y3 < &2 * hmin /\ 
	y4 < &2 * hmin /\ y5 < &2 * hmin /\ y6 < &2 * hmin)) /\
   (&0 <= gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun )
   ==> 
     (gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun / &(wtcount6_y y1 y2 y3 y4 y5 y6) + 
	beta_bump_y y1 y2 y3 y4 y5 y6 
      - #0.0105256 +  #0.00522841*dih_y y1 y2 y3 y4 y5 y6 > #0.0))`;;

let QITNPEA4_3803737830_full = add_hyp 
  [
"QITNPEA4 0 0 0 1 3803737830";
"QITNPEA4 0 0 1 0 3803737830";
"QITNPEA4 0 1 0 0 3803737830";
"QITNPEA4 1 0 0 0 3803737830";
"QITNPEA4 0 0 1 1 3803737830";
"QITNPEA4 0 1 0 1 3803737830";
"QITNPEA4 1 0 0 1 3803737830";
"QITNPEA4 0 1 1 0 3803737830";
"QITNPEA4 1 0 1 0 3803737830";
"QITNPEA4 1 1 0 0 3803737830";
"QITNPEA4 0 1 1 1 3803737830";
"QITNPEA4 1 0 1 1 3803737830";
"QITNPEA4 1 1 0 1 3803737830";
"QITNPEA4 1 1 1 0 3803737830";
"QITNPEA4 1 1 1 1 3803737830";
"QITNPEA4 3803737830 supercritical";
"CIHTIUM";
"FWGKMBZ";
] QITNPEA4_3803737830_concl;;

g QITNPEA4_3803737830_full;;

let QITNPEA4_3803737830 = prove_by_refinement(
  QITNPEA4_3803737830_full,
  (* {{{ proof *)
  [
    dt/r
      comment "WLOG. y2 <= y6"
    sgth `!(p:real->real->real->real->real->real->bool). ((!y1 y2 y3 y4 y5 y6. (p y1 y2 y3 y4 y5 y6 ==> p y1 y6 y5 y4 y3 y2)) /\ (!y1 y2 y3 y4 y5 y6. (y2 <= y6) ==> p y1 y2 y3 y4 y5 y6)) ==> (!y1 y2 y3 y4 y5 y6. p y1 y2 y3 y4 y5 y6)` mmp
      mt[arith `y <= x \/ x <= y`]
      conj
      g/r
      rt[Sphere.ineq]
      st/r
      rep 2 (fxast `gamma4fgcy` mp)
      art[]
          gthen `gamma4fgcy y1 y6 y5 y4 y3 y2 lmfun = gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun` subst1
	mt[gamma4fgcy_sym23;gamma4fgcy_sym12;gamma4fgcy_sym03]
      gthen `wtcount6_y y1 y6 y5 y4 y3 y2 = wtcount6_y y1 y2 y3 y4 y5 y6` subst1
	rt[Sphere.wtcount6_y;Sphere.wtcount3_y] then ARITH_TAC
	  gthen `beta_bump_y y1 y6 y5 y4 y3 y2 = beta_bump_y y1 y2 y3 y4 y5 y6` subst1
    rt[Sphere.beta_bump_y] 
    rat
    gthen `dih_y y1 y6 y5 y4 y3 y2 = dih_y y1 y2 y3 y4 y5 y6` subst1
    mt[Nonlinear_lemma.dih_y_sym;Nonlinear_lemma.dih_y_sym2]
    gthen `rad2_y y1 y2 y3 y4 y5 y6 = rad2_y y1 y6 y5 y4 y3 y2` subst1
    mt[Merge_ineq.rad2_y_sym]
    rep 2 (fxa mp)
    mt[]
    comment "WLOG y2 < &2 * hmin"
    rt[Sphere.ineq]
    st/r
    fxast `delta_x` mp
    st/r
    fxast `delta_x` (C intro [`y1`;`y2`;`y3`;`y4`;`y5`;`y6`])
    rt[Sphere.ineq;arith `x > &0 <=> &0 < x`;Sphere.y_of_x]
    asimp[y_bounds]
    dt
    fxast `eta_y` (C intro [`&1`;`&1`;`&1`;`y1`;`y2`;`y6`])
    rt[Sphere.ineq;arith `&1 <= &1`]
    asimp[y_bounds]
    gthen `y1 <= sqrt8` assume
    rt[?a]
asimp[y_bounds;Sphere.sqrt2]
    art[]
    dt
    intro rad2_eta2 [`y1`;`y2`;`y3`;`y4`;`y5`;`y6`]
    asimp[y_bounds;Sphere.delta_y]
    dt
    asmcases `&2 * hminus <= y2`
    fxast `>` mp
    art[]
ants
    repeat (fxa mp) then rat
      fxast `eta_y` mp
      rat
      comment "remove rad2"
      fxast `rad2_y` mp
      rt[Sphere.rad2_y]
      dthen (fun t -> assume (mm (arith `x < &2 ==> ~(x > &2)`) t))
      repeat (fxast `ineq` (C intro [`y1`;`y2`;`y3`;`y4`;`y5`;`y6`]))
      art[]
      comment "fix up weight"

  ]);;
  (* }}} *)

let WEDGE_GE_NULL = prove_by_refinement(
  `!u0 u1 v1 v2. ~collinear {u0,u1,v1} /\ ~collinear {u0,u1,v2} /\ azim u0 u1 v1 v2 = &0 ==>
     wedge_ge u0 u1 v1 v2 = aff_ge {u0,u1} {v1}`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  REWRITE_TAC[EXTENSION];
  GEN_TAC;
  GMATCH_SIMP_TAC (GSYM Local_lemmas.AZIM_EQ_0_GE_ALT2);
  REWRITE_TAC[Local_lemmas.WEDGE_GE_AZIM_LE];
  ASM_REWRITE_TAC[];
  INTRO_TAC Local_lemmas.AZIM_RANGE [`u0`;`u1`;`v1`;`x`];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let X_IN_AFF_GE_LEFT = prove_by_refinement(
  `!(x:real^A) S U. (x IN S DIFF U) ==> (x IN aff_ge S U)`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  GOAL_TERM (fun w -> (SUBGOAL_THEN ( env w `aff_ge S U = aff_ge (S DIFF U) U`) SUBST1_TAC));
    REWRITE_TAC[Sphere.aff_ge_def];
    BY(MESON_TAC[ AFFSIGN_DISJOINT_DIFF]);
  MATCH_MP_TAC Packing3.IN_TRANS;
  GOAL_TERM (fun w -> (EXISTS_TAC ( env w`aff_ge (S DIFF U) {}`)));
  CONJ2_TAC;
    MATCH_MP_TAC AFF_GE_MONO_RIGHT;
    BY(SET_TAC[]);
  REWRITE_TAC[AFF_GE_EQ_AFFINE_HULL];
  MATCH_MP_TAC Marchal_cells_2.IN_AFFINE_KY_LEMMA1;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let WEDGE_GE_ALMOST_DISJOINT = prove_by_refinement(
  `!u0 u1 v1 v2.  ~collinear {u0,u1,v1} /\ ~collinear {u0,u1,v2}  ==>
    wedge_ge u0 u1 v1 v2 INTER wedge_ge u0 u1 v2 v1 SUBSET aff_ge {u0,u1} {v1} UNION aff_ge {u0,u1} {v2}
     `,
  (* {{{ proof *)
  [
  st/r
    asmcase `azim u0 u1 v1 v2 = &0`
      mmp SUBSET_TRANS
      ex (% `wedge_ge u0 u1 v1 v2`)
      conj
      set[]
      gm WEDGE_GE_NULL
      art[]
      set[]
      ets (% `!x. ~(x IN aff_ge {u0,u1} {v1}) /\ ~(x IN aff_ge {u0,u1} {v2}) /\ x IN wedge_ge u0 u1 v1 v2 /\ x IN wedge_ge u0 u1 v2 v1 ==> F`)
      set[]
      st/r
      gthen (% `~(azim u0 u1 v1 x = &0) /\ ~(azim u0 u1 v2 x = &0)`) mp
      amt[Local_lemmas.AZIM_EQ_0_GE_ALT2]
      st/r
      gthen (% `~(azim u0 u1 x v1 = &0) /\ ~(azim u0 u1 x v2 = &0)`) mp
      amt[Local_lemmas.AZIM_EQ_0_SYM2]
      st/r
      gthen (% `~collinear {u0, u1,x}`) assume
      dt
	gthen (% `~(x = v1) /\ ~(x = v2)`) mp
	amt[]
	st/r
      fxast `collinear` mp
      copy
      rt[Local_lemmas.collinear_fan22;DE_MORGAN_THM]
      conj2
      
      st/r
      
      
  ]);;
  (* }}} *)

let WEDGE_WEDGE_GE = prove_by_refinement(
  `!u0 u1 v1 v2. ~collinear {u0,u1,v1} /\ ~collinear {u0,u1,v2}  ==>
    wedge_ge u0 u1 v1 v2 = wedge u0 u1 v1 v2 UNION aff_ge {u0,u1} {v1} UNION aff_ge {u0,u1} {v2}`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let WEDGE_GE_ALMOST_DISJOINT2 = prove_by_refinement(
  `!u0 u1 v1 v2.  ~collinear {u0,u1,v1} /\ ~collinear {u0,u1,v2}  ==>
    wedge_ge u0 u1 v1 v2 INTER wedge_ge u0 u1 v2 v1 SUBSET aff_ge {u0,u1} {v1} UNION aff_ge {u0,u1} {v2}
     `,
  (* {{{ proof *)
  [
  st/r
    asmcase `azim u0 u1 v1 v2 = &0`
      mmp SUBSET_TRANS
      ex (% `wedge_ge u0 u1 v1 v2`)
      conj
      set[]
      gm WEDGE_GE_NULL
      art[]
      set[]
      ets (% `!x. ~(x IN aff_ge {u0,u1} {v1}) /\ ~(x IN aff_ge {u0,u1} {v2}) /\ x IN wedge_ge u0 u1 v1 v2 /\ x IN wedge_ge u0 u1 v2 v1 ==> F`)
      set[]
      st/r
      gthen (% `~(azim u0 u1 v1 x = &0) /\ ~(azim u0 u1 v2 x = &0)`) mp
      amt[Local_lemmas.AZIM_EQ_0_GE_ALT2]
      st/r
      gthen (% `~(azim u0 u1 x v1 = &0) /\ ~(azim u0 u1 x v2 = &0)`) mp
      amt[Local_lemmas.AZIM_EQ_0_SYM2]
      st/r
      gthen (% `~collinear {u0, u1,x}`) assume
      dt
	gthen (% `~(x = v1) /\ ~(x = v2)`) mp
	amt[]
	st/r
      fxast `collinear` mp
      copy
      rt[Local_lemmas.collinear_fan22;DE_MORGAN_THM]
      conj2
      
      st/r
      
      
  ]);;
  (* }}} *)
