
module Work_in_progress = struct
end;;

(* *************************************************************************** *)
(* COMPLETED LEMMAS *)
(* *************************************************************************** *)

(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)

needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;

module Tame_classification = struct
end;;

open Hypermap;;
open Import_tame_classification;;

  let new_definition' t = 
    if has_stv t 
    then (Print_types.print_term_types t; failwith "new_definition has stv") 
    else new_definition t;;

parse_as_infix("POWER",(24,"right"));;
parse_as_infix("in_dart_of_loop",(11,"right"));;
(* parse_as_infix("iso",(24,"right"));; *)
unparse_as_infix "iso";;

make_overloadable "vertices" `:B -> (num list)`;;

overload_interface ("vertices",`FST:num list # bool -> num list`);;

(* LIST PROCESSING *)

let MEM_replace = prove_by_refinement(
  `!x f xs g. MEM x (replace f xs g) ==> (MEM x g \/ (MEM f g /\ (MEM x xs)))`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    REWRITE_TAC[replace];
    BY(MESON_TAC[]);
  REWRITE_TAC[replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MEM];
    REWRITE_TAC[MEM_APPEND];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM2_replace = prove_by_refinement(
  `!x f xs g. MEM f g /\ MEM x xs ==> MEM x (replace f xs g)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM;replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)


let REVERSE_rev = prove_by_refinement(
  ` REVERSE = rev`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[REVERSE;Seq.rev;Seq.catrev]);
  ASM_REWRITE_TAC[REVERSE;Seq.rev];
  REWRITE_TAC[Seq.catrev];
  REWRITE_TAC[Seq.catrevE];
  BY(REWRITE_TAC[Seq.cats0;Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let upt0 = prove_by_refinement(
  `!i. upt 0 i = iota 0 i`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Import_tame_classification.upt];
  GEN_TAC;
  BY(REWRITE_TAC[arith `i - 0 = i`])
  ]);;
  (* }}} *)

let list_pairs_rev = prove_by_refinement(
  `!a. list_pairs (rev a) = rev (zip a (rotr 1 a))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs;GSYM Seq.rev_rotr];
  GEN_TAC;
  GMATCH_SIMP_TAC (GSYM Seq.rev_zip);
  BY(REWRITE_TAC[Seq.size_rotr])
  ]);;
  (* }}} *)

let nth_iota_nod = prove_by_refinement(
  `!x0 k i. i < k ==> nth x (iota 0 k) i = i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
  GMATCH_SIMP_TAC Seq2.EL_nth;
  TYPIFY `0` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.size_iota];
  GMATCH_SIMP_TAC Seq.nth_iota;
  BY(ASM_REWRITE_TAC[] THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota0 = prove_by_refinement(
  `!i' i j k x y. i' + 1 = k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',0)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ i' = k - 1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zipr_iota0 = prove_by_refinement(
  `!i j k x y. 0 < k  ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) 0 = 0,k-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota = prove_by_refinement(
  `!i' i j k x y. i' + 1 < k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',i'+1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ ~(i' = k-1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nth_zipr_iota = prove_by_refinement(
  `!i' i j k x y. 0 < i' /\ i' < k ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) i' = i',i'-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `~(i' = 0)` (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_iota = prove_by_refinement(
  `!i j k.  (MEM (i,j) (list_pairs (iota 0 k)) <=> ((i+1 < k /\ j = i+1) \/ (i+1=k  /\ j=0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.size_list_pairs [`iota 0 k`];
  REWRITE_TAC[List_hypermap.list_pairs;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `i' + 1 < k \/ i' + 1 = k` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      GMATCH_SIMP_TAC nth_zip_iota;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zip_iota0;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    TYPIFY `i` EXISTS_TAC;
    GMATCH_SIMP_TAC nth_zip_iota;
    REWRITE_TAC[PAIR_EQ];
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `i` EXISTS_TAC;
  GMATCH_SIMP_TAC nth_zip_iota0;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_rev_iota = prove_by_refinement(
  `!i j k.  0 < k ==> 
     (MEM (i,j) (list_pairs (rev (iota 0 k))) <=> ((i = 0 /\ j=k-1) \/ (0 < i /\ i < k /\ j = i-1)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[list_pairs_rev;Seq.mem_rev];
  INTRO_TAC List_hypermap.size_list_pairs [`rev (iota 0 k)`];
  REWRITE_TAC[list_pairs_rev;Seq.size_rev;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `(i' =0 \/ 0 < i')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      ASM_REWRITE_TAC[];
      GMATCH_SIMP_TAC nth_zipr_iota0;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zipr_iota;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i` EXISTS_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC nth_zipr_iota0;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC nth_zipr_iota;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_bn_minimal = prove_by_refinement(
  `!f xs. ~(xs = []) ==> MEM (bn_minimal f xs) xs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_minimal];
  GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[]);
  REWRITE_TAC[bn_minimal];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)





(* hyp't. *)

(*
let hyp_t_exists = 
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked H NF L x /\ ~(L IN final_loops H NF) ==>
  (?t. (!NF' L'.  (transform H x) POWER t (NF,L) = (NF',L') ==>
      L' IN final_loops H NF') /\
  (!i NF' L'. i < t /\ (transform H x) POWER i (NF,L) = (NF',L') ==>
      ~(L' IN final_loops H NF')))`;;
*)

(* hyp't = new_specification... *)

(*
let transform_H_concl = 
  `transform (H,NF,L,x) = (N',NF',L',x') ==> H' = H`;;

let transform_x_concl = 
  `transform (H,NF,L,x) = (H',NF',L',x') ==> x' = x`;;
*)

let transform_z_index = new_definition
  `transform_z_index (H,NF,L,x) i = 
     (let (NF',L') = (transform H x POWER i) (NF,L) in
        (index L x (hyp'z H NF' L' x)))`;;

let transform_p_index = new_definition
  `transform_p_index (H,NF,L,x) i = 
     (let (NF',L') = (transform H x POWER i) (NF,L) in
	hyp'p H NF' L' x)`;;

(* 
let good_iso_fgraph = prove_by_refinement(
  `!x y. good_list x /\ iso_fgraph x y /\ uniq(list_of_darts y) ==> good_list y`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list;iso_fgraph;is_iso;is_Iso;is_pr_Iso;is_pr_Hom;EQ_CLASS;IMAGE_INFIX;GSYM Seq2.ALL_all;GSYM ALL_MEM]
 ...
  ]);;
  (* }}} *)
*)

(*
let list_pairs_rotate = prove_by_refinement(
  `!n x. rotate n (list_pairs x) = list_pairs (rotate n x)`,
  (* {{{ proof *)
  [
  rt[List_hypermap.list_pairs]
  ]);;
  (* }}} *)

let list_of_darts_cong = prove_by_refinement(
  `!x y. set_of_list (MAP (__cong) x) = set_of_list (MAP (__cong) y) ==>
    set_of_list (list_of_darts x) = set_of_list (list_of_darts y)`,
  (* {{{ proof *)
  [
  rt[EXTENSION;IN_SET_OF_LIST]
    st/r
  rt[List_hypermap.list_of_darts]

  ]);;
  (* }}} *)

let good_cong_eq = prove_by_refinement(
  `!x y. good_list x /\ good_list y /\ 
   IMAGE (__cong) (set_of_list x) = IMAGE (__cong) (set_of_list y) ==>
    hypermap_of_list x = hypermap_of_list y`,
  (* {{{ proof *)
  [
rt[GSYM SET_OF_LIST_MAP]
  st/r
  rt[List_hypermap.hypermap_of_list]
apterm
    rt[PAIR_EQ]
rt[List_hypermap.darts_of_list;List_hypermap.e_list_ext]


rt[List_hypermap.f_list_ext;List_hypermap.n_list_ext;List_hypermap.n_list;List_hypermap.f_list]
typ `darts_of_list x = darts_of_list y /\ list_of_darts x = list_of_darts y` ets
mt[]
  ]);;
  (* }}} *)
*)

(*
let good_iso = prove_by_refinement(
  `!x y. good_list x /\ good_list y /\ iso_fgraph x y ==>
  (iso (hypermap_of_list (x)) (hypermap_of_list (y)) \/
     iso (opposite_hypermap (hypermap_of_list (x))) (hypermap_of_list (y)))`,
  (* {{{ proof *)
  [
rt[List_hypermap.good_list;iso_fgraph;is_iso;is_Iso;is_pr_Iso;is_pr_Hom;EQ_CLASS;IMAGE_INFIX;GSYM Seq2.ALL_all;GSYM ALL_MEM]
st/r
fxa disjcase thenl [disj1;disj2]
mmp Hypermap_iso.hyp_iso_imp_iso
  ]);;
  (* }}} *)
*)


let plane_step = `!g p fs f v n e vl. 
  (Seed p, g) IN RTranCl (next_plane p) /\
  fs = nonFinals g /\
  ~(fs = []) /\
  f = minimalFace fs /\
  v = minimalVertex g f /\
  3 <= n /\ n <= maxGon p /\
  MEM e (enumerator n (LENGTH (vertices f))) /\
  ~(containsDuplicateEdge g f v e) /\
  vl = indexToVertexList f v e 
 ==>
  (Seed p, subdivFace g f vl) IN RTranCl (next_plane p)`;;  

let plane_correspondence_seed = `!H p. dih2k H p ==>
  iso H (hypermap_of_list (fgraph (Seed p)))`;;

let iso_correspondence_finals = new_definition
  `iso_corresponding_finals phi H NF g <=>
    (hyp_iso phi ((quotient H NF) ,(hypermap_of_list (fgraph g))) /\
       IMAGE (IMAGE phi) (final_quotient_faces H NF) = 
	map (darts_of_list o vertices ) (filter SND (faces g)))`;;

let subdivFace_step = new_recursive_definition list_RECURSION
  `(subdivFace_step g f u n [] = (g,f,u,[])) /\
    (subdivFace_step g f u n (vo :: vos) = 
      if (vo = NONE) then subdivFace_step g f u (SUC n) vos else
	(let v = the vo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace_step g f v 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		(g',f2,v,vos))))`;;

let subdivFace_instep = 
  `subdivFace0 g f u 0 [] = makeFaceFinal f g /\
   subdivFace0 g f u 0 vos = 
    (let (g',f',v',vos') = subdivFace_step g f u 0 vos in subdivFace0 g' f' u' 0 vos')`;;

let subdivFace_shorten = 
  `~(vos = []) /\ (g',f',v',vos') = subdivFace_step g f u n vos ==>
  LENGTH vos' < LENGTH vos`;;

let face_index_on_loop = new_definition `face_index_on_loop L f x' d i = 
  (let y = (f POWER i ) x' in
     (if y in_dart_of_loop L 
     then index L x' y
     else d))`;;

let hyp_enumeration = new_definition `hyp_enumeration L f x' n = 
  REVERSE (foldr (\i bs. CONS (face_index_on_loop L f x' (HD bs) i) bs) [0] (iota 0 n))`;;

let hyp't = new_definition `hyp't L f x' n = 
  (let rs = hyp_enumeration L f x' n in
     CARD { i | 0 < i /\ i < n /\ SUC (EL (i-1) rs) < EL i rs })`;;

(* fix *)
(*
let hyp_enumeration_enumerates = 
 `MEM (hyp_enumeration L f x' n) 
   (FILTER (\is. ~(containsDuplicateEdge g f v is)) (enumerator n (LENGTH (vertices f))))`;;


let plane_correspondence_step = `!H NF phi g p.
  (Seed p, g) IN RTranCl (next_plane p) /\
  iso_correspondence_finals phi H NF g /\
  fs = nonFinals g /\
  ~(fs = []) /\
  f = minimalFace fs /\
  v = minimalVertex g f /\
  3 <= n /\ n <= maxGon p /\
  MEM e (enumerator n (LENGTH (vertices f))) /\
  IMAGE phi qf = map (darts_of_list o vertices ) f /\
  ~(containsDuplicateEdge g f v e) /\
  vl = indexToVertexList f v e  /\
  IMAGE phi (dart_of_loop L) =  list_pairs f /\
  x in_dart_of_loop L /\
  FST (phi x) = v /\ 
  // add matching p-q data with e.
  (NF',L') = (transform H x) POWER (hyp't H NF L X)  (NF,L) 
 ==>
  (?phi'. iso_correspondence_finals phi' H NF' (subdivFace g f vl))`;;
  
let flag_correspondece = `! `;;
*)


(*
let AQIUNPP2 = prove_by_refinement(
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked (H ,NF, L, x) /\ ~(L IN final_loops H NF) 
   ==> (let (NF',L') =  (transform H x (NF,L)) in is_marked (H,NF',L',x))`,
  (* {{{ proof *)
  [
g/r
st
intro Hypermap.lemma_normal_family_transform [`H`;`NF`;`L`;`x`]
art[]
repeat (pop mp)
rt[LET_THM;transform;is_marked]
st/r
art[]
comment "1st"
conj
rt[family_transform]
set[]

"redo here "
comment "2nd"
conj
rt[in_dart_of_loop;loop1_transform]
gm lemma_generate_loop
rt[path1_transform;glue]
  ]);;
  (* }}} *)
*)

(* Tame isomorphism *)

let tame9a_iso = prove_by_refinement(
  `!H H' f. tame_9a H /\ hyp_iso f (H,H') ==> tame_9a H'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.tame_9a];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_card_components [`H`;`H'`;`f`];
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `?y. y IN dart H /\ f y = x` MP_TAC;
    INTRO_TAC Hypermap_iso.iso_dart [`H'`;`f`;`H`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC;
    BY(SET_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM (C INTRO_TAC [`y`]));
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let tame10_iso = prove_by_refinement(
  `!H H' f. tame_10 H /\ hyp_iso f (H,H') ==> tame_10 H'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.tame_10];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[Hypermap_iso.iso_number_of_nodes])
  ]);;
  (* }}} *)

let tame11a_iso = prove_by_refinement(
  `!H H' f. tame_11a H /\ hyp_iso f (H,H') ==> tame_11a H'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.tame_11a];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_card_components [`H`;`H'`;`f`];
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `?y. y IN dart H /\ f y = x` MP_TAC;
    INTRO_TAC Hypermap_iso.iso_dart [`H'`;`f`;`H`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC;
    BY(SET_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM (C INTRO_TAC [`y`]));
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let tgt_squanderTarget = prove_by_refinement(
  `tgt = &squanderTarget / &10000`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Import_tame_classification.squanderTarget;Tame_defs.tgt];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let d_tame_squanderFace = prove_by_refinement(
  `!n.  (d_tame n) = & (squanderFace n)  / &10000`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.d_tame;Import_tame_classification.squanderFace;tgt_squanderTarget];
  GEN_TAC;
  ASM_CASES_TAC `n = 3`;
    ASM_REWRITE_TAC[];
    BY(REAL_ARITH_TAC);
  ASM_CASES_TAC `n=4`;
    BY(ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);
  ASM_CASES_TAC `n=5`;
    BY(ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);
  ASM_CASES_TAC `n=6`;
    BY(ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);
  BY(ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let b_tame_squanderVertex = prove_by_refinement(
  `!p q. b_tame p q = &(squanderVertex p q) / &10000`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.b_tame;Import_tame_classification.squanderVertex;tgt_squanderTarget];
  REPEAT GEN_TAC;
  REWRITE_TAC[PAIR_EQ];
  TYPIFY_GOAL_THEN `!b a a'. &(if b then a else a') / &10000 = if b then (&a / &10000) else (&a' / &10000)` (unlist REWRITE_TAC);
    BY(REAL_ARITH_TAC);
  TYPIFY_GOAL_THEN `!a. DECIMAL a 1000 = &(a * 10) / &10000 /\ DECIMAL a 100 = &(a * 100) / &10000 /\ DECIMAL a 10000 = &a / &10000` (unlist REWRITE_TAC);
    REWRITE_TAC[DECIMAL;GSYM REAL_OF_NUM_MUL];
    BY(REAL_ARITH_TAC);
  BY(NUM_REDUCE_TAC)
  ]);;
  (* }}} *)

let a_tame_excessTCount = prove_by_refinement(
  `a_tame = &excessTCount/ &10000`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.a_tame;Import_tame_classification.excessTCount];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let BIJ_face_iso = prove_by_refinement(
  `!f (H:(A)hypermap) (H':(B)hypermap) c x' x. 
    f x = x' /\ hyp_iso f (H,H') /\ x IN dart H  /\ x' IN dart H' ==>
     BIJ (IMAGE f) {face H y | y | y IN dart H /\ c (CARD (face H y)) /\ y IN node H x}
      {face H' y' | y' | y' IN dart H' /\ c (CARD (face H' y')) /\ y' IN node H' x'}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[BIJ];
  SUBCONJ_TAC;
    REWRITE_TAC[INJ];
    CONJ_TAC;
      REWRITE_TAC[IN_ELIM_THM];
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `f y` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      INTRO_TAC Hypermap_iso.hyp_iso_card_components [`H`;`H'`;`f`];
      ASM_REWRITE_TAC[];
      DISCH_TAC;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Lunar_deform.IMAGE_FACE_F]);
      CONJ_TAC;
        INTRO_TAC Hypermap_iso.iso_dart [`H'`;`f`;`H`];
        ASM_REWRITE_TAC[];
        DISCH_THEN (unlist REWRITE_TAC);
        MATCH_MP_TAC FUN_IN_IMAGE;
        BY(ASM_REWRITE_TAC[]);
      CONJ_TAC;
        BY(ASM_MESON_TAC[IN]);
      INTRO_TAC Hypermap_iso.iso_components [`H'`;`f`;`H`];
      ASM_REWRITE_TAC[];
      DISCH_THEN (C INTRO_TAC [`x`]);
      ANTS_TAC;
        BY(ASM_REWRITE_TAC[IN]);
      ASM_REWRITE_TAC[];
      DISCH_THEN (unlist REWRITE_TAC);
      MATCH_MP_TAC FUN_IN_IMAGE;
      BY(ASM_REWRITE_TAC[IN]);
    COMMENT "INJ";
    REWRITE_TAC[IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC Hypermap_iso.hyp_iso_INJ [`f`;`H`;`H'`];
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[INJ];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC Hypermap_iso.image_set_inj_gen [`dart H`;`f`];
    ANTS_TAC;
      BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
    DISCH_THEN (C INTRO_TAC [`x''`;`y`]);
    DISCH_THEN MATCH_MP_TAC;
    FIRST_X_ASSUM_ST `IMAGE` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_face_subset]);
  REWRITE_TAC[INJ];
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "surj";
  REWRITE_TAC[SURJ];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REBIND_TAC (`y:A`,"z");
  INTRO_TAC Hypermap_iso.iso_components [`H'`;`f`;`H`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_THEN (C INTRO_TAC [`x`]);
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[IN]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?z. f z = y' /\ z IN node H x /\ z IN dart H` (C SUBGOAL_THEN MP_TAC);
    FIRST_X_ASSUM_ST `node` MP_TAC;
    REWRITE_TAC[IMAGE];
    REWRITE_TAC[EXTENSION];
    REWRITE_TAC[IN_ELIM_THM];
    DISCH_THEN (C INTRO_TAC [`y'`]);
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x'''` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `x IN dart H` MP_TAC);
    BY(SET_TAC[Hypermap.lemma_node_subset;IN]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `face H z` EXISTS_TAC;
  SUBCONJ2_TAC;
    EXPAND_TAC "y'";
    BY(ASM_MESON_TAC[Hypermap_iso.iso_components;IN]);
  DISCH_TAC;
  TYPIFY `z` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `CARD (face H z) = CARD (face H' y')` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components;IN])
  ]);;
  (* }}} *)

let BIJ_face_set_iso = prove_by_refinement(
  `!f (H:(A)hypermap) (H':(B)hypermap) . 
    hyp_iso f (H,H')  ==>
     BIJ (IMAGE f) (face_set H) (face_set H')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[BIJ];
  SUBCONJ2_TAC;
    TYPIFY `IMAGE (IMAGE f) (face_set H) = (face_set H')` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Misc_defs_and_lemmas.IMAGE_SURJ]);
    BY(ASM_MESON_TAC[Hypermap_iso.iso_face_set]);
  REWRITE_TAC[SURJ;INJ];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  COMMENT "INJ";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?x1 x2. x1 IN dart H /\ x2 IN dart H /\ x = face H x1 /\ y = face H x2` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_face_representation]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap_iso.hyp_iso_INJ [`f`;`H`;`H'`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[INJ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.image_set_inj_gen [`dart H`;`f`];
  ANTS_TAC;
    BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`x`;`y`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap.lemma_face_subset]);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let CARD_face_iso = prove_by_refinement(
  `!f (H:(A)hypermap) (H':(B)hypermap) c x' x. 
    f x = x' /\ hyp_iso f (H,H') /\ x IN dart H  /\ x' IN dart H' ==>
     CARD {face H y | y | y IN dart H /\ c (CARD (face H y)) /\ y IN node H x} = 
      CARD {face H' y' | y' | y' IN dart H' /\ c (CARD (face H' y')) /\ y' IN node H' x'}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Misc_defs_and_lemmas.BIJ_CARD;
  TYPIFY `IMAGE f` EXISTS_TAC;
  CONJ_TAC;
    MATCH_MP_TAC FINITE_SUBSET;
    TYPIFY `IMAGE (face H) (dart H)` EXISTS_TAC;
    CONJ_TAC;
      MATCH_MP_TAC FINITE_IMAGE;
      BY(REWRITE_TAC[Hypermap.node_map_and_darts]);
    BY(SET_TAC[]);
  MATCH_MP_TAC BIJ_face_iso;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let exceptional_face_dart = prove_by_refinement(
  `!H x. exceptional_face H x ==> x IN dart H`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.exceptional_face];
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  INTRO_TAC Hypermap.lemma_face_exception [`H`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `CARD` MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[CARD_SING];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let exceptional_face_iso = prove_by_refinement(
  `!H H' f x. exceptional_face H x /\ hyp_iso f (H,H') ==>
   exceptional_face H' (f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC exceptional_face_dart [`H`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `exceptional_face` MP_TAC;
  REWRITE_TAC[Tame_defs.exceptional_face];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `CARD (face H x) = CARD (face H' (f x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let exceptional_face_iso_inv = prove_by_refinement(
  `!H H' (f:A->B) x. x IN dart H /\ exceptional_face H' (f x) /\ hyp_iso f (H,H') ==>
   exceptional_face H x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_inv [`f`;`H'`;`H`];
  ASM_REWRITE_TAC[];
  TYPED_ABBREV_TAC `g = res_inv f (dart H)`;
  INTRO_TAC exceptional_face_iso [`H'`;`H`;`g`;`f x`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `g (f x) = x` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  EXPAND_TAC "g";
  MATCH_MP_TAC Hypermap_iso.inj_res_inv_left;
  TYPIFY `dart H'` EXISTS_TAC;
  CONJ_TAC;
    MATCH_MP_TAC Hypermap_iso.hyp_iso_INJ;
    BY(ASM_REWRITE_TAC[]);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let node_exceptional_face_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ node_exceptional_face H x /\ hyp_iso f (H,H') ==>
   node_exceptional_face H' (f x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.node_exceptional_face];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC exceptional_face_iso_inv [`H`;`H'`;`f`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `CARD (node H x) = CARD (node H' (f x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let node_type_exceptional_face_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ node_type_exceptional_face H x /\ hyp_iso f (H,H') ==>
    node_type_exceptional_face H' (f x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.node_type_exceptional_face];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC exceptional_face_iso_inv [`H`;`H'`;`f`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `CARD (node H x) = CARD (node H' (f x)) /\ type_of_node H x = type_of_node H' (f x)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components]);
  REWRITE_TAC[Tame_defs.node_exceptional_face;Tame_defs.exceptional_face;Tame_defs.type_of_node;Tame_defs.set_of_triangles_meeting_node;Tame_defs.set_of_quadrilaterals_meeting_node;Tame_defs.set_of_exceptional_meeting_node;PAIR_EQ];
  TYPIFY `f x IN dart H'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(REPEAT CONJ_TAC THEN MATCH_MP_TAC CARD_face_iso THEN TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let tame12o_iso = prove_by_refinement(
  `!H H' f. tame_12o H /\ hyp_iso f (H,H') ==> tame_12o H'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.tame_12o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x IN dart H'` ASM_CASES_TAC;
    TYPIFY `?t. t IN dart H /\ x = f t` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC Hypermap_iso.iso_dart [`H'`;`f`;`H`];
      BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN SET_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    CONJ_TAC;
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC node_type_exceptional_face_iso;
      TYPIFY `H` EXISTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC node_exceptional_face_iso;
    TYPIFY `H` EXISTS_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Tame_defs.node_type_exceptional_face;Tame_defs.node_exceptional_face];
  BY(ASM_MESON_TAC[exceptional_face_dart])
  ]);;
  (* }}} *)

let adm_1_iso = prove_by_refinement(
  `!H H' (f:A->B) w. adm_1 H w /\ hyp_iso f (H,H') ==> adm_1 H' (w o (IMAGE ( res_inv f (dart H))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.adm_1;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_surj [`H'`;`H`;`f`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `IMAGE (res_inv f (dart H)) (face H' x) = (face H x') /\ CARD (face H' x) = CARD (face H x')` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  CONJ2_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components]);
  INTRO_TAC Hypermap_iso.hyp_iso_inv [`f`;`H'`;`H`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `(res_inv f (dart H)) x = x'` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.iso_components]);
  EXPAND_TAC "x";
  MATCH_MP_TAC Hypermap_iso.inj_res_inv_left;
  TYPIFY `(dart H')` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_INJ])
  ]);;
  (* }}} *)

let set_of_triangles_meeting_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
    CARD (set_of_triangles_meeting_node H x) = CARD (set_of_triangles_meeting_node H' (f x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.set_of_triangles_meeting_node];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f x IN dart H'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(REPEAT CONJ_TAC THEN MATCH_MP_TAC CARD_face_iso THEN TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let set_of_quadrilaterals_meeting_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
    CARD (set_of_quadrilaterals_meeting_node H x) = CARD (set_of_quadrilaterals_meeting_node H' (f x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.set_of_quadrilaterals_meeting_node];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f x IN dart H'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(REPEAT CONJ_TAC THEN MATCH_MP_TAC CARD_face_iso THEN TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let set_of_exceptional_meeting_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
    CARD (set_of_exceptional_meeting_node H x) = CARD (set_of_exceptional_meeting_node H' (f x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.set_of_exceptional_meeting_node];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f x IN dart H'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(REPEAT CONJ_TAC THEN MATCH_MP_TAC CARD_face_iso THEN TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let bij_set_of_face_meeting_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
    BIJ (IMAGE f) (set_of_face_meeting_node H x) (set_of_face_meeting_node H' (f x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Tame_defs.set_of_face_meeting_node];
  INTRO_TAC BIJ_face_iso [`f`;`H`;`H'`;`(\ (n:num). T)`;`f x`;`x`];
  REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart])
  ]);;
  (* }}} *)

let bij_set_of_triangles_meeting_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
    BIJ (IMAGE f) (set_of_triangles_meeting_node H x) (set_of_triangles_meeting_node H' (f x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Tame_defs.set_of_triangles_meeting_node];
  MATCH_MP_TAC BIJ_face_iso;
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart])
  ]);;
  (* }}} *)

let type_of_node_iso = prove_by_refinement(
  `!H H' f x. x IN dart H /\ hyp_iso f (H,H') ==>
  type_of_node H x = type_of_node H' (f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Tame_defs.type_of_node;PAIR_EQ];
  BY(ASM_MESON_TAC[ set_of_exceptional_meeting_node_iso; set_of_quadrilaterals_meeting_node_iso; set_of_triangles_meeting_node_iso])
  ]);;
  (* }}} *)

let adm_2_iso = prove_by_refinement(
  `!H H' (f:A->B) w. adm_2 H w /\ hyp_iso f (H,H') ==> adm_2 H' (w o (IMAGE ( res_inv f (dart H))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.adm_2;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_surj [`H'`;`H`;`f`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`x:B`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sum (set_of_face_meeting_node H' x) (w o IMAGE (res_inv f (dart H))) = sum (set_of_face_meeting_node H x') w` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[set_of_exceptional_meeting_node_iso;set_of_quadrilaterals_meeting_node_iso;set_of_triangles_meeting_node_iso]);
  MATCH_MP_TAC Basics.BIJ_SUM;
  ASM_REWRITE_TAC[];
  INTRO_TAC set_of_face_meeting_node_iso [`H'`;`H`;`res_inv f (dart H)`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Hypermap_iso.hyp_iso_inv;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `res_inv f (dart H) x = x'` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  EXPAND_TAC "x";
  MATCH_MP_TAC Hypermap_iso.inj_res_inv_left;
  TYPIFY `dart H'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_INJ])
  ]);;
  (* }}} *)

let adm_3_iso = prove_by_refinement(
  `!H H' (f:A->B) w. adm_3 H w /\ hyp_iso f (H,H') ==> adm_3 H' (w o (IMAGE ( res_inv f (dart H))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.adm_3];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.hyp_iso_surj [`H'`;`H`;`f`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sum (set_of_triangles_meeting_node H' x) (w o IMAGE (res_inv f (dart H))) = sum (set_of_triangles_meeting_node H x') w` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[type_of_node_iso]);
  MATCH_MP_TAC Basics.BIJ_SUM;
  INTRO_TAC bij_set_of_triangles_meeting_node_iso [`H'`;`H`;`res_inv f (dart H)`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Hypermap_iso.hyp_iso_inv;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `res_inv f (dart H) x = x'` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  EXPAND_TAC "x";
  MATCH_MP_TAC Hypermap_iso.inj_res_inv_left;
  TYPIFY `dart H'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_INJ])
  ]);;
  (* }}} *)

let tame13a_iso = prove_by_refinement(
  `!H H' f. tame_13a H /\ hyp_iso f (H,H') ==> tame_13a H'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs.tame_13a;Tame_defs.admissible_weight;Tame_defs.total_weight];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `w o (IMAGE (res_inv f (dart H)))` EXISTS_TAC;
  TYPIFY `sum (face_set H') (w o IMAGE (res_inv f (dart H)))  = sum (face_set H) w` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[adm_1_iso;adm_2_iso;adm_3_iso]);
  MATCH_MP_TAC Basics.BIJ_SUM;
  MATCH_MP_TAC BIJ_face_set_iso;
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_inv])
  ]);;
  (* }}} *)

(* End of tame Isomorphism *)

(* plane graphs good *)



let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let subdivFace0_induct = prove_by_refinement(
  `!B vs g f u n.  ((!f' g. B g ==> B(makeFaceFinal f' g)) /\ (!g u v f'' n .
        B g /\ (~(n=0) \/  ~(nextVertex f'' u = v)) ==> 
    (let ws = upt (countVertices g) (countVertices g + n) in
     let (f1,f2,g') = splitFace g u v f'' ws in B g'))) ==>
    (B g ==> (B(subdivFace0 g f u n vs)))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT LET_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `makeFaceFinal` (C INTRO_TAC [`g'`;`f2`;`v`;`0`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  LET_TAC;
  ASM_REWRITE_TAC[];
  LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let nonFinals_subdivFace0_induct = prove_by_refinement(
  `!B vs g f u n.  ((!f' g. B g ==> B(makeFaceFinal f' g)) /\ (!g u v f'' n .
        B g /\ MEM f'' (nonFinals g) /\ (~(n=0) \/  ~(nextVertex f'' u = v)) ==> 
    (let ws = upt (countVertices g) (countVertices g + n) in
     let (f1,f2,g') = splitFace g u v f'' ws in B g'))) ==>
    (B g /\ MEM f (nonFinals g) ==> (B(subdivFace0 g f u n vs)))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT LET_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `makeFaceFinal` (C INTRO_TAC [`g'`;`f2`;`v`;`0`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  LET_TAC;
  ASM_REWRITE_TAC[];
  LET_TAC;
  (REWRITE_TAC[]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `splitFace` MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  FIRST_X_ASSUM_ST `REVERSE` MP_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  REWRITE_TAC[nonFinals];
  REWRITE_TAC[MEM_FILTER];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    EXPAND_TAC "f2";
    EXPAND_TAC "f2'";
    BY(REWRITE_TAC[type_face_SND]);
  REWRITE_TAC[faces_graph];
  FULL_EXPAND_TAC "f2";
  REWRITE_TAC[MEM_APPEND];
  DISJ1_TAC;
  FULL_EXPAND_TAC "fs";
  MATCH_MP_TAC MEM2_replace;
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let MEM_generatePolygon = prove_by_refinement(
  `!i v f g g'. MEM g' (generatePolygon i v f g) ==> (?e vs.
     MEM e (enumerator i (LENGTH (vertices f))) /\
     ~containsDuplicateEdge g f v e /\
     vs = indexToVertexList f v e /\
     g' = subdivFace g f vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[generatePolygon;LET_THM;MEM_MAP;MEM_FILTER];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)


(* now induction good_list *)

let fgraph_graph = prove_by_refinement(
  `!f n a b. fgraph (Graph f n a b) = MAP FST f`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[bn_Graph;fgraph;faces;vertices])
  ]);;
  (* }}} *)

let uniq_list_of_darts_seed = prove_by_refinement(
  `!p. uniq(list_of_darts(fgraph (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.cats0];
  REWRITE_TAC[Seq.cat_uniq];
  GEN_TAC;
  CONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[Import_tame_classification.upt];
    BY(REWRITE_TAC[Seq.iota_uniq]);
  CONJ2_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[REVERSE_rev];
    REWRITE_TAC[Seq.rev_uniq];
    REWRITE_TAC[Import_tame_classification.upt];
    BY(REWRITE_TAC[Seq.iota_uniq]);
  REWRITE_TAC[GSYM Seq.hasP];
  REWRITE_TAC[NOT_EXISTS_THM];
  GEN_TAC;
  REWRITE_TAC[TAUT `~(a /\ b) <=> (a ==> ~b)`];
  REWRITE_TAC[upt0;maxGon];
  TYPIFY `?i j. x = i,j` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[REVERSE_rev;Seq.mem_rev;list_pairs_iota];
  GMATCH_SIMP_TAC list_pairs_rev_iota;
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let all_nonempty_seed = prove_by_refinement(
  `!p. all (\l. ~(l = [])) (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.all];
  REWRITE_TAC[Import_tame_classification.upt;maxGon];
  REWRITE_TAC[GSYM Seq.size_eq0;REVERSE_rev;Seq.size_rev];
  REWRITE_TAC[Seq.size_iota];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_transpose_seed = prove_by_refinement(
  `!p d. MEM d (list_of_darts (fgraph (Seed p))) ==> MEM (SND d,FST d) (list_of_darts (fgraph (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.mem_cat];
  REWRITE_TAC[Import_tame_classification.upt;maxGon;REVERSE_rev];
  REPEAT GEN_TAC;
  TYPIFY_GOAL_THEN `(p+3)-0 = p+3` SUBST1_TAC;
    BY(ARITH_TAC);
  TYPIFY `?i j. d = (i,j)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[list_pairs_iota];
  REPEAT (GMATCH_SIMP_TAC list_pairs_rev_iota);
  REWRITE_TAC[MEM];
  REWRITE_TAC[arith `0 < p + 3 /\ (p+3)- 1 = p+2 /\ (i + 1 = p + 3 <=> i = p+ 2) /\ (i + 1 < p + 3 <=> i < p + 2)`];
  REPEAT STRIP_TAC;
        BY(ASM_TAC THEN ARITH_TAC);
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_REWRITE_TAC[]);
  DISJ1_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let good_list_seed = prove_by_refinement(
  `!p. good_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[List_hypermap.good_list;mem_transpose_seed;all_nonempty_seed;uniq_list_of_darts_seed])
  ]);;
  (* }}} *)

let FST_setFinal = prove_by_refinement(
  `!vs f. MAP FST (replace f [setFinal f] vs) = MAP FST vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[replace]);
  REWRITE_TAC[replace];
  GEN_TAC;
  REWRITE_TAC[APPEND_SING];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MAP];
    BY(REWRITE_TAC[setFinal_ALT;Import_tame_classification.vertices_face_FST]);
  BY(ASM_REWRITE_TAC[MAP])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!g f. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;fgraph;bn_Graph;faces;makeFaceFinalFaceList;setFinal];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

let PlaneGraphs_all_nonempty = prove_by_refinement(
 `!g. PlaneGraphs g  ==> all (\(l:(num)list). ~(l = [])) (fgraph g)`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[all_nonempty_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  INTRO_TAC subdivFace0_induct [`(all (\ (l:(num)list). ~(l = []))) o fgraph`;`TL vs`;`g`;`(minimalFace (nonFinals g))`;`the (HD vs)`;`0`];
  REWRITE_TAC[o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  REWRITE_TAC[fgraph_makeFaceFinal];
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g'";
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[APPEND_cat;Seq.all_cat];
  REWRITE_TAC[MAP];
  FIRST_X_ASSUM_ST `Face` MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[Seq.all];
    ASM_REWRITE_TAC[];
    TYPIFY `~(vertices (Face (APPEND (REVERSE ws) f1'') F) = [])` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[vertices_face_FST];
    REWRITE_TAC[APPEND_EQ_NIL];
    EXPAND_TAC "f1''";
    REWRITE_TAC[APPEND_EQ_NIL];
    BY(MESON_TAC[NOT_CONS_NIL]);
  COMMENT "last case";
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  FULL_EXPAND_TAC "f2''";
  REWRITE_TAC[GSYM Seq.map_MAP];
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[Seq.map_MAP;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_replace));
  REWRITE_TAC[MEM];
  DISCH_THEN DISJ_CASES_TAC;
    FIRST_X_ASSUM_ST `all` MP_TAC;
    REWRITE_TAC[fgraph];
    REWRITE_TAC[GSYM Seq.map_MAP;GSYM Seq.allP];
    REWRITE_TAC[Seq.map_MAP;MEM_MAP];
    BY(REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC) THEN MESON_TAC[]);
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "x'";
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM_ST `upt` MP_TAC;
  REWRITE_TAC[vertices_face_FST];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[APPEND_EQ_NIL];
  BY(REWRITE_TAC[NOT_CONS_NIL])
]);;
  (* }}} *)

let mem_minimalFace_nonFinals = prove_by_refinement(
  `!g. ~(nonFinals g = []) ==> MEM (minimalFace (nonFinals g)) (nonFinals g)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  REWRITE_TAC[minimalFace];
  BY(MESON_TAC[mem_bn_minimal])
  ]);;
  (* }}} *)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]

xxd...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

let tame9a_correspondence = prove_by_refinement(
 `!g. tame_hypermap (hypermap_of_list (fgraph g)) /\ PlaneGraphs g 
   ==>
  tame9a g`,
  (* {{{ proof *)
  [



rt[Import_tame_classification.bn_Faces]
rt[Import_tame_classification.faces;Import_tame_classification.fgraph]
st/r

  ]);;
  (* }}} *)
