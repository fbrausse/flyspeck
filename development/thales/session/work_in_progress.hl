
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
(* open Import_tame_classification;; *)

(* open More_tame_concl;; *)

(*
open Hypermap;;
open Import_tame_classification;;
open Tame_defs;;
open More_tame_concl;;
*)


(* TO HERE *)

(*
let loop_of_list2 = new_definition' `loop_of_list2 (r:(A)list) = 
  loop(set_of_list r, res (next_el r) (set_of_list r) )`;;

let loop_family_of_list2 = new_definition' `loop_family_of_list2 (N:((A)list)list) = 
  set_of_list (map loop_of_list N )`;;
*)

1;;

Hypermap.is_split_condition;;

(* ... *)

let split_condition_list = new_definition'
  `split_condition_list L N r (d:A#A) <=>
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\ 
    MEM r N /\
    ~(final_list L r) /\
    MEM d r /\
    LAST (find_list (parts L r) d) = d`;;

let atom_list = new_definition'
  `atom_list L r (d:A#A) = find_list (parts L r) d`;;

let find_atom = new_definition'
   `find_atom L N (d:A#A) = atom_list L (find_list N d) d`;;

let partition_into_atom0r = new_definition' 
  `partition_into_atom0r n acc (r:(A)list) = 
  partition_into_atom0 n acc (rev r)`;;

(* ... *)

let NOT_IMP_THM = prove_by_refinement(
  `!a b. (~(a ==> b)) <=> (~b /\ a)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let IMP_IMP_THM = prove_by_refinement(
  `!a b. (a ==> b ==> c) <=> (a /\ b ==> c)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let inverse_node_map_list = prove_by_refinement(
  `!L d. good_list L /\ MEM d (list_of_darts L) ==>
    inverse(node_map (hypermap_of_list L)) d = f_list L (e_list d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.inverse_hypermap_maps];
  REWRITE_TAC[o_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `edge_map (hypermap_of_list L) d IN dart (hypermap_of_list L)` (C SUBGOAL_THEN MP_TAC);
    GMATCH_SIMP_TAC Hypermap.lemma_dart_invariant;
    GMATCH_SIMP_TAC dart_hypermap_of_list;
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  ASM_SIMP_TAC[Lp_gen_theory.e_list_ext_eq_e_list];
  BY(ASM_SIMP_TAC[f_list_ext_f_list])
  ]);;
  (* }}} *)

let face_map_list = prove_by_refinement(
  `!L d. good_list L /\ MEM d (list_of_darts L) ==>
    (face_map (hypermap_of_list L)) d = f_list L (d)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC f_list_ext_f_list;
  BY(ASM_REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

(* was normal_list_f_or_ni *)

let loop_list_f_or_ni = prove_by_refinement(
  `!L r x. loop_list L r /\ MEM x r  ==>
   (next_el r x = f_list L x \/ next_el r x = f_list L (e_list x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_list;one_step_list;GSYM Seq.allP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(* was normal_list_f_xor_ni *)

let edge_nondeg_f_xor_ni = prove_by_refinement(
  `!L x. good_list L /\  MEM x (list_of_darts L) /\
     is_edge_nondegenerate (hypermap_of_list L) ==>
     ~(f_list L x = f_list L (e_list x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_edge_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  BY(ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST;face_map_list;inverse_node_map_list])
  ]);;
  (* }}} *)

let contour_list_is_contour = prove_by_refinement(
  `!L s. good_list L /\ contour_list L s /\ 
    uniq s /\ all (\d. MEM d (list_of_darts L)) s ==> 
    is_contour (hypermap_of_list L) (\i. EL i s) (PRE (sizel s) )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_def_contour;contour_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Hypermap.one_step_contour];
  FIRST_X_ASSUM_ST `LAST` (C INTRO_TAC [`EL i s`]);
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC MEM_EL;
  CONJ_TAC;
    BY(REWRITE_TAC[lower_case] THEN ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[one_step_list];
  TYPIFY `EL i s = nth (HD s) s i` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Seq2.EL_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `~(s = [])` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM Seq.size_eq0];
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `~(i = sizel s - 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `EL (sizel s - 1) s = nth (HD s) s (sizel s - 1)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Seq2.EL_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `EL i s = LAST s` ASM_CASES_TAC;
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM kill;
    INTRO_TAC Seq2.uniq_nthP [`HD s`;`s`];
    ASM_REWRITE_TAC[];
    INTRO_TAC LAST_EL [`s`];
    ASM_REWRITE_TAC[lower_case];
    REWRITE_TAC[NOT_FORALL_THM];
    DISCH_TAC;
    GEXISTL_TAC [`i`;`sizel s - 1`];
    REWRITE_TAC[NOT_IMP_THM];
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  TYPIFY `next_el s (nth (HD s) s i) = EL (SUC i) s` (C SUBGOAL_THEN ASSUME_TAC);
    (REWRITE_TAC[Seq2.next_el]);
    GMATCH_SIMP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.index_uniq);
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    REWRITE_TAC[arith `i+1 = SUC i`];
    MATCH_MP_TAC Seq2.EL_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC inverse_node_map_list;
  GMATCH_SIMP_TAC face_map_list;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  MATCH_MP_TAC Seq.mem_nth;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let index_hd0 = prove_by_refinement(
  `!s. ~(s = []) ==> indexl (HD s) s = 0`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[Seq2.index_head;Seq2.head_HD;Seq.size_eq0;arith `0 < n <=> ~(n=0)`])
  ]);;
  (* }}} *)

let next_el_power_eq = prove_by_refinement(
  `!s t.  ~(s = []) /\ ~(t = []) /\ uniq (s:(A)list) /\ uniq t /\
     (!i. (next_el s POWER i) (HD s) = (next_el t POWER i) (HD t)) ==>
    (s = t)`,
  (* {{{ proof *)
  [
  TYPIFY `!s t.  ~(s = []) /\ ~(t = []) /\ uniq (s:(A)list) /\ uniq t /\ (sizel s <= sizel t) /\     (!i. (next_el s POWER i) (HD s) = (next_el t POWER i) (HD t)) ==>    (s = t)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[arith `n <= m:num \/ m <= n`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_from_nth) [`HD s`];
  DISCH_THEN MATCH_MP_TAC;
  TYPIFY `MEM (HD s) s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  TYPIFY `MEM (HD t) t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  INTRO_TAC Seq2.next_el_power [`HD s`;`s`;`HD s`];
  ASM_SIMP_TAC[index_hd0];
  INTRO_TAC Seq2.next_el_power [`HD t`;`t`;`HD t`];
  ASM_SIMP_TAC[index_hd0];
  TYPIFY `HD t = HD s` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    REWRITE_TAC[Hypermap.POWER_0];
    REWRITE_TAC[I_THM];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[arith `0 + i = i`];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`i`]);
    TYPIFY `i MOD sizel s = i` ((C SUBGOAL_THEN SUBST1_TAC));
      BY(ASM_SIMP_TAC[MOD_LT]);
    TYPIFY `i MOD sizel t = i` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MOD_LT;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(MESON_TAC[]);
  MATCH_MP_TAC (arith `n <= m:num /\ ~(n < m) ==> (n = m)`);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_ASSUM (C INTRO_TAC [`0`]);
  REPEAT (FIRST_X_ASSUM (C INTRO_TAC [`sizel s`]));
  TYPIFY `sizel s MOD sizel t = sizel s` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC MOD_LT;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `sizel s MOD sizel s = 0` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC Oxl_2012.MOD_REFL;
    REWRITE_TAC[Seq.size_eq0];
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `~(sizel s = 0) /\ ~(sizel t = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  ASM_SIMP_TAC[MOD_0];
  INTRO_TAC Seq2.uniq_nthP [`HD s`;`t`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`0`;`sizel s`]);
  ASM_SIMP_TAC[arith `~(n = 0) ==> 0 < n`];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rot_eq_rot = prove_by_refinement(
  `!n m s t. rot n s = rot m t ==> (?l. rot l s = t)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s = sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_rot]);
  TYPIFY `sizel t <= m` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.rot_oversize]);
  TYPIFY `rot (sizel t - m) (rot n s) = rot (sizel t - m) (rot m t)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `sizel t - m + m <= sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `rot` kill;
  ASM_SIMP_TAC[GSYM Seq.rot_addn];
  TYPIFY `sizel t - m + m = sizel t` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.rot_size];
  BY(ASM_MESON_TAC[Seq2.rot_rot_eq_rot])
  ]);;
  (* }}} *)

let next_el_power_rot = prove_by_refinement(
`!s t d.   uniq (s:(A)list) /\ uniq t /\
    MEM d s /\ MEM d t /\
     (!i. (next_el s POWER i) d = (next_el t POWER i) d) ==>
    (?k. rot k s = t)`,
   (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC rot_eq_rot;
  INTRO_TAC Seq2.rot_to_index [`s`;`d`];
  INTRO_TAC Seq2.rot_to_index [`t`;`d`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [ `indexl d s`;`indexl d t`];
  MATCH_MP_TAC next_el_power_eq;
  ASM_SIMP_TAC[Seq2.next_el_rot_eq];
  REWRITE_TAC[NOT_CONS_NIL];
  ASM_REWRITE_TAC[HD];
  BY(ASM_MESON_TAC[Seq.rot_uniq])
  ]);;
  (* }}} *)

let final_list_power = prove_by_refinement(
  `!L r i d. good_list L /\ final_list L r /\ MEM d r /\ uniq r /\ 
    MEM d (list_of_darts L) ==>
     MEM ((next_el r POWER i) d) r  /\
     MEM ((next_el r POWER i) d) (list_of_darts L) /\
    (next_el r POWER i) d = (next_el (find_face L d) POWER i) d`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER_0;I_THM];
    BY(SIMP_TAC[]);
  REWRITE_TAC[Hypermap.POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`next_el r d`]);
  ASM_REWRITE_TAC[];
  TYPIFY `next_el r d = f_list L d` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    REWRITE_TAC[final_list];
    REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN (C INTRO_TAC [`d`]) THEN ASM_REWRITE_TAC[];
    BY(DISCH_THEN (unlist REWRITE_TAC));
  ANTS_TAC;
    ASM_SIMP_TAC[Seq2.mem_next_el];
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP List_hypermap.mem_f_list);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP List_hypermap.mem_find_face_imp_mem_darts);
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `find_face L (f_list L d) = find_face L d /\  f_list L d = next_el (find_face L d) d ` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  GMATCH_SIMP_TAC List_hypermap.find_face_f_list;
  REWRITE_TAC[List_hypermap.f_list];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let final_list_rot = prove_by_refinement(
  `!L r d.  good_list L /\ final_list L r /\ MEM d r /\ uniq r /\
     MEM d (list_of_darts L)  ==>
     (?n.  rot n r = find_face L d)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC next_el_power_rot;
  TYPIFY `d` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  ASM_SIMP_TAC[List_hypermap.uniq_find_face];
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  GEN_TAC;
  INTRO_TAC final_list_power [`L`;`r`;`i`;`d`];
  ASM_REWRITE_TAC[];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let rot_sym = prove_by_refinement(
  `! r (s:(A)list). (?k. rot k r = s) <=> (?k. rot k s = r)`,
  (* {{{ proof *)
  [
  TYPIFY `!r (s:(A)list). (?k. rot k r = s) ==> (?k. rot k s = r)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC rot_eq_rot;
  GEXISTL_TAC [`0`;`k`];
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.rot0])
  ]);;
  (* }}} *)

let set_of_list_rot = prove_by_refinement(
  `!s n. set_of_list (rot n s) = set_of_list s`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;Seq.mem_rot])
  ]);;
  (* }}} *)

let loop_of_face_list = prove_by_refinement(
  `!L r x. good_list L /\ final_list L r /\ uniq r /\
    MEM x r /\ MEM x (list_of_darts L)
     ==>
    loop_of_face (hypermap_of_list L) x = loop_of_list r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_loop_identity];
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_SIMP_TAC[Tame_list.loop_map_next_el];
  ASM_SIMP_TAC[dart_of_loop_of_list];
  INTRO_TAC final_list_rot [`L`;`r`;`x`];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[rot_sym];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "r";
  REWRITE_TAC[set_of_list_rot];
  GMATCH_SIMP_TAC Seq2.next_el_rot_eq;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[List_hypermap.face_of_list]);
  DISCH_TAC;
  REWRITE_TAC[FUN_EQ_THM];
  INTRO_TAC Seq2.next_el_permutes [`find_face L x`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  DISCH_TAC;
  TYPIFY_GOAL_THEN `res (next_el (find_face L x)) (set_of_list (find_face L x)) = next_el (find_face L x)` (SUBST1_TAC o GSYM);
    BY(ASM_SIMP_TAC[Hypermap_and_fan.PERMUTES_IMP_RES_EQ_FUN]);
  GEN_TAC THEN REWRITE_TAC[Sphere.res];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC THEN ASM_SIMP_TAC[];
    REWRITE_TAC[IN_SET_OF_LIST];
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    DISCH_TAC;
    GMATCH_SIMP_TAC Tame_list.f_list_ext_f_list;
    REWRITE_TAC[List_hypermap.f_list];
    TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[good_list]);
    REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.mem_find_face_imp_faces_eq]);
  FIRST_X_ASSUM MP_TAC;
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let final_list_face = prove_by_refinement(
  `!L r. good_list L /\ MEM r (list_of_faces L) ==> final_list L r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[final_list;List_hypermap.list_of_faces;MEM_MAP;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.f_list];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[List_hypermap.find_face_alt];
  AP_TERM_TAC;
  MATCH_MP_TAC (GSYM List_hypermap.find_pair_list_unique);
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let marked_list_edge_map_final = prove_by_refinement(
  `!L N r d. good_list L /\ 
    marked_list L N r d ==> 
    edge_map (hypermap_of_list L) d IN 
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `find_list` MP_TAC;
  LET_TAC;
  DISCH_TAC;
  TYPIFY `set_of_list r'` EXISTS_TAC;
  REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (f_list L d) (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `f_list` (SUBST1_TAC o GSYM);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  TYPIFY `e_list_ext L d = e_list d` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "r'";
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC mem_find_list1;
  SUBCONJ_TAC;
    INTRO_TAC e_list_ext_n_f [`L`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[FUN_EQ_THM;o_THM];
    DISCH_THEN (C INTRO_TAC [`d`]);
    ASM_SIMP_TAC[];
    GMATCH_SIMP_TAC f_list_ext_f_list;
    ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list];
    DISCH_THEN kill;
    GMATCH_SIMP_TAC n_list_ext_n_list;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
      BY(REWRITE_TAC[GSYM Seq.allP] THEN ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC normal_list_mem_n;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  COMMENT "finals";
  TYPIFY `loop_of_list (find_list N (e_list d))` EXISTS_TAC;
  (REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case]);
  TYPED_ABBREV_TAC `r' = find_list N (e_list d)`;
  TYPIFY `MEM r' N` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "r'";
    MATCH_MP_TAC List_hypermap.mem_find_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  nCONJ_TAC 2;
    GMATCH_SIMP_TAC dart_of_loop_of_list;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `e_list d` EXISTS_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  ASM_SIMP_TAC[in_dart_loop_of_list];
  SUBCONJ_TAC;
    FULL_EXPAND_TAC "r'";
    MATCH_MP_TAC mem_find_list1;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  GMATCH_SIMP_TAC loop_of_face_list;
  TYPIFY `r'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC normal_list_list_of_darts [`L`;`N`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_list = prove_by_refinement(
  `!L N r d. good_list L /\ 
       MEM d r /\ MEM r N /\ normal_list L N /\ final_list L r ==>
    d IN (
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `set_of_list r` EXISTS_TAC;
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `loop_of_face (hypermap_of_list L) d` EXISTS_TAC;
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case;MEM_MAP];
  TYPIFY `loop_of_face (hypermap_of_list L) d = loop_of_list r` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC loop_of_face_list;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  nCONJ_TAC 1;
    REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
    GEN_TAC;
    MATCH_MP_TAC (GSYM in_dart_loop_of_list);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  REWRITE_TAC[IN_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_loops_list = prove_by_refinement(
  `!L N r. good_list L /\ 
       MEM r N /\ normal_list L N /\ final_list L r ==>
    loop_of_list r IN (final_loops (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[loop_family_of_list;upper_case;IN_SET_OF_LIST];
  CONJ_TAC;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  TYPIFY `?d. MEM d r` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[GSYM List_hypermap.mem_not_nil];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d` EXISTS_TAC;
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  TYPIFY `loop_of_face (hypermap_of_list L) d = loop_of_list r` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC loop_of_face_list;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC in_dart_loop_of_list;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil])
  ]);;
  (* }}} *)

let face_loop_imp_final_list = prove_by_refinement(
  `!L N r x. good_list L /\ normal_list L N /\ MEM r N /\ MEM x r /\
    loop_of_face (hypermap_of_list L) x = loop_of_list r ==>
    final_list L r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_loop_identity];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `dart_of_loop` MP_TAC;
  ASM_SIMP_TAC[dart_of_loop_of_list];
  FIRST_X_ASSUM_ST `loop_map` MP_TAC;
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  ASM_SIMP_TAC[ loop_map_next_el];
  GMATCH_SIMP_TAC List_hypermap.face_of_list;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[final_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY ` x' IN (set_of_list (find_face L x))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  FIRST_X_ASSUM_ST `next_el` (SUBST1_TAC o GSYM);
  REWRITE_TAC[Sphere.res];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC f_list_ext_f_list;
  REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
  FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_conv = prove_by_refinement(
  `!L N d. good_list L /\ 
       d IN (
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N)) /\
       normal_list L N ==> (?r. MEM d r /\ MEM r N /\ final_list L r)
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "t";
  FULL_EXPAND_TAC "L'";
  REPEAT (FIRST_X_ASSUM_ST `=` kill);
  FIRST_X_ASSUM_ST `loop_family_of_list` MP_TAC;
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `in_dart_of_loop` MP_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  FIRST_X_ASSUM_ST `IN` MP_TAC;
  TYPIFY `dart_of_loop (loop_of_face (hypermap_of_list L) x) = dart_of_loop (loop_of_list x')` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  SUBCONJ_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  MATCH_MP_TAC face_loop_imp_final_list;
  GEXISTL_TAC [`N`;`x`];
  (ASM_REWRITE_TAC[]);
  ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.face_refl])
  ]);;
  (* }}} *)

let final_loops_conv = prove_by_refinement(
  `!L N z. good_list L /\ 
    z IN final_loops (hypermap_of_list L) (loop_family_of_list N) /\
       normal_list L N ==> (?r. MEM r N /\ final_list L r /\ z = loop_of_list r)
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "z";
  REPEAT (FIRST_X_ASSUM_ST `=` kill);
  FIRST_X_ASSUM_ST `loop_family_of_list` MP_TAC;
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `in_dart_of_loop` MP_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  TYPIFY `dart_of_loop (loop_of_face (hypermap_of_list L) x) = dart_of_loop (loop_of_list x')` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  SUBCONJ_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC face_loop_imp_final_list;
  GEXISTL_TAC [`N`;`x`];
  (ASM_REWRITE_TAC[]);
  ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.face_refl])
  ]);;
  (* }}} *)

let final_loops_list_eq = prove_by_refinement(
  `!L N. good_list L /\ normal_list L N ==>
    final_loops (hypermap_of_list L) (loop_family_of_list N) = 
      set_of_list (MAP loop_of_list (filter (final_list L) N))
   `,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP;Seq.mem_filter];
  MATCH_MP_TAC (TAUT `((a ==>b ) /\ (b ==> a)) ==> (a = b)`);
  REPEAT STRIP_TAC;
    INTRO_TAC final_loops_conv [`L`;`N`;`x`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC final_loops_list [`L`;`N`;`x'`];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_list_eq = prove_by_refinement(
  `!L N. good_list L /\ normal_list L N ==>
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N) = 
   set_of_list (final_dart_list L N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;final_dart_list];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (TAUT `((a ==>b ) /\ (b ==> a)) ==> (a = b)`);
  CONJ_TAC;
    DISCH_TAC;
    INTRO_TAC darts_in_final_loops_conv [`L`;`N`;`x`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[Seq.mem_filter]);
  REWRITE_TAC[Seq2.mem_flatten;Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC darts_in_final_loops_list;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let support_of_sequence_list = prove_by_refinement(
  `!s.  ~(s=[]) ==>  
    support_of_sequence (\i. EL i s) (PRE (sizel s)) = set_of_list s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.support_of_sequence];
  REWRITE_TAC[EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_EXISTS_EL];
  REWRITE_TAC[arith `!i. i <= n <=> i < SUC n`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC (PRE (sizel s)) = sizel s` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[lower_case]);
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size_eq0];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let next_el_cat_sym = prove_by_refinement(
  `!s t. uniq (cat s t) ==> next_el (cat s t) = next_el (cat t s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.rot_size_cat [`s`;`t`];
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(ASM_SIMP_TAC[Seq2.next_el_rot_eq])
  ]);;
  (* }}} *)

let indexl_last = prove_by_refinement(
  `!x s. uniq s /\ ~(s = []) ==> indexl (last x s) s = sizel s - 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.nth_last];
  GMATCH_SIMP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.index_uniq);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size_eq0];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let indexl_LAST = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> indexl (LAST s) s = sizel s - 1`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[indexl_last;last_LAST])
  ]);;
  (* }}} *)

let next_el_cat1 = prove_by_refinement(
  `!s t.   uniq s /\ MEM x s /\ ~(x = LAST s) ==>
    next_el (cat s t) x = next_el s x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Seq2.next_el_mod);
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.mem_cat];
  ASM_REWRITE_TAC[Seq.index_cat];
  ASM_REWRITE_TAC[Seq.nth_cat];
  TYPIFY `indexl x s + 1 < sizel s` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    TYPIFY `indexl x s + 1 < sizel (cat s t)` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[Seq.size_cat];
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_SIMP_TAC[MOD_LT]);
  TYPIFY `indexl x s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  TYPIFY `~(sizel s - 1 = indexl x s)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  INTRO_TAC indexl_LAST [`s`] THEN ASM_REWRITE_TAC[];
  TYPIFY `~(s = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.uniq_index_inj;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC MEM_LAST;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_cat2 = prove_by_refinement(
  `!s t.   uniq (cat s t) /\ MEM x t /\ ~(x = LAST t) ==>
    next_el (cat s t) x = next_el t x`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[next_el_cat_sym;next_el_cat1;Seq.uniq_catC;Seq.cat_uniq])
  ]);;
  (* }}} *)

let cat_eq_nil = prove_by_refinement(
  `!s t. cat s t = [] <=> (s = [] /\ t = [])`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[upper_case;APPEND_EQ_NIL])
  ]);;
  (* }}} *)

let next_el_cat_last2 = prove_by_refinement(
  `!s t. uniq (cat s t) /\ ~(t = []) /\ ~(s = []) ==>
      next_el (cat s t) (LAST t) = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `HD s = HD (cat s t)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[upper_case;HD_APPEND]);
  GMATCH_SIMP_TAC (GSYM Seq2.next_el_last);
  TYPIFY `~(cat s t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[cat_eq_nil]);
  ASM_SIMP_TAC[last_LAST];
  CONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_cat] THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[LAST_APPEND;upper_case])
  ]);;
  (* }}} *)

let next_el_cat_last1 = prove_by_refinement(
  `!s t. uniq (cat s t) /\ ~(t = []) /\ ~(s = []) ==>
      next_el (cat s t) (LAST s) = HD t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC next_el_cat_sym;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC next_el_cat_last2;
  BY(ASM_MESON_TAC[Seq.uniq_catC])
  ]);;
  (* }}} *)

let LAST_find_list = prove_by_refinement(
  `!s x. x = LAST(flatten s) /\ ~(flatten s = []) /\ uniq (flatten s) ==>
      LAST (find_list s x) = x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[List_hypermap.find_list;LAST;Seq.flatten_cons;Seq.flatten0];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    FIRST_X_ASSUM_ST `LAST` MP_TAC THEN ASM_REWRITE_TAC[LAST_APPEND;upper_case];
    COND_CASES_TAC;
      BY(MESON_TAC[]);
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cat_uniq];
    REWRITE_TAC[GSYM Seq.hasP];
    REWRITE_TAC[NOT_EXISTS_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`x`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `MEM x (cat h (flatten t))` (C SUBGOAL_THEN MP_TAC);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_LAST]);
  ASM_REWRITE_TAC[Seq.mem_cat];
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `~(flatten t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[LAST_APPEND;upper_case]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cat_uniq];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let find_list_uniq = prove_by_refinement(
  `!L s x. uniq (flatten L) /\ MEM x s /\ MEM s L ==> find_list L x = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;List_hypermap.find_list];
  REWRITE_TAC[Seq.flatten_cons;Seq.cat_uniq];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = s` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM s t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `has` MP_TAC THEN REWRITE_TAC[GSYM Seq.hasP;Seq2.mem_flatten];
  DISCH_TAC;
  TYPIFY `~(MEM x h)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_flatten_unlast = prove_by_refinement(
  `!s r (x:A). uniq (flatten s) /\ MEM x r /\ MEM r s /\ ~(x = LAST r) ==>
     next_el (flatten s) x = next_el r x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = h` ASM_CASES_TAC;
    FULL_EXPAND_TAC "h";
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  GMATCH_SIMP_TAC next_el_cat2;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `next_el` GMATCH_SIMP_TAC;
  TYPIFY `r` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq2.mem_flatten];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC LAST_find_list [`t`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq2.mem_flatten;MEM]);
  TYPIFY `find_list t x = r` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC find_list_uniq;
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let HD_flatten = prove_by_refinement(
  `!t. ~(flatten t = []) /\ ~(HD t = []) ==> HD (flatten t) = HD (HD t)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0]);
  REWRITE_TAC[HD];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPIFY `cat h = cat (HD h :: TL h)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.cat_cons];
  BY(REWRITE_TAC[HD])
  ]);;
  (* }}} *)

let next_el_flatten_last_hd = prove_by_refinement(
  `!s (r:A list). uniq (flatten s) /\ all (\r. ~(r = [])) s /\ r = HD s /\
    ~(s = []) ==>
     next_el (flatten s) (LAST r) = HD (next_el s r)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;HD];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "h";
  TYPIFY `(flatten t = [])` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq.cats0];
    TYPIFY `t = []` (C SUBGOAL_THEN ASSUME_TAC);
      PROOF_BY_CONTR_TAC;
      TYPIFY `?x. MEM x (flatten t)` ENOUGH_TO_SHOW_TAC;
        BY(ASM_REWRITE_TAC[MEM]);
      REWRITE_TAC[Seq2.mem_flatten];
      FIRST_X_ASSUM MP_TAC;
      REWRITE_TAC[List_hypermap.mem_not_nil];
      REPEAT WEAKER_STRIP_TAC;
      FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
      BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[next_el1];
    GMATCH_SIMP_TAC (GSYM Seq2.next_el_last);
    ASM_SIMP_TAC[last_LAST];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n <=> ~(n = 0)`]);
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  (GMATCH_SIMP_TAC next_el_cat_last1);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
  REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.flatten0]);
  DISCH_TAC;
  GMATCH_SIMP_TAC HD_flatten;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (HD t) t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_HD]);
  FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let HD_take = prove_by_refinement(
  `!i. ~(i=0) /\ ~(s = []) ==> HD (take i s) = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM (MP_TAC o MATCH_MP CONS_HD_TL);
  DISCH_THEN SUBST1_TAC;
  BY(REWRITE_TAC[Seq.take_cons;HD])
  ]);;
  (* }}} *)

let cat_to = prove_by_refinement(
  `!(x:A) s. MEM x s ==> (?a b. s = cat a b /\ x = HD b /\ ~(b = []))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.rot_to [`s`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `?i s'. rot i (x :: s') = s` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[rot_sym]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = 0` ASM_CASES_TAC;
    TYPIFY `s = x::s'` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.rot0]);
    GEXISTL_TAC [`[]:A list`;`s`];
    BY(ASM_MESON_TAC[Seq.cat0s;HD;MEM]);
  FIRST_X_ASSUM_ST `rot` MP_TAC;
  REWRITE_TAC[Seq.rot];
  DISCH_TAC;
  GEXISTL_TAC [`dropl i (x :: s')`;`take i (x :: s')`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC HD_take;
  (ASM_REWRITE_TAC[HD;NOT_CONS_NIL]);
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[Seq.take_cons;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let next_el_flatten_last = prove_by_refinement(
  `!s (r:A list). uniq (flatten s) /\ all (\r. ~(r = [])) s /\ MEM r s 
   ==> 
     next_el (flatten s) (LAST r) = HD (next_el s r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM cat_to) [`r`;`s`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "s";
  GMATCH_SIMP_TAC next_el_cat_sym;
  REWRITE_TAC[Seq.flatten_cat];
  TYPIFY `next_el (cat (flatten a) (flatten b)) (LAST r) = next_el (cat (flatten b) (flatten a)) (LAST r)` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC next_el_cat_sym;
    BY(ASM_REWRITE_TAC[GSYM Seq.flatten_cat]);
  SUBCONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[GSYM Seq.flatten_cat];
  MATCH_MP_TAC next_el_flatten_last_hd;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 3;
    BY(ASM_REWRITE_TAC[cat_eq_nil]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[upper_case;HD_APPEND]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[Seq.allP;Seq.mem_cat]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.uniq_catC;Seq.flatten_cat]);
  BY(ASM_REWRITE_TAC[])
   ]);;
  (* }}} *)

let index_indexf = prove_by_refinement(
  `!x y. uniq r /\ MEM x r /\ MEM y r ==> 
    index (loop_of_list r) x y = indexf x y r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Hypermap.determine_loop_index;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  GMATCH_SIMP_TAC in_dart_loop_of_list;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.pre_card_dart_of_loop];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  GMATCH_SIMP_TAC loop_map_next_el;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC indexf_n;
  INTRO_TAC indexf_lt_sizel [`r`;`x`;`y`];
  ASM_SIMP_TAC[];
  TYPIFY `~(r  = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_REWRITE_TAC[];
  TYPIFY `~(sizel r = 0)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rev1 = prove_by_refinement(
  `!h. rev [h] = [h]`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.rev_cons;rev0;Seq.rcons])
  ]);;
  (* }}} *)

let LAST_rev = prove_by_refinement(
  `!t. ~(t = []) ==> LAST (rev t) = HD t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM];
  REWRITE_TAC[Seq.rev_cons;Seq.rcons];
  REWRITE_TAC[Seq.rev_cons;Seq.rcons;HD];
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  REWRITE_TAC[GSYM Seq.cats1];
  TYPIFY `t = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[rev0;Seq.cat0s];
    BY(REWRITE_TAC[LAST_CLAUSES]);
  TYPIFY `~(rev t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.revK;rev0]);
  INTRO_TAC Seq.last_cat [`h`;`rev t`;`[h]`];
  REPEAT (GMATCH_SIMP_TAC last_LAST);
  ASM_REWRITE_TAC[NOT_CONS_NIL;cat_eq_nil];
  BY(ASM_MESON_TAC[LAST_CLAUSES])
  ]);;
  (* }}} *)

let cat_from = prove_by_refinement(
  `!(x:A) s. MEM x s ==> (?a b. s = cat a b /\ x = LAST a /\ ~(a = []))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_to [`x`;`rev s`];
  ASM_REWRITE_TAC[Seq.mem_rev];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`rev b`;`rev a`];
  ASM_REWRITE_TAC[GSYM Seq.rev_cat];
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.revK]);
  CONJ2_TAC;
    BY(ASM_MESON_TAC[rev0;Seq.revK]);
  BY(ASM_SIMP_TAC[LAST_rev])
  ]);;
  (* }}} *)

let LAST_cat = prove_by_refinement(
  `!u v. ~(v = []) ==> LAST (cat u v) = LAST v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.last_cat [`LAST v`;`u`;`v`];
  REPEAT (GMATCH_SIMP_TAC last_LAST);
  BY(ASM_REWRITE_TAC[NOT_CONS_NIL;cat_eq_nil])
  ]);;
  (* }}} *)

let HD_rev = prove_by_refinement(
  `!t. ~(t = []) ==> HD (rev t) = LAST t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM LAST_rev);
  REWRITE_TAC[Seq.revK];
  BY(ASM_MESON_TAC[rev0;Seq.revK])
  ]);;
  (* }}} *)

let FORALL_REV_THM = prove_by_refinement(
  ` (!r. f (rev r)) <=> (!r. f r)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.revK]);
  ]);;
  (* }}} *)

let partition_into_atom0r_cases = prove_by_refinement(
  `!r rs n acc.  partition_into_atom0r n acc [] = acc /\
    partition_into_atom0r n acc (rcons rs r) =
     (if acc = []
      then partition_into_atom0r n [[r]] rs
      else if n r = HD (HD acc)
           then partition_into_atom0r n ((r :: HD acc) :: TL acc) rs
           else partition_into_atom0r n ([r] :: acc) rs)
   `,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[partition_into_atom0r;rev0;partition_into_atom0;Seq.rev_rcons])
  ]);;
  (* }}} *)

let partsr = prove_by_refinement(
  `!L r. parts L r = partition_into_atom0r (f_list L o e_list) [] r`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[parts;partition_into_atom0r;partition_into_atom])
  ]);;
  (* }}} *)

let LISTR_INDUCT = prove_by_refinement(
  `!f. (f []) /\ (!h t. f t ==> f (rcons t h)) ==> (!r. f r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  ONCE_REWRITE_TAC[GSYM FORALL_REV_THM];
  REPEAT DISCH_TAC;
  (LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[rev0;Seq.rev_cons]);
  ASM_MESON_TAC[]
  ]);;
  (* }}} *)

let LISTR_INDUCT_TAC = 
  MATCH_MP_TAC LISTR_INDUCT THEN CONJ_TAC 
    THENL[ALL_TAC;REPEAT GEN_TAC THEN DISCH_TAC];;

let LAST_rcons = prove_by_refinement(
  `!t h. LAST (rcons t h) = h`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.last_rcons;last_LAST;rcons_nonnil])
  ]);;
  (* }}} *)

let partition_into_atom0r_pure = prove_by_refinement(
  `!n r a. ~(r = []) /\ uniq r /\
    (!x. MEM x r ==> x = LAST r \/ (next_el r x = n x)) ==>
    partition_into_atom0r n a r = 
   if (a = [] \/ ~(n (LAST r) = HD (HD a))) then r :: a 
   else (cat r (HD a)) :: TL a`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases;MEM;HD];
  GEN_TAC;
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "insert";
  TYPIFY `t = []` ASM_CASES_TAC;
    (ASM_REWRITE_TAC[LAST;partition_into_atom0r_cases;Seq.rev_cons;rev0;rev1;Seq.rcons]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat1s]);
  TYPIFY `!x. MEM x t ==> x = LAST t \/ next_el t x = n x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x = LAST t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (C INTRO_TAC [`x`]);
    REWRITE_TAC[Seq.mem_rcons;MEM;LAST_rcons];
    TYPIFY `~(x = h)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.rcons_uniq]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_MESON_TAC[Seq.rcons_uniq]);
  TYPIFY `n (LAST t) = h` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `rcons` (C INTRO_TAC [`LAST t`]);
    REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat];
    ASM_SIMP_TAC[MEM_LAST];
    REWRITE_TAC[Seq.cats1;LAST_rcons];
    DISCH_THEN DISJ_CASES_TAC;
      BY(ASM_MESON_TAC[MEM_LAST;Seq.rcons_uniq]);
    FIRST_X_ASSUM MP_TAC;
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat_last1;
    (ASM_REWRITE_TAC[HD;Seq.cats1;Seq.rcons_uniq;NOT_CONS_NIL]);
    BY(SIMP_TAC[]);
  COMMENT "a empty";
  TYPIFY `a = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases];
    FIRST_X_ASSUM GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[NOT_CONS_NIL;HD;TL;GSYM Seq.cats1];
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.rcons_uniq];
    BY(SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "now ~(a = [])";
  SIMP_TAC[LAST_rcons];
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.rcons_uniq] THEN DISCH_TAC;
  ((COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN FIRST_X_ASSUM GMATCH_SIMP_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL;HD;TL]));
    ONCE_REWRITE_TAC[GSYM Seq.cats1];
    REWRITE_TAC[GSYM Seq.catA];
    BY(MESON_TAC[Seq.cat1s]);
  BY(MESON_TAC[Seq.cats1])
  ]);;
  (* }}} *)

let parts_pure = prove_by_refinement(
  `!L r. ~(r = []) /\ uniq r /\
    (!x. MEM x r ==> x = LAST r \/ next_el r x = f_list L (e_list x)) 
  ==> parts L r = [r]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[partsr];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC partition_into_atom0r_pure;
  BY(ASM_REWRITE_TAC[o_THM])
  ]);;
  (* }}} *)

let eqseq_cat2 = prove_by_refinement(
  `!s1 s2 s3 s4.
    sizel s3 = sizel s4 ==>
    (cat s1 s3 = cat s2 s4 <=> s1 = s2 /\ s3 = s4)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `s1 = s2 /\ s3 = s4` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `sizel (cat s1 s3) = sizel (cat s2 s4)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq.size_cat];
  DISCH_TAC;
  TYPIFY `sizel s1 = sizel s2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.eqseq_cat])
  ]);;
  (* }}} *)

let partition_into_atom0r_cons_acc = prove_by_refinement(
  `!n r a0 a. 
    partition_into_atom0r n (a0::a) r = 
      cat (partition_into_atom0r n [a0] r) a`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC;
    REWRITE_TAC[partition_into_atom0r_cases;MEM;];
    BY(REWRITE_TAC[Seq.cat1s]);
  REWRITE_TAC[partition_into_atom0r_cases;MEM;];
  REWRITE_TAC[rcons_nonnil;NOT_CONS_NIL;HD;TL];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(DISCH_THEN (unlist REWRITE_TAC o GSYM));
  DISCH_THEN (unlist ONCE_REWRITE_TAC);
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  BY(REWRITE_TAC[Seq.cats0;Seq.catA])
  ]);;
  (* }}} *)

let partition_into_atom0r_cat = prove_by_refinement(
  `!n r u v x a. MEM x r  /\ ~(next_el r x = n x) /\
     r = cat u v /\ LAST u = x /\ ~(u= []) /\ ~(v = []) /\ uniq r ==>
    partition_into_atom0r n a r = 
    cat (partition_into_atom0r n [] u) (partition_into_atom0r n a v)`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases;MEM;LAST_rcons;Seq.rcons_uniq;Seq.mem_rcons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `LAST v = h` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[LAST_cat;LAST_rcons]);
  TYPIFY `?v'. rcons v' h = v` (C SUBGOAL_THEN MP_TAC);
    INTRO_TAC Seq2.cat_butlast_last [`h`;`v`];
    ASM_REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
    DISCH_THEN SUBST1_TAC;
    REWRITE_TAC[Seq.cats1];
    ASM_SIMP_TAC[last_LAST];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "v";
  TYPIFY `t = cat u v'` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `rcons t h = cat u k` MP_TAC;
    REWRITE_TAC[GSYM Seq.cats1;Seq.catA];
    BY(GMATCH_SIMP_TAC eqseq_cat2);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v'`;`x`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_REWRITE_TAC[partition_into_atom0r_cases];
  TYPIFY `v' = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq.cats0;partition_into_atom0r_cases];
    COMMENT "expand u";
    TYPIFY `?u'. rcons u' x = u` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC Seq2.cat_butlast_last [`x`;`u`];
      ASM_REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
      DISCH_THEN SUBST1_TAC;
      REWRITE_TAC[Seq.cats1];
      ASM_SIMP_TAC[last_LAST];
      BY(MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "u";
    REWRITE_TAC[partition_into_atom0r_cases;NOT_CONS_NIL;HD;TL];
    TYPIFY `~(n x = h)` (C SUBGOAL_THEN ASSUME_TAC);
      DISCH_TAC;
      FIRST_X_ASSUM_ST `next_el` kill;
      FIRST_X_ASSUM_ST `next_el` MP_TAC;
      REWRITE_TAC[];
      ASM_REWRITE_TAC[Seq.rcons];
      INTRO_TAC next_el_cat_last1 [`rcons u' x`;`[h]`];
      SIMP_TAC[LAST_rcons;NOT_CONS_NIL;HD];
      DISCH_THEN MATCH_MP_TAC;
      REWRITE_TAC[Seq.cats1;rcons_nonnil];
      TYPIFY `t = (rcons u' x)` ENOUGH_TO_SHOW_TAC;
        DISCH_THEN (SUBST1_TAC o GSYM);
        REWRITE_TAC[Seq.rcons_uniq];
        BY(ASM_REWRITE_TAC[]);
      BY(ASM_REWRITE_TAC[Seq.cats0]);
    ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
    BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
  COMMENT "now v' nonnil";
  TYPIFY `MEM x (cat u v')` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[Seq.mem_cat];
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `~(next_el (cat u v') x = n x)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `next_el` kill;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `next_el (rcons t h)` MP_TAC;
    REWRITE_TAC[];
    TYPIFY `rcons t h = rcons (cat u v') h` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat1;
    TYPIFY `~(x = LAST (cat u v'))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Seq.mem_cat;MEM_LAST]);
    ASM_SIMP_TAC[LAST_cat];
    FIRST_X_ASSUM_ST `uniq` MP_TAC;
    ASM_REWRITE_TAC[Seq.cat_uniq;GSYM Seq.hasP];
    BY(ASM_MESON_TAC[MEM_LAST]);
  FIRST_X_ASSUM_ST `partition_into_atom0r` MP_TAC;
  ASM_REWRITE_TAC[];
  DISCH_THEN (unlist REWRITE_TAC);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let parts_cat = prove_by_refinement(
  `!L r u v x.  r = cat u v /\ LAST u = x /\ ~(u = []) /\ ~(v = []) /\
    ~(next_el r x = f_list L (e_list x)) /\ uniq r ==> 
     parts L r = cat (parts L u) (parts L v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[partsr];
  GMATCH_SIMP_TAC (GSYM partition_into_atom0r_cat);
  TYPIFY `r` EXISTS_TAC;
  REWRITE_TAC[];
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[o_THM];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[Seq.mem_cat];
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let parts_cases = prove_by_refinement(
  `!n r. (!x. MEM x r ==> x = LAST r \/ next_el r x = n x) \/
     (?u v x. r = cat u v /\ LAST u = x /\ ~(u = []) /\ ~(v = []) /\
	 ~(next_el r x = n x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (TAUT (`(~a ==> b) ==> (a \/ b)`));
  REWRITE_TAC[NOT_FORALL_THM;DE_MORGAN_THM];
  REWRITE_TAC[TAUT `(~(a ==> b \/ c) <=> a /\ ~b /\ ~c)`];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_from [`x`;`r`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`a`;`b`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `cat` MP_TAC;
  ASM_REWRITE_TAC[Seq.cats0];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let size_induct = prove_by_refinement(
  `!P.  (!i. (!r:A list. sizel r < i ==> P r) ==> 
	   (!r:A list. sizel r = i ==> P r  )) 
    ==> (!r:A list. P r)`,
  (* {{{ proof *)
  [
  GEN_TAC THEN DISCH_TAC;
  TYPIFY `!n r. sizel r <= n ==> P r` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[arith `n <= n:num`]);
  TYPIFY `!i. (!r. sizel r < i ==> P r) ==> (!r. sizel r <= i ==> P r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `n <= i <=> n < i:num \/ n = i`]);
  INDUCT_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[arith `~(n < 0)`]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[arith `m <= n <=> m < SUC n`])
  ]);;
  (* }}} *)

let parts_induct_lemma = prove_by_refinement(
  `!r u v. uniq r /\ r = cat u v /\ ~(u = []) /\ ~(v = []) ==>
   sizel u < sizel r /\ sizel v < sizel r /\ uniq u /\ uniq v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel r = sizel u + sizel v` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `cat` (SUBST1_TAC);
    BY(REWRITE_TAC[Seq.size_cat]);
  TYPIFY `~(sizel u = 0) /\ ~(sizel v = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  TYPIFY `sizel u < sizel r /\ sizel v < sizel r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  BY(ASM_SIMP_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let parts_flatten = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> flatten (parts L r) = r`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.flatten_cons];
    BY(REWRITE_TAC[concat_flatten;Seq.cats0]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.flatten_cat];
  REPEAT (FIRST_ASSUM_ST `flatten` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_all_nonnil = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> all (\p. ~(p = [])) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  REPEAT (FIRST_ASSUM_ST `all` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_next_unlast = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> 
     all (\p. (!x. MEM x p /\ ~(x = LAST p) ==> 
		 next_el p x = f_list L (e_list x))) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  RULE_ASSUM_TAC (REWRITE_RULE[IMP_IMP_THM]);
  TYPIFY `cat u v = r` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[]);
  REPEAT (FIRST_ASSUM_ST `all` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_next_last = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==>
  //    ~(next_el r (LAST r) = f_list L (e_list (LAST r))) ==> 
     all (\p. (!(x:A#A). MEM x p /\ (x = LAST p) /\ ~(x = LAST r) ==> 
		 ~(next_el r x = f_list L (e_list x)))) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  RULE_ASSUM_TAC (REWRITE_RULE[IMP_IMP_THM]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[parts_induct_lemma]);
  REWRITE_TAC[GSYM Seq.allP;MEM];
  TYPIFY `sizel v < i /\ sizel u < i /\ uniq u /\ uniq v` (C SUBGOAL_THEN ASSUME_TAC);
    BY((ASM_MESON_TAC[parts_induct_lemma]));
  COMMENT "u";
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    RENAME_FREE_VAR (`x':(A#A)list`,"p");
    TYPIFY `~(x'' = LAST u)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    TYPIFY `MEM x'' u` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[parts_flatten;Seq2.mem_flatten]);
    FIRST_X_ASSUM (C INTRO_TAC [`u`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
    TYPIFY `p` EXISTS_TAC;
    ASM_REWRITE_TAC[NOT_FORALL_THM];
    TYPIFY `x''` EXISTS_TAC;
    REWRITE_TAC[TAUT `~(a ==> ~b) <=> a /\ b`];
    ASM_REWRITE_TAC[];
    TYPIFY `next_el r x'' = next_el u x''` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    TYPIFY `r = cat u v` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[]);
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "v";
  REPEAT WEAKER_STRIP_TAC;
  RENAME_FREE_VAR (`x':(A#A)list`,"p");
  TYPIFY `MEM x'' v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten;Seq2.mem_flatten]);
  FIRST_X_ASSUM (C INTRO_TAC [`v`]);
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
  TYPIFY `p` EXISTS_TAC;
  ASM_REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `x''` EXISTS_TAC;
  REWRITE_TAC[TAUT `~(a ==> ~b) <=> a /\ b`];
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `LAST (cat u v)` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[LAST_cat]);
  DISCH_TAC;
  TYPIFY `next_el r x'' = next_el v x''` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `r = cat u v` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC next_el_cat2;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* was next_el_parts1 *)

let next_el_parts_unlast = prove_by_refinement(
  `!L r p x.  uniq r /\ ~(r = []) /\
     MEM x p /\ MEM p (parts L r) /\ ~(x = LAST p) ==>
    next_el r x = next_el p x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_SIMP_TAC[parts_flatten]);
  GMATCH_SIMP_TAC next_el_flatten_unlast;
  TYPIFY `p` EXISTS_TAC;
  BY(ASM_SIMP_TAC[parts_flatten])
  ]);;
  (* }}} *)

let next_el_parts_last = prove_by_refinement(
  `!L r p x.  uniq r /\ ~(r = []) /\
     MEM x p /\ MEM p (parts L r) /\ (x = LAST p) ==>
    next_el r x =  HD (next_el (parts L r) p) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_SIMP_TAC[parts_flatten]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC next_el_flatten_last;
  (ASM_SIMP_TAC[parts_flatten]);
  MATCH_MP_TAC parts_all_nonnil;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let quotient_all_uniq = prove_by_refinement(
  `!L N r x. marked_list L N r x ==>
    all uniq (quotient_list L N)`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[marked_list;LET_THM])
  ]);;
  (* }}} *)

let LYNVPSU = quotient_all_uniq;;

let parts_nonnil = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> ~(parts L r = [])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_flatten [`L`;`r`] THEN ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.flatten0])
  ]);;
  (* }}} *)

let quotient_all_nonnil = prove_by_refinement(
  `!L N.  normal_list L N ==>
  all (\l. ~(l = [])) (quotient_list L N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[quotient_list;core_list];
  REWRITE_TAC[GSYM Seq.allP;upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[MAP_EQ_NIL];
  MATCH_MP_TAC parts_nonnil;
  FIRST_X_ASSUM_ST `normal_list` MP_TAC;
  REWRITE_TAC[normal_list;GSYM Seq.allP];
  BY(ASM_MESON_TAC[uniq_flatten_uniq])
  ]);;
  (* }}} *)

let parts_uniq  = prove_by_refinement(
  `!L r p. ~(r = []) /\ uniq r /\ MEM p (parts L r) ==> uniq p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC uniq_flatten_uniq;
  BY(ASM_MESON_TAC[parts_flatten])
  ]);;
  (* }}} *)

let indexl_next_el = prove_by_refinement(
  `!s x. uniq s /\ MEM x s ==> indexl (next_el s x) s = 
     if (indexl x s = sizel s - 1) then 0 else (indexl x s + 1) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[Seq2.next_el];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.index_head];
  GMATCH_SIMP_TAC Seq.index_uniq;
  ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC (REWRITE_RULE[GSYM Seq.index_mem]);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let parts_node_inverse_power = prove_by_refinement(
  `!L N r p k x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\
    MEM x p /\ k + indexl x p < sizel p 
     ==>  ((inverse (node_map (hypermap_of_list L)) POWER k) x = 
      EL (k + indexl x p) p)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 4 GEN_TAC;
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER_0;I_THM;arith `0+n=n`];
    BY(SIMP_TAC[Seq2.EL_index]);
  REWRITE_TAC[Hypermap.POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    INTRO_TAC parts_uniq [`L`;`r`;`p`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  TYPIFY `~(x = LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    DISCH_TAC;
    INTRO_TAC indexl_LAST [`p`] THEN ASM_REWRITE_TAC[];
    BY(FIRST_X_ASSUM_ST `SUC` MP_TAC THEN ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    TYPIFY `MEM x (flatten (parts L r))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  INTRO_TAC inverse_node_map_list [`L`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_SIMP_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`p`]);
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  ASM_SIMP_TAC[Seq2.mem_next_el];
  TYPIFY `indexl (next_el p x) p = indexl x p + 1` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(CONJ_TAC THEN REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) THEN ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC indexl_next_el;
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let parts_in_node = prove_by_refinement(
  `!L N r p x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\ MEM x p ==>
     x IN (node (hypermap_of_list L) (HD p))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_node_inverse_power [`L`;`N`;`r`;`p`;`indexl x p`;`HD p`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    INTRO_TAC parts_uniq [`L`;`r`;`p`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  ASM_SIMP_TAC[MEM_HD];
  ASM_SIMP_TAC[index_hd0];
  REWRITE_TAC[arith `n + 0 = n`];
  ASM_SIMP_TAC[Seq2.EL_index];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.lemma_power_inverse_in_node2])
  ]);;
  (* }}} *)

let parts_fst = prove_by_refinement(
  `!L N r p x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\ MEM x p ==>
     FST x = FST (HD p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.fst_node_hypermap_of_list [`L`;`HD p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC parts_in_node;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let f_list_fst_snd = prove_by_refinement(
  `!L x.  all uniq L /\ MEM x (list_of_darts L) ==> 
     FST (f_list L x) = SND x `,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (MP_TAC o MATCH_MP List_hypermap.mem_find_face);
  TYPIFY `MEM (p1,p2) (find_face L (p1,p2))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
  REWRITE_TAC[List_hypermap.f_list;List_hypermap.find_face];
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC List_hypermap.next_el_list_pairs;
  BY(ASM_MESON_TAC[Seq.allP])
  ]);;
  (* }}} *)

let parts_darts = prove_by_refinement(
  `!L N r p x. MEM x p /\ MEM p (parts L r) /\ MEM r N /\
      normal_list L N ==> MEM x (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    TYPIFY `MEM x (flatten (parts L r))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let parts_last_as_fst_hd = prove_by_refinement(
  `!L N r p p'.  
     normal_list L N /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    good_list L /\
    all uniq L /\
    MEM r N /\
    MEM p (parts L r) /\ p' = next_el (parts L r) p ==>
    FST (HD p), FST (HD p') = LAST p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC parts_fst;
    GEXISTL_TAC [`L`;`N`;`r`];
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC MEM_LAST;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC (GSYM f_list_fst_snd);
  TYPIFY `L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    TYPIFY `MEM(LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC[parts_darts]);
  DISCH_TAC;
  AP_TERM_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  GMATCH_SIMP_TAC (GSYM next_el_parts_last);
  TYPIFY `LAST p` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[MEM_LAST];
  INTRO_TAC parts_next_last [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`p`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`LAST p`]);
  ASM_SIMP_TAC[MEM_LAST];
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`LAST p`];
  ASM_REWRITE_TAC[];
  INTRO_TAC loop_list_f_or_ni [`L`;`r`;`LAST p`];
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[normal_list;Seq.allP]);
    BY(ASM_MESON_TAC[MEM_LAST;Seq2.mem_flatten;parts_flatten]);
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `~(LAST p = LAST r)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `normal_list` MP_TAC;
  REWRITE_TAC[normal_list;GSYM Seq.allP;f_last];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `f_list` (C INTRO_TAC [`r`]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let parts_list_pairs = prove_by_refinement(
  `!L N r. normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         MEM (r:(A#A)list) N /\
         all uniq L ==>
    list_pairs ( (\f. MAP (\x. FST (HD x)) f) (parts L r)) =
         MAP LAST (parts L r)`,
  (* {{{ proof *)
  [
  rt[List_hypermap.list_pairs]
  st/r
  mmp (rr[IMP_IMP_THM] Seq.eq_from_nth)
  abbrev `x0 = FST (HD r)`
  abbrev `x1 = SND (HD r)`
  typ `x0,x1` ex
  abbrev `lz = sizel (zip (MAP (\x. FST (HD x)) (parts L r)) (rot 1 (MAP (\x. FST (HD x)) (parts L r))))`
  abbrev `lm = sizel (MAP LAST (parts L r))` 
  typ `lm = lz /\ sizel (MAP (\x. FST (HD x)) (parts L r)) = lz /\ sizel (rot 1 (MAP (\x. FST (HD x)) (parts L r))) = lz /\ sizel (parts L r) = lz /\ sizel (rot 1 (parts L r)) = lz /\ sizel (MAP (\x. FST (HD x)) (rot 1 (parts L r))) = lz` sat
  fexp "lm"
  fexp "lz"
  gm Seq.size2_zip
  rt[Seq.size_rot;Seq.size_map;lower_case]
  ARITH_TAC
  art[]
  st/r
  gm Seq.nth_zip
  art[]
  art[lower_case;sym Seq.map_rot]
  repeat (gm (sym Seq2.EL_nth))
  art[upper_case]
  repeat (gm EL_MAP)  
  abbrev `p = EL i (parts L r)` 
  art[lower_case]
  art[Seq.map_MAP]
  gm (sym parts_last_as_fst_hd)
  typ `next_el (parts L r) p` ex
  typ `MEM p (parts L r)` sat
  fexp "p"
  mmp MEM_EL
  art[lower_case]
  conj 
  amt[]
  rt[PAIR_EQ]
 apterm then apterm
  gm Seq2.next_el_alt
  typ `p` ex
  art[]
  repeat (gm (sym Seq2.EL_nth))
  art[]
  typ `indexl p (parts L r) = i` ets
  amt[]

(* give lemma that parts is unique using uniq_flatten_uniq. 
   then finish off. *)

  ]);;
  (* }}} *)

MAP_map;;
quotient_list;;
core_list;;

let list_of_darts_quotient = prove_by_refinement(
  `!L N.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    list_of_darts (quotient_list L N) = 
	     MAP LAST (flatten (MAP (parts L) N))`,
  (* {{{ proof *)
  [
  rt[quotient_list;core_list]
  rt[List_hypermap.list_of_darts_alt;MAP_flatten;upper_case]
  rt[List_hypermap.list_of_faces]
  rt[sym MAP_o]
  st/r
  typ `!r. MEM r N ==> ((list_pairs o (\f. MAP (\x. FST (HD x)) f)) o parts L) r = (MAP LAST o parts L) r` ets
  st/r
  apterm
  mmp MAP_EQ
  art[lower_case;sym Seq.allP]
  art[upper_case]  
  ]);;
  (* }}} *)

normal_list;;
PAIRS_EQ2;;
List_hypermap.list_of_nodes;;
List_hypermap.nodes_of_list;;
Hypermap.is_restricted;;
normal_list;;
good_list;;
List_hypermap.good_list;;
List_hypermap.f_list;;
List_hypermap.find_face;;
tyo `EL`;;
good_list;;
marked_list;;
partition_into_atom0;;
Hypermap.s_flagged;;
marked_list;;
s_flag_list;;
s_list;;
l_m;;
Hypermap.lemma_hyp_m;;
Hypermap.is_split_condition;;

xxd

let marked_list_empty_flagged = prove_by_refinement(
  `!L N r d. good_list L /\ 
    marked_list L N r d /\ final_list L r ==> 
    empty_flagged (hypermap_of_list L) (loop_family_of_list N)`,    
  (* {{{ proof *)
  [
  rt[Hypermap.empty_flagged;marked_list;flag_list]
  st/r
  asimp[darts_in_final_loops_list_eq;IN_SET_OF_LIST]
  asimp[final_loops_list_eq]
xxd
  conj
  rt[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM]



  Hypermap.lemma_true_loop

  st/r

  ]);;
  (* }}} *)

final_dart_list;;

Hypermap.is_marked;;

let hyp_m_l_m = prove_by_refinement(
`!L N r x.
      hyp'm (hypermap_of_list L) N (loop_of_list r) x = 
     min_num 
       { m | ~(ITER (SUC(SUC m)) (next_el r) x = 
	     f_list L (ITER (SUC m) (next_el r) x))  }`,
  (* {{{ proof *)
  [
  rt[Hypermap.lemma_hyp_m]
  ]);;
  (* }}} *)



Hypermap.is_normal;;
normal_list;;

(* SET ASIDE A BIT:::: *)



(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)

(* Added Jan 2014. *)





(*
let exists_atomize = prove_by_refinement(
  `!ni (s:(A)list). (all (\d. ~(ni d = d)) s) /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
fxast `LAST` mp
rt[GSYM Seq.all_cons]
amt[Seq.all_cons]
  ]);;
  (* }}} *)
*)

let exists_atomize = prove_by_refinement(
  `!ni f (s:(A)list).  (all (\d. ~(ni d = d)) s) /\ 
    (all (\d. ~(ni d = f d)) s) /\ 
    next_el s (LAST s) = f (LAST s) /\
    all (\d. next_el s d = f d \/ next_el s d = ni d) s /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC then g
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    nconj 2
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
    
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
  ]);;
  (* }}} *)


(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
