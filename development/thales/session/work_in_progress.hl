
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;


module Work_in_progress = struct
end;;


  open Hales_tactic;;
open Hypermap;;
open Import_tame_classification;;
open Tame_defs;;
open Tame_concl;;
open More_tame_concl;;
open Oxaxucs;;  (* invariance of tame under iso *)
open Asfutbf;;  (* contravening V, and opposite *)
open Elllnyz;;  (* isabell iso_fgraph and hypermap iso *)
open Wmlnymd;;  (* tameness in as lists and as hypermaps *)
open Dpzgbyf;;  (* basic properties of planegraphs and seeds *)


let nextElem_nonmem = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem s u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let rcons_nonnil = prove_by_refinement(
  `!s x. ~(rcons s x = [])`,
  (* {{{ proof *)
  [
BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.rcons;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let nextElem_nonmem_rcons = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem (rcons s a) u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rcons = prove_by_refinement(
  `!s h x u. MEM x s ==> (nextElem s h x = nextElem (rcons s h) u x)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    TYPIFY `x = h` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    SIMP_TAC[];
    COND_CASES_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[HD;Seq.rcons];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0;MEM]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> nextElem s (HD s) x = nextElem (rot 1 s) (HD (rot 1 s)) x `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[nextElem;Seq.head;MEM;Seq.rot1_cons] THEN GEN_TAC;
  REWRITE_TAC[HD];
  DISCH_TAC;
  TYPIFY `MEM x t /\ ~(x = h)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM kill THEN DISCH_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[nextElem_rcons])
  ]);;
  (* }}} *)

let index_uniq = prove_by_refinement(
  `!x y. MEM x s /\ MEM y s /\ indexl x s = indexl y s ==> (x = y)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.nth_index])
  ]);;
  (* }}} *)

let index0 = prove_by_refinement(
  `!s x. MEM x s /\ indexl x s = 0 ==> x = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl (HD s) s = 0` ENOUGH_TO_SHOW_TAC;
    TYPIFY `MEM (HD s) s` (C SUBGOAL_THEN MP_TAC);
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[MEM]);
    DISCH_TAC;
    BY(ASM_MESON_TAC[index_uniq]);
  INTRO_TAC (GSYM Seq2.index_head) [`x`;`s`];
  DISCH_THEN (SUBST1_TAC);
  REPLICATE_TAC 2 (AP_TERM_TAC ORELSE AP_THM_TAC);
  GMATCH_SIMP_TAC Seq2.head_HD;
  REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
  BY(ASM_MESON_TAC[Seq.size_eq0;MEM])
  ]);;
  (* }}} *)

let index_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> SUC (indexl x (rot 1 s)) = indexl x s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;HD;Seq.index;Seq.find;Seq.rot1_cons;Seq.has_pred1];
  REWRITE_TAC[Seq.pred1];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  AP_TERM_TAC;
  REWRITE_TAC[Seq.find_cat;GSYM Seq.cats1];
  REWRITE_TAC[GSYM Seq.pred1];
  REWRITE_TAC[GSYM Seq.pred1;Seq.has_pred1];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let index_nextElem_next_el = prove_by_refinement(
  `!n s x. MEM x s /\ indexl x s = n ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    LIST_INDUCT_TAC;
      BY(REWRITE_TAC[MEM]);
    REWRITE_TAC[HD;nextElem];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC index0 [`h::t`;`x`];
    ASM_REWRITE_TAC[HD];
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC;
      BY(ASM_REWRITE_TAC[Dpzgbyf.next_el1]);
    GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
    BY(ASM_MESON_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0]);
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC nextElem_rot;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    DISCH_TAC;
    INTRO_TAC Seq2.head_HD [`x`;`s`];
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0];
    BY(ASM_MESON_TAC[MEM;arith `~(0=SUC n)`;Seq2.index_head]);
  DISCH_TAC;
  GMATCH_SIMP_TAC Seq2.next_el_alt;
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`rot 1 s`;`x`]);
  TYPIFY `MEM x (rot 1 s) /\ indexl x (rot 1 s) = n` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[Seq.mem_rot];
    MATCH_MP_TAC (arith `SUC u = SUC v ==> u = v`);
    GMATCH_SIMP_TAC index_rot;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC Seq2.next_el_mod [`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[arith `n+1 = SUC n`] THEN MATCH_MP_TAC MOD_LT;
  BY(ASM_MESON_TAC[Seq.index_mem;Seq.size_rot])
  ]);;
  (* }}} *)

let nextElem_next_el = prove_by_refinement(
  `!s x. MEM x s ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
BY(MESON_TAC[index_nextElem_next_el])
  ]);;
  (* }}} *)

let nextVertex_next_el = prove_by_refinement(
  `!f x. MEM x (FST f) ==> nextVertex f x = next_el (FST f) x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextVertex;FORALL_PAIR_THM];
  BY(SIMP_TAC[nextElem_next_el])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!f g. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;makeFaceFinal;faces_graph;makeFaceFinalFaceList];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

let vertices_set2_makeFaceFinal = prove_by_refinement(
  `!f g. vertices_set2 (makeFaceFinal f' g) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;makeFaceFinal;bn_vertices_graph];
  BY(REWRITE_TAC[vertices_graph])
  ]);;
  (* }}} *)

let set_of_list_flatten_APPEND = prove_by_refinement(
  `!a b. set_of_list (flatten (APPEND a b)) = 
    set_of_list (flatten a) UNION set_of_list (flatten b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[List_hypermap.set_of_list_flatten_map];
  REWRITE_TAC[upper_case;SET_OF_LIST_APPEND;MAP_APPEND];
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let SPLIT_AT_MEM_FST = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (FST(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let SPLIT_AT_MEM_SND = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (SND(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let SPLIT_AT_ACC = prove_by_refinement(
  `!f (u:A) v b. MEM v b ==>
    (MEM v (FST (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[MEM_APPEND])
  ]);;
  (* }}} *)

let SPLIT_AT_BOTH = prove_by_refinement(
  `!f (u:A) v b.  
    (MEM v f) /\ (v = u ==> MEM v b) ==>
    (MEM v (FST (split_at_rec u b f)) \/ MEM v (SND (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v = h` ASM_CASES_TAC;
    DISJ1_TAC;
    MATCH_MP_TAC SPLIT_AT_ACC;
    BY(ASM_REWRITE_TAC[MEM_APPEND;MEM]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[MEM_APPEND;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let PAIR_EQ_EXPAND = prove_by_refinement(
  `!x a b. x = (a,b) <=> (FST x = a /\ SND x = b)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ])
  ]);;
  (* }}} *)

let BETWN_MEM = prove_by_refinement(
  `!f (u:A) v w. MEM w (betwn f u v) ==>
     MEM w f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn;split_at;split_at_rec];
  REPEAT GEN_TAC;
  REPEAT (LET_TAC);
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM w post1 \/ MEM w pre2 \/ MEM w pre2' ==> MEM w f` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    FIRST_X_ASSUM MP_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ_EXPAND]);
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN ASM_REWRITE_TAC[];
  BY(MESON_TAC[SPLIT_AT_MEM_SND;SPLIT_AT_MEM_FST;MEM])
  ]);;
  (* }}} *)

let BETWN_UNION = prove_by_refinement(
  `!f (u:A) v.  MEM u f /\ MEM v f ==>
      (set_of_list (betwn f u v) UNION set_of_list (betwn f v u) UNION {u,v} = 
      set_of_list f)`,
  (* {{{ proof *)
  [
  st/r
  ... xxd
  ]);;
  (* }}} *)



let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)

(* Added Jan 2014. *)





(*
let exists_atomize = prove_by_refinement(
  `!ni (s:(A)list). (all (\d. ~(ni d = d)) s) /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
fxast `LAST` mp
rt[GSYM Seq.all_cons]
amt[Seq.all_cons]
  ]);;
  (* }}} *)
*)

let exists_atomize = prove_by_refinement(
  `!ni f (s:(A)list).  (all (\d. ~(ni d = d)) s) /\ 
    (all (\d. ~(ni d = f d)) s) /\ 
    next_el s (LAST s) = f (LAST s) /\
    all (\d. next_el s d = f d \/ next_el s d = ni d) s /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC then g
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    nconj 2
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
    
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
  ]);;
  (* }}} *)


(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
