
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;
(* open Import_tame_classification;; *)

(* open More_tame_concl;; *)

(*

open Import_tame_classification;;
open Tame_defs;;
open More_tame_concl;;
*)


(* TO HERE *)


1;;


(* ... *)

let quotient_list_iso_quotient = prove_by_refinement(
  `!L N . 
  is_restricted (hypermap_of_list L) /\
    good_list_nodes L /\
  normal_list L N /\
  is_edge_nondegenerate (hypermap_of_list L) /\
  good_list L /\
  all uniq L
   ==>
    hyp_iso (set_of_list o (find_atom L N))
     (hypermap_of_list (quotient_list L N),
      quotient (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Hypermap_iso.hyp_iso_edge_face];
  INTRO_TAC good_list_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  ASM_SIMP_TAC[face_map_list];
  INTRO_TAC normal_list_normal [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_SIMP_TAC[Hypermap.lemma_quotient;List_hypermap.components_hypermap_of_list];
  ASM_SIMP_TAC[GSYM List_hypermap.darts_of_list;atom_list_bij];
  ASM_SIMP_TAC[mem_list_of_darts_quotient];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[o_THM];
  INTRO_TAC find_atom_part [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM atom_last_p) [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC Hypermap.unique_f_quotient;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST];
    CONJ_TAC;
      REWRITE_TAC[upper_case];
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_SIMP_TAC[in_dart_loop_of_list]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "f_quotient";
  CONJ2_TAC;
    GMATCH_SIMP_TAC head_of_atom_parts;
    TYPIFY `p` EXISTS_TAC;
    (CONJ_TAC);
      BY(ASM_MESON_TAC[]);
    TYPED_ABBREV_TAC `p' = next_el (parts L r) p`;
    TYPIFY `MEM p' (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p'`];
    ASM_REWRITE_TAC[] THEN DISCH_TAC;
    TYPIFY `MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
    TYPIFY `f_list (quotient_list L N) (LAST p) = LAST p'` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC f_list_quotient;
      TYPIFY `r` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC find_atom_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC face_map_list;
    ASM_REWRITE_TAC[];
    INTRO_TAC f_list_quotient_alt [`L`;`N`;`r`;`r`;`p`;`p'`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    GMATCH_SIMP_TAC atom_eq_last;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[parts_darts]);
    DISCH_TAC;
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  COMMENT "e_quotient";
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  SUBCONJ_TAC;
    GMATCH_SIMP_TAC mem_list_of_darts_quotient;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  TYPIFY `MEM (e_list (LAST p)) (list_of_darts (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `good_list` MP_TAC;
    REWRITE_TAC[good_list];
    REWRITE_TAC[List_hypermap.e_list];
    BY(ASM_MESON_TAC[]);
  FIRST_ASSUM MP_TAC;
  GMATCH_SIMP_TAC mem_list_of_darts_quotient;
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC find_atom_part;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `atom (hypermap_of_list L) (loop_of_list r) (LAST p) = atom_choice (hypermap_of_list L) (loop_family_of_list N) (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC atom_choice_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap.e_quotient_via_atom_choice [`hypermap_of_list L`;`loop_family_of_list N`;`LAST p`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[darts_of_family;loop_family_of_list;IN_UNIONS;IN_ELIM_THM;IN_SET_OF_LIST];
    TYPIFY `dart_of_loop (loop_of_list r)` EXISTS_TAC;
    ASM_SIMP_TAC[in_dart_loop_of_list];
    TYPIFY `loop_of_list r` EXISTS_TAC;
    REWRITE_TAC[upper_case];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  DISCH_THEN kill;
  GMATCH_SIMP_TAC head_of_atom_parts;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[parts_darts]);
  DISCH_TAC;
  TYPIFY `atom_choice (hypermap_of_list L) (loop_family_of_list N) (LAST p') = atom (hypermap_of_list L) (loop_of_list r') (LAST p')` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC atom_choice_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC atom_last_p;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_EXTENSION = prove_by_refinement(
  `(a = b) ==> (!x. MEM x a <=> MEM x b)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let loop_of_list_inj = prove_by_refinement(
  `!N r r'. uniq (flatten N) /\ all (\l. ~(l = [])) N /\
     MEM r N /\ MEM r' N /\ loop_of_list r = loop_of_list r' ==>
     r = r'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = []) /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.allP]);
  TYPIFY `uniq r /\ uniq r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[uniq_flatten_uniq]);
  TYPIFY `set_of_list r = set_of_list r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[dart_of_loop_of_list]);
  TYPIFY `?x. MEM x r` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_condition_list_split = prove_by_refinement(
  `!L N r d. good_list L /\ good_list_nodes L /\ all uniq L /\
    split_condition_list L N r d ==> 
    is_split_condition (hypermap_of_list L)
     (loop_family_of_list N)
     (loop_of_list r) d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_condition_list;is_split_condition];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[normal_list_normal];
  REWRITE_TAC[in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST;upper_case];
  CONJ_TAC THENL [MATCH_MP_TAC MEMf_MAP THEN ASM_REWRITE_TAC[];ALL_TAC];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[in_dart_loop_of_list];
  REWRITE_TAC[GSYM loop_family_of_list;lower_case];
  GMATCH_SIMP_TAC head_of_atom_parts;
  TYPIFY `?p. MEM p (parts L r) /\ MEM d p` (C SUBGOAL_THEN MP_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP parts_flatten);
    DISCH_THEN (C INTRO_TAC [`L`]);
    DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[final_loops_list_eq];
  TYPIFY `find_list (parts L r) d = p` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC find_list_uniq;
    BY(ASM_SIMP_TAC[parts_flatten]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_MAP;Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC loop_of_list_inj [`N`;`r`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_m_min = prove_by_refinement(
  `!H NF L x. is_split_condition H NF L x ==>
      hyp'm H NF L x = min_num { m |
	~((loop_map L POWER (SUC (SUC m))) x = 
	    (face_map H POWER (SUC (SUC m))) x)}`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  REWRITE_TAC[TAUT `!a b. (~a ==> b) <=> (~b ==> a)`];
  REWRITE_TAC[arith `~(x <= c':num) <=> c' < x`];
  INTRO_TAC lemma_hyp_m [`H`;`NF`;`L`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`SUC (SUC c')`]);
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)
(*
let min_num_eq = prove_by_refinement(
  `!X Y. (?m. X m /\ Y m /\ (!k. k < m ==> ~X m /\ ~Y m)) ==>
    min_num X = min_num Y `,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[min_num_unique;IN;arith `c <= d:num <=> ~(d < c)`])
  ]);;
  (* }}} *)
*)

(*
let min_num_lt = prove_by_refinement(
  `!X m. (!i. i < m ==> ~(i IN X)) /\ (~(X = {})) ==> m <= min_num X`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `~(m < n) ==> (n <= m:num)`);
  DISCH_TAC;
  TYPIFY `min_num X IN X` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[min_num_in]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let min_num_power = prove_by_refinement(
  `!f g x:A. 
    (?i. ~((f POWER i) x = (g POWER i) x)) ==>
    min_num {m | ~((g POWER (SUC m)) x = (f POWER (SUC m)) x )} =
     min_num { m | ~((g POWER (SUC m)) x = (f ((g POWER m) x )) ) }`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `X = {m | ~((g POWER SUC m) x = (f POWER SUC m) x)}`;
  TYPED_ABBREV_TAC `m = min_num X`;
  TYPIFY `!n. n IN X <=> ~((g POWER SUC n) x = (f POWER SUC n) x)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "X";
    BY(REWRITE_TAC[IN_ELIM_THM]);
  TYPIFY `~(f x = g x) \/ (f x = g x)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[]);
  DISCH_THEN DISJ_CASES_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    ASM_REWRITE_TAC[POWER_1;arith `SUC 0 = 1`];
    DISCH_TAC;
    TYPIFY `min_num X = 0` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC min_num_unique;
      BY(ASM_REWRITE_TAC[arith `0 <= c'`]);
    TYPIFY `min_num {m | ~((g POWER SUC m) x = f ((g POWER m) x))} = 0` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC min_num_unique;
      BY(ASM_REWRITE_TAC[arith `0 <= c'`;arith `SUC 0 = 1`;POWER_0;POWER_1;IN_ELIM_THM;I_THM]);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `~(0 IN X)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[arith `SUC 0 = 1`;POWER_1;I_THM]);
  TYPIFY `~(i = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[POWER_0]);
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN MP_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `m IN X` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "m" THEN MATCH_MP_TAC min_num_in;
    ASM_REWRITE_TAC[EXTENSION;NOT_IN_EMPTY];
    ASM_REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
    TYPIFY `PRE i` EXISTS_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[]);
  TYPIFY `!k. k <= m ==> (g POWER k) x = (f POWER k) x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `k = 0` ASM_CASES_TAC;
      BY(ASM_REWRITE_TAC[POWER_0]);
    TYPIFY `?j. k = SUC (j)` (C SUBGOAL_THEN MP_TAC);
      BY(TYPIFY `PRE k` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    PROOF_BY_CONTR_TAC;
    TYPIFY `(j IN X)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_REWRITE_TAC[]);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP min_num_le);
    BY(ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `!k. k <= m ==> f ((g POWER k) x) = (f POWER (SUC k)) x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    ASM_SIMP_TAC[];
    BY(REWRITE_TAC[Hypermap.COM_POWER;o_THM]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  CONJ_TAC;
    FIRST_X_ASSUM GMATCH_SIMP_TAC;
    REWRITE_TAC[arith `m <= m`];
    ASM_SIMP_TAC[arith `m <= m:num`];
    FIRST_X_ASSUM_ST `IN` MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[arith `m <= c':num <=> ~(c' < m)`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `POWER` MP_TAC;
  REWRITE_TAC[];
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let f_list_ext_power_mem = prove_by_refinement(
  `!L d i. MEM d (list_of_darts L) /\ good_list L ==>
     MEM ((f_list_ext L POWER i) d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[GSYM List_hypermap.components_hypermap_of_list;GSYM IN_SET_OF_LIST];
  INTRO_TAC Hypermap.lemma_dart_invariant_power_face [`hypermap_of_list L`;`d`;`i`];
  ASM_SIMP_TAC[dart_hypermap_of_list];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let f_list_ext_f_list_power = prove_by_refinement(
  `!L i d. MEM d (list_of_darts L) /\ good_list L ==>
   (f_list_ext L POWER i) d = (f_list L POWER i) d`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INDUCT_TAC;
    BY(REWRITE_TAC[POWER_0]);
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC f_list_ext_f_list;
  ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[mem_f_list])
  ]);;
  (* }}} *)

let l_m_exists = prove_by_refinement(
  `!L N r d.
   split_condition_list L N r d /\ ~final_list L r /\
      next_el r d = f_list L d 
   ==>
    (?m. ~(ITER (SUC (SUC m)) (next_el r) d = 
	 f_list L (ITER (SUC m) (next_el r) d)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `final_list` MP_TAC;
  REWRITE_TAC[final_list;GSYM Seq.allP;NOT_FORALL_THM;NOT_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM;GSYM POWER_TO_ITER]);
  INTRO_TAC indexf_n [`d`;`x`;`r`];
  TYPIFY `normal_list L N /\ MEM d r /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  ASM_REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `f_list L x =  next_el r x` MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf d x r = 0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[];
    BY((ASM_REWRITE_TAC[POWER_0;arith `SUC 0 = 1`;POWER_1;I_THM]));
  TYPIFY `?j. indexf d x r = SUC j` (C SUBGOAL_THEN MP_TAC);
    BY(TYPIFY `PRE (indexf d x r)` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`j`]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[COM_POWER;o_THM])
  ]);;
  (* }}} *)

let l_m_lt = prove_by_refinement(
  `!L N r d i.    split_condition_list L N r d /\ ~final_list L r /\
      next_el r d = f_list L d /\
    i < l'm L r d ==> (ITER (SUC (SUC i)) (next_el r) d = 
	 f_list L (ITER (SUC i) (next_el r) d))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC min_num_le [`{m | ~(ITER (SUC (SUC m)) (next_el r) d = f_list L (ITER (SUC m) (next_el r) d))}`;`i`];
  REWRITE_TAC[IN_ELIM_THM;GSYM Tame_defs2.l_m];
  BY(ASM_SIMP_TAC[arith `i <= m:num <=> ~(m < i)`])
  ]);;
  (* }}} *)

let l_m_lt2 = prove_by_refinement(
  `!L N r d i.    split_condition_list L N r d /\ ~final_list L r /\
      next_el r d = f_list L d /\
    i < l'm L r d ==> (ITER (SUC (SUC i)) (next_el r) d = 
	  (ITER (SUC (SUC i)) (f_list L) d))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN SPEC_TAC (`i:num`,`i:num`);
  INTRO_TAC l_m_lt [`L`;`N`;`r`;`d`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INDUCT_TAC;
    ASM_SIMP_TAC[arith `SUC 0 = 1`];
    REWRITE_TAC[ITER;ITER_1];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `f_list L (ITER (SUC i) (next_el r) d)` GMATCH_SIMP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  REWRITE_TAC[ITER];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let hyp_m_l_m = prove_by_refinement(
`!L N r d.
   good_list L /\ good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'm (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'm L r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_split_condition (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_split]);
  ASM_SIMP_TAC[Tame_defs2.l_m;hyp_m_min];
  REWRITE_TAC[GSYM POWER_TO_ITER];
  TYPIFY `{m | ~((next_el r POWER SUC (SUC m)) d =        f_list L ((next_el r POWER SUC m) d))} = {m | ~((next_el r POWER (SUC m)) (next_el r d) =        f_list L ((next_el r POWER m) (next_el r d)))}` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[EXTENSION;IN_ELIM_THM;POWER;o_THM]);
  GMATCH_SIMP_TAC (GSYM min_num_power);
  ASM_REWRITE_TAC[ETA_AX];
  TYPIFY `{m | ~((next_el r POWER SUC m) (f_list L d) =        (f_list L POWER SUC m) (f_list L d))} = {m | ~((next_el r POWER (SUC (SUC m))) d =        (f_list L POWER SUC(SUC m)) ( d))}` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[EXTENSION;IN_ELIM_THM;POWER;o_THM];
    BY(ASM_MESON_TAC[]);
  TYPIFY `(?i. ~((next_el r POWER i) (f_list L d) = (f_list L POWER i) (f_list L d))) /\ (!i. (loop_map (loop_of_list r) POWER i) d = (next_el r POWER i) d) /\ (!i. (face_map (hypermap_of_list L) POWER i) d = (f_list L POWER i) d)` ENOUGH_TO_SHOW_TAC;
    BY(DISCH_THEN (unlist REWRITE_TAC));
  FIRST_X_ASSUM_ST `split_condition_list` MP_TAC THEN REWRITE_TAC[split_condition_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[loop_map_next_el];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  COMMENT "final";
  CONJ_TAC;
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    REWRITE_TAC[final_list;GSYM Seq.allP;NOT_FORALL_THM;NOT_IMP_THM];
    REPEAT WEAKER_STRIP_TAC;
    PROOF_BY_CONTR_TAC;
    RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM]);
    INTRO_TAC indexf_n [`d`;`x`;`r`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `~` MP_TAC;
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    TYPIFY_GOAL_THEN `!i. next_el r ((next_el r POWER i) d) = (next_el r POWER (SUC i)) d` (unlist REWRITE_TAC);
      BY(REWRITE_TAC[COM_POWER;o_THM]);
    TYPIFY `indexf d x r = 0` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[POWER_0;arith `SUC 0 = 1`;POWER_1;I_THM]);
    TYPIFY `?j. indexf d x r = SUC j` (C SUBGOAL_THEN MP_TAC);
      BY(TYPIFY `PRE (indexf d x r)` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[POWER];
    ASM_REWRITE_TAC[o_THM];
    BY(REWRITE_TAC[COM_POWER;o_THM]);
  COMMENT "f_list";
  GEN_TAC;
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP normal_list_darts_of_list_mem);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_condition_list_of_darts = prove_by_refinement(
  `!L N r d. split_condition_list L N r d ==> MEM d (list_of_darts L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_condition_list];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP normal_list_darts_of_list_mem);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_y_l_y = prove_by_refinement(
`!L N r d.
   good_list L /\ good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'y (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'y L r d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.hyp_y;l_y];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[hyp_m_l_m];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[split_condition_list_of_darts])
  ]);;
  (* }}} *)

(* was  let hyp_m_min_num = 0;;  *)

let hyp_p_min_num = prove_by_refinement(
  `!H NF L x. is_split_condition H NF L x ==>
      hyp'p H NF L x = 
    min_num {p | (face_map H POWER SUC p) (hyp'y H NF L x) IN 
		 darts_of_family NF }`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  INTRO_TAC lemma_hyp_p [`H`;`NF`;`L`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`SUC c'`]);
  ASM_REWRITE_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let darts_of_family_loop_family_of_list = prove_by_refinement(
  `!N L. normal_list L N ==>
    darts_of_family(loop_family_of_list N) = set_of_list (flatten N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[darts_of_family;loop_family_of_list;EXTENSION;IN_UNIONS;IN_ELIM_THM;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM EXTENSION];
  REWRITE_TAC[MESON[] `(?t. (?L. (?x. MEM x N /\ L = loop_of_list x) /\ t = dart_of_loop L) /\      x IN t) <=> (?r. MEM r N /\ x IN (dart_of_loop(loop_of_list r)))`];
  REWRITE_TAC[Seq2.mem_flatten];
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[IN_SET_OF_LIST;dart_of_loop_of_list])
  ]);;
  (* }}} *)

let marked_list_split_condition_list = prove_by_refinement(
  `!L N r d. 
    good_list L /\
            is_edge_nondegenerate (hypermap_of_list L) /\
    marked_list L N r d /\ ~final_list L r 
     ==> split_condition_list L N r d`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  REWRITE_TAC[marked_list;split_condition_list];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`;`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_flatten [`L`;`r`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
  REWRITE_TAC[Seq2.mem_flatten];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`d`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `find_list (parts L r) d = l` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC find_list_uniq;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC [parts_flatten]);
  ASM_REWRITE_TAC[];
  PROOF_BY_CONTR_TAC;
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
  TYPIFY `l` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC THEN FIRST_X_ASSUM (C INTRO_TAC [`d`]) THEN ASM_REWRITE_TAC[];
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`d`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[parts_darts]);
  BY(ASM_MESON_TAC[next_el_parts_unlast])
  ]);;
  (* }}} *)

let mem_l_y_dart = prove_by_refinement(
  `!L N r d. good_list L /\ split_condition_list L N r d ==> 
    MEM (l'y L r d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[l_y;GSYM IN_SET_OF_LIST];
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_of_darts]);
  REWRITE_TAC[IN_SET_OF_LIST];
  BY((ASM_SIMP_TAC[f_list_ext_power_mem;GSYM f_list_ext_f_list_power]))
  ]);;
  (* }}} *)

let hyp_p_l_p = prove_by_refinement(
`!L N r d.
   good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'p (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'p L N r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_split_condition (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_split]);
  ASM_SIMP_TAC[hyp_p_min_num;l_p];
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  GMATCH_SIMP_TAC darts_of_family_loop_family_of_list;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC hyp_y_l_y;
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  AP_TERM_TAC THEN REWRITE_TAC[EXTENSION;IN_ELIM_THM];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GEN_TAC;
  AP_THM_TAC THEN AP_TERM_TAC;
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC mem_l_y_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_z_l_z = prove_by_refinement(
`!L N r d.
   good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'z (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'z L N r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[hyp_z;l_z];
  GMATCH_SIMP_TAC hyp_p_l_p;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC hyp_y_l_y;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC mem_l_y_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_q_l_q = prove_by_refinement(
   `!L n r d. hyp'q (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'q L N r d`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[l_q])
  ]);;
  (* }}} *)

(* was let contour_list_nil= 0;; *)

let contour_list_cons = prove_by_refinement(
  `!L. contour_list L [] /\ 
     (contour_list L [h] <=> MEM h (list_of_darts L)) /\ 
     (contour_list L (h1::h2::s) <=> MEM h1 (list_of_darts L) /\
	one_step_list L h1 h2 /\ contour_list L (h2::s))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[contour_list];
  (REWRITE_TAC[Seq.size;LENGTH;arith `!i. ~(i < 0)`;Seq.all]);
  REWRITE_TAC[arith `SUC i < SUC j <=> i < j`;arith `~(i<0)`;EL;TL];
  GEN_TAC;
  TYPIFY `MEM h1 (list_of_darts L)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM h2 (list_of_darts L)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `all (\x. MEM x (list_of_darts L)) s` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[EQ_EXPAND];
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    PROOF_BY_CONTR_TAC;
    FIRST_ASSUM (C INTRO_TAC [`0`]);
    REWRITE_TAC[arith `0 < SUC l`;EL;HD];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `LENGTH` MP_TAC;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`SUC i`]);
    BY(ASM_REWRITE_TAC[EL;TL;arith `SUC i < SUC j <=> i < j`]);
  TYPIFY `i = 0 \/ (?j. i = SUC (j))` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[arith `i = 0 \/ i = SUC (PRE i)`]);
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let contour_list_is_contour = prove_by_refinement(
  `!L s. good_list L /\ contour_list L s ==>
    is_contour (hypermap_of_list L) (\i. EL i s) (PRE (sizel s) )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_def_contour;contour_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Hypermap.one_step_contour];
  FIRST_X_ASSUM_ST `SUC` (C INTRO_TAC [`i`]);
  ASM_SIMP_TAC[arith `i < PRE s ==> SUC i < s`];
  REWRITE_TAC[one_step_list];
  TYPIFY `MEM (EL i s) s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC MEM_EL;
    BY(POP_ASSUM MP_TAC THEN REWRITE_TAC[lower_case] THEN ARITH_TAC);
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISJ1_TAC;
    GMATCH_SIMP_TAC face_map_list;
    BY(ASM_MESON_TAC[]);
  DISJ2_TAC;
  GMATCH_SIMP_TAC inverse_node_map_list;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* *)

let face_map_list_power = prove_by_refinement(
  `!L i d. good_list L /\ MEM d (list_of_darts L) ==>
    (face_map (hypermap_of_list L) POWER i) d = 
      (f_list L POWER i) d`,
  (* {{{ proof *)
  [
 GEN_TAC;
  INDUCT_TAC THEN REWRITE_TAC[POWER_0;I_THM];
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap.lemma_dart_invariant [`hypermap_of_list L`;`d`];
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  BY(ASM_SIMP_TAC[face_map_list])
  ]);;
  (* }}} *)

let hyp_S_list = prove_by_refinement(
  `!L n r d. 
       good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    ~final_list L r /\
    split_condition_list L N r d ==>
    hyp'S (hypermap_of_list L) (loop_family_of_list N)
    (loop_of_list r) d = set_of_list (s_list L r d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[hyp_S;s_list;EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST;GSYM POWER_TO_ITER];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  ASM_SIMP_TAC[hyp_m_l_m];
  TYPIFY `normal_list L N /\ MEM r N /\ MEM d r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.mem_iota;arith `i < 1 + n <=> i <= n`];
  TYPIFY `!i. (face_map (hypermap_of_list L) POWER i) d = (f_list L POWER i) d` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  GEN_TAC;
  MATCH_MP_TAC face_map_list_power;
  BY(ASM_MESON_TAC[split_condition_list_of_darts])
  ]);;
  (* }}} *)

let marked_list_empty_flagged = prove_by_refinement(
  `!L N r d. good_list L /\ all uniq L /\ good_list_nodes L /\
    marked_list L N r d /\ final_list L r ==> 
    empty_flagged (hypermap_of_list L) (loop_family_of_list N)`,    
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.empty_flagged;marked_list;flag_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[darts_in_final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  COMMENT "edge symmetry";
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC head_of_atom_parts;
    ASM_REWRITE_TAC[];
    REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC);
    REWRITE_TAC[loop_family_of_list;upper_case;MEM_MAP;IN_SET_OF_LIST;MEM_FILTER];
    REWRITE_TAC[NOT_EXISTS_THM];
    FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `contour_list` kill;
    TYPIFY `x'` (RENAME_TAC "r'");
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN POP_ASSUM kill;
    REWRITE_TAC[in_dart_of_loop];
    TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC normal_list_uniq_nonnil THEN ASM_MESON_TAC[]);
    ASM_SIMP_TAC[in_dart_loop_of_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `?p'. MEM x p' /\ MEM p' (parts L r')` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC parts_flatten [`L`;`r'`];
      ASM_REWRITE_TAC[] THEN DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
      REWRITE_TAC[Seq2.mem_flatten];
      BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`r'`;`p'`;`LAST p'`]);
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[]);
    TYPIFY `edge_map (hypermap_of_list L) (LAST p') = e_list (LAST p')` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[]);
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    MATCH_MP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    MATCH_MP_TAC parts_darts;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    BY(ASM_MESON_TAC[MEM_LAST]);
  COMMENT "support condition";
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM (C INTRO_TAC [`x`;`y`]);
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`\i. EL i s`;`PRE (sizel s)`];
  nCONJ_TAC 2;
    MATCH_MP_TAC contour_list_is_contour;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC support_of_sequence_list;
  ASM_REWRITE_TAC[EL];
  COMMENT "next step not needed";
  TYPIFY `~(s = [])` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `PRE (sizel s) = (LENGTH s - 1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[LAST_EL]);
    REWRITE_TAC[lower_case];
    MATCH_MP_TAC (arith `~(n = 0) ==> PRE n = n - 1`);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[]
  ]);;
  (* }}} *)

let marked_list_s_flagged = prove_by_refinement(
  `!L N r d. good_list L /\ all uniq L /\ good_list_nodes L /\
    marked_list L N r d /\ ~final_list L r ==> 
    s_flagged (hypermap_of_list L) 
    (loop_family_of_list N) (loop_of_list r) d`,    
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_list_split_condition_list [`L`;`N`;`r`;`d`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_list;is_restricted]);
  REPEAT (POP_ASSUM MP_TAC);
  REWRITE_TAC[Hypermap.s_flagged;marked_list;s_flag_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[darts_in_final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[hyp_S_list];
  COMMENT "edge symmetry";
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC;
    REPEAT (GMATCH_SIMP_TAC head_of_atom_parts);
    ASM_REWRITE_TAC[];
    REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC);
    REWRITE_TAC[loop_family_of_list;upper_case;MEM_MAP;IN_SET_OF_LIST;MEM_FILTER];
    REWRITE_TAC[NOT_EXISTS_THM];
    FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `contour_list` kill;
    TYPIFY `x` (RENAME_TAC "r'");
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN POP_ASSUM kill;
    REWRITE_TAC[in_dart_of_loop];
    TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC normal_list_uniq_nonnil THEN ASM_MESON_TAC[]);
    ASM_SIMP_TAC[in_dart_loop_of_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `?p'. MEM y p' /\ MEM p' (parts L r')` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC parts_flatten [`L`;`r'`];
      ASM_REWRITE_TAC[] THEN DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
      REWRITE_TAC[Seq2.mem_flatten];
      BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`r'`;`p'`;`LAST p'`]);
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.mem_cat;IN_SET_OF_LIST;IN_UNION];
    TYPIFY `edge_map (hypermap_of_list L) (LAST p') = e_list (LAST p')` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN SUBST1_TAC THEN MESON_TAC[]);
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    MATCH_MP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    MATCH_MP_TAC parts_darts;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    BY(ASM_MESON_TAC[MEM_LAST]);
  COMMENT "support condition";
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`]);
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`\i. EL i s`;`PRE (sizel s)`];
  nCONJ_TAC 2;
    MATCH_MP_TAC contour_list_is_contour;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC support_of_sequence_list;
  ASM_REWRITE_TAC[EL];
  COMMENT "next step not needed";
  TYPIFY `~(s = [])` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `PRE (sizel s) = (LENGTH s - 1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[LAST_EL]);
    REWRITE_TAC[lower_case];
    MATCH_MP_TAC (arith `~(n = 0) ==> PRE n = n - 1`);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let simple_hypermap_list = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L /\ all uniq L ==>
     simple_hypermap (hypermap_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[simple_hypermap];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC SUBSET_ANTISYM;
  CONJ2_TAC;
    REWRITE_TAC[SUBSET;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
    BY(MESON_TAC[node_refl;face_refl]);
  REWRITE_TAC[SUBSET;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[dart_hypermap_of_list;IN_SET_OF_LIST]);
  ASM_SIMP_TAC[List_hypermap.face_of_list];
  ASM_SIMP_TAC[MEM_hypermap_of_list_node;IN_SET_OF_LIST];
  TYPED_ABBREV_TAC `f = find_pair_list L x`;
  TYPED_ABBREV_TAC `v = FST x`;
  TYPIFY `MEM f L /\ MEM v f` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "f";
    SUBCONJ_TAC;
      BY(ASM_SIMP_TAC[List_hypermap.mem_find_pair_list]);
    DISCH_TAC;
    INTRO_TAC List_hypermap.dart_in_face [`x`;`L`];
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[List_hypermap.find_face_alt];
    TYPIFY `x = (v,SND x)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[PAIR_EQ2]);
    BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (* Wmlnymd. *) dart_of_unique [`L`;`f`;`v`;`x'`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FIRST_X_ASSUM MP_TAC;
    ASM_REWRITE_TAC[List_hypermap.find_face_alt];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC List_hypermap.find_pair_list_unique;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  INTRO_TAC (* Wmlnymd. *) dart_of_unique [`L`;`f`;`v`;`x`];
  ASM_REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let list_pairs_not_uniq = prove_by_refinement(
  `!s. ~uniq s /\ uniq (list_pairs s) ==> (?x:A#A x'. MEM x (list_pairs s) /\
   MEM x' (list_pairs s) /\ ~(x = x') /\ (FST x = FST x'))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq2.uniq_nthP;NOT_FORALL_THM;NOT_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`i`;`j`]);
  ASM_REWRITE_TAC[];
  INTRO_TAC List_hypermap.size_list_pairs [`s`];
  DISCH_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPED_ABBREV_TAC `x = nth x0 (list_pairs s) i`;
  TYPED_ABBREV_TAC `x' = nth x0 (list_pairs s) j`;
  GEXISTL_TAC [`x`;`x'`];
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    EXPAND_TAC "x";
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  CONJ_TAC;
    EXPAND_TAC "x'";
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  RENAME_TAC "a" `x0:A`;
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC);
  TYPIFY_GOAL_THEN `nth (x0:A#A) (list_pairs s) i = nth (a,a) (list_pairs s) i /\ nth x0 (list_pairs s) j = nth (a,a) (list_pairs s) j` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[Seq.set_nth_default;arith `i < j /\ j < s ==> i < s:num`]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "x";
  FULL_EXPAND_TAC "x'";
  REPEAT (GMATCH_SIMP_TAC List_hypermap.nth_list_pairs);
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let simple_hypermap_all_uniq = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L /\ 
     simple_hypermap (hypermap_of_list L) ==> all uniq L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[simple_hypermap];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "l");
  PROOF_BY_CONTR_TAC;
  INTRO_TAC list_pairs_not_uniq [`l`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[List_hypermap.list_of_darts_alt];
  DISCH_TAC THEN INTRO_TAC uniq_flatten_uniq [`list_of_faces L`;`list_pairs l`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x (list_of_darts L) /\ MEM x' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.list_of_darts_alt];
    REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[EXTENSION;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
  DISCH_THEN (C INTRO_TAC [`x'`]);
  ASM_SIMP_TAC[List_hypermap.face_of_list];
  ASM_SIMP_TAC[MEM_hypermap_of_list_node;IN_SET_OF_LIST];
  TYPIFY `find_face L x = list_pairs l` ENOUGH_TO_SHOW_TAC;
    BY(ASM_SIMP_TAC[]);
  REWRITE_TAC[List_hypermap.find_face_alt];
  AP_TERM_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let simple_hypermap_uniq = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L ==>
     (simple_hypermap (hypermap_of_list L) <=> all uniq L)`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[simple_hypermap_all_uniq;simple_hypermap_list])
  ]);;
  (* }}} *)

let iso_is_node_nondegenerate = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ is_node_nondegenerate H ==> is_node_nondegenerate K`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_node_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`f x`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let iso_is_no_double_joins = prove_by_refinement(
 `!f H K. hyp_iso f (K,H) /\ is_no_double_joins H ==> is_no_double_joins K`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_no_double_joins];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `y IN dart K` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_node_subset;SUBSET]);
  TYPIFY `f x = f y` ENOUGH_TO_SHOW_TAC;
    FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.hyp_iso_bij);
    REWRITE_TAC[BIJ;INJ];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Hypermap_iso.hyp_iso_dart);
  ASM_SIMP_TAC[];
  INTRO_TAC Hypermap_iso.hyp_iso_edge_node [`H`;`f`;`K`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  FIRST_ASSUM (MP_TAC o MATCH_MP Lp_gen_theory.components_iso_image);
  TYPIFY `edge_map K y IN dart K /\ edge_map K x IN dart K` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_dart_invariant]);
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[FUN_IN_IMAGE])
  ]);;
  (* }}} *)

(* was let is_card_dart = 0;; *)

let iso_card_face = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ 
    (!x. x IN dart H ==> 3 <= CARD (face H x)) ==>
    (!x. x IN dart K ==> 3 <= CARD (face K x))
   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`f x`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let hyp_iso_restricted = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ is_restricted H ==>
     is_restricted K
 `,
  (* {{{ proof *)
  [
  REWRITE_TAC[is_restricted];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.iso_planar_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_plain_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_connected_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_simple_imp [`f`;`H`;`K`];
  INTRO_TAC iso_is_no_double_joins [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_edge_nondegenerate_imp [`f`;`H`;`K`];
  INTRO_TAC iso_is_node_nondegenerate [`f`;`H`;`K`];
  INTRO_TAC iso_card_face [`f`;`H`;`K`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[ Local_lemmas.EXISTS_IN]);
  FIRST_X_ASSUM_ST `?` MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `{}` MP_TAC THEN REWRITE_TAC[Local_lemmas.EXISTS_IN];
  FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.hyp_iso_bij);
  REWRITE_TAC[BIJ;SURJ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let iso_restricted = prove_by_refinement(
  `!H K. iso H K ==> (is_restricted H <=> is_restricted K)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso K H` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.iso_sym]);
  INTRO_TAC Hypermap_iso.iso_imp_hyp_iso [`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_imp_hyp_iso [`K`;`H`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[hyp_iso_restricted])
  ]);;
  (* }}} *)

let DAKEFCC = iso_restricted;;

(* xxd to here *)

let marked_list_is_node_nondegenerate = prove_by_refinement(
  `!L N r d. 
    good_list L /\  good_list_nodes L /\
    good_list_nodes (quotient_list L N) /\
    marked_list L N r d  ==> 
    is_node_nondegenerate (quotient (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  rt[marked_list;LET_THM]
  st/r
  typ `is_restricted (hypermap_of_list L) /\ is_edge_nondegenerate (hypermap_of_list L) /\ all uniq L` sat
  rep 6 (pop kill)
  amt[simple_hypermap_all_uniq;is_restricted;marked_list]
  intro quotient_list_iso_quotient [`L`;`N`]
  art[]
  abbrev `ql = hypermap_of_list (quotient_list L N)`
  abbrev `q = quotient (hypermap_of_list L) (loop_family_of_list N)`
  dt
  typ `?g. hyp_iso g (q,ql)` smp
  amt[Hypermap_iso.iso_imp_hyp_iso;Hypermap_iso.hyp_iso_imp_iso;Hypermap.iso_sym]
    typ `is_node_nondegenerate ql` ets
  mt[iso_is_node_nondegenerate]
  fexp "ql"
  rt[Hypermap.lemma_node_nondegenerate]
  typ `good_list (quotient_list L N)` sat
  mmp good_list_quotient
  art[]
  asimp[dart_hypermap_of_list;IN_SET_OF_LIST]
  st/r
  gm (* Wmlnymd. *) dart_of_card_node
  abbrev `v = FST x`
  typ `v` ex
  art[]
  rt[lower_case;arith `2 <= n <=> n > 1`]
  fxast `1` mp then rt[sym Seq.allP]
  dthen (C intro [`v`])
  rt[ (* Wmlnymd. *) facesAt_list;lower_case]
 dthen mmp
 ... xxd  (* finish by relating elements to flatten L *)
  ]);;
  (* }}} *)

is_restricted;;
marked_list;;
is_marked;;
Hypermap.lemma_node_nondegenerate;;


1;;
(* SET ASIDE A BIT:::: *)



(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)



(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
