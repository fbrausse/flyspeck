
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;

module Work_in_progress = struct
end;;

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;


let mem_z0_ri = prove_by_refinement(
  `!i L N r x k.
         good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
    (i < k) /\
     (transform_count L N r x = k) ==>
    MEM (ztrans L N r x 0) (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  INDUCT_TAC then rt[]
  st/r
  amt[Pwssrat.mem_ztrans_rtrans;Reduction2.transform_assumption_v2_lemma;Reduction2.trans0]
  st/r
  intro Pwssrat.PWSSRAT [`L`;`N`;`r`;`x`;`ztrans L N r x 0`;`i`]
  asimp[Reduction2.transform_assumption_v2_lemma;]
  rt[arith `SUC i = 1+i`]
  rt[trans_add]
  dthen gm
  conj
  conj
  fxa mmp
  typ `k` ex then asimp[]
  asm then ARITH_TAC
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  asm then ARITH_TAC
xxd


  mmp xxd
  ]);;
  (* }}} *)


let final_assumption_yz_in_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (!i j. 0 < i /\ i < k /\ j < k ==>
	(MEM (FST (ytrans L N r x j)) (core L (rtrans L N r x i))) /\
	MEM (FST (ztrans L N r x j)) (core L (rtrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM ( (ytrans L N r x j)) ( (rtrans L N r x i)) /\ MEM ((ztrans L N r x j)) ((rtrans L N r x i))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `i <= j:num` ASM_CASES_TAC;
    TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ARITH_TAC);
    TYPIFY `j = (j - i:num) + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    REWRITE_TAC[trans_add];
    REWRITE_TAC[Reduction2.trans0];
    TYPIFY `~(final_list L (rtrans L (ntrans L N r x i) (rtrans L N r x i) x (j-i)))` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[GSYM trans_add];
      MATCH_MP_TAC Kbwpbhq.transform_count_not;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Pnxvwfs.PNXVWFS2;Pnxvwfs.PNXVWFS1;Reduction2.transform_assumption_v2_lemma]);
  TYPIFY `j = 0 + j` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  TYPIFY `i = (i - j) + (j:num)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[trans_add];
  TYPIFY `~(final_list L (rtrans L (ntrans L N r x j) (rtrans L N r x j) x (i - j)))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM trans_add];
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `marked_list L (ntrans L N r x j) (rtrans L N r x j) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[ Pbflhet.properties_of_ytrans0;Reduction2.transform_assumption_v2_lemma]);
  (DISCH_TAC)
   ....  need MEM z0 (rtrans j).
  ]);;
  (* }}} *)


Pnxvwfs.PNXVWFS2;;


UNFINISHED;;
(*

*)



(*
let final_assumption_? = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
    (!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)))

`,
  (* {{{ proof *)
  [
  st/r
  rt[dest_triple_full]
  repeat LET_TAC
  fxast `HD` mp then repeat LET_TAC
  fexp "vs'"
  rt[Seq.flatten_cons;Seq.flatten0]
  gm dest_triple0_foldl_steps

  #
  ]);;
  (* }}} *)
*)
