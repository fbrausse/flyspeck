
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_list;;
open Import_tame_classification;;
open Tame_defs;;
open More_tame_concl;;

(*
open Hypermap;;
open Import_tame_classification;;
open Tame_defs;;
open Tame_concl;;
open More_tame_concl;;
open Oxaxucs;;  (* invariance of tame under iso *)
open Asfutbf;;  (* contravening V, and opposite *)
open Elllnyz;;  (* isabell iso_fgraph and hypermap iso *)
open Wmlnymd;;  (* tameness in as lists and as hypermaps *)
open Dpzgbyf;;  (* basic properties of planegraphs and seeds *)
*)


(* TO HERE *)

let inj_on_I = prove_by_refinement(
  `!L. inj_on I L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;I_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(* was iso_list_ref *)

let iso_list_refl  = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list). iso_list L L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC THEN TYPIFY `I:A->A` EXISTS_TAC;
  BY(REWRITE_TAC[I_THM;MAP_I;inj_on_I;GSYM I_DEF])
  ]);;
  (* }}} *)

let inj_on_o = prove_by_refinement(
  `!X phi phi'. inj_on phi X /\ inj_on phi' (IMAGE phi X) ==>
    inj_on (phi' o phi) X`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;o_THM;IMAGE;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[IN])
  ]);;
  (* }}} *)

let undup_map_undup = prove_by_refinement(
  `!f s. undup (MAP f (undup s)) = undup (MAP f s)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MAP;Seq.undup]);
  REWRITE_TAC[MAP;Seq.undup];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEMf_MAP]);
  ASM_REWRITE_TAC[Seq.undup;MAP];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC;
      BY(REWRITE_TAC[]);
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[MEM_MAP];
    BY(MESON_TAC[Seq.mem_undup]);
  COND_CASES_TAC;
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[MEM_MAP] THEN MESON_TAC[Seq.mem_undup]);
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let list_of_elements_map = prove_by_refinement(
  `!f s. undup (MAP f (list_of_elements s)) = list_of_elements (MAP (MAP f) s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[GSYM MAP_flatten];
  BY(REWRITE_TAC[undup_map_undup])
  ]);;
  (* }}} *)

let elements_of_list_MAP = prove_by_refinement(
  `elements_of_list (MAP (MAP phi) s) = IMAGE phi (elements_of_list s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list];
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;GSYM SET_OF_LIST_MAP];
  REWRITE_TAC[GSYM list_of_elements_map];
  BY(REWRITE_TAC[Seq.mem_undup])
  ]);;
  (* }}} *)

let iso_list_trans = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list) 
    (L':((B)list)list#((B#B)list)list)
    (L'':((C)list)list#((C#C)list)list).
   iso_list L L' /\ iso_list L' L'' ==> iso_list L L''`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `phi' o phi` EXISTS_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC inj_on_o;
    ASM_REWRITE_TAC[];
    TYPIFY `elements_of_list p1' = IMAGE phi (elements_of_list p1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[elements_of_list_MAP];
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM MAP_o];
  CONJ_TAC;
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    REWRITE_TAC[FUN_EQ_THM];
    BY(REWRITE_TAC[o_THM;MAP_o]);
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[o_THM;GSYM MAP_o];
  GEN_TAC;
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP];
  BY(REWRITE_TAC[o_THM])
  ]);;
  (* }}} *)

let inj_on_INJ = prove_by_refinement(
  `!(f:A->B) s. inj_on f s <=> INJ f s (:B)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;INJ;IN_UNIV];
  BY(REWRITE_TAC[IN])
  ]);;
  (* }}} *)

let inj_on_BIJ = prove_by_refinement(
  `!f (s:A->bool). inj_on (f:A->B) s ==> BIJ f s (IMAGE f s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Lunar_deform.INJ_IMP_BIJ_IMAGE);
  TYPIFY `(:B)` EXISTS_TAC;
  BY(ASM_REWRITE_TAC[GSYM inj_on_INJ])
  ]);;
  (* }}} *)

let iso_list_sym = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list) 
    (L':((B)list)list#((B#B)list)list).
    iso_list L L' /\
    (set_of_list (MAP FST (flatten (SND L))) SUBSET elements_of_list (FST L)) /\
    (set_of_list (MAP SND (flatten (SND L))) SUBSET elements_of_list (FST L)) 
     ==> iso_list L' L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `phi' = INVERSE phi (elements_of_list p1) (elements_of_list p1')`;
  TYPIFY `phi'` EXISTS_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP inj_on_BIJ);
  TYPIFY `IMAGE phi (elements_of_list p1) = elements_of_list p1'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[elements_of_list_MAP]);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Misc_defs_and_lemmas.INVERSE_BIJ);
  SUBCONJ_TAC;
    REWRITE_TAC[inj_on_INJ;INJ;IN_UNIV];
    BY(FIRST_X_ASSUM MP_TAC THEN ASM_MESON_TAC[BIJ;INJ]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM MAP_o];
  TYPIFY `!t. t IN (elements_of_list p1) ==> phi' (phi t) = t` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "phi'";
    GMATCH_SIMP_TAC Misc_defs_and_lemmas.INVERSE_XY;
    BY(ASM_MESON_TAC[FUN_IN_IMAGE]);
  CONJ_TAC;
    TYPIFY `MAP (MAP phi' o MAP phi) p1 = MAP I p1` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[MAP_I;I_THM]);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
    REWRITE_TAC[upper_case;GSYM MAP_o];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MAP (phi' o phi) x = MAP I x` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[MAP_I;I_THM]);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements];
    REWRITE_TAC[Seq.mem_undup];
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  TYPIFY `MAP (MAP (\u. phi' (FST u),phi' (SND u)) o MAP (\u. phi (FST u),phi (SND u))) p2 = MAP I p2` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
  REWRITE_TAC[upper_case;GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\u. phi' (FST u),phi' (SND u)) o (\u. phi (FST u),phi (SND u))) x = MAP I x` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `flatten` MP_TAC) THEN REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.elements_of_list];
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements] THEN REWRITE_TAC[Seq.mem_undup];
    FIRST_X_ASSUM kill;
    FIRST_X_ASSUM MATCH_MP_TAC;
    REWRITE_TAC[MEM_MAP];
    BY(TYPIFY `(p1'',p2'')` EXISTS_TAC THEN REWRITE_TAC[] THEN ASM_MESON_TAC[Seq2.mem_flatten]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  REWRITE_TAC[MEM_MAP];
  BY(TYPIFY `(p1'',p2'')` EXISTS_TAC THEN REWRITE_TAC[] THEN ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let GNBEVVU = prove_by_refinement(
  `!L N L' N'. 
    good_list L /\ iso_list (L,N) (L',N') ==> 
    iso (hypermap_of_list L) (hypermap_of_list L')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Elllnyz.hypermap_of_list_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let iso_list_non_nil = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ all (\l. ~(l = [])) L ==>
					    all (\l. ~(l = [])) L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC THEN ASM_REWRITE_TAC[MAP_EQ_NIL];
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[MAP_EQ_NIL])
  ]);;
  (* }}} *)

let iso_list_uniq = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ uniq (list_of_darts L) ==>
					    uniq (list_of_darts L')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[map_list_of_darts];
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[PAIR_EQ];
  BY(ASM_MESON_TAC[inj_on_imp_inj_dart])
  ]);;
  (* }}} *)

let iso_list_good_list = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ 
    good_list L ==>
    good_list L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Elllnyz.map_good_list;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let PEUTLZH = iso_list_good_list;;

let iso_list_good_list_nodes = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ 
    good_list L /\ good_list_nodes L ==>
    good_list_nodes L'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso (hypermap_of_list L) (hypermap_of_list L')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GNBEVVU]);
  TYPIFY `good_list L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[PEUTLZH]);
  ASM_TAC THEN REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC List_hypermap.good_list_nodes_condition;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM Hypermap.number_of_nodes];
  FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.iso_imp_hyp_iso);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.iso_number_of_nodes [`f`;`hypermap_of_list L'`;`hypermap_of_list L`];
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  REWRITE_TAC[GSYM list_of_elements_map];
  INTRO_TAC uniq_map [`list_of_elements L`;`phi`];
  ANTS_TAC;
    REWRITE_TAC[List_hypermap.uniq_list_of_elements];
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    REWRITE_TAC[inj_on;List_hypermap.elements_of_list;IN_SET_OF_LIST];
    BY(REWRITE_TAC[IN;GSYM IN_SET_OF_LIST]);
  SIMP_TAC[Seq.undup_id];
  REWRITE_TAC[lower_case;Seq.size_map];
  BY(ASM_MESON_TAC[Hypermap.number_of_nodes;List_hypermap.good_list_nodes_condition])
  ]);;
  (* }}} *)

let OISRWOF = iso_list_good_list_nodes;;

let IN_ELIM_SET_OF_LIST = prove_by_refinement(
  `!u s. set_of_list s u = MEM u s`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

let iso_list_all_uniq = prove_by_refinement(
  `!L L'. iso_list(L,[]) (L',[]) /\
    all uniq L ==> all uniq L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all` MP_TAC;
  ASM_REWRITE_TAC[GSYM Seq.allP;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x'`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `inj_on` MP_TAC;
  REWRITE_TAC[inj_on;List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements];
  ASM_REWRITE_TAC[Seq2.set_of_list_undup];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Seq2.mem_flatten;IN;IN_ELIM_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let UEYETNI = iso_list_all_uniq;;

let normal_list_list_of_darts = prove_by_refinement(
  `!L N. normal_list L N ==> all (\x. MEM x (list_of_darts L)) (flatten N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list;loop_list;GSYM Seq.allP];
  BY(ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let normal_list_darts_of_list = prove_by_refinement(
  `!L N. normal_list L N ==> (set_of_list (flatten N) SUBSET (darts_of_list L))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list;loop_list;GSYM Seq.allP];
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.darts_of_list];
  REWRITE_TAC[Seq2.mem_flatten];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_sym_normal = prove_by_refinement(
  `!L N L' N'. normal_list L N /\ iso_list (L,N) (L',N') ==> iso_list (L',N') (L,N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC iso_list_sym;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
  INTRO_TAC normal_list_list_of_darts [`L`;`N`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  REWRITE_TAC[List_hypermap.list_of_darts_alt;Seq2.mem_flatten;List_hypermap.list_of_faces];
  REWRITE_TAC[MEM_MAP;List_hypermap.list_pairs];
  REWRITE_TAC[FORALL_PAIR_THM;EXISTS_PAIR_THM];
  BY(MESON_TAC[Seq.mem_rot;Seq2.mem_zip])
  ]);;
  (* }}} *)

let normal_list_nil = prove_by_refinement(
  `!L. normal_list L []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list];
  BY(REWRITE_TAC[concat_flatten;Seq.all;MEM;Seq.uniq])
  ]);;
  (* }}} *)

let iso_list_sym_nil = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) ==> iso_list (L',[]) (L,[])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC iso_list_sym_normal;
  BY(ASM_REWRITE_TAC[normal_list_nil])
  ]);;
  (* }}} *)

let iso_list_sym_nil_eq = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) <=> iso_list (L',[]) (L,[])`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[iso_list_sym_nil])
  ]);;
  (* }}} *)

let INJ_NUM_EXISTS = prove_by_refinement(
  `!A:A->bool. FINITE A ==> (?j:A->num. inj_on j A)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[inj_on_INJ];
  INTRO_TAC Counting_spheres.INJ_FINITE_EXISTS [`CARD A`;`A`;`1..(CARD A)`];
  REWRITE_TAC[HAS_SIZE;FINITE_NUMSEG;CARD_NUMSEG_1];
  ASM_REWRITE_TAC[arith `n:num <= n`];
  REWRITE_TAC[INJ;IN_UNIV];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let JXBJOAB = prove_by_refinement(
  `!(L:((A)list)list). 
   ?(L':((num)list)list). iso_list (L,[]) (L',[])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[iso_list;MAP];
  INTRO_TAC INJ_NUM_EXISTS [`elements_of_list L`];
  REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_num = JXBJOAB;;

let inj_on_dart_of_list = prove_by_refinement(
  `!p L. inj_on (p:A->B) (elements_of_list L) ==> 
    inj_on (\t. p(FST t),p(SND t))   (darts_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;List_hypermap.darts_of_list;List_hypermap.elements_of_list];
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REWRITE_TAC[IN_ELIM_SET_OF_LIST];
  BY(MESON_TAC[mem_list_of_darts_imp_mem_list_of_elements_alt])
  ]);;
  (* }}} *)

let iso_list_uniq_flatten = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. normal_list L N /\
      iso_list (L,N) (L',N') ==> uniq (flatten N')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[GSYM MAP_flatten];
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[];
  INTRO_TAC inj_on_subset [`nphi`;`darts_of_list L`;`set_of_list(flatten N)`];
  ASM_REWRITE_TAC[inj_on];
  BY(REWRITE_TAC[IN_ELIM_SET_OF_LIST])
  ]);;
  (* }}} *)

let iso_list_all_nonnil = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. normal_list L N /\
      iso_list (L,N) (L',N') ==> all (\s. ~(s = [])) N'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `s = []` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[MAP_EQ_NIL];
  BY(ASM_MESON_TAC[MAP_EQ_NIL])
  ]);;
  (* }}} *)

normal_list;;


(* SET ASIDE A BIT:::: *)


(* was MEM_splitFace *)

let MEM_splitFace1 = prove_by_refinement(
  `!g u v f ws.  
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM f1 (faces g'))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  ASM_REWRITE_TAC[faces_graph];
  REWRITE_TAC[MEM_APPEND];
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let MEM_splitFace2 = prove_by_refinement(
  `!g u v f ws.  MEM f (faces g) ==>
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM f2 (faces g'))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  ASM_REWRITE_TAC[faces_graph];
  REWRITE_TAC[MEM_APPEND];
  DISJ1_TAC;
  MATCH_MP_TAC MEM2_replace;
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let split_face2_vertex1 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM u (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face2_vertex2 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM v (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face1_vertex1 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM u (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face1_vertex2 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM v (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let splitFace1_vertex1 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM u (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face1_vertex1 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace1_vertex2 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM v (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face1_vertex2 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace2_vertex1 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM u (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face2_vertex1 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace2_vertex2 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM v (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face2_vertex2 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)


let pairwise_lt_shift = prove_by_refinement(
  `!ts f u v.  indexf u v f <= indexf u (HD ts) f /\
    pairwisel (\i j. indexf u i f < indexf u j f) ts ==>
    pairwisel (\i j. indexf v i f < indexf v j f) ts`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[pairwisel]);
  REWRITE_TAC[NOT_CONS_NIL;HD;pairwisel];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `T` MP_TAC) THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    TYPIFY `u` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[arith `iv <= ih /\ ih < iH:num ==> iv <= iH`]);
  TYPIFY `indexf u (HD t) f <= sizel f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[indexf_le_sizel]);
  TYPIFY `MEM u f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`h`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM v f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM h f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `indexf v (HD t) f = sizel f` ASM_CASES_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC indexf_lt_sizel;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (HD t) f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[indexf2]);
  INTRO_TAC indexf_add_left [`u`;`v`;`h`;`f`];
  INTRO_TAC indexf_add_left [`u`;`v`;`HD t`;`f`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let HD_MAP = prove_by_refinement(
  `!s f. ~(s = []) ==> HD (MAP f s) = f (HD s)`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[HD;MAP])
  ]);;
  (* }}} *)

let pairwise_o = prove_by_refinement(
  `!ts f g. (pairwisel (\x y. f (g x) (g y)) ts = pairwisel f (MAP g ts))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[pairwisel;MAP;o_THM];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[MAP_EQ_NIL];
  BY(ASM_SIMP_TAC[HD_MAP])
  ]);;
  (* }}} *)


(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)

let splitFace_split_face = prove_by_refinement(
  `!g u v f ws f1 f2 g'. splitFace g u v f ws = f1,f2,g' ==>
    split_face f u v ws = (f1,f2)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[splitFace];
  REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[PAIR_EQ];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)

(* Added Jan 2014. *)





(*
let exists_atomize = prove_by_refinement(
  `!ni (s:(A)list). (all (\d. ~(ni d = d)) s) /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
fxast `LAST` mp
rt[GSYM Seq.all_cons]
amt[Seq.all_cons]
  ]);;
  (* }}} *)
*)

let exists_atomize = prove_by_refinement(
  `!ni f (s:(A)list).  (all (\d. ~(ni d = d)) s) /\ 
    (all (\d. ~(ni d = f d)) s) /\ 
    next_el s (LAST s) = f (LAST s) /\
    all (\d. next_el s d = f d \/ next_el s d = ni d) s /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC then g
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    nconj 2
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
    
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
  ]);;
  (* }}} *)


(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
