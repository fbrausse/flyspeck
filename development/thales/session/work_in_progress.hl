
module Work_in_progress = struct
end;;

(* *************************************************************************** *)
(* COMPLETED LEMMAS *)
(* *************************************************************************** *)

(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)

(* hypermap liason *)

(* the list bn_Archive is the concatenation of bn_Tri, bn_Quad, bn_Pent, and bn_Hex.
    These definitions need to be loaded from the Arch theory (which converts
    them from .ML files)  *)


flyspeck_needs "../tame_archive/tame_archive.hl";;



open Tame_archive;;  (* must open because of reflected references *)
open Hypermap;;
open Tame_classification;;

time Tame_archive.arc3 ();;  (* 0.18 secs *)
List.length !Tame_archive.ref3;;  (* 9 *)
arc3();; (* build data *)

let archive3a = new_definition (mk_eq (`archive3a:((num list)list)list`, hol_of_list3 !ref3));;

let isabelle_graph_class_axiom3 = new_definition
  `isabelle_graph_class_axiom3 = (!g. bn_PlaneGraphs g /\ bn_tame g /\ 
  (!f. bn_Faces g f ==> LENGTH (FST f) = 3) ==>
  bn_iso_in (bn_fgraph g) (set_of_list archive3a))`;;

let isabelle_graph_class_axiom = (* new_definition *)
  `tame_graph_classification_theorem = 
  (!g. bn_PlaneGraphs g /\ bn_tame g ==> bn_iso_in (bn_fgraph g) (set_of_list tame_archive))`;;

let tame_bn_tame = `!H. tame_hypermap (H:(A)hypermap) 
  ==> (?g. bn_PlaneGraphs g /\ bn_tame g /\
	 iso H (hypermap_of_list (bn_fgraph g)))`;;

let tame_not_contravening = `isabelle_graph_classification_theorem 
  ==> (!V. tame_hypermap (hypermap_of_fan (V,ESTD V)) ==> ~contravening V)`;;

let bn_cong_iso_refl = prove_by_refinement(
  `!(g:((A)list)list). bn_cong_iso g g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_cong_iso];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `I:A->A` EXISTS_TAC;
  REWRITE_TAC[bn_is_iso;bn_is_Iso;bn_is_pr_Iso;bn_is_Hom;bn_inj_on;I_THM;MAP_I;IMAGE_I];
  DISJ1_TAC;
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rot_bn_rotate = prove_by_refinement(
  `!n s. rot n s = bn_rotate n s`,
  (* {{{ proof *)
  [
  rt[Seq.rot;bn_rotate;bn_rotate1]
    INDUCT_TAC
    rt[POWER_0]
  rt[Seq.drop0;Seq.take;I_THM;Seq.cats0]
g
rt[POWER;o_THM;bn_rotate1]
  ]);;
  (* }}} *)


let perm_eq_bn_cong_iso = prove_by_refinement(
  `!g1 g2. good_list g1 /\ bn_cong_iso g1 g2 ==> perm_eq g1 g2`,
  (* {{{ proof *)
  [
  rt[Seq.perm_eq;bn_cong_iso]
  ]);;
  (* }}} *)


let bn_cong_iso = prove_by_refinement(
  `!g1 g2. good_list g1 /\ bn_cong_iso g1 g2 ==> iso (hypermap_of_list g1) (hypermap_of_list g2)`,
  (* {{{ proof *)
  [
g/r
      rt[bn_cong_iso;bn_is_iso;bn_is_Iso;bn_is_pr_Iso;bn_is_Hom;bn_inj_on]
	rt[bn_congs;iso]
st/r
  ]);;
  (* }}} *)


bn_congs;;

let HAS_REAL_INTEGRAL_DOMINATED = prove_by_refinement(
  `!f g a b i j.
    (f has_real_integral i) (real_interval [a,b]) /\
    (g has_real_integral j) (real_interval [a,b]) /\
    (!x. x IN real_interval [a,b] ==> f x <= g x) ==>
    (i <= j)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  REPEAT (FIRST_X_ASSUM_ST `has_real_integral` MP_TAC);
  PURE_ONCE_REWRITE_TAC[TAUT `(a ==> b ==> c) <=> (b /\ a ==> c)`];
  DISCH_THEN (MP_TAC o (MATCH_MP HAS_REAL_INTEGRAL_SUB));
  DISCH_TAC;
  INTRO_TAC HAS_REAL_INTEGRAL_POS [`(\x. g x - f x)`;`real_interval [a,b]`;`j - i`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC THEN (FIRST_X_ASSUM (C INTRO_TAC [`x`]));
    BY(ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let HAS_REAL_INTEGRAL_ABS_DOMINATED = prove_by_refinement(
  `!f g a b i j.
    (f has_real_integral i) (real_interval [a,b]) /\
    (g has_real_integral j) (real_interval [a,b]) /\
    (!x. x IN real_interval [a,b] ==> abs (f x) <= g x) ==>
    (abs i <= j)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[arith `abs i <= j <=> i <= j /\ --j <= i`];
  CONJ_TAC THEN MATCH_MP_TAC HAS_REAL_INTEGRAL_DOMINATED;
    GEXISTL_TAC [`f`;`g`;`a`;`b`];
    ASM_REWRITE_TAC[];
    BY(REPEAT WEAKER_STRIP_TAC THEN (FIRST_X_ASSUM (C INTRO_TAC [`x`])) THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);
  GEXISTL_TAC [`(\x. -- g x)`;`f`;`a`;`b`];
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    MATCH_MP_TAC HAS_REAL_INTEGRAL_NEG;
    BY(ASM_REWRITE_TAC[]);
  BY(REPEAT WEAKER_STRIP_TAC THEN (FIRST_X_ASSUM (C INTRO_TAC [`x`])) THEN ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let atn_1_series = prove_by_refinement(
  `abs (pi / &4 - sum (0..n) u) <= &1 / &(2 * n+3) `,
  (* {{{ proof *)
  [
  intro REAL_FUNDAMENTAL_THEOREM_OF_CALCULUS_INTERIOR [`atn`;`\x. inv (&1 + x pow 2)`;`&0`;`&1`]
    rt[arith `&0 <= &1`;ATN_0;ATN_1;arith `x - &0 = x`]
ants
conj
rt[REAL_CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN]
st/r
mmp REAL_CONTINUOUS_ATREAL_WITHINREAL
rt[REAL_CONTINUOUS_AT_ATN]
st/r
rt[HAS_REAL_DERIVATIVE_ATN]
typ `(\x. inv (&1 + x pow 2)) = (\x. sum (0..n) (\i. (-- &1 * x pow 2) pow i) + (-- &1 * x pow 2) pow (SUC n) / (&1 + x pow 2))` sat
rt[FUN_EQ_THM]
g
calc
subconj
mmp (arith `&0 < a /\ &0 <= b ==> ~(a + b = &0)`)
fyn
rat
intro SUM_GP_BASIC [`-- &1 * x pow 2`;`n`]
abbrev `a = sum (0..n) (\i. (-- &1 * x pow 2) pow i)`
rt[real_pow;arith `&1 - -- &1 * u = &1 + u`]
CONV_TAC REAL_RING
dt
mmp HAS_REAL_INTEGRAL_ABS_DOMINATED
exl [ `(\x. (-- &1 * x pow 2) pow SUC n / (&1 + x pow 2))`;`(\x. x pow (2 * SUC n))`;`&0`;`&1`]
nconj 2
rt[] then st/r
rt[REAL_ABS_DIV]
fyn
subconj
mmp (arith `&0 <= a ==> &0 < abs (&1 + a)`)
fyn



intro HAS_REAL_INTEGRAL_ADD [`(\x. sum (0..n) (\i. (-- &1 * x pow 2) pow i))`;`(\x. (-- &1 * x pow 2) pow SUC n / (&1 + x pow 2))`

  ]);;
  (* }}} *)
