
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;

module Work_in_progress = struct
end;;

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;


(* kill fztrans, if_betwn *)

let ftrans = new_definition'
  `!L N r (x:A#A) i. ftrans L N r x i = if i = 0 then SND x else FST (ztrans L N r x (PRE i))`;;


let ifbetwn = new_definition'
  `!s (x:A) y. ifbetwn s x y = if MEM x s /\ MEM y s /\ ~(x=y) then rcons (betwn s x y) y else []`;;


(* ********************************************************************* *)
(* UVNS  *)
(* ********************************************************************* *)

let el_cat = prove_by_refinement(
  `!i a b. i < sizel (cat a b) ==> 
    EL i (cat a b) = if i < sizel a then EL i a else EL (i - sizel a) b`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.nth_cat [`HD a`;`a`;`b`;`i`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[GSYM Seq2.EL_nth]);
  TYPIFY `i - sizel a < sizel b` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat] THEN ARITH_TAC);
  BY(ASM_SIMP_TAC[GSYM Seq2.EL_nth])
  ]);;
  (* }}} *)

let el_cat_suc = prove_by_refinement(
  `!i a b. SUC i < sizel (cat a b)  ==>
    (?j. SUC j < sizel a /\ EL i (cat a b) = EL j a /\ EL (SUC i) (cat a b) = EL (SUC j) a) \/
    (?j. SUC j < sizel b /\ EL i (cat a b) = EL j b /\ EL (SUC i) (cat a b) = EL (SUC j) b) \/
    (~(a=[]) /\ ~(b=[]) /\ EL i (cat a b) = LAST a /\ EL (SUC i) (cat a b) = HD b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC i < sizel a` ASM_CASES_TAC;
    DISJ1_TAC;
    TYPIFY `i` EXISTS_TAC;
    BY(ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`]);
  DISJ2_TAC;
  TYPIFY `i < sizel ( a)` ASM_CASES_TAC;
    DISJ2_TAC;
    SUBCONJ_TAC;
      REWRITE_TAC[GSYM Seq.size_eq0];
      BY(ASM_TAC THEN ARITH_TAC);
    DISCH_TAC;
    SUBCONJ_TAC;
      BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat;GSYM Seq.size_eq0] THEN ARITH_TAC);
    DISCH_TAC;
    ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`];
    TYPIFY `SUC i - sizel a = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    ASM_SIMP_TAC[LAST_EL];
    ASM_SIMP_TAC[LAST_EL;GSYM Seq.size];
    TYPIFY `sizel a - 1 = i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(REWRITE_TAC[EL]);
  DISJ1_TAC;
  TYPIFY `i - sizel a` EXISTS_TAC;
  SUBCONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat] THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `i < sizel (cat a b)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_SIMP_TAC[ el_cat];
  TYPIFY_GOAL_THEN `SUC (i - sizel a) = SUC i - sizel a` (unlist REWRITE_TAC);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let EL_SUC_CONS = prove_by_refinement(
  `!i h t. EL (SUC i) (h::t) = EL i t`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[EL;TL]);
  ]);;
  (* }}} *)

let HD_flatten = prove_by_refinement(
  `!s. ~(s = []) /\ ~(HD s = []) ==> HD (flatten s ) = HD (HD s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.flatten_cons;HD;NOT_CONS_NIL];
  BY(SIMP_TAC[Tame_list.hd_cat])
  ]);;
  (* }}} *)

let el_flatten = prove_by_refinement(
  `!R i. SUC i < sizel (flatten R) /\ all (\r. ~(r = [])) R ==>
    (?r j. MEM r R /\ SUC j < sizel r /\ (EL i (flatten R) = EL j r) /\ 
       EL (SUC i) (flatten R) = EL (SUC j) r)  \/ 
    (?j. SUC j < sizel R /\ EL i (flatten R) = LAST (EL j R) /\ 
	EL (SUC i) (flatten R) = HD (EL (SUC j) R))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.size_nil;Seq.flatten0;MEM;arith `~(SUC i < 0)`];
  REWRITE_TAC[Seq.flatten_cons;Seq.all_cons;Seq.size_cons;TL];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC i < sizel h` ASM_CASES_TAC;
    DISJ1_TAC;
    GEXISTL_TAC [`h`;`i`];
    ASM_SIMP_TAC[];
    BY(ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`]);
  TYPIFY `i < sizel h` ASM_CASES_TAC;
    DISJ2_TAC;
    TYPIFY `0` EXISTS_TAC;
    REWRITE_TAC[arith `SUC i < SUC j <=> i < j`];
    SUBCONJ_TAC;
      REWRITE_TAC[arith `0 < n <=> ~(n=0)`;Seq.size_eq0];
      DISCH_TAC;
      BY(FIRST_X_ASSUM_ST `cat` MP_TAC THEN ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0] THEN ASM_TAC);
    DISCH_TAC;
    CONJ_TAC;
      ASM_SIMP_TAC[EL;el_cat;HD;arith `SUC i < n ==> i < n`];
      ASM_SIMP_TAC[ LAST_EL];
      REWRITE_TAC[lower_case];
      TYPIFY_GOAL_THEN `sizel h - 1 = i` (unlist REWRITE_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[EL_SUC_CONS];
    ASM_SIMP_TAC[el_cat];
    TYPIFY `SUC i - sizel h = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[EL];
    GMATCH_SIMP_TAC HD_flatten;
    CONJ_TAC;
      DISCH_TAC;
      BY(FIRST_X_ASSUM_ST `cat` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0;Seq.cats0]);
    FIRST_X_ASSUM_ST `all` MP_TAC;
    REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    MATCH_MP_TAC MEM_HD;
    BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n ==> ~(n=0)`]);
  TYPIFY `?i'.  sizel h + i' = i` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `i - sizel h` EXISTS_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "i";
  ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`];
  REPLICATE_TAC 3 (POP_ASSUM kill);
  TYPIFY `(sizel h + i' ) - sizel h = i'` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  REWRITE_TAC[arith `SUC (sizel h + i') - sizel h = SUC i'`];
  REWRITE_TAC[EL_SUC_CONS];
  FIRST_X_ASSUM_ST `cat` MP_TAC THEN REWRITE_TAC[Seq.size_cat;arith `SUC (h + i') < h + t <=> SUC i' < t`];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`i'`]);
  ASM_REWRITE_TAC[];
  REPEAT STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  DISJ2_TAC;
  TYPIFY `SUC j` EXISTS_TAC THEN ASM_REWRITE_TAC[EL_SUC_CONS];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let scroll_flatten_map2 = prove_by_refinement(
  `!k i u (a:num->A).   
     ((a i) ::  flatten (MAP (\i. rcons (u i) (a i)) (iota (SUC i) k))) = 
      rcons (flatten (MAP (\i. (a i) :: (u (SUC i))) (iota i k)))  (a (i+k))`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.iota;MAP;Seq.rcons;arith `i+0=i`]);
  REWRITE_TAC[arith `SUC i = i + 1`;Seq.iota_add;Seq.map_cat;lower_case];
  TYPIFY_GOAL_THEN `!x. iota (x) 1 = [x]` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[Seq.iota;arith `1 = SUC 0`]);
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.cats1;Seq.flatten_cat;lower_case];
  ASM_SIMP_TAC[GSYM Seq.cat_cons;arith `i + 1 = SUC i`];
  DISCH_THEN kill;
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.catA];
  AP_TERM_TAC;
  REWRITE_TAC[upper_case;MAP;Aq1.flatten_sing];
  BY(REWRITE_TAC[lower_case;CONS_11;Seq.catA;Seq.cat_cons;Seq.cat0s;arith `SUC (i+k) = SUC i + k /\ i + SUC k = SUC i + k `])
  ]);;
  (* }}} *)

let scroll_flatten_map = prove_by_refinement(
  `!k i u (a:num->A).   
     ((a i) ::  flatten (MAP (\i. rcons (u i) (a (SUC i))) (iota (i) k))) = 
      rcons (flatten (MAP (\i. (a i) :: (u i)) (iota i k)))  (a (i+k))`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.iota;MAP;Seq.rcons;arith `i+0=i`]);
  REWRITE_TAC[arith `SUC k = k + 1`;Seq.iota_add;Seq.map_cat;lower_case];
  TYPIFY_GOAL_THEN `!x. iota (x) 1 = [x]` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[Seq.iota;arith `1 = SUC 0`]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.cats1;Seq.flatten_cat;lower_case];
  ASM_SIMP_TAC[GSYM Seq.cat_cons;arith `i + 1 = SUC i`];
  DISCH_THEN kill;
  REWRITE_TAC[GSYM Seq.catA];
  AP_TERM_TAC;
  REWRITE_TAC[upper_case;MAP;Aq1.flatten_sing];
  BY(REWRITE_TAC[lower_case;CONS_11;Seq.catA;Seq.cat_cons;Seq.cat0s;arith `SUC (i+k) = SUC i + k /\ i + SUC k = SUC i + k `])
  ]);;
  (* }}} *)

let f_list_imp_last = prove_by_refinement(
  `!L r x.  
    good_list L /\
    MEM x (list_of_darts L) /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    uniq r /\ ~(r = []) /\
    MEM x r /\ next_el r x = f_list L x ==> MEM x (MAP LAST (parts L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "u");
  PROOF_BY_CONTR_TAC THEN RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM]);
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[NOT_FORALL_THM];
  INTRO_TAC parts_flatten [`L`;`r`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `MEM u (flatten (parts L r))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `l` EXISTS_TAC;
  ASM_REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `u` EXISTS_TAC;
  DISCH_THEN MP_TAC THEN ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`u`];
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.next_el_parts_unlast [`L`;`r`;`l`;`u`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let next_el_core_list_pairs = prove_by_refinement(
  `!L N r u1 v1.
    good_list L /\
    good_list_nodes L /\
    normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            MEM r N /\
            all uniq L /\
    uniq (core L r) /\
    MEM u1 (core L r) /\
    next_el (core L r) u1 = v1 ==>
    MEM (u1,v1) (list_pairs (core L r))
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC list_pairs_core;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  GMATCH_SIMP_TAC f_list_imp_last;
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.mem_core [`L`;`r`;`u1`] THEN ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `MEM u1 (MAP FST (flatten (parts L r)))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "u");
  TYPIFY `l` (RENAME_TAC "p");
  INTRO_TAC normal_list_parts_next_last [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  TYPIFY `FST u = FST (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (LAST p) r /\ MEM (LAST p) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_flatten;parts_flatten]);
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  TYPIFY `v1 = SND (LAST p)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[GSYM PAIR];
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC f_list_fst_snd [`L`;`LAST p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  INTRO_TAC More_lemma_e.next_core_FST_SYM [`L`;`N`;`r`;`LAST p`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let filter_prebatch0  = prove_by_refinement(
  `!f0 L N r x. MAP (filter isSome) (prebatch f0 L N r x 0) = []`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[prebatch0;MAP])
  ]);;
  (* }}} *)

let flatten_filter = prove_by_refinement(
  `!s f. flatten (MAP (filter f) s) = filter f (flatten s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MAP_EQ_NIL;Seq.flatten0;Seq.filter;MAP];
  BY(ASM_REWRITE_TAC[Seq.flatten_cons;Seq.filter_cat])
  ]);;
  (* }}} *)

let filter_prebatch_batch = prove_by_refinement(
  `!f0 L N r x i. flatten(MAP (filter isSome) (prebatch f0 L N r x i)) = 
    filter (isSome) (batch0 f0 L N r x i)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM prebatch_batch;flatten_filter])
  ]);;
  (* }}} *)

let filter_nseq = prove_by_refinement(
  `!n f x. filter f (nseq n x) = if (f x) then nseq n x else []`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[nseq0;nseq_suc;Seq.filter_nil;Seq.filter_cons];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let filter_prebatch1 = prove_by_refinement(
  `!FST_f L N r x.
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
            is_restricted (hypermap_of_list L) /\
            0 < transform_count L N r x
            ==> MAP (filter isSome) (prebatch FST_f L N r x 1) =
                [ [SOME (FST (ytrans L N r x 0)) ; SOME (FST (ztrans L N r x 0))]]`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC prebatch1 [`FST_f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REWRITE_TAC[MAP;Seq.filter_cat;Seq.filter_cons;Seq.filter_nil;Ssrbool.isSome;filter_nseq;Seq.cat0s;CONS_11];
  BY(REWRITE_TAC[Seq.cat1s])
  ]);;
  (* }}} *)

let dest_triple_full_prebatch = 0;;

let dest_triple0_prebatch = prove_by_refinement(
  `!L N r (x:A#A) i.
    dest_triple0 (core L r) [] (take i (core_triple_v4 L N r x)) = 
    flatten (prebatch (core L r) L N r x i)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[prebatch];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM Reduction3.dest_triple0_foldl_steps);
  BY(REWRITE_TAC[Seq.flatten0])
  ]);;
  (* }}} *)

let marked_list_uniq_core = prove_by_refinement(
  `!L N r x. 
    marked_list L N r x ==>
    uniq (core L r)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[marked_list;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all uniq` MP_TAC;
  REWRITE_TAC[quotient_list_core;GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let initial_prebatch_explicit = prove_by_refinement(
  `!i L N r (x:A#A).
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\ 
     i < transform_count L N r x ==>    
     (let initial_seg =
         (if ftrans L N r x 0 = FST (ytrans L N r x 0)
          then []
          else SOME (SND x) ::
               MAP SOME (betwn (core L r) (ftrans L N r x 0) (FST (ytrans L N r x 0)))) in
     cat initial_seg (flatten (prebatch (core L r) L N r x (SUC i))) =  SOME (SND x) ::
     (flatten
     (MAP
      (\i. cat
           (if ftrans L N r x i = FST (ytrans L N r x i)
            then []
            else cat
                 (MAP SOME
                 (betwn (core L r) (ftrans L N r x i)
                 (FST (ytrans L N r x i))))
                 [SOME (FST (ytrans L N r x i))])
           (cat
            (nseq
             (sizel
             (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))
            NONE)
           [SOME (ftrans L N r x (SUC i))]))
     (iota 0 (SUC i)))))`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[prebatch1;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[Seq.iota;MAP;Aq1.flatten_sing;ftrans;arith `~(SUC 0 = 0)`];
    REWRITE_TAC[arith `SUC 0 = 1`];
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC prebatch1;
    ASM_REWRITE_TAC[arith `0 < k <=> ~(k = 0)`];
    ASM_SIMP_TAC[Reduction3.transform_count_non0];
    REWRITE_TAC[LET_THM;arith `PRE 1 = 0`];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat0s;Seq.flatten_cat;Aq1.flatten_sing;Seq.cat_cons;CONS_11];
    REWRITE_TAC[GSYM Seq.catA];
    AP_TERM_TAC;
    BY(REWRITE_TAC[Seq.cat1s]);
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  GMATCH_SIMP_TAC prebatch_suc_explicit;
  ASM_REWRITE_TAC[arith `0 < SUC i`];
  CONJ_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[marked_list_uniq_core]);
    CONJ_TAC;
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `MEM (ytrans L N r x i') r` ENOUGH_TO_SHOW_TAC;
        BY(ASM_MESON_TAC[ Reduction4.final_assumption_mem_fst_core]);
      MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
      ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
      MATCH_MP_TAC Kbwpbhq.transform_count_not;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM (ztrans L N r x i') r` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[ Reduction4.final_assumption_mem_fst_core]);
    MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
    ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
    BY(ASM_SIMP_TAC[ Kbwpbhq.transform_count_not]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[arith `SUC i < k ==> i < k`];
  REWRITE_TAC[LET_THM];
  SIMP_TAC[Seq.flatten_cat;Seq.catA];
  DISCH_THEN kill;
  REWRITE_TAC[arith `SUC (SUC i) = SUC i +1`;Seq.iota_add];
  TYPIFY `iota (0 + SUC i) 1 = [SUC i]` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[arith `1 = SUC 0 `;Seq.iota;CONS_11];
    BY(ARITH_TAC);
  REWRITE_TAC[lower_case;Seq.map_cat;Seq.map_cons;Seq.map];
  REWRITE_TAC[Aq1.flatten_sing;Seq.cat_cons;CONS_11;Seq.flatten_cat;ftrans;arith `PRE(SUC n) = n`];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[arith `~(SUC (SUC i) = 0)`];
  BY(REWRITE_TAC[arith `~(SUC (SUC i) = 0)`;arith `~(SUC i = 0)`])
  ]);;
  (* }}} *)

let initial_prebatch_explicit_scroll = prove_by_refinement(
  `!i L N r (x:A#A). 
       good_list L /\
     good_list_nodes L /\
     marked_list L N r x /\
     ~final_list L r /\
     is_restricted (hypermap_of_list L) /\
     i < transform_count L N r x
     ==> (SOME (SND x) ::
          flatten
          (MAP
           (\i. cat
                (if ftrans L N r x i = FST (ytrans L N r x i)
                 then []
                 else cat
                      (MAP SOME
                      (betwn (core L r) (ftrans L N r x i)
                      (FST (ytrans L N r x i))))
                      [SOME (FST (ytrans L N r x i))])
                (cat
                 (nseq
                  (sizel
                  (betwn (find_face L x) (ytrans L N r x i)
                  (ztrans L N r x i)))
                 NONE)
                [SOME (ftrans L N r x (SUC i))]))
          (iota 0 (SUC i)))) =
         rcons
         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (SUC i))))
         (SOME (ftrans L N r x (SUC i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC scroll_flatten_map [`SUC i`;`0`;`\i. cat               (if ftrans L N r x i = FST (ytrans L N r (x:A#A) i)                then []                else cat                     (MAP SOME                     (betwn (core L r) (ftrans L N r x i)                     (FST (ytrans L N r x i))))                     [SOME (FST (ytrans L N r x i))])               (                (nseq                 (sizel                 (betwn (find_face L x) (ytrans L N r x i)                 (ztrans L N r x i)))                NONE)               )`;`\i. SOME (ftrans L N r (x:A#A) i)`];
  ASM_REWRITE_TAC[arith `0 + i = i`];
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[ftrans;CONS_11];
  AP_TERM_TAC;
  REWRITE_TAC[Tame_list.map_id_eq];
  REWRITE_TAC[GSYM Seq.allP];
  BY(REWRITE_TAC[GSYM Seq.cats1;Seq.catA])
  ]);;
  (* }}} *)

let initial_prebatch_explicit2 = prove_by_refinement(
  `!i L N r (x:A#A).
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\ 
     i < transform_count L N r x ==>    
     (let initial_seg =
         (if ftrans L N r x 0 = FST (ytrans L N r x 0)
          then []
          else SOME (SND x) ::
               MAP SOME (betwn (core L r) (ftrans L N r x 0) (FST (ytrans L N r x 0)))) in
     cat initial_seg (flatten (prebatch (core L r) L N r x (SUC i))) =  
         rcons
         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (SUC i))))
         (SOME (ftrans L N r x (SUC i))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN LET_TAC;
  INTRO_TAC initial_prebatch_explicit [`i`;`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM];
  SIMP_TAC[LET_THM];
  DISCH_THEN kill;
  MATCH_MP_TAC initial_prebatch_explicit_scroll;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple_full_explicit = prove_by_refinement(
  `!L N r x k. 
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    transform_count L N r x = k /\
    (?w. prev_el (core L r) w,w = x) /\
    is_restricted (hypermap_of_list L)  ==>
      dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x) =
         cat (         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (k)))))  ((SOME (FST (ztrans L N r x (PRE k)))):: 
	   if FST (ztrans L N r x (PRE k)) = FST x then [] else
				 rcons (MAP SOME (betwn (core L r) (FST (ztrans L N r x (PRE k)) ) (FST x))) (SOME (FST x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple_full;dest_triple0_prebatch];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  INTRO_TAC dest_triple0_prebatch [`L`;`N`;`r`;`x`;`k`];
  TYPIFY `take k (core_triple_v4 L N r x) = core_triple_v4 L N r x` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC Seq.take_oversize;
    BY(ASM_REWRITE_TAC[size_core_triple;arith `k <= k:num`]);
  SIMP_TAC[] THEN DISCH_THEN kill;
  TYPIFY `flatten [initial_seg; flatten (prebatch (core L r) L N r x k); final_seg] = cat (cat (initial_seg) (flatten (prebatch (core L r) L N r x (SUC (PRE k))))) final_seg` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[Seq.flatten_cons;Seq.catA;Seq.flatten0;Seq.cats0];
    BY(ASM_SIMP_TAC[arith `~(k=0) ==> SUC (PRE k) = k`]);
  INTRO_TAC initial_prebatch_explicit2 [`PRE k`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[arith `~(k=0) ==> PRE k < k`];
  LET_TAC;
  INTRO_TAC Reduction3.el_core_triple [`L`;`N`;`r`;`x`;`0`];
  ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`;EL;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `u` (FULL_LEFT_EXPAND_TAC);
  TYPIFY `initial_seg = initial_seg'` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "initial_seg";
    FULL_EXPAND_TAC "initial_seg'";
    BY(REWRITE_TAC[ftrans]);
  FULL_EXPAND_TAC "initial_seg'";
  FIRST_X_ASSUM_ST `rcons` SUBST1_TAC;
  ASM_SIMP_TAC[arith `~(k=0) ==> SUC (PRE k) = k`];
  REWRITE_TAC[GSYM Seq.cats1;GSYM Seq.catA];
  AP_TERM_TAC;
  REWRITE_TAC[Seq.cat1s;CONS_11];
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[ftrans]);
  FULL_EXPAND_TAC "final_seg";
  TYPIFY `v' = FST (ztrans L N r x (PRE k)) /\ u0 = FST x` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    BY(REWRITE_TAC[Seq.cats1]);
  (FULL_EXPAND_TAC "u0");
  CONJ2_TAC;
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[]);
  INTRO_TAC  last_core_triple [`L`;`N`;`r`;`x`;`PRE k`];
  BY(ASM_SIMP_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let COND_RAND2 = prove_by_refinement(
  `!f b x y. f (if b then x else y) = (if b then f x else f y)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let filter_isSome_map = prove_by_refinement(
  `!xs. filter isSome (MAP SOME xs) = (MAP SOME xs)`,
  (* {{{ proof *)
  [
      REWRITE_TAC[Seq.all_filterP;GSYM Seq.allP;Ssrbool.isSome;MEM_MAP];
  BY(MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

let filter_issome_dest_triple_full = prove_by_refinement(
  `!L N r (x:A#A) k.
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
         (?w. prev_el (core L r) w,w = x) /\
         is_restricted (hypermap_of_list L)
         ==> MAP the (filter isSome (dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x))) =
             cat
             (flatten
             (MAP
              (\i.  (ftrans L N r x i) ::
                   (if ftrans L N r x i = FST (ytrans L N r x i)
                    then []
                    else cat
                         (
                         (betwn (core L r) (ftrans L N r x i)
                         (FST (ytrans L N r x i))))
                         [ (FST (ytrans L N r x i))])
                   )
             (iota 0 k)))
             ( (FST (ztrans L N r x (PRE k))) ::
              (if FST (ztrans L N r x (PRE k)) = FST x
               then []
               else rcons
                    (
                    (betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))
                    ( (FST x))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dest_triple_full_explicit [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC COND_RAND2 [`filter (isSome: (A)option -> bool)`];
  SIMP_TAC[filter_isSome_map;Seq.filter_cat;Seq.filter_cons;Ssrbool.isSome;GSYM Seq.cats1;Seq.filter_nil;GSYM flatten_filter;GSYM MAP_o];
  DISCH_TAC;
  REWRITE_TAC[Seq.map_cat;lower_case;the_some;Seq.map];
  REWRITE_TAC[Seq.map_MAP;Tame_list.MAP_flatten];
  MATCH_MP_TAC Reduction2.cat_eq;
  REWRITE_TAC[CONS_11];
  INTRO_TAC COND_RAND2 [`(MAP the): ((A)option)list -> (A)list`];
  SIMP_TAC[MAP];
  DISCH_TAC;
  CONJ2_TAC;
    AP_TERM_TAC;
    REWRITE_TAC[lower_case;Seq.map_cat;Seq.map;the_some];
    REWRITE_TAC[Seq.map_MAP;GSYM MAP_o];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    MATCH_MP_TAC MAP_EQ_DEGEN;
    REWRITE_TAC[the_some;o_THM];
    BY(REWRITE_TAC[lower_case;GSYM Seq.allP]);
  AP_TERM_TAC;
  REWRITE_TAC[GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[o_THM;Seq.filter_cat;Seq.filter_cons;Ssrbool.isSome;MAP;the_some;CONS_11;Seq.filter_nil];
  ASM_SIMP_TAC[lower_case;Seq.map_cat];
  ASM_SIMP_TAC[Seq.map_MAP;MAP;ftrans];
  REWRITE_TAC[filter_nseq;Ssrbool.isSome;MAP;Seq.cats0];
  AP_TERM_TAC;
  REWRITE_TAC[lower_case;Seq.map_cat];
  REWRITE_TAC[lower_case;Seq.map_cat;Seq.map;the_some];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  TYPED_ABBREV_TAC `b = (betwn (core L r) (if x' = 0 then SND x else FST (ztrans L N r x (PRE x'))) (FST (ytrans L N r x x')))`;
  REWRITE_TAC[filter_isSome_map;Seq.map_MAP;GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ_DEGEN;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP];
  BY(REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP;o_THM;the_some])
  ]);;
  (* }}} *)

let uniq_el = prove_by_refinement(
  `!i j s. uniq s /\ i < sizel s /\ j < sizel s /\ ~(i = j) ==> ~(EL i s = EL j s)`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.nth_uniq;Seq2.EL_nth])
  ]);;
  (* }}} *)

let indexf_subseg = prove_by_refinement(
  `!v s t a b i.  s = cat (cat a t) b /\  (MEM v t ==> v = EL 0 t) /\ 
    uniq s /\ MEM v s /\
    SUC i < sizel t ==> SUC (indexf v (EL i t) s) = indexf v (EL (SUC i) t) s
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexf v (EL i t) s + indexf (EL i t) (EL (SUC i) t) s = indexf v (EL (SUC i) t) s /\ indexf (EL i t) (EL (SUC i) t) s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  TYPIFY `i < sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM (EL i t) t /\ MEM (EL (SUC i) t) t` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT (GMATCH_SIMP_TAC mem_el_index);
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ2_TAC;
    MATCH_MP_TAC Tame_list.next_el_indexf;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 3;
      REWRITE_TAC[Seq.size_cat];
      BY(ASM_TAC THEN ARITH_TAC);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC next_el_cat1;
    GMATCH_SIMP_TAC next_el_cat2;
    GMATCH_SIMP_TAC next_el_el;
    GMATCH_SIMP_TAC last_cat;
    GMATCH_SIMP_TAC LAST_EL THEN REWRITE_TAC[lower_case;GSYM Seq.size_eq0];
    ASM_REWRITE_TAC[Seq.mem_cat];
    GMATCH_SIMP_TAC uniq_el;
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN ASM_REWRITE_TAC[Seq.cat_uniq];
    ASM_SIMP_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  MATCH_MP_TAC Tame_list.indexf_add_right;
  ASM_SIMP_TAC[arith `1 <= n <=> ~(n=0)`];
  INTRO_TAC Tame_list.indexf0 [`v`;`EL (SUC i) t`;`s`];
  ASM_SIMP_TAC[Seq.mem_cat];
  REPEAT (GMATCH_SIMP_TAC mem_el_index);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  BY(ASM_MESON_TAC[arith `~(0 = SUC i)`;uniq_el;arith `i < n ==> 0 < n`])
  ]);;
  (* }}} *)

let indexf_subseg_rot = prove_by_refinement(
  `!v s n t a b i.  rot n s = cat (cat a t) b /\  (MEM v t ==> v = EL 0 t) /\ 
    uniq s /\ MEM v s /\
    SUC i < sizel t ==> SUC (indexf v (EL i t) s) = indexf v (EL (SUC i) t) s
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_subseg [`v`;`rot n s`;`t`;`a`;`b`;`i`];
  REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT (GMATCH_SIMP_TAC (GSYM Reduction2.indexf_rotn_alt));
  ASM_SIMP_TAC[];
  TYPIFY `?n'. s = rot n' (cat (cat a t) b)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[ Tame_list.rot_sym]);
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Seq.mem_cat;Seq.mem_rot];
  REPEAT (GMATCH_SIMP_TAC mem_el_index);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let uniq_tl = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> uniq (TL s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC CONS_HD_TL [`s`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  TYPIFY `uniq (cat [HD s] (TL s))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.cat1s]);
  BY(MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let post_betwn = prove_by_refinement(
  `!x y s. HD s = x /\ MEM y s /\ ~(x = y) /\ uniq s ==>
    (?post. s = x:: cat (rcons (betwn s x y) y) post)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn];
  REPEAT WEAKER_STRIP_TAC THEN REPEAT LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(s=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  TYPIFY `MEM x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_HD]);
  INTRO_TAC (GEN_ALL Pwssrat.take_index_fst_split) [`x`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `indexl x s = 0` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[Pplhulj.indexl_hd]);
  ASM_REWRITE_TAC[Seq.take];
  DISCH_TAC THEN FULL_EXPAND_TAC "pre1";
  INTRO_TAC (GEN_ALL Pwssrat.dropl_index_snd_split) [`x`;`s`];
  ASM_REWRITE_TAC[Seq.drop];
  DISCH_TAC THEN FULL_EXPAND_TAC "post1";
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  INTRO_TAC tl_drop [`s`] THEN ASM_SIMP_TAC[];
  DISCH_TAC THEN TYPIFY `dropl 1 s` FULL_RIGHT_EXPAND_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC (GEN_ALL Pwssrat.take_index_fst_split) [`y`;`TL s`];
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[uniq_tl];
    DISCH_THEN (SUBST1_TAC o GSYM);
    TYPIFY `dropl (1+indexl y (TL s)) ((TL s))` EXISTS_TAC;
    REWRITE_TAC[GSYM Seq.cats1;GSYM Seq.catA];
    TYPIFY `TL s = cat (take (indexl y (TL s)) (TL s))  (cat [y] (dropl (1 + indexl y (TL s)) (TL s)))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[CONS_HD_TL]);
    REWRITE_TAC[Seq.catA];
    TYPIFY `(cat (take (indexl y (TL s)) (TL s)) [y]) = take (1 + indexl y (TL s)) (TL s)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[Seq.cat_take_drop]);
    REWRITE_TAC[arith `1 + n = SUC n`];
    GMATCH_SIMP_TAC Reduction3.take_el;
    REWRITE_TAC[GSYM Seq.cats1];
    SUBCONJ_TAC;
      REWRITE_TAC[Seq.index_mem];
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    AP_TERM_TAC;
    REWRITE_TAC[CONS_11];
    BY(ASM_SIMP_TAC[Seq2.EL_index]);
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[];
  BY(ASM_MESON_TAC[CONS_HD_TL;MEM])
  ]);;
  (* }}} *)

let indexf_ifbetwn = prove_by_refinement(
  `!s v (x:A) y i. MEM v s /\ MEM x s /\ MEM y s /\ uniq s /\ ~(MEM v (ifbetwn s x y)) /\
    SUC i < sizel (x:: ifbetwn s x y) ==>
    SUC (indexf v (EL i (x :: ifbetwn s x y)) s) = indexf v (EL (SUC i) (x::ifbetwn s x y)) s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexf_subseg_rot;
  TYPIFY `indexl x s` EXISTS_TAC;
  INTRO_TAC (GSYM Pwssrat.rotate_rot_indexl) [`x`;`s`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    ASM_REWRITE_TAC[ifbetwn;MEM;EL;HD];
    GEXISTL_TAC [`[]:(A)list`;`TL (rotate_to s y)`];
    REWRITE_TAC[Seq.cat0s;Seq.cat1s];
    TYPIFY `~(rotate_to s y = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[rot_eq_nil;List_hypermap.mem_not_nil]);
    BY(ASM_MESON_TAC[CONS_HD_TL;Tame_list.hd_rotate_to]);
  INTRO_TAC post_betwn [`x`;`y`;`rotate_to s x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[Tame_list.hd_rotate_to];
    BY(ASM_MESON_TAC[Seq.mem_rot;Seq.rot_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[MEM;EL;HD];
  ASM_REWRITE_TAC[ifbetwn];
  TYPIFY `[]:(A)list` EXISTS_TAC;
  REWRITE_TAC[Seq.cat0s];
  REWRITE_TAC[Seq.cat0s;Seq.cat_cons];
  TYPIFY `betwn (rotate_to s x) x y = betwn s x y` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Seq.index_size;Reduction2.betwn_rot])
  ]);;
  (* }}} *)

let mem_ftrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i <= transform_count L N r x ==>
    MEM ( (ftrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[ftrans];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC (GSYM More_lemma_e.FST_next_face_eq_SND);
    TYPIFY `L` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC mem_fst_core;
    GEXISTL_TAC [`N`;`x`];
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Aq1.next_mark_mem_r_trans_v0]);
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_snd_x_core = prove_by_refinement(
  `!L N r x.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r  ==>
    MEM (SND x) (core L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC mem_ftrans_core [`L`;`N`;`r`;`x`;`0`];
  REWRITE_TAC[ftrans;arith `0 < k <=> ~(k=0)`];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_fst_x_core = prove_by_refinement(
  `!L N r x.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r  ==>
    MEM ( (FST x )) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let mem_fst_ytrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i < transform_count L N r x ==>
    MEM (FST (ytrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_fst_ztrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i < transform_count L N r x ==>
    MEM (FST (ztrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let marked_x_exists = prove_by_refinement(
  `!L N r (x:A#A).   
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r ==>
  (?w. prev_el (core L r) w,w = x)
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SND x` EXISTS_TAC;
  REWRITE_TAC[PAIR_EQ2];
  GMATCH_SIMP_TAC (GSYM More_lemma_e.FST_next_face_eq_SND);
  BY(ASM_MESON_TAC[More_lemma_e.prev_core_x])
  ]);;
  (* }}} *)

let filter_issome_dest_triple_full_alt = prove_by_refinement(
  `!L N r (x:A#A) k.
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
         is_restricted (hypermap_of_list L)
         ==> MAP the (filter isSome (dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x))) =
             cat
             (flatten
             (MAP
              (\i.  (ftrans L N r x i) :: ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))
             (iota 0 k)))
             ( (FST (ztrans L N r x (PRE k))) :: ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC filter_issome_dest_triple_full [`L`;`N`;`r`;`x`;`k`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_x_exists]);
  SIMP_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC Reduction2.cat_eq;
  INTRO_TAC mem_ftrans_core [`L`;`N`;`r`;`x`];
  INTRO_TAC mem_fst_ytrans_core [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!i. i < k ==> MEM (ftrans L N r x i) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `i < k ==> i <= k:num`]);
  CONJ_TAC;
    AP_TERM_TAC;
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[Seq2.ALL_all];
    REWRITE_TAC[GSYM Seq.allP] THEN REWRITE_TAC[Seq.mem_iota;CONS_11;arith `0 + k = k`] THEN REPEAT WEAKER_STRIP_TAC;
    ASM_SIMP_TAC[];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cats1]);
  REWRITE_TAC[CONS_11];
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `MEM (FST (ztrans L N r x (PRE k))) (core L r) /\     MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[mem_fst_x_core]);
    BY(ASM_MESON_TAC[mem_fst_ztrans_core;arith `~(k=0) ==> PRE k < k`]);
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let last_ifbetwn = prove_by_refinement(
  `!s x y. MEM y s /\ MEM x s ==> LAST (x:: ifbetwn s x y) = y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[ifbetwn];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[LAST;rcons_nonnil;LAST_rcons]);
  REWRITE_TAC[LAST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_assumption_uvns_vs'  = prove_by_refinement(
  `!L N r x k v.
     is_restricted (hypermap_of_list L) /\
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
    ~(MEM (SND x) ((ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))) /\
    (!i. i < k ==> // new
       ~MEM (SND x) (ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))) /\
    (!i. i < k ==>  // new
       indexf (SND x) (FST (ytrans L N r x i)) (core L r) < 
       indexf (SND x) (FST (ztrans L N r x i)) (core L r)) /\
	  (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r))
		`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  TYPED_ABBREV_TAC `mtf = (MAP the     (filter isSome (dest_triple_full (core L r) v (core_triple_v4 L N r x))))`;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM filter_issome_dest_triple_full_alt) [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  TYPIFY `SND x = v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ marked_x_exists ;PAIR;FST;SND]);
  ASM_SIMP_TAC[];
  FIRST_X_ASSUM_ST `dest_triple_full` kill;
  DISCH_TAC;
  COMMENT "mem";
  TYPIFY `MEM v (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_snd_x_core]);
  TYPIFY `(!i. i <= k ==> MEM (ftrans L N r x i) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_ftrans_core]);
  TYPIFY `(!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_ytrans_core]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_x_core]);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `PRE k < k` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  INTRO_TAC el_cat_suc [`i`;`(flatten      (MAP       (\i. ftrans L N r x i ::            ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))      (iota 0 k)))`;`(FST (ztrans L N r x (PRE k)) ::       ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))`];
  ASM_SIMP_TAC[NOT_CONS_NIL];
  DISCH_THEN DISJ_CASES_TAC;
    POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    INTRO_TAC el_flatten [`(MAP  (\i. ftrans L N r x i ::       ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))) (iota 0 k))`;`j`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      REWRITE_TAC[GSYM Seq.allP;MEM_MAP];
      REPEAT WEAKER_STRIP_TAC;
      BY(FIRST_X_ASSUM_ST `ftrans` (MP_TAC o GSYM) THEN ASM_REWRITE_TAC[NOT_CONS_NIL]);
    DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
      MATCH_MP_TAC (arith `SUC i = j ==> i < j`);
      FIRST_X_ASSUM_ST `MEM` (MP_TAC o REWRITE_RULE[Seq.mem_iota;MEM_MAP;arith `0 + k = k`;arith `0 <= i`]);
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `r'` FULL_LEFT_EXPAND_TAC;
      MATCH_MP_TAC indexf_ifbetwn;
      ASM_SIMP_TAC[];
      BY(ASM_MESON_TAC[arith `i < j ==> i <= j:num`]);
    REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_REWRITE_TAC[lower_case;Seq.size_iota];
    REPEAT (GMATCH_SIMP_TAC Tame_list.el_iota);
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC last_ifbetwn;
    REWRITE_TAC[arith `0 + j = j`];
    TYPIFY `SUC j' < k /\ j' < k` (C SUBGOAL_THEN ASSUME_TAC);
      FIRST_X_ASSUM_ST `SUC j' < l` MP_TAC THEN REWRITE_TAC[Seq.size_map;Seq.size_iota;lower_case];
      BY(ARITH_TAC);
    ASM_SIMP_TAC[arith `SUC j' < k ==> j' <= k`];
    ASM_SIMP_TAC[ftrans;arith `~(SUC j = 0) /\ PRE (SUC j) = j`];
    BY(ASM_MESON_TAC[]);
  COMMENT "next case";
  POP_ASSUM (DISJ_CASES_TAC) THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    MATCH_MP_TAC (arith `SUC i = j ==> i < j`);
    MATCH_MP_TAC indexf_ifbetwn;
    ASM_SIMP_TAC[];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM_ST `ftrans` (C INTRO_TAC [`k`]) THEN REWRITE_TAC[ftrans];
    BY(ASM_SIMP_TAC[arith `k <= k:num`]);
  COMMENT "last case";
  GMATCH_SIMP_TAC Aq23.LAST_FLATTEN_2;
  REWRITE_TAC[MAP_EQ_NIL;HD];
  GMATCH_SIMP_TAC LAST_EL;
  REWRITE_TAC[MAP_EQ_NIL;GSYM Seq.size;REWRITE_RULE[Seq.map_MAP] Seq.size_map;Seq.size_iota];
  REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN REWRITE_TAC[GSYM Seq.size;Seq.size_iota];
  GMATCH_SIMP_TAC last_ifbetwn;
  REWRITE_TAC[NOT_CONS_NIL];
  REPEAT (GMATCH_SIMP_TAC el_iota);
  REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  ASM_SIMP_TAC[arith `~(k=0) ==> k - 1 < k`;arith `~(k=0) ==> 0 + k - 1 = PRE k`;arith `PRE k <= k`];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)





UNFINISHED;;

