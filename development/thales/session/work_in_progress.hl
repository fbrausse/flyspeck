
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;

(*    *)


(* ............... NEW DEFS *)

(* ********************************************************************** *)
(* SIZE_VS LEMMAS *)
(* ********************************************************************** *)

let size_initial_seg = prove_by_refinement(
  `!f u v s.
    MEM v (f) /\ MEM u (f) /\ uniq f /\
          s = (if v = u then [] else SOME v :: MAP SOME (betwn f v u))
  ==> sizel s = indexf v u (f)`,
  (* {{{ proof *)
  [
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Tame_list.indexf_refl;Seq.size_nil]);
  REWRITE_TAC[Seq.size_cons;Seq.size_map;lower_case];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  TYPIFY `~(indexf v u f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Tame_list.indexf0])
  ]);;
  (* }}} *)

let size_term_seg = prove_by_refinement(
  `!f v' u0 s.
    MEM v' (f) /\ MEM u0 (f) /\ uniq f /\
          s = (if v' = u0
               then []
               else rcons (MAP SOME (betwn f v' u0)) (SOME u0))
  ==> sizel s = indexf v' u0 (f)`,
  (* {{{ proof *)
  [
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Tame_list.indexf_refl;Seq.size_nil]);
  REWRITE_TAC[Seq.size_rcons;Seq.size_map;lower_case];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  TYPIFY `~(indexf v' u0 f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Tame_list.indexf0])
  ]);;
  (* }}} *)

let size_dest_triple0_nil = prove_by_refinement(
  `!f s . sizel (dest_triple0 f s []) = sizel s`,
  (* {{{ proof *)
  [
  rt[dest_triple0]
  ]);;
  (* }}} *)

let dest_triple0_cat = prove_by_refinement(
  `!uvns f s s' . ~(s' = []) ==> dest_triple0 f (cat s s') uvns = cat s (dest_triple0 f s' uvns)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(ASM_REWRITE_TAC[dest_triple0]);
  REPEAT WEAKER_STRIP_TAC THEN REWRITE_TAC[dest_triple0] THEN REPEAT LET_TAC;
  TYPIFY `u0 = u0'` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u0";
    FULL_EXPAND_TAC "u0'";
    AP_TERM_TAC;
    BY(ASM_SIMP_TAC[Tame_list.last_cat]);
  FULL_EXPAND_TAC "u0'";
  TYPIFY `b = b'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "b'";
  ASM_REWRITE_TAC[Tame_list.cat_eq_nil];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `flatten [cat s s';ns;[SOME v]] = cat s (flatten [s';ns;[SOME v]])` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `flatten [cat s s'; [SOME u]; ns; [SOME v]] = cat s (flatten [s'; [SOME u]; ns; [SOME v]])` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  TYPIFY `flatten [cat s s'; b; [SOME u]; ns; [SOME v]] = cat s (flatten [s'; b; [SOME u]; ns; [SOME v]])` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC])
  ]);;
  (* }}} *)

let size_dest_triple0_cons = prove_by_refinement(
  `!f u v n uvns.  MEM u f /\ MEM v f ==>
     sizel (dest_triple0 f [] ((u,v,n)::uvns)) = 
      SUC n + sizel (dest_triple0 f [SOME v] uvns)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  TYPIFY `flatten [[]; [SOME u]; ns; [SOME v]] = cat (APPEND [SOME u] ns) [SOME v]` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  GMATCH_SIMP_TAC dest_triple0_cat;
  REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat];
  REWRITE_TAC[lower_case;Seq.size_cat];
  FULL_EXPAND_TAC "ns";
  REWRITE_TAC[Seq.size_nseq;Seq2.size1];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let size_dest_triple0_cons2 = prove_by_refinement(
  `!f u v w n uvns. uniq f /\ 1 < sizel f /\  MEM u f /\ MEM v f /\  MEM w f ==>
     sizel (dest_triple0 f [SOME w] ((u,v,n)::uvns)) = 
      SUC n + indexf w u f + sizel (dest_triple0 f [SOME v] uvns)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  REWRITE_TAC[LAST;the_some];
  DISCH_TAC THEN FULL_EXPAND_TAC "u0";
  TYPIFY `sizel ns = n` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "ns";
    BY(REWRITE_TAC[Seq.size_nseq]);
  REWRITE_TAC[Tame_list.concat_flatten;APPEND_ASSOC;APPEND_NIL];
  REWRITE_TAC[lower_case];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC dest_triple0_cat;
    ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
    BY(ASM_SIMP_TAC[indexf_refl] THEN ARITH_TAC);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC dest_triple0_cat;
    ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
    GMATCH_SIMP_TAC Tame_list.next_el_indexf;
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  GMATCH_SIMP_TAC dest_triple0_cat;
  ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
  TYPIFY `sizel b = indexf w u f - 1 /\ ~(indexf w u f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  FULL_EXPAND_TAC "b";
  REWRITE_TAC[lower_case;Seq.size_map];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  SUBCONJ2_TAC;
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)
