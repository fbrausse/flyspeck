
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;

module Work_in_progress = struct
end;;

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;


(* ********************************************************************* *)
(* UVNS  *)
(* ********************************************************************* *)

let filter_prebatch0  = prove_by_refinement(
  `!f0 L N r x. MAP (filter isSome) (prebatch f0 L N r x 0) = []`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[prebatch0;MAP])
  ]);;
  (* }}} *)

let flatten_filter = prove_by_refinement(
  `!s f. flatten (MAP (filter f) s) = filter f (flatten s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MAP_EQ_NIL;Seq.flatten0;Seq.filter;MAP];
  BY(ASM_REWRITE_TAC[Seq.flatten_cons;Seq.filter_cat])
  ]);;
  (* }}} *)


let filter_prebatch_batch = prove_by_refinement(
  `!f0 L N r x i. flatten(MAP (filter isSome) (prebatch f0 L N r x i)) = 
    filter (isSome) (batch0 f0 L N r x i)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM prebatch_batch;flatten_filter])
  ]);;
  (* }}} *)

let filter_nseq = prove_by_refinement(
  `!n f x. filter f (nseq n x) = if (f x) then nseq n x else []`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[nseq0;nseq_suc;Seq.filter_nil;Seq.filter_cons];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let filter_prebatch1 = prove_by_refinement(
  `!FST_f L N r x.
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
            is_restricted (hypermap_of_list L) /\
            0 < transform_count L N r x
            ==> MAP (filter isSome) (prebatch FST_f L N r x 1) =
                [ [SOME (FST (ytrans L N r x 0)) ; SOME (FST (ztrans L N r x 0))]]`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC prebatch1 [`FST_f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REWRITE_TAC[MAP;Seq.filter_cat;Seq.filter_cons;Seq.filter_nil;Ssrbool.isSome;filter_nseq;Seq.cat0s;CONS_11];
  BY(REWRITE_TAC[Seq.cat1s])
  ]);;
  (* }}} *)

let filter_prebatch_suc_explicit = prove_by_refinement(
  `!i FST_f L N r x. good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
            is_restricted (hypermap_of_list L) /\
            uniq FST_f /\
            (!i. i < transform_count L N r x
                 ==> MEM (FST (ytrans L N r x i)) FST_f) /\
            (!i. i < transform_count L N r x
                 ==> MEM (FST (ztrans L N r x i)) FST_f) /\
            0 < i /\
            i < transform_count L N r x
            ==> MAP (filter isSome) (prebatch FST_f L N r x (SUC i)) =
		
                cat ((MAP (filter isSome) (prebatch FST_f L N r x i)))
                ([MAP SOME (cat
                 (if FST (ztrans L N r x (PRE i)) = FST (ytrans L N r x i)
                  then []
                  else cat
                       (
                       (betwn FST_f (FST (ztrans L N r x (PRE i)))
                       (FST (ytrans L N r x i))))
                       [ (FST (ytrans L N r x i))])
                 [(FST (ztrans L N r x i))])])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC prebatch_suc_explicit [`i`;`FST_f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  rt[lower_case;Seq.map_cat]
  apterm

xxd
  REWRITE_TAC[MAP;lower_case;Seq.map_cat;Seq.filter_cat;Seq.filter_cons;Seq.filter_nil;Ssrbool.isSome;filter_nseq;Seq.cat0s;CONS_11];
  BY(REWRITE_TAC[Seq.cat1s])

  #
  ]);;
  (* }}} *)



UNFINISHED;;




(*
let final_assumption_? = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
    (!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)))

`,
  (* {{{ proof *)
  [
  st/r
  rt[dest_triple_full]
  repeat LET_TAC
  fxast `HD` mp then repeat LET_TAC
  fexp "vs'"
  rt[Seq.flatten_cons;Seq.flatten0]
  gm dest_triple0_foldl_steps

  #
  ]);;
  (* }}} *)
*)


(* assumption needed by final_assumption_yz_in_core *)

let mem_z0_ri = prove_by_refinement(
  `!i L N r x k.
         good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
    (i < k) /\
     (transform_count L N r x = k) ==>
    MEM (ztrans L N r x 0) (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  INDUCT_TAC then rt[]
  st/r
  amt[Pwssrat.mem_ztrans_rtrans;Reduction2.transform_assumption_v2_lemma;Reduction2.trans0]
  st/r
  intro Pwssrat.PWSSRAT [`L`;`N`;`r`;`x`;`ztrans L N r x 0`;`i`]
  asimp[Reduction2.transform_assumption_v2_lemma;]
  rt[arith `SUC i = 1+i`]
  rt[trans_add]
  dthen gm
  conj
  conj
  fxa mmp
  typ `k` ex then asimp[]
  asm then ARITH_TAC
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  asm then ARITH_TAC
  ...


  mmp xxd
  ]);;
  (* }}} *)
