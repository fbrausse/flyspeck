
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;


(* ............... NEW DEFS *)
(* ............... END NEW DEFS *)



1;;

(* DIHEDRAL IN A DAY *)

(* MOVE THESE *)

let fgraph_seed = prove_by_refinement(
  `!p. fgraph (Seed p) = [iota 0 (maxGon p);rev (iota 0 (maxGon p))]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;SEED;faces;graphl;LET_THM;GRAPH;MAP];
  BY(REWRITE_TAC[lower_case;upt0])
  ]);;
  (* }}} *)

let uniq_list_of_darts_seed = prove_by_refinement(
 `!p. uniq(list_of_darts(fgraph (Seed p)))`, 
  (* {{{ proof *)
  [
  REWRITE_TAC[SEED;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.cats0];
  REWRITE_TAC[Seq.cat_uniq];
  GEN_TAC;
  CONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[upt]; 
    BY(REWRITE_TAC[Seq.iota_uniq]);
  CONJ2_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[REVERSE_rev];
    REWRITE_TAC[Seq.rev_uniq];
    REWRITE_TAC[upt]; 
    BY(REWRITE_TAC[Seq.iota_uniq]);
  REWRITE_TAC[GSYM Seq.hasP];
  REWRITE_TAC[NOT_EXISTS_THM];
  GEN_TAC;
  REWRITE_TAC[TAUT `~(a /\ b) <=> (a ==> ~b)`];
  REWRITE_TAC[upt0;maxGon]; 
  TYPIFY `?i j. x = i,j` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[REVERSE_rev;Seq.mem_rev;list_pairs_iota];
  GMATCH_SIMP_TAC list_pairs_rev_iota;
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let all_nonempty_seed = prove_by_refinement(
  `!p. all (\l. ~(l = [])) (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[SEED;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.all];
  REWRITE_TAC[upt;maxGon];
  REWRITE_TAC[GSYM Seq.size_eq0;REVERSE_rev;Seq.size_rev];
  REWRITE_TAC[Seq.size_iota];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_transpose_seed = prove_by_refinement(
  `!p d. MEM d (list_of_darts (fgraph (Seed p))) ==> MEM (SND d,FST d) (list_of_darts (fgraph (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[SEED;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.mem_cat];
  REWRITE_TAC[upt;maxGon;REVERSE_rev];
  REPEAT GEN_TAC;
  TYPIFY_GOAL_THEN `(p+3)-0 = p+3` SUBST1_TAC;
    BY(ARITH_TAC);
  TYPIFY `?i j. d = (i,j)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[list_pairs_iota];
  REPEAT (GMATCH_SIMP_TAC list_pairs_rev_iota);
  REWRITE_TAC[MEM];
  REWRITE_TAC[arith `0 < p + 3 /\ (p+3)- 1 = p+2 /\ (i + 1 = p + 3 <=> i = p+ 2) /\ (i + 1 < p + 3 <=> i < p + 2)`];
  REPEAT STRIP_TAC;
        BY(ASM_TAC THEN ARITH_TAC);
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_REWRITE_TAC[]);
  DISJ1_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let good_list_seed = prove_by_refinement(
  `!p. good_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[List_hypermap.good_list;mem_transpose_seed;all_nonempty_seed;uniq_list_of_darts_seed])
  ]);;
  (* }}} *)

(* was elements_of_list_seed *)

let list_of_elements_seed = prove_by_refinement(
  `!p. list_of_elements (fgraph (Seed p)) = REVERSE (upt 0 (p+3))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[SEED;maxGon;graphl];
  GEN_TAC;
  REWRITE_TAC[LET_THM];
  REWRITE_TAC[fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.flatten_cons;Seq.cats0;Seq.flatten0];
  GMATCH_SIMP_TAC undup_cat;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.mem_rev;REVERSE_rev]);
  MATCH_MP_TAC Seq.undup_id;
  REWRITE_TAC[Seq.rev_uniq;REVERSE_rev];
  BY(REWRITE_TAC[upt0;Seq.iota_uniq])
  ]);;
  (* }}} *)

let good_vertices_set2_seed = prove_by_refinement(
  `!p. vertices_set2 (Seed p) = elements_of_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list;list_of_elements_seed];
  REWRITE_TAC[vertices_set2;SEED;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
  BY(MESON_TAC[Seq.mem_rev;REVERSE_rev])
  ]);;
  (* }}} *)

let all_uniq_seed = prove_by_refinement(
  `!p. all uniq (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;SEED;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[fgraph_graph];
  REWRITE_TAC[fgraph_graph;MAP;Seq.all];
  REWRITE_TAC[Seq.rev_uniq;REVERSE_rev];
  BY(REWRITE_TAC[upt0;Seq.iota_uniq])
  ]);;
  (* }}} *)

let good_facesAt_seed = prove_by_refinement(
  `!p. (!v. v IN vertices_set2 (Seed p)
        ==> facesAt (Seed p) v = FILTER (\f. MEM v (FST f)) (faces (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[good_vertices_set2_seed;List_hypermap.elements_of_list;IN_SET_OF_LIST;list_of_elements_seed];
  REWRITE_TAC[REVERSE_rev;Seq.mem_rev];
  REWRITE_TAC[vertices_set2;SEED;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[faces_graph];
  REWRITE_TAC[facesAt;FACE_LIST_AT];
  REWRITE_TAC[upt0];
  REWRITE_TAC[Seq.mem_iota] THEN REWRITE_TAC[arith `0 + n = n /\ 0 <= n`];
  SIMP_TAC[EL_REPLICATE];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[Seq.all_filterP;GSYM filter_FILTER];
  REWRITE_TAC[Seq.all;REVERSE_rev;Seq.mem_rev];
  BY(REWRITE_TAC[Seq.mem_iota] THEN REWRITE_TAC[arith `0 + n = n /\ 0 <= n`])
  ]);;
  (* }}} *)

let lemma_node_representation_eq = prove_by_refinement(
  `!H u. u IN node_set H <=> (?x. x IN dart H /\ u = node H x)`,
  (* {{{ proof *)
  [
BY(MESON_TAC[Hypermap.lemma_node_representation;Hypermap.lemma_in_hypermap_orbits])
  ]);;
  (* }}} *)

let INJ_EMPTY = prove_by_refinement(
  `!f:A->B Y. INJ f {} Y`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[INJ;NOT_IN_EMPTY])
  ]);;
  (* }}} *)

let uniq_inj_on = prove_by_refinement(
  `!u v. sizel u = sizel v /\ uniq u /\ uniq v ==>
   ?(f:A->B). inj_on f (set_of_list u) /\ v = MAP f u
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `f = (\(x:A). EL (indexl x u) v)`;
  TYPIFY `f` EXISTS_TAC;
  REWRITE_TAC[inj_on];
  REWRITE_TAC[IN_ELIM_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ2_TAC;
    FULL_EXPAND_TAC "f";
    ONCE_REWRITE_TAC[Packing3.LIST_EL_EQ];
    ASM_REWRITE_TAC[lower_case;Seq.size_map];
    TYPIFY `LENGTH u = LENGTH v` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[upper_case]);
    ASM_SIMP_TAC[upper_case;EL_MAP];
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC index_el;
    BY(ASM_MESON_TAC[upper_case]);
  DISCH_TAC;
  FULL_EXPAND_TAC "f";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl (EL (indexl x u) v) v = indexl (EL (indexl y u) v) v` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REPEAT (GMATCH_SIMP_TAC index_el);
  BY(ASM_MESON_TAC[index_uniq;Seq.index_mem])
  ]);;
  (* }}} *)

let set_of_list_rev = prove_by_refinement(
  `!u. set_of_list (rev u) = set_of_list u`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;Seq.mem_rev])
  ]);;
  (* }}} *)

let elements_of_list_pr = prove_by_refinement(
  `!u. elements_of_list [u;rev u] = set_of_list u`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup;concat_flatten;APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND;set_of_list_rev];
  BY(REWRITE_TAC[UNION_IDEMPOT])
  ]);;
  (* }}} *)

let iso_list_dih2k = prove_by_refinement(
  `!(L:((A)list)list) (L':((B)list)list). 
    dih2k_list L /\ dih2k_list L' /\ 
    sizel (HD L) = sizel (HD L') ==> iso_list (L,[]) (L',[])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;MAP;dih2k_list];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC uniq_inj_on [`u`;`u'`];
  FIRST_X_ASSUM MP_TAC THEN ASM_SIMP_TAC[HD];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f` EXISTS_TAC;
  ASM_REWRITE_TAC[elements_of_list_pr];
  REWRITE_TAC[MAP];
  BY(REWRITE_TAC[upper_case;MAP_REVERSE])
  ]);;
  (* }}} *)

let iso_list_imp_dih2k = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ dih2k_list L ==> dih2k_list L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;iso_list;MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP phi u` EXISTS_TAC;
  ASM_REWRITE_TAC[MAP;upper_case;MAP_REVERSE];
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `inj_on` MP_TAC THEN REWRITE_TAC[inj_on];
  ASM_REWRITE_TAC[elements_of_list_pr;IN_ELIM_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let dih2k_all_uniq = prove_by_refinement(
  `!L. dih2k_list L ==> all uniq L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[MEM];
  BY(REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[Seq.rev_uniq])
  ]);;
  (* }}} *)

let fgraph_seed = prove_by_refinement(
  `!p. fgraph (Seed p) = [iota 0 (maxGon p);rev (iota 0 (maxGon p))]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;fgraph;SEED;faces;graphl;LET_THM;GRAPH;MAP];
  BY(REWRITE_TAC[lower_case;upt0])
  ]);;
  (* }}} *)

let seed_dih2k = prove_by_refinement(
  `!p. dih2k_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph_seed;dih2k_list];
  GEN_TAC;
  TYPIFY `iota 0 (maxGon p)` EXISTS_TAC;
  BY(REWRITE_TAC[Seq.iota_uniq])
  ]);;
  (* }}} *)

let dih2k_0 = prove_by_refinement(
  `dih2k_list [([]:(A)list);[]]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;CONS_11];
  BY(MESON_TAC[Seq.nil_uniq;rev0])
  ]);;
  (* }}} *)

let dih2k_1 = prove_by_refinement(
  `!x:A. dih2k_list [[x];[x]]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;CONS_11];
  BY(MESON_TAC[rev1;Seq.rev_uniq;Seq.cons_uniq;Seq.nil_uniq;MEM])
  ]);;
  (* }}} *)

let rev2 = prove_by_refinement(
  `!x y. rev [x;y] = [y;x]`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[Seq.rev_cons];
  REWRITE_TAC[rev1];
  REWRITE_TAC[GSYM Seq.cats1];
  BY(REWRITE_TAC[GSYM Seq.cats1;Seq.cat1s])
  ]);;
  (* }}} *)

let dih2k_2 = prove_by_refinement(
  `!x:A y. ~(x = y) ==> dih2k_list [[x;y];[y;x]]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dih2k_list;CONS_11];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `[x;y]` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.cons_uniq;rev2];
  BY(ASM_REWRITE_TAC[MEM;Seq.nil_uniq])
  ]);;
  (* }}} *)

let dih2k_good_list = prove_by_refinement(
  `!L. 3 <= sizel (HD L) /\ dih2k_list L ==> good_list L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `p = sizel (HD L) - 3`;
  INTRO_TAC (* Dpzgbyf. *) good_list_seed [`p`];
  DISCH_TAC;
  INTRO_TAC seed_dih2k [`p`];
  DISCH_TAC;
  TYPIFY `sizel (HD (fgraph (Seed p))) = sizel (HD L)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[fgraph_seed;HD;Seq.size_iota;maxGon];
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC iso_list_dih2k [`fgraph (Seed p)`;`L`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[iso_list_good_list])
  ]);;
  (* }}} *)

let seed_good_list_nodes = prove_by_refinement(
  `!p. good_list_nodes (fgraph(Seed p))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `good_list (fgraph (Seed p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[good_list_seed]);
  POP_ASSUM MP_TAC;
  REWRITE_TAC[fgraph_seed;maxGon];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Tame_list.good_list_nodes_condition2;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (iota 0 (p+3)) /\ uniq (rev (iota 0 (p+3)))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Seq.iota_uniq;Seq.rev_uniq]);
  COMMENT "symmetry reduction";
  TYPIFY `!d d'. MEM d (list_pairs (iota 0 (p+3))) /\ MEM d' (list_pairs (rev (iota 0 (p+3)))) /\ (FST d = FST d') ==> d' IN (node (hypermap_of_list [iota 0 (p+3);rev (iota 0 (p+3))]) d)` ENOUGH_TO_SHOW_TAC;
    REWRITE_TAC[List_hypermap.list_of_darts_cons];
    REWRITE_TAC[Seq.mem_cat;MEM;List_hypermap.list_of_darts_nil];
    REPEAT STRIP_TAC;
          BY(ASM_MESON_TAC[list_pairs_unique;node_refl]);
        BY(ASM_MESON_TAC[]);
      BY(ASM_MESON_TAC[Hypermap.lemma_node_identity;node_refl]);
    BY(ASM_MESON_TAC[list_pairs_unique;node_refl]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d' = inverse (node_map (hypermap_of_list [iota 0 (p + 3); rev (iota 0 (p + 3))])) d` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    MATCH_MP_TAC Hypermap.lemma_inverse_in_node;
    BY(REWRITE_TAC[node_refl]);
  MATCH_MP_TAC list_pairs_unique;
  (TYPIFY `rev (iota 0 (p+3))` EXISTS_TAC);
  ASM_REWRITE_TAC[];
  CONJ2_TAC;
    INTRO_TAC List_hypermap.fst_node_hypermap_of_list [`[iota 0 (p + 3); rev (iota 0 (p + 3))]`;`d`];
    ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`(inverse      (node_map (hypermap_of_list [iota 0 (p + 3); rev (iota 0 (p + 3))]))     d)`]);
    ANTS_TAC;
      MATCH_MP_TAC Hypermap.lemma_inverse_in_node;
      BY(REWRITE_TAC[node_refl]);
    BY(MESON_TAC[]);
  GMATCH_SIMP_TAC inverse_node_map_list;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[List_hypermap.list_of_darts_cons;Seq.mem_cat]);
  REPLICATE_TAC 2 (POP_ASSUM kill);
  DISCH_TAC;
  TYPIFY `find_face [iota 0 (p + 3); rev (iota 0 (p + 3))] (e_list d) = list_pairs (rev (iota 0 (p+3)))` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (SUBST1_TAC o GSYM);
    MATCH_MP_TAC List_hypermap.mem_f_list;
    INTRO_TAC mem_transpose_seed [`p`;`d`];
    ASM_REWRITE_TAC[fgraph_seed;maxGon];
    BY(REWRITE_TAC[List_hypermap.e_list]);
  TYPIFY `MEM (e_list d) (list_of_darts [iota 0 (p + 3); rev (iota 0 (p + 3))])` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.e_list];
    INTRO_TAC mem_transpose_seed [`p`;`d`];
    REWRITE_TAC[fgraph_seed;maxGon];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[List_hypermap.find_face_cons];
  TYPIFY `?i j.  (i,j) = d` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "d";
  REPEAT (FIRST_X_ASSUM_ST `e_list` MP_TAC);
  REWRITE_TAC[List_hypermap.e_list];
  (ASM_REWRITE_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
  (ASM_REWRITE_TAC[List_hypermap.list_of_darts_cons;Seq.mem_cat]);
  REWRITE_TAC[List_hypermap.list_of_darts_nil;MEM];
  TYPIFY `~(MEM (j,i) (list_pairs (iota 0 (p+3))))` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `list_pairs` MP_TAC;
    REWRITE_TAC[list_pairs_iota];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[];
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let dih2k_good_list_nodes = prove_by_refinement(
  `!L. 3 <= sizel (HD L) /\ dih2k_list L ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `p = sizel (HD L) - 3`;
  INTRO_TAC  seed_good_list_nodes [`p`];
  DISCH_TAC;
  INTRO_TAC seed_dih2k [`p`];
  DISCH_TAC;
  TYPIFY `sizel (HD (fgraph (Seed p))) = sizel (HD L)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[fgraph_seed;HD;Seq.size_iota;maxGon];
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC iso_list_dih2k [`fgraph (Seed p)`;`L`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[iso_list_good_list_nodes;good_list_seed])
  ]);;
  (* }}} *)


let is_normal_loop_list = prove_by_refinement(
  `!L N.  is_restricted (hypermap_of_list L) /\
     good_list L /\
    good_list_nodes L /\
   all (\r. ~(r=[])) N /\
    all uniq N /\
    is_normal (hypermap_of_list L) (loop_family_of_list N) ==>
    all (loop_list L) N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list];
  REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap.lemma_in_dart [`(hypermap_of_list L)`;`(loop_family_of_list N)`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  COMMENT "expand is_normal";
  FIRST_X_ASSUM_ST `is_normal` MP_TAC;
  REWRITE_TAC[is_normal;loop_family_of_list;IN_SET_OF_LIST;upper_case];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `is_loop` (C INTRO_TAC [`loop_of_list x`]);
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  TYPIFY `MEM (loop_of_list x) (MAP loop_of_list N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[is_loop;loop_list];
  REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `dart` MP_TAC;
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  DISCH_TAC;
  TYPIFY `x` (RENAME_TAC "r");
  TYPIFY `x''` (RENAME_TAC "d");
  SUBCONJ_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    TYPIFY `loop_of_list r` EXISTS_TAC;
    SUBCONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    REWRITE_TAC[in_dart_of_loop;];
    GMATCH_SIMP_TAC in_dart_loop_of_list;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[one_step_list];
  FIRST_X_ASSUM (C INTRO_TAC [`d`]);
  REWRITE_TAC[in_dart_of_loop];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[in_dart_loop_of_list]);
  REWRITE_TAC[one_step_contour];
  REPEAT (GMATCH_SIMP_TAC loop_map_next_el);
  REPEAT (GMATCH_SIMP_TAC face_map_list);
  REPEAT (GMATCH_SIMP_TAC inverse_node_map_list);
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let is_normal_nodal = prove_by_refinement(
  `!(L:((A)list)list) N.  is_restricted (hypermap_of_list L) /\
     good_list L /\
    good_list_nodes L /\
    is_normal (hypermap_of_list L) (loop_family_of_list N) /\
   all (\r. ~(r=[])) N /\
    all uniq N ==>
(!d. MEM d (flatten N)
              ==> node (hypermap_of_list L) d SUBSET 
	      set_of_list (flatten N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap.lemma_in_dart [`(hypermap_of_list L)`;`(loop_family_of_list N)`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  COMMENT "expand is_normal";
  FIRST_X_ASSUM_ST `is_normal` MP_TAC;
  REWRITE_TAC[is_normal;loop_family_of_list;IN_SET_OF_LIST;upper_case];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[SUBSET] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x:A#A` (RENAME_TAC "d'");
  FIRST_X_ASSUM_ST `flatten` MP_TAC;
  REWRITE_TAC[IN_SET_OF_LIST;Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `node` (C INTRO_TAC [`loop_of_list l`;`d`;`d'`]);
  ANTS_TAC;
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[in_dart_of_loop;in_dart_loop_of_list]);
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` EXISTS_TAC;
  FIRST_X_ASSUM MP_TAC;
  BY(ASM_MESON_TAC[in_dart_of_loop;in_dart_loop_of_list])
  ]);;
  (* }}} *)

let path_of_loop_of_list = prove_by_refinement(
  `!r d.
   d = HD r /\ uniq r /\ ~(r = []) ==>
   MAP (path_of_loop (loop_of_list r) d) (iota 0 (sizel r)) = r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP (path_of_loop (loop_of_list r) d) (iota 0 (sizel r)) = MAP (\k. (next_el r POWER k) d) (iota 0 (sizel r))` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP];
    REWRITE_TAC[Seq.mem_iota;arith `0 + n = n`];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[ path_of_loop];
    BY(ASM_SIMP_TAC[loop_map_next_el]);
  REWRITE_TAC[Packing3.LIST_EL_EQ];
  REWRITE_TAC[LENGTH_MAP;Seq.size_iota];
  REWRITE_TAC[lower_case;Seq.size_iota];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[upper_case;EL_MAP];
  GMATCH_SIMP_TAC EL_MAP;
  INTRO_TAC nth_iota_nod [`0`;`LENGTH r`;`j`];
  ASM_SIMP_TAC[lower_case;Seq.size_iota];
  GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
  ASM_SIMP_TAC[Seq.size_iota];
  GMATCH_SIMP_TAC Seq2.next_el_power;
  ASM_SIMP_TAC[index_hd0;arith `0+j=j`;MEM_HD];
  TYPIFY `HD r` EXISTS_TAC;
  TYPIFY `j MOD sizel r = j` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC MOD_LT;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let path_of_loop_uniq = prove_by_refinement(
  `!l d n. CARD (dart_of_loop l) = n /\
       d IN dart_of_loop l 
==> uniq (
     MAP (path_of_loop l d) (iota 0 n))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_inj_path_of_loop [`l`;`d`];
  ASM_REWRITE_TAC[in_dart_of_loop];
  REWRITE_TAC[lemma_inj_list2;pre_card_dart_of_loop];
  REWRITE_TAC[Seq2.uniq_nthP];
  DISCH_THEN (C INTRO_TAC [`PRE (CARD (dart_of_loop l))`]);
  REWRITE_TAC[arith `n:num <= n`];
  INTRO_TAC Hypermap.lemma_card_dart_of_loop [`l`];
  ASM_REWRITE_TAC[card_dart_of_loop;pre_card_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `PRE` MP_TAC;
  ASM_SIMP_TAC[arith `0 < n ==> (!i. i <= PRE n <=> i < n)`];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `nth` MP_TAC;
  REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC (GSYM Seq2.EL_nth));
  REPEAT (GMATCH_SIMP_TAC EL_MAP);
  REPEAT (GMATCH_SIMP_TAC Seq2.EL_nth);
  ASM_REWRITE_TAC[Seq.size_map;lower_case;Seq.size_iota];
  FIRST_X_ASSUM_ST `sizel` MP_TAC;
  REWRITE_TAC[lower_case;Seq.size_map;Seq.size_iota];
  DISCH_TAC;
  TYPIFY `0` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `0` EXISTS_TAC;
  REPEAT (GMATCH_SIMP_TAC nth_iota_nod);
  ASM_SIMP_TAC[arith `i < j /\ j < n ==> i < n`;arith `i < j ==> ~(i=j)`];
  TYPIFY `i < n:num` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`i`;`j`]);
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_iota = prove_by_refinement(
  `!j n i. i < n ==> EL i (iota j n) = j+i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  (GMATCH_SIMP_TAC Seq2.EL_nth);
  TYPIFY `0` EXISTS_TAC;
  GMATCH_SIMP_TAC Seq.nth_iota;
  BY(ASM_REWRITE_TAC[Seq.size_iota])
  ]);;
  (* }}} *)

let I_POWER = prove_by_refinement(
  `!n. I POWER n = I`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  INDUCT_TAC THEN REWRITE_TAC[POWER_0;I_THM];
  BY(ASM_REWRITE_TAC[POWER;I_THM;o_THM])
  ]);;
  (* }}} *)

let path_of_loop_inj = prove_by_refinement(
  `!l l' d n.
    CARD (dart_of_loop l) = CARD (dart_of_loop l') /\
     CARD (dart_of_loop l') = n /\
   d IN dart_of_loop l /\ 
   d IN dart_of_loop l' /\
    MAP (path_of_loop l d) (iota 0 (n)) = 
    MAP (path_of_loop l' d) (iota 0 (n)) ==>
      l = l'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_loop_identity];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    REPEAT (GMATCH_SIMP_TAC Hypermap.lemma_dart_loop_via_path);
    REWRITE_TAC[RIGHT_AND_EXISTS_THM;in_dart_of_loop];
    GEXISTL_TAC [`d`;`d`];
    ASM_REWRITE_TAC[pre_card_dart_of_loop];
    REWRITE_TAC[support_of_sequence;EXTENSION;IN_ELIM_THM];
    GEN_TAC;
    INTRO_TAC Hypermap.lemma_card_dart_of_loop [`l`];
    INTRO_TAC Hypermap.lemma_card_dart_of_loop [`l'`];
    ASM_REWRITE_TAC[card_dart_of_loop;pre_card_dart_of_loop];
    ASM_SIMP_TAC[arith `0 < n ==> (!i. i <= PRE n <=> i < n)`];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `MAP` (MP_TAC o MATCH_MP MEM_EXTENSION);
    REWRITE_TAC[MEM_MAP;Seq.mem_iota;arith `0 <= x`;arith `0+n=n`];
    BY(MESON_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[FUN_EQ_THM];
  GEN_TAC;
  TYPIFY `!k. k < n ==> (loop_map l POWER k) d = (loop_map l' POWER k) d` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `EL k (MAP (path_of_loop l d) (iota 0 n)) = EL k (MAP (path_of_loop l' d) (iota 0 n))` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_REWRITE_TAC[]);
    REPEAT (GMATCH_SIMP_TAC EL_MAP);
    REPEAT (GMATCH_SIMP_TAC el_iota);
    ASM_SIMP_TAC[arith `0+k=k`;lower_case;Seq.size_iota];
    BY(REWRITE_TAC[path_of_loop]);
  INTRO_TAC Hypermap.lemma_card_dart_of_loop [`l`];
  ASM_REWRITE_TAC[card_dart_of_loop;pre_card_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!k. (loop_map l POWER k) d = (loop_map l' POWER k) d` (C SUBGOAL_THEN ASSUME_TAC);
    GEN_TAC;
    INTRO_TAC DIVMOD_EXIST [`k`;`n`];
    ASM_SIMP_TAC[arith `0 < n ==> ~(n=0)`];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC [arith `a + b:num = b + a`];
    REWRITE_TAC[multiplication_exponents;addition_exponents;o_THM];
    INTRO_TAC Hypermap.lemma_order_loop_map [`l`];
    INTRO_TAC Hypermap.lemma_order_loop_map [`l'`];
    BY(ASM_SIMP_TAC[card_dart_of_loop;I_POWER;I_THM]);
  INTRO_TAC Hypermap.lemma_in_dart_of_loop_loop [`l`;`d`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[in_dart_of_loop]);
  ASM_REWRITE_TAC[pre_card_dart_of_loop;in_dart_of_loop];
  ASM_SIMP_TAC[arith `0 < n ==> (!i. i <= PRE n <=> i < n)`];
  DISCH_TAC;
  TYPIFY `(x IN dart_of_loop l)` ASM_CASES_TAC;
    FIRST_X_ASSUM MP_TAC;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `loop_map l ((loop_map l POWER i) d)  = loop_map l' ((loop_map l' POWER i) d)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ASM_MESON_TAC[COM_POWER;o_THM]);
  TYPIFY `(x IN dart_of_loop l')` ASM_CASES_TAC;
    FIRST_X_ASSUM MP_TAC;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `loop_map l ((loop_map l POWER i) d)  = loop_map l' ((loop_map l' POWER i) d)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ASM_MESON_TAC[COM_POWER;o_THM]);
  INTRO_TAC Hypermap.loop_map_and_loop_darts [`l`];
  INTRO_TAC Hypermap.loop_map_and_loop_darts [`l'`];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[Hypermap.map_permutes_outside_domain])
  ]);;
  (* }}} *)

let hd_iota = prove_by_refinement(
  `!n a. ~(n=0) ==> HD (iota a n) = a`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM EL];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC el_iota;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let loop_of_list_path_of_loop = prove_by_refinement(
  `!l d n.
     d IN (dart_of_loop l) /\
    CARD (dart_of_loop l) =n ==>
    loop_of_list (MAP (path_of_loop l d) (iota 0 n)) = l`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC path_of_loop_inj;
  GEXISTL_TAC [`d`;`n`];
  INTRO_TAC path_of_loop_of_list [`MAP (path_of_loop l d) (iota 0 n)`;`d`];
  TYPIFY `~(n = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `CARD` MP_TAC THEN ASM_REWRITE_TAC[] THEN GMATCH_SIMP_TAC CARD_EQ_0;
    BY(REWRITE_TAC[Hypermap.loop_map_and_loop_darts] THEN ASM_TAC THEN SET_TAC[]);
  TYPIFY `uniq (MAP (path_of_loop l d) (iota 0 n))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[path_of_loop_uniq]);
  TYPIFY `~(MAP (path_of_loop l d) (iota 0 n) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MAP_EQ_NIL];
    BY(ASM_REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota]);
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    GMATCH_SIMP_TAC HD_MAP;
    ASM_SIMP_TAC[hd_iota];
    ASM_REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
    BY(REWRITE_TAC[path_of_loop;POWER_0;I_THM]);
  TYPIFY `sizel (MAP (path_of_loop l d) (iota 0 n)) = n` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Seq.size_map;lower_case;Seq.size_iota]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REPEAT (GMATCH_SIMP_TAC dart_of_loop_of_list);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  REWRITE_TAC[ MEM_MAP];
  TYPIFY `0` EXISTS_TAC;
  REWRITE_TAC[Seq.mem_iota;path_of_loop;POWER_0;I_THM];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let loop_of_list_surj = prove_by_refinement(
  `!l d. d IN dart_of_loop l  ==>
    ?r. l = loop_of_list r /\ sizel r = CARD (dart_of_loop l) /\
      uniq r /\ ~(r = []) /\ HD r = d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `n = CARD (dart_of_loop l)`;
  TYPIFY `(MAP (path_of_loop l d) (iota 0 n))` EXISTS_TAC;
  INTRO_TAC loop_of_list_path_of_loop [`l`;`d`;`n`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `~(n = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `CARD` MP_TAC THEN ASM_REWRITE_TAC[] THEN GMATCH_SIMP_TAC CARD_EQ_0;
    BY(REWRITE_TAC[Hypermap.loop_map_and_loop_darts] THEN ASM_TAC THEN SET_TAC[]);
  TYPIFY `uniq (MAP (path_of_loop l d) (iota 0 n))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[path_of_loop_uniq]);
  TYPIFY `~(MAP (path_of_loop l d) (iota 0 n) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MAP_EQ_NIL];
    BY(ASM_REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC HD_MAP;
  ASM_SIMP_TAC[hd_iota];
  ASM_REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  (REWRITE_TAC[path_of_loop;POWER_0;I_THM]);
  BY(REWRITE_TAC[Seq.size_map;lower_case;Seq.size_iota])
  ]);;
  (* }}} *)

let loop_of_list_rot = prove_by_refinement(
  `!r k. uniq r  ==> 
    loop_of_list (rot k r) = loop_of_list r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_of_list];
  REWRITE_TAC[set_of_list_rot];
  BY(ASM_SIMP_TAC[Seq2.next_el_rot_eq])
  ]);;
  (* }}} *)

let loop_of_list_surj2 = prove_by_refinement(
  `!l d. d IN dart_of_loop l  ==>
    ?r. loop_of_list r = l /\ CARD (dart_of_loop (l)) =sizel r  /\
      uniq r /\ ~(r = []) /\ LAST r = d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM loop_of_list_surj) [`l`;`d`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `rot 1 r` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.size_rot;Seq.rot_uniq];
  INTRO_TAC Seq2.nth_shift_left [`HD r`;`r`;`sizel r - 1`];
  REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC (GSYM Seq2.EL_nth));
  TYPIFY `~(sizel r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  ASM_SIMP_TAC[GSYM Seq.size_eq0;arith `~(n=0)==> 0<n`;Seq.size_rot;arith `~(n=0)==> (n-1)<n`];
  REWRITE_TAC[EL];
  DISCH_THEN (SUBST1_TAC o GSYM);
  CONJ2_TAC;
    GMATCH_SIMP_TAC LAST_EL;
    BY(ASM_REWRITE_TAC[GSYM Seq.size_eq0;lower_case;Seq.size_rot]);
  BY(ASM_SIMP_TAC[loop_of_list_rot])
  ]);;
  (* }}} *)

let DIH2K_IMP_PRE_SIMPLE_HYP2 = prove_by_refinement(
  `!H k x.  dih2k H k /\ ~(k=0) /\ x IN dart H ==>
     ~(node_map H x IN face H x)`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[Hypermap.node_map_and_darts;Wrgcvdr_cizmrrh.DIH2K_IMP_PRE_SIMPLE_HYP])
  ]);;
  (* }}} *)

let list_pairs_empty_alt = prove_by_refinement(
  `list_pairs [] = []`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[List_hypermap.list_pairs;Seq2.rot_nil;Seq.zip])
  ]);;
  (* }}} *)

let set_of_list_pairs_set_of_list = 0;;

let set_of_list_pairs_set_of_list_subset = prove_by_refinement(
  `!u v. set_of_list (list_pairs u) SUBSET 
    set_of_list (list_pairs v) ==>
    set_of_list u SUBSET set_of_list v`,
  (* {{{ proof *)
  [
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.mem_list_pairs_exists [`x`;`u`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists])
  ]);;
  (* }}} *)

let set_of_list_pairs_set_of_list_eq = prove_by_refinement(
  `!u v. set_of_list (list_pairs u) =
    set_of_list (list_pairs v) ==>
    set_of_list u = set_of_list v`,
  (* {{{ proof *)
  [
BY(ASM_MESON_TAC[SUBSET_ANTISYM_EQ;set_of_list_pairs_set_of_list_subset])
  ]);;
  (* }}} *)

let card_set_of_list_uniq2 = prove_by_refinement(
  `!l. CARD (set_of_list l) = sizel l ==> uniq l`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[GSYM Seq.ltn_size_undup]);
  INTRO_TAC Seq2.set_of_list_undup [`l`];
  BY(ASM_MESON_TAC[Seq.undup_uniq;Seq2.card_set_of_list_uniq;arith `x = (y:num) ==> ~(x < y)`])
  ]);;
  (* }}} *)

let list_pairs_rot = prove_by_refinement(
  `!u v. uniq u  /\ sizel u = sizel v /\ 
    set_of_list (list_pairs u) = set_of_list (list_pairs v) ==>
    (?k. rot k u = v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `u = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq2.rot_nil];
    FIRST_X_ASSUM_ST `set_of_list` MP_TAC;
    ASM_REWRITE_TAC[list_pairs_empty_alt;set_of_list];
    BY(ASM_MESON_TAC[SET_OF_LIST_EQ_EMPTY;List_hypermap.list_pairs_empty]);
  MATCH_MP_TAC next_el_power_rot;
  TYPIFY `HD u` EXISTS_TAC;
  TYPIFY `set_of_list u = set_of_list v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[set_of_list_pairs_set_of_list_eq]);
  TYPIFY `MEM (HD u) u` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC MEM_HD THEN ASM_REWRITE_TAC[]);
  TYPIFY `MEM (HD u) v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    MATCH_MP_TAC card_set_of_list_uniq2;
    BY(ASM_MESON_TAC[Seq2.card_set_of_list_uniq;]);
  DISCH_TAC;
  TYPIFY `!i d. MEM d u /\ MEM d v ==> (next_el u POWER i) d = (next_el v POWER i) d` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  INDUCT_TAC;
    BY(REWRITE_TAC[POWER_0]);
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `next_el u d = next_el v d /\ MEM (next_el u d) u` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  ASM_SIMP_TAC[Seq2.mem_next_el];
  INTRO_TAC List_hypermap.mem_list_pairs_exists [`d`;`u`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_explicit;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let list_pairs_rot_subset = prove_by_refinement(
  `!u v. uniq u  /\ sizel u = sizel v /\ 
    set_of_list (list_pairs u) SUBSET set_of_list (list_pairs v) ==>
    (?k. rot k u = v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC list_pairs_rot;
  ASM_REWRITE_TAC[];
  INTRO_TAC set_of_list_pairs_set_of_list_subset [`u`;`v`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC CARD_SUBSET_LE [`set_of_list u`;`set_of_list v`];
  ASM_REWRITE_TAC[FINITE_SET_OF_LIST];
  ANTS_TAC;
    BY(ASM_MESON_TAC[CARD_SET_OF_LIST_LE;Seq2.card_set_of_list_uniq;lower_case]);
  DISCH_TAC;
  TYPIFY `uniq v` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC card_set_of_list_uniq2;
    BY(ASM_MESON_TAC[Seq2.card_set_of_list_uniq]);
  TYPIFY `!d. d IN set_of_list (list_pairs v) ==> d IN set_of_list (list_pairs u)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN SET_TAC[]);
  REWRITE_TAC[IN_SET_OF_LIST;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM p1 (u)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists;IN_SET_OF_LIST]);
  TYPIFY `?p2. MEM (p1,p2) (list_pairs u)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists;IN_SET_OF_LIST]);
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(p1,p2) = (p1,p2')` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC list_pairs_unique;
  ASM_REWRITE_TAC[];
  TYPIFY `v` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[SUBSET;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let e_list_o = prove_by_refinement(
  `e_list o e_list = I`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;o_THM;FORALL_PAIR_THM;List_hypermap.e_list;I_THM])
  ]);;
  (* }}} *)

let e_list_image = prove_by_refinement(
  `!f r.
    uniq f /\ ~(f = []) /\ sizel f = sizel r /\
     (!d. MEM d (list_pairs f) ==> MEM (e_list d) (list_pairs r)) ==>
     (?k.  rot k f = rev r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC list_pairs_rot_subset;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Seq.size_rev];
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;upper_case;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC list_pairs_rev_eq [`r`;`(p2,p1)`];
  REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  FIRST_X_ASSUM (C INTRO_TAC [`p1,p2`]);
  REWRITE_TAC[List_hypermap.e_list];
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let e_list_pairs_rev = prove_by_refinement(
  `!f r. uniq f /\ ~(f = []) /\ sizel f = sizel r /\
    (!d. MEM d (list_pairs f) ==> MEM (e_list d) (list_pairs r)) /\
    HD f = LAST r 
   ==> r = rev f`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC e_list_image [`f`;`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `rev (rot k f) = r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.revK]);
  FULL_EXPAND_TAC "r";
  TYPIFY `rot k f  = f` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq.revK]);
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  GMATCH_SIMP_TAC LAST_rev;
  SUBCONJ_TAC;
    REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_rot];
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  DISCH_TAC;
  TYPIFY `sizel f <= k` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.rot_oversize]);
  INTRO_TAC Seq2.index_rot [`f`;`k`;`HD f`];
  ASM_SIMP_TAC[MEM_HD;arith `~(n <= k:num) ==> k < n`];
  TYPIFY `indexl (HD f) f = 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_hd0]);
  ASM_REWRITE_TAC[];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[arith `k <= 0 ==> k = 0`;Seq.rot0]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexl` MP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `rev` kill);
  ASM_SIMP_TAC[index_hd0;Seq.size_rev;Seq.size_rot];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let AUQTZYZ_list = prove_by_refinement(
  `!L (f:(A#A)list).  good_list L /\
    is_restricted (hypermap_of_list L) /\ 
    MEM f (list_of_faces L)  ==>
    (?r.  normal_list L [f;r] /\ 
       dih2k_list (quotient_list L [f;r]))`,
  (* {{{ proof *)
  [
  st/r
  abbrev `d = HD ( f)` 
  typ `~(f = [])` sat
  fxast `MEM` mp
  rt[List_hypermap.list_of_faces]
  rt[MEM_MAP]
  st/r
  fxast `list_parts` mp
  art[]
  rt[List_hypermap.list_pairs_empty]  
  amt[good_list;Seq.allP]
  typ `MEM d f` sat
  amt[MEM_HD]
  intro Auqtzyz.AUQTZYZ [`hypermap_of_list L`;`d`;`loop_of_face (hypermap_of_list L) d`]
  asimp[dart_hypermap_of_list;IN_SET_OF_LIST]
  typ `MEM d (list_of_darts L)` sat
  gm List_hypermap.mem_find_face_nonempty
  rt[List_hypermap.find_face]
  conj
  amt[good_list]
  mmp List_hypermap.mem_find_list
 rt[Seq2.mem_flatten]
  amt[]
  art[]
  st/r
  abbrev `k = sizel f`
  abbrev `n = CARD (dart_of_loop L2)`
  abbrev `qH = quotient (hypermap_of_list L)      {loop_of_face (hypermap_of_list L) d, L2}`
  typ `CARD (face (hypermap_of_list L) d) = k` sat
 asimp[List_hypermap.card_face_of_list]
  intro  List_hypermap.find_face_eq [`L`;`d`;`f`]
  asimp[]
  amt[good_list]
  typ `uniq (list_of_darts L) /\ uniq f` sat
  amt[good_list;List_hypermap.uniq_face]
  typ `!x. MEM x f ==> MEM x (list_of_darts L)` sat
  rt[List_hypermap.list_of_darts_alt;Seq2.mem_flatten]
  amt[]
  typ `final_list L f` sat
  mmp final_list_face
  art[]
    typ `dart_of_loop (loop_of_list f) = set_of_list f` sat
  asimp[dart_of_loop_of_list]
  typ `loop_of_face (hypermap_of_list L) d = loop_of_list f` sat
  intro loop_of_face_list [`L`;`f`;`d`]
  art[]
  repeat (fxast `{x,y}` mp) then art[]
  rep 2 dt
  fxast `complement` kill
  typ `~(k=0)` sat
  fxast `CARD` kill
  fexp "k"
  art[Seq.size_eq0]
  comment "1. pick out distinguished dart in second face"
  typ `?d'. d' IN dart_of_loop L2 /\ d' IN node (hypermap_of_list L) d` sat
  intro (GEN_ALL Wrgcvdr_cizmrrh.DIH_IMP_EVERY_NODE_INTER_FACE) [`k`;`qH`]
  fxast `dih2k` mp
  asimp[]
  dt
  typ `?a. a IN (dart_of_loop L2)` smp
  mt[Hypermap.lemma_card_dart_of_loop;EXTENSION;NOT_IN_EMPTY]
  st/r
  fxa (C intro [ `atom (hypermap_of_list L) (loop_of_list f) d`;`atom (hypermap_of_list L) L2 a`])
  rt[SUBSET;IN_INSERT;NOT_IN_EMPTY]
  ants
  fexp "qH"
  strip/r then asimp[lemma_quotient;atoms_of_family;IN_ELIM_THM;IN_INSERT;NOT_IN_EMPTY;in_dart_of_loop]
  amt[IN_SET_OF_LIST]
  amt[]
  st/r
  typ `head_of_atom d
  comment "ants"
  typ `d' IN dart_of_loop L2` sat
  fexp "d'"
  intro DIH2K_IMP_PRE_SIMPLE_HYP2 [`qH`;`k`;`{d}`]
  fxast `dih2k` mp
  asimp[]
  dt

  intro loop_of_list_surj2 [`L2`;`d'`]



xxd.

  comment "normal list"
  subconj
  rt[normal_list]

  comment "dih2k"
  ]);;
  (* }}} *)
bb 3;;
Auqtzyz.AUQTZYZ;;
iso_list_good_list_nodes;;
mem_transpose_seed;;
list_pairs_unique;;
(* ... ... ... ... ...*)


let iso_list_nilfamily = prove_by_refinement(
  `!L L' N N'. iso_list (L,N) (L',N') ==> iso_list (L,[]) (L',[])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;MAP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(*
let iso_list_cons = prove_by_refinement(
  `!L n1 n1' L' n2 n2'. 
   iso_list (L,(n1::n2)) (L',(n1' :: n2')) <=> P`,
  (* {{{ proof *)
  [
  rt[iso_list]
  rt[MAP;CONS_11]
  st/r

  ]);;
  (* }}} *)
*)

iso_list_normal;;

let iso_list_marked_rN = 0;;

let iso_list_mem_rN = prove_by_refinement(
  `!L N r x L' N' r' x'. good_list L' /\ MEM r N /\
      iso_list (L,([x]:: r :: N)) (L',([x']::r' :: N')) ==>
    MEM r' N'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;MAP;CONS_11];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let iso_list_mem_xr = prove_by_refinement(
  `!L N r x L' N' r' x'. good_list L' /\ MEM x r /\
      iso_list (L,([x]:: r :: N)) (L',([x']::r' :: N')) ==>
    MEM x' r'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;MAP;CONS_11];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_cons = prove_by_refinement(
  `!L N L' N' u u'. iso_list(L,(u::N)) (L',(u'::N')) ==>
   iso_list(L,N) (L',N')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;MAP;CONS_11];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let elements_of_list_quotient_list = prove_by_refinement(
  `!L N. 
   normal_list L N /\
     is_edge_nondegenerate (hypermap_of_list L) /\
     good_list L /\
     all uniq L ==>
    elements_of_list (quotient_list L N) SUBSET
   elements_of_list L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.mem_list_of_elements;List_hypermap.elements_of_list;SUBSET;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `y` EXISTS_TAC;
  MATCH_MP_TAC list_of_darts_quotient_darts;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let inj_on_quotient_list = prove_by_refinement(
  `!phi. normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
     good_list L /\
     all uniq L /\
   inj_on phi (elements_of_list L) ==>
   inj_on phi (elements_of_list (quotient_list L N))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC inj_on_subset;
  TYPIFY `elements_of_list L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC elements_of_list_quotient_list;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


(* same as e_list_fun:
let e_list_map = prove_by_refinement(
  `!phi x.
   (let nphi = (\u. phi (FST u),phi (SND u)) in
                 e_list (nphi x) = nphi (e_list x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  BY(REWRITE_TAC[List_hypermap.e_list])
  ]);;
  (* }}} *)
*)


let inj_on_one_step_list = prove_by_refinement(
  `!phi:A->B L h1 h2.
       good_list L /\
         inj_on phi (elements_of_list L) /\
         MEM h1 (list_of_darts L) /\ 
        MEM h2 (list_of_darts L) ==>
     (let nphi = (\u. phi (FST u),phi (SND u)) in
	  one_step_list (MAP (MAP phi) L) (nphi h1) (nphi h2) = 
	    one_step_list L h1 h2)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM;FORALL_PAIR_THM];
  REWRITE_TAC[one_step_list;REWRITE_RULE[LET_THM;FORALL_PAIR_THM] e_list_fun];
  REWRITE_TAC[List_hypermap.e_list];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC (REWRITE_RULE[LET_THM;FORALL_PAIR_THM] f_list_map));
  ASM_SIMP_TAC[List_hypermap.e_list];
  TYPIFY `MEM (p2,p1) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `(p2,p1) = e_list (p1,p2)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REWRITE_TAC[List_hypermap.e_list]);
    MATCH_MP_TAC good_list_e_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (f_list L (p1,p2)) (list_of_darts L) /\ MEM (f_list L (p2,p1)) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_f_list]);
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC (TAUT `((a <=> a') /\ (b <=> b')) ==> (a \/ b <=> a'  \/ b')`);
  TYPIFY `!r1 r2 x.  r1,r2 = x ==> (phi:A->B) r1,phi r2 = phi (FST x),phi(SND x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[FST;SND]);
  TYPIFY `!r1 r2 x. MEM x (list_of_darts L) /\ MEM (r1,r2) (list_of_darts L) /\ phi r1,phi r2 = phi (FST x),phi(SND x) ==> (r1,r2) = x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[REWRITE_RULE[GSYM PAIR_EQ] inj_on_imp_inj_dart;]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* not true. h may be outside domain of inj-on.
let inj_on_list_of_darts = prove_by_refinement
  `!phi:A->B L h.
         good_list L /\
         inj_on phi (elements_of_list L) ==>
   ( MEM (phi (FST h),phi (SND h)) (list_of_darts (MAP (MAP phi) L)) <=>
 MEM h (list_of_darts L) )`,
*)

let count_list_hd_dart = 0;;

let contour_list_hd_dart = prove_by_refinement(
  `!L h s. contour_list L (h::s) ==> MEM h (list_of_darts L)`,
  (* {{{ proof *)
  [
  GEN_TAC THEN GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[contour_list_cons];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let inj_on_contour_list = prove_by_refinement(
  `!phi:A->B L s.
         good_list L /\
         inj_on phi (elements_of_list L)
         ==> (let nphi = (\u. phi (FST u),phi (SND u)) in
              contour_list L s ==>
		contour_list (MAP (MAP phi) L) (MAP nphi s)
		  )`,
  (* {{{ proof *)
  [
  GEN_TAC THEN GEN_TAC;
  REWRITE_TAC[LET_THM];
  LIST_INDUCT_TAC THEN REWRITE_TAC[MAP;contour_list_cons];
  FIRST_X_ASSUM MP_TAC;
  TYPIFY `t` (fun t -> SPEC_TAC (t,t));
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[MAP;contour_list_cons];
    REWRITE_TAC[map_list_of_darts];
    TYPIFY ` phi(FST h),phi (SND h) = (\h. phi(FST h),phi (SND h)) h` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REWRITE_TAC[]);
    MATCH_MP_TAC MEMf_MAP;
    BY(POP_ASSUM MP_TAC THEN REWRITE_TAC[MAP;contour_list_cons]);
  ASM_REWRITE_TAC[MAP;contour_list_cons] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_one_step_list [`phi`;`L`;`h`;`h'`];
  ASM_REWRITE_TAC[LET_THM];
  TYPIFY `MEM h' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[contour_list_cons];
    BY(MESON_TAC[contour_list_hd_dart]);
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REWRITE_TAC[map_list_of_darts];
  TYPIFY ` phi(FST h),phi (SND h) = (\h. phi(FST h),phi (SND h)) h` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[]);
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let inj_on_power = prove_by_refinement(
  `!(phi:A->B) f g L r k d. 
     MEM d r /\ (!x. MEM x r ==> MEM (f x) r) /\
    inj_on phi (elements_of_list L) /\
    (set_of_list r) SUBSET (darts_of_list L) ==>
   (let nphi = (\u. phi (FST u),phi (SND u)) in
      (!x. MEM x r ==> g (nphi d) = nphi (f d)) ==>
      (g POWER k) (nphi d) = nphi ((f POWER k) d))`,
  (* {{{ proof *)
  [
  rep 5 g
  induct_tac
  rt[POWER_0;I_THM;LET_THM]
  rt[POWER;o_THM]
  rt[LET_THM]
xxd
  ]);;
  (* }}} *)

let inj_on_l_m = prove_by_refinement(
  `!(phi:A->B) L r d.
         good_list L /\ good_list_nodes L /\
      MEM d (list_of_darts L) /\
      MEM d r /\
      set_of_list r SUBSET (darts_of_list L) /\
         inj_on phi (elements_of_list L)
         ==> (let nphi = (\u. phi (FST u),phi (SND u)) in
              l'm (MAP (MAP phi) L) (MAP nphi r) (nphi d) = l'm L r d)`,
  (* {{{ proof *)
  [
  st/r
  rt[LET_THM]
  ASM_SIMP_TAC[Tame_defs2.l_m;hyp_m_min];
  REWRITE_TAC[GSYM POWER_TO_ITER];
  apterm
  rt[EXTENSION;IN_ELIM_THM]
  gv "k"
  typ `!k. 

xxd

  ]);;
  (* }}} *)

final_list;;
s_list;;
s_flag_list;;

let map_parts = prove_by_refinement(
  `!phi L N. inj_on phi (elements_of_list L) ==>
   (MAP (parts (MAP (MAP phi) L)) (MAP (MAP (\u. phi (FST u),phi (SND u))) N)) = MAP (MAP (MAP (\u. phi (FST u),phi (SND u)))) (MAP (parts L) N)`,
     MAP (`,
  (* {{{ proof *)
  [
  
  #
  ]);;
  (* }}} *)

let iso_list_quotient = prove_by_refinement(
  `!L N L' N'. normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
     good_list L /\
     all uniq L /\
    iso_list (L,N) (L',N') ==> 
    iso_list (quotient_list L N,[]) (quotient_list L' N',[])`,
  (* {{{ proof *)
  [
  rt[iso_list;MAP]
  st/r
  typ `phi` ex
  subconj
  asimp[inj_on_quotient_list]  
  dt
  art[]
  comment "expand out"
  rt[quotient_list;upper_case]
  ]);;
  (* }}} *)

marked_list;;
iso_list;;

let MEEIXJO = prove_by_refinement(
  `!L N L' N' r r' (x:A#A) (x':B#B).
  good_list L /\ 
  iso_list (L,([x]:: r :: N)) (L',([x']::r' :: N')) /\
  marked_list L N r x ==> marked_list L' N' r' x'`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)

quotient_list;;
marked_list;;

1;;
(* SET ASIDE A BIT:::: *)



(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)



(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
