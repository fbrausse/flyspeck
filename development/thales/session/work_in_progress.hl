
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;


(* ............... NEW DEFS *)


let newvertex = new_definition'
  `newvertex_v2 L r (x:A#A) =
    (let f = find_face L x in
      let f' = rotate_to f x in
	MAP FST (filter (\d. ~MEM d r) f'))`;;

let newvertex_prepped = new_definition'
  `newvertex_prepped_v2 L (N:((num#num)list)list) r x <=>
  (final_list L r \/
      let n = sizel (undup (MAP FST (flatten N))) in
      let news = newvertex_v2 L r x in
	news = iota n (sizel news))`;;

let generatePolygon_reduction = new_definition'
  `generatePolygon_reduction_v2 <=> (!L:((num)list)list N N' g p fs f v k r x.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped_v2 L N r x /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
      planegraph g /\
      (!v. v IN vertices_set2 g
              ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      (r,x) = loop_choice g L N   /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k 
    ==>
      (?g' i. 
	 match_quotient_list g' L N' /\
	 planegraph g' /\
	 3 <= i /\ i <= maxGon p /\
	 (!v. v IN vertices_set2 g'
              ==> facesAt g' v = FILTER (\f. MEM v (FST f)) (faces g')) /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  ))`;;

let next_g_exists = prove_by_refinement(
  `!L N g. ?next_g next_gon. 
    (let rx = loop_choice g L N in
     let           p = foldr maxn 0 (MAP sizel L) in
     let  fs = nonFinals g in
     let f = minimalFace fs in
     let  v = minimalVertex g f in
     let  r = FST rx in
     let x = SND rx in
     let  k = transform_count L N r x in
     let  N' = ntrans L N r x k in
      (generatePolygon_reduction_v2 /\
	 good_list L /\
	 good_list_nodes L /\
	 is_restricted (hypermap_of_list L) /\
          newvertex_prepped_v2 L N r x /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraph g /\
          (!v. v IN vertices_set2 g
               ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
          vertices_set2 g = elements_of_list (fgraph g) ==>
      (match_quotient_list next_g L N' /\
                   planegraph next_g /\
                   3 <= next_gon /\
                   next_gon <= maxGon p /\
                   (!v. v IN vertices_set2 next_g
                        ==> facesAt next_g v =
                            FILTER (\f. MEM v (FST f)) (faces next_g)) /\
                   vertices_set2 next_g = elements_of_list (fgraph next_g) /\
                   MEM next_g (generatePolygon next_gon v f g))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[RIGHT_EXISTS_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon_reduction_v2` MP_TAC THEN REWRITE_TAC[generatePolygon_reduction];
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    REWRITE_TAC[PAIR_EQ2];
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`g'`;`i`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

new_specification ["next_g_v2";"next_gon_v2"]
  (REWRITE_RULE[SKOLEM_THM] next_g_exists);;

(* ............... END NEW DEFS *)

let oldvertex = prove_by_refinement(
  `!L N g.
    good_list L /\
    normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
    set_of_list (MAP FST (flatten N)) = vertices_set2 g
  `,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_SIMP_TAC[quotient_list_elements])
  ]);;
  (* }}} *)

let set_of_list_newvertex = prove_by_refinement(
  `!L r x. good_list L /\ 
    MEM x (list_of_darts L) ==>
    set_of_list (newvertex_v2 L r x) = 
    IMAGE FST { t | MEM t (find_face L x) /\ ~MEM t r}`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex;LET_THM;EXTENSION;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_MAP;IN_IMAGE;IN_ELIM_THM];
  REWRITE_TAC[Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
  REWRITE_TAC[Seq.mem_rot];
  CONJ2_TAC;
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  MATCH_MP_TAC List_hypermap.uniq_find_face;
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let oldnew_vertex_disjoint = prove_by_refinement(
  `!L N r x. good_list L /\
    good_list_nodes L /\
    transform_assumption_v2 L /\
    marked_list L N r x 
    ==>
    set_of_list (MAP FST (flatten N)) INTER set_of_list (newvertex_v2 L r x)
    = {}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC set_of_list_newvertex;
  ASM_REWRITE_TAC[EXTENSION;IN_IMAGE;IN_ELIM_THM;IN_SET_OF_LIST;IN_INTER;NOT_IN_EMPTY];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x'' (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC;
    FIRST_X_ASSUM_ST `MAP` MP_TAC;
    ASM_REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC MEM_hypermap_of_list_node [`L`;`x''`;`x'''`];
    SUBANTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_mem_darts;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[marked_list]);
    TYPIFY `MEM x''' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      FIRST_ASSUM_ST `normal_list` (ASSUME_TAC o MATCH_MP normal_list_list_of_darts);
      BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    FIRST_ASSUM_ST `normal_list` MP_TAC;
    REWRITE_TAC[normal_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x'' IN node (hypermap_of_list L) x'''` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[lemma_node_identity;node_refl]);
    FIRST_X_ASSUM (C INTRO_TAC [`x'''`]);
    ANTS_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_flatten]);
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`x''`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  INTRO_TAC Obdatyb.OBDATYB [`L`;`N`;`r`;`x`;`x''`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let inj_on_union = prove_by_refinement(
  `!fs ft s t. inj_on fs s /\ inj_on ft t /\ 
    (s INTER t = {}) /\
    (!x y. x IN s /\ y IN t ==> ~(fs x = ft y)) ==> 
    (?f. inj_on f (s UNION t) /\ 
       (!x. x IN s ==> f x = fs x) /\ (!y. y IN t ==> f y = ft y))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `f = (\x. if (x IN s) then fs x else ft x)`;
  TYPIFY `f` EXISTS_TAC;
  nCONJ_TAC 1;
    FULL_EXPAND_TAC "f";
    BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `!y. y IN t ==> ~(y IN s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM_ST `INTER` MP_TAC THEN SET_TAC[]);
  nCONJ_TAC 2;
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "f";
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `inj_on` MP_TAC) THEN REWRITE_TAC[inj_on_ALT;IN_UNION];
  FULL_EXPAND_TAC "f" THEN REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let inj_on_union3 = prove_by_refinement(
  `!fs1 fs2 fs3 s1 s2 s3. inj_on fs1 s1 /\ inj_on fs2 s2 /\
    inj_on fs3 s3 /\
    (s1 INTER s2 = {}) /\ (s2 INTER s3 = {}) /\ (s1 INTER s3 = {}) /\
    (!x1 x2. x1 IN s1 /\ x2 IN s2 ==> ~(fs1 x1 = fs2 x2)) /\
    (!x1 x3. x1 IN s1 /\ x3 IN s3 ==> ~(fs1 x1 = fs3 x3)) /\
    (!x2 x3. x2 IN s2 /\ x3 IN s3 ==> ~(fs2 x2 = fs3 x3))
 ==> 
    (?f. inj_on f (s1 UNION s2 UNION s3) /\ 
       (!x1. x1 IN s1 ==> f x1 = fs1 x1) /\ 
       (!x2. x2 IN s2 ==> f x2 = fs2 x2) /\ 
       (!x3. x3 IN s3 ==> f x3 = fs3 x3))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union [`fs1`;`fs2`;`s1`;`s2`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union [`f`;`fs3`;`s1 UNION s2`;`s3`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_TAC THEN SET_TAC[]);
    REWRITE_TAC[IN_UNION];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM UNION_ASSOC;IN_UNION];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let INJ_inj_on = prove_by_refinement(
  `!f s t. INJ f s t ==> inj_on f s`,
  (* {{{ proof *)
  [
  SIMP_TAC[INJ;inj_on_ALT];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let set_of_list_iota_alt = prove_by_refinement(
  `!m n. set_of_list (iota m n) = {i | m <= i /\ i < m + n}`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST;Seq.mem_iota])
  ]);;
  (* }}} *)

let vertices_normal_list = prove_by_refinement(
  `!g L N. good_list L /\ normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
     (set_of_list (MAP FST (flatten N))) = 
	set_of_list (iota 0 (countVertices g))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM quotient_list_elements);
  TYPIFY `L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `quotient_list` (SUBST1_TAC o GSYM);
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  REWRITE_TAC[vertices_set2;vertices_graph;upt0];
  ]);;
  (* }}} *)

(* was card_vertices_set2 *)
let card_vertices_set2 = 0;;

let card_vertices_normal_list = prove_by_refinement(
  `!g L N. good_list L /\ normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
    CARD (set_of_list (MAP FST (flatten N))) = countVertices g`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC vertices_normal_list;
  TYPIFY `g` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  BY(REWRITE_TAC[Seq.size_iota;Seq.iota_uniq])
  ]);;
  (* }}} *)

let uniq_bij_map = prove_by_refinement(
  `!u v. sizel u = sizel v /\ uniq u /\ uniq v ==>
    (?f. BIJ f (set_of_list u) (set_of_list v) /\ v = MAP f u)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC uniq_inj_on [`u`;`v`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[SET_OF_LIST_MAP];
  MATCH_MP_TAC inj_on_BIJ;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let simple_list = prove_by_refinement(
  `!L u v x. 
    good_list L /\
    good_list_nodes L /\
    MEM x (list_of_darts L) /\
    MEM u (find_face L x) /\ MEM v (find_face L x) /\
    FST u = FST v /\
    all uniq L  ==>
    u = v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC good_face_rep [`L`;`find_face L x`];
  ANTS_TAC;
    ASM_SIMP_TAC[simple_hypermap_uniq];
    MATCH_MP_TAC List_hypermap.mem_find_face;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of_unique [`L`;`f0`;`FST u`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FULL_EXPAND_TAC "f0";
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
    TYPIFY `find_face L x = find_face L u` (C SUBGOAL_THEN SUBST1_TAC);
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[good_list]);
    BY(REWRITE_TAC[List_hypermap.find_face_alt;fst_list_pairs]);
  INTRO_TAC dart_of_unique [`L`;`f0`;`FST v`;`v`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FULL_EXPAND_TAC "f0";
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
    TYPIFY `find_face L x = find_face L v` (C SUBGOAL_THEN SUBST1_TAC);
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[good_list]);
    BY(REWRITE_TAC[List_hypermap.find_face_alt;fst_list_pairs]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let newvertex_uniq = prove_by_refinement(
  `!L r x. MEM x (list_of_darts L) /\
    good_list L /\
    good_list_nodes L /\
    all uniq L
  ==> uniq (newvertex_v2 L r x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  MATCH_MP_TAC uniq_map;
  GMATCH_SIMP_TAC Seq.filter_uniq;
  REWRITE_TAC[Seq.mem_filter];
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  REWRITE_TAC[Seq.mem_rot;Seq.rot_uniq];
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  ASM_SIMP_TAC[List_hypermap.uniq_find_face];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC simple_list;
  GEXISTL_TAC [`L`;`x`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let rotate_to_map = prove_by_refinement(
  `!phi f x. uniq f /\ MEM x f /\ inj_on phi (set_of_list f) ==>
    rotate_to (MAP phi f) (phi x) = MAP phi (rotate_to f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[lower_case];
    GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
    ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC THEN REWRITE_TAC[inj_on;IN_ELIM_SET_OF_LIST];
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC indexl_map;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[inj_on;IN_ELIM_SET_OF_LIST]);
  BY(REWRITE_TAC[lower_case;Seq.map_rot])
  ]);;
  (* }}} *)

let map_newvertex = prove_by_refinement(
  `!phi L r x. 
    good_list L /\
    MEM x (list_of_darts L) /\
    (set_of_list r SUBSET (darts_of_list L)) /\
    inj_on phi (elements_of_list L) ==>
    newvertex_v2 (MAP (MAP phi) L) 
    (MAP (\x. (phi (FST x)), (phi (SND x))) r)  (phi (FST x), phi (SND x)) 
      = MAP phi (newvertex_v2 L r x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex];
  REWRITE_TAC[LET_THM;GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC find_face_map;
  ASM_REWRITE_TAC[];
  INTRO_TAC (rotate_to_map) [`\d. phi (FST d),phi (SND d)`;`find_face L x`;`x`];
  REWRITE_TAC[];
  DISCH_THEN GMATCH_SIMP_TAC;
  GMATCH_SIMP_TAC List_hypermap.uniq_find_face;
  REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[good_list]);
  CONJ_TAC;
    MATCH_MP_TAC inj_on_subset;
    TYPIFY `darts_of_list L` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.darts_of_list];
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  REWRITE_TAC[lower_case;Seq.filter_map;Seq.preim];
  TYPED_ABBREV_TAC `l = rotate_to (find_face L x) x`;
  TYPIFY `filter  (\x. ~MEM (phi (FST x),phi (SND x)) (map (\x. phi (FST x),phi (SND x)) r)) l = filter (\d. ~MEM d r) l` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_in_filter);
    REWRITE_TAC[upper_case];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[EQ_EXPAND];
    REPEAT STRIP_TAC;
      FIRST_X_ASSUM_ST `MAP` MP_TAC;
      REWRITE_TAC[];
      TYPIFY `phi (FST x'),phi (SND x') = (\x. phi (FST x),phi (SND x)) x'` (C SUBGOAL_THEN SUBST1_TAC);
        BY(REWRITE_TAC[]);
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    POP_ASSUM MP_TAC;
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    DISCH_THEN (C INTRO_TAC [`x'`;`x''`]);
    ASM_REWRITE_TAC[];
    DISCH_THEN MP_TAC THEN ANTS_TAC;
      CONJ_TAC;
        REWRITE_TAC[List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
        REPLICATE_TAC 3 (FIRST_X_ASSUM_ST `MEM` MP_TAC);
        FULL_EXPAND_TAC "l";
        GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
        REWRITE_TAC[Seq.mem_rot];
        CONJ_TAC;
          GMATCH_SIMP_TAC List_hypermap.uniq_find_face;
          CONJ_TAC;
            BY(ASM_MESON_TAC[good_list]);
          BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
        BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
      FIRST_X_ASSUM_ST `SUBSET` MP_TAC THEN REWRITE_TAC[SUBSET;IN_SET_OF_LIST];
      BY(ASM_MESON_TAC[IN]);
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[upper_case;GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ;
  BY(REWRITE_TAC[lower_case;GSYM Seq.allP;o_THM])
  ]);;
  (* }}} *)

let FST_o_FST = prove_by_refinement(
  `!f g. FST o (\u. f (FST u),g u) = f o FST`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;o_THM])
  ]);;
  (* }}} *)

let map_vertices_normal_list = prove_by_refinement(
  `!N f.
    MAP FST (flatten (MAP (MAP (\u. f (FST u),f(SND u) )) N)) = 
    MAP f (MAP FST (flatten N))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[GSYM MAP_flatten;GSYM MAP_o;FST_o_FST])
  ]);;
  (* }}} *)

let final_list_snd_is_fst = prove_by_refinement(
  `!L N r d. final_list L r /\ 
    normal_list L N /\ all uniq L /\ MEM r N /\ MEM d r ==>
    MEM (SND d) (MAP FST (flatten N))
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[final_list];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC f_list_fst_snd [`L`;`d`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  MATCH_MP_TAC MEMf_MAP;
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `r` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `f_list` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Seq2.mem_next_el;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let match_quotient_list_map = prove_by_refinement(
  `!g L N f. 
   is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    good_list L /\ normal_list L N /\
   (!x. MEM x (MAP FST (flatten N)) ==> f x = x) /\
    inj_on f (elements_of_list L) ==>
    match_quotient_list g (MAP (MAP f) L) (MAP (MAP (\u. f (FST u),f (SND u))) N) = match_quotient_list g L N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso_list (L,N) (MAP (MAP f) L, (MAP (MAP (\u. f (FST u),f (SND u))) N))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[iso_list];
    BY(TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `(filter (final_list (MAP (MAP f) L)) (MAP (MAP (\u. f (FST u),f (SND u))) N)) = MAP (MAP (\u. f (FST u),f (SND u)) ) (filter (final_list L) N)` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[Seq.filter_map;lower_case;Seq.preim];
    AP_TERM_TAC;
    MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_in_filter);
    REWRITE_TAC[upper_case];
    GEN_TAC;
    DISCH_TAC;
    INTRO_TAC iso_list_final_list_eq [`L`;`MAP (MAP f) L`;`N`;`MAP (MAP (\u. f (FST u),f (SND u))) N`;`x`;`(MAP (\u. f (FST u),f (SND u)) x)`];
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[iso_list;CONS_11];
    BY(TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[CONS_11;MAP]);
  TYPIFY `quotient_list (MAP (MAP f) L) (MAP (MAP (\u. f (FST u),f (SND u))) N) = quotient_list L N` (C SUBGOAL_THEN SUBST1_TAC);
    INTRO_TAC isop_list_quotient [`f`;`L`;`N`;`MAP (MAP f) L`;`MAP (MAP (\u. f (FST u),f (SND u))) N`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[isop_list]);
    ASM_REWRITE_TAC[isop_list];
    DISCH_THEN (unlist REWRITE_TAC);
    TYPIFY `MAP (MAP f) (quotient_list L N) = MAP I (quotient_list L N)` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `MAP f x = MAP I x` ENOUGH_TO_SHOW_TAC;
        BY(SIMP_TAC[MAP_I;I_THM;upper_case]);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
      X_GENv_TAC "d";
      DISCH_TAC;
      TYPIFY `d IN (elements_of_list (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
        REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements;IN_SET_OF_LIST;Seq.mem_undup;Seq2.mem_flatten];
        BY(ASM_MESON_TAC[]);
      FIRST_X_ASSUM MP_TAC;
      GMATCH_SIMP_TAC quotient_list_elements;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
    BY(REWRITE_TAC[I_THM;MAP_I]);
  TYPIFY `fgraph g = quotient_list L N` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `(MAP (MAP (\u. f (FST u),f (SND u))) (filter (final_list L) N)) = MAP I (filter (final_list L) N)` (C SUBGOAL_THEN MP_TAC);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[GSYM MAP_I];
    REWRITE_TAC[upper_case];
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
    X_GENv_TAC "d";
    DISCH_TAC;
    INTRO_TAC final_list_snd_is_fst [`L`;`N`;`x`;`d`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(FIRST_X_ASSUM_ST `filter` MP_TAC THEN REWRITE_TAC[Seq.mem_filter]);
    DISCH_TAC;
    REWRITE_TAC[PAIR_EQ2];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    MATCH_MP_TAC MEMf_MAP;
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `x` EXISTS_TAC;
    BY(ASM_MESON_TAC[Seq.mem_filter]);
  REWRITE_TAC[MAP_I;I_THM];
  DISCH_THEN SUBST1_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)


let iso_list_newvertex_lemma = prove_by_refinement(
  `!L N r x g. 
    good_list L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    good_list_nodes L /\
    transform_assumption_v2 L /\
    marked_list L N r x /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) 
   ==>
    (?L' N' r' x'. 
         iso_list (L,([x]::r::N)) (L',([x']::r'::N')) /\
	 match_quotient_list g L' N' /\
	 newvertex_prepped_v2 L' N' r' x')
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  INTRO_TAC oldnew_vertex_disjoint [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[iso_list];
  TYPED_ABBREV_TAC `s1 = set_of_list (MAP FST (flatten N))`;
  TYPED_ABBREV_TAC `s2 = set_of_list (newvertex_v2 L r x)`;
  TYPED_ABBREV_TAC `s3 = elements_of_list L DIFF (s1 UNION s2)`;
  TYPIFY `s1 INTER s3 = {} /\ s2 INTER s3 = {}` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN SET_TAC[]);
  TYPIFY `s1 SUBSET (elements_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s1";
    GMATCH_SIMP_TAC (GSYM quotient_list_elements);
    TYPIFY `L` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC elements_of_list_quotient_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(ASM_MESON_TAC[]);
  TYPIFY `s2 SUBSET (elements_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s2";
    ASM_SIMP_TAC[SUBSET;set_of_list_newvertex;IN_IMAGE;IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST];
    REWRITE_TAC[List_hypermap.mem_list_of_elements];
    TYPIFY `SND x''` EXISTS_TAC;
    ASM_REWRITE_TAC[GSYM PAIR];
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  TYPIFY `elements_of_list L = s1 UNION s2 UNION s3` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN SET_TAC[]);
  TYPED_ABBREV_TAC `fs1 = (I:num->num)`;
  TYPED_ABBREV_TAC `n = CARD s1`;
  COMMENT "redo here";
  TYPIFY `?fs2. BIJ fs2 s2 (set_of_list (iota n (CARD s2))) /\ iota n (CARD s2) =  MAP fs2 (newvertex_v2 L r x)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s2";
    MATCH_MP_TAC uniq_bij_map;
    REWRITE_TAC[Seq.size_iota;Seq.iota_uniq];
    GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
    MATCH_MP_TAC newvertex_uniq;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "redone";
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `n' = CARD s1 + CARD s2`;
  TYPIFY `?fs3. BIJ fs3 s3 (set_of_list (iota n' (CARD s3)))` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Counting_spheres.BIJ_EXTENDS_INJ [`s3`;`set_of_list (iota n' (CARD s3))`;`{}:num->bool`;`fs1`];
    ASM_REWRITE_TAC[INJ_EMPTY];
    ANTS_TAC;
      CONJ_TAC;
        FULL_EXPAND_TAC "s3";
        MATCH_MP_TAC FINITE_DIFF;
        BY(REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST]);
      REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST];
      CONJ_TAC;
        BY(SET_TAC[]);
      GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
      REWRITE_TAC[Seq.size_iota];
      BY(REWRITE_TAC[Seq.iota_uniq]);
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union3 [`fs1`;`fs2`;`fs3`;`s1`;`s2`;`s3`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    CONJ_TAC;
      REWRITE_TAC[inj_on];
      FULL_EXPAND_TAC "fs1";
      BY(SIMP_TAC[I_THM]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[INJ_inj_on;BIJ]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[INJ_inj_on;BIJ]);
    RULE_ASSUM_TAC(REWRITE_RULE[set_of_list_iota_alt]);
    FULL_EXPAND_TAC "fs1" THEN REWRITE_TAC[I_THM];
    FULL_EXPAND_TAC "n'";
    FULL_EXPAND_TAC "n";
    FIRST_X_ASSUM_ST `flatten` MP_TAC;
    INTRO_TAC card_vertices_normal_list [`g`;`L`;`N`];
    ASM_REWRITE_TAC[];
    INTRO_TAC vertices_normal_list [`g`;`L`;`N`];
    ASM_REWRITE_TAC[];
    DISCH_THEN SUBST1_TAC;
    DISCH_TAC;
    DISCH_TAC;
    TYPIFY `!x1. x1 IN s1 ==> x1 < CARD s1` (C SUBGOAL_THEN ASSUME_TAC);
      FULL_EXPAND_TAC "s1";
      REWRITE_TAC[IN_SET_OF_LIST;Seq.mem_iota];
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    REPEAT (FIRST_X_ASSUM_ST `BIJ` MP_TAC) THEN REWRITE_TAC[BIJ;SURJ;IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    REPEAT CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
        TYPIFY `x1 < CARD s1 /\ CARD s1 <= fs2 x2` (C SUBGOAL_THEN MP_TAC);
          BY(ASM_MESON_TAC[]);
        BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
      TYPIFY `x1 < CARD s1 /\ CARD s1 + CARD s2 <= fs3 x3` (C SUBGOAL_THEN MP_TAC);
        BY(ASM_MESON_TAC[]);
      BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
    TYPIFY `fs2 x2 < CARD s1 + CARD s2 /\ CARD s1 + CARD s2 <= fs3 x3` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP (MAP f) L` EXISTS_TAC;
  TYPED_ABBREV_TAC `nf = (\u. f (FST u),f (SND u))`;
  GEXISTL_TAC [`MAP (MAP nf) N`;`MAP nf r`;`nf x`];
  CONJ_TAC;
    TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[MAP;CONS_11];
    BY(FULL_EXPAND_TAC "nf" THEN REWRITE_TAC[]);
  COMMENT "newvertex_prepped";
  SUBCONJ2_TAC;
    REWRITE_TAC[newvertex_prepped];
    TYPIFY `final_list (MAP (MAP f) L) (MAP nf r)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    (REWRITE_TAC[LET_THM]);
    TYPIFY `sizel (undup (MAP FST (flatten N))) = n` (C SUBGOAL_THEN SUBST1_TAC);
      FULL_EXPAND_TAC "n";
      FULL_EXPAND_TAC "s1";
      GMATCH_SIMP_TAC (GSYM Seq2.card_set_of_list_uniq);
      REWRITE_TAC[Seq.undup_uniq];
      BY(REWRITE_TAC[Seq2.set_of_list_undup]);
    TYPIFY `newvertex_v2 (MAP (MAP f) L) (MAP nf r) (nf x) = MAP fs2 (newvertex_v2 L r x)` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM_ST `newvertex_v2` (SUBST1_TAC o GSYM);
      REWRITE_TAC[Seq.size_iota];
      REWRITE_TAC[GSYM MAP_flatten;GSYM MAP_o;FST_o_FST];
      FULL_EXPAND_TAC "nf" THEN REWRITE_TAC[FST_o_FST];
      ASM_REWRITE_TAC[MAP_o];
      TYPIFY `sizel (undup (MAP f (MAP FST (flatten N)))) = n` (C SUBGOAL_THEN SUBST1_TAC) THEN REWRITE_TAC[];
      FULL_EXPAND_TAC "n";
      FULL_EXPAND_TAC "s1";
      GMATCH_SIMP_TAC (GSYM Seq2.card_set_of_list_uniq);
      REWRITE_TAC[Seq.undup_uniq];
      REWRITE_TAC[Seq2.set_of_list_undup];
      TYPIFY_GOAL_THEN `!u. set_of_list (MAP f u) = IMAGE f (set_of_list u)` (unlist REWRITE_TAC);
        BY(REWRITE_TAC[SET_OF_LIST_MAP]);
      ASM_REWRITE_TAC[];
      AP_TERM_TAC;
      REWRITE_TAC[EXTENSION;IN_IMAGE];
      BY(ASM_MESON_TAC[I_THM]);
    INTRO_TAC map_newvertex [`f`;`L`;`r`;`x`];
    FULL_EXPAND_TAC "nf";
    TYPIFY `MAP fs2 (newvertex_v2 L r x) = MAP f (newvertex_v2 L r x)` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP];
      REWRITE_TAC[GSYM IN_SET_OF_LIST];
      BY(ASM_MESON_TAC[]);
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
      BY(FIRST_X_ASSUM_ST `marked_list` MP_TAC THEN MESON_TAC[marked_list]);
    REWRITE_TAC[SUBSET;List_hypermap.darts_of_list;IN_SET_OF_LIST];
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  (DISCH_TAC);
  FULL_EXPAND_TAC "nf";
  GMATCH_SIMP_TAC match_quotient_list_map;
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "s1";
  FIRST_X_ASSUM_ST `flatten` MP_TAC;
  REWRITE_TAC[IN_SET_OF_LIST];
  FULL_EXPAND_TAC "fs1";
  BY(REWRITE_TAC[I_THM])
  ]);;
  (* }}} *)


let SHXWKXQ = iso_list_newvertex_lemma;;

(* mono increasing generatePolygon in #final-faces + #faces *)
(* ?n. new_g^n is all final *)
(* least n *)
(* then induction on n *)


let restricted_hypermaps_are_planegraphs_reduction1 = prove_by_refinement(
  `generatePolygon_reduction  /\ 
    (!L. good_list L /\ good_list_nodes L ==>
	   transform_assumption_v2 L) ==>
    restricted_hypermaps_are_planegraphs`,
  (* {{{ proof *)
  [
  rt[restricted_hypermaps_are_planegraphs;planegraph_PlaneGraphs]
  st/r
  rt[good_graph]
  ]);;
  (* }}} *)



finalGraph;;
good_graph;;
normal_list_size_bound;;

let match_quotient_list_size = prove_by_refinement(
  `!g L N. match_quotient_list g L N ==> 
    sizel (filter SND (faces g)) <= sizel N`,
  (* {{{ proof *)
  [
  rt[match_quotient_list]
  ]);;
  (* }}} *)

match_quotient_list;;

1;;

(* then XZAJELF *)
(* come back *)




1;;
(* SET ASIDE A BIT:::: *)



(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)



(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
