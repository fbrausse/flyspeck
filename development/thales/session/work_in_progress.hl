
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;

module Work_in_progress = struct
end;;

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;


(* kill fztrans, if_betwn *)

(* DEFS *)

let ftrans = new_definition'
  `!L N r (x:A#A) i. ftrans L N r x i = if i = 0 then SND x else FST (ztrans L N r x (PRE i))`;;

let ifbetwn = new_definition'
  `!s (x:A) y. ifbetwn s x y = if MEM x s /\ MEM y s /\ ~(x=y) then rcons (betwn s x y) y else []`;;

(* END DEFS *)

let ifbetwn_disjoint = prove_by_refinement(
  `!x y w f.
    uniq f /\  MEM w (ifbetwn f x y)
            ==> ~MEM w (ifbetwn f y x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  REWRITE_TAC[MEM;GSYM Seq.cats1;Seq.mem_cat];
  BY(ASM_MESON_TAC[Tame_list.not_betwn1;Tame_list.not_betwn2;Reduction3.betwn_disjoint])
  ]);;
  (* }}} *)

let core_nil = prove_by_refinement(
  `!L. core L [] = []`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[core;MAP_EQ_NIL;parts_nil])
  ]);;
  (* }}} *)

let core_cat = prove_by_refinement(
  `!L u v.
    uniq (cat u v) /\
    ~(u = []) /\
    ~(next_el (cat u v) (LAST u) = f_list L (e_list (LAST u))) ==>
    core L (cat u v) = cat (core L u) (core L v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v = []` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[core_nil;Seq.cats0]);
  REWRITE_TAC[core];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  BY(REWRITE_TAC[lower_case;Seq.map_cat])
  ]);;
  (* }}} *)

let take_eq_nil = prove_by_refinement(
  `!r k. take k r = [] <=> (k= 0 \/ r = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.take];
  BY(INDUCT_TAC THEN REWRITE_TAC[Seq.take;NOT_CONS_NIL;arith `~(SUC k = 0)`])
  ]);;
  (* }}} *)

let rot_core = prove_by_refinement(
  `!L r r' k.
    uniq r /\ ~(r=[]) /\
    rot k r = r' /\
    ~(next_el r (LAST r) = f_list L (e_list (LAST r))) /\
    ~(next_el r' (LAST r') = f_list L (e_list (LAST r'))) ==>
    (?k'. rot k' (core L r) = (core L r'))
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k=0` ASM_CASES_TAC;
    TYPIFY `0` EXISTS_TAC;
    BY(FIRST_X_ASSUM_ST `rot` MP_TAC THEN ASM_SIMP_TAC[Seq.rot0]);
  INTRO_TAC Seq.rot [`k`;`r`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC core_cat [`L`;`dropl k r`;`take k r`];
  INTRO_TAC core_cat [`L`;`take k r`;`dropl k r`];
  SIMP_TAC[Seq.cat_take_drop;GSYM Seq.rot];
  ASM_REWRITE_TAC[Seq.rot_uniq;take_eq_nil];
  TYPIFY `LAST (take k r) = LAST r'` (C SUBGOAL_THEN SUBST1_TAC);
    POP_ASSUM SUBST1_TAC;
    GMATCH_SIMP_TAC LAST_cat;
    BY(ASM_REWRITE_TAC[take_eq_nil]);
  POP_ASSUM (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq;Seq.rot_uniq]);
  DISCH_TAC;
  TYPIFY `dropl k r = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `0` EXISTS_TAC;
    REWRITE_TAC[Seq.rot0;core_nil;Seq.cats0];
    BY(ASM_MESON_TAC[Seq.cat0s]);
  TYPIFY `LAST (dropl k r) = LAST r` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[LAST_cat;Seq.cat_take_drop]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq;Seq.rot_uniq]);
  DISCH_THEN SUBST1_TAC;
  BY(ASM_MESON_TAC[Seq.rot_size_cat])
  ]);;
  (* }}} *)

let ifbetwn_rot = prove_by_refinement(
  `!x y s n.
    uniq s ==>
    ifbetwn (rot n s) x y = ifbetwn s x y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[ifbetwn;Seq.mem_rot];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `n <= sizel s` ASM_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.mem_rot;Reduction2.betwn_rot]);
    BY(ASM_MESON_TAC[Seq.rot_oversize;arith `~(n <= s) ==> (s <= n:num)`]);
  ]);;
  (* }}} *)

let normal_list_rot_core = prove_by_refinement(
  `!N L r p p'. 
    good_list L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) /\
    ~(HD p = LAST p') /\
    MEM p' (parts L r) ==>
    (?k rest. 
       rot k (core L r) = 
	cat (core L (HD p :: ifbetwn r (HD p) (LAST p') )) rest)`, 
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r =[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `uniq p' /\ ~(p' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM ( (HD p)) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_HD]);
  TYPIFY `?k. HD(rot k r) = (HD p)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Pwssrat.rotate_rot_indexl;Tame_list.hd_rotate_to]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `r' = rot k r`;
  INTRO_TAC rot_core [`L`;`r`;`r'`;`k`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM post_betwn) [`HD p`;`LAST p'`;`r'`];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST;Seq.rot_uniq;Seq.mem_rot]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN SUBANTS_TAC;
    CONJ_TAC;
      TYPIFY `f_last L r` (C SUBGOAL_THEN ASSUME_TAC);
        BY(ASM_MESON_TAC[normal_list;Seq.allP]);
      RULE_ASSUM_TAC(REWRITE_RULE[f_last]);
      ASM_REWRITE_TAC[];
      TYPIFY `MEM (LAST r) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
        BY(ASM_MESON_TAC[MEM_LAST;normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
      BY(ASM_MESON_TAC[edge_nondeg_f_xor_ni;f_last]);
    TYPIFY `MEM (LAST r') r` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[MEM_LAST;rot_eq_nil;Seq.mem_rot]);
    TYPIFY `MEM (LAST r') (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[MEM_LAST;normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
    TYPIFY `next_el r' (LAST r') = HD p` (C SUBGOAL_THEN ASSUME_TAC);
      GMATCH_SIMP_TAC Aq4.next_el_last_hd;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[rot_eq_nil]);
    INTRO_TAC next_el_parts_last [`L`;`r`;`prev_el (parts L r) p`;`LAST (prev_el (parts L r) p)`];
    TYPED_ABBREV_TAC `p'' = prev_el (parts L r ) p`;
    ASM_REWRITE_TAC[];
    TYPIFY `MEM p'' (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.mem_prev_el]);
    TYPIFY `uniq p'' /\ ~(p'' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[parts_uniq_nonnil]);
    ASM_SIMP_TAC[MEM_LAST];
    TYPIFY `next_el (parts L r) p'' = p` (C SUBGOAL_THEN ASSUME_TAC);
      FULL_EXPAND_TAC "p''";
      GMATCH_SIMP_TAC Seq2.next_prev_id;
      BY(ASM_SIMP_TAC[Tame_list.uniq_parts]);
    ASM_REWRITE_TAC[];
    TYPIFY `LAST r' = LAST p''` (C SUBGOAL_THEN ASSUME_TAC);
      INTRO_TAC Seq2.next_el_inj [`r`;`LAST r'`;`LAST p''`];
      INTRO_TAC Tame_list.next_el_parts_last [`L`;`r`;`p''`;`LAST p''`];
      ASM_SIMP_TAC[MEM_LAST];
      BY(ASM_MESON_TAC[Seq2.next_el_rot_eq]);
    DISCH_THEN (ASSUME_TAC o GSYM) THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Tame_list.normal_list_parts_next_last;
    TYPIFY `L` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC edge_nondeg_f_xor_ni;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `core L post` EXISTS_TAC;
  TYPIFY `MEM (LAST p') r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST]);
  TYPIFY `ifbetwn r' (HD p) (LAST p') = ifbetwn r (HD p) (LAST p')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ifbetwn_rot]);
  TYPIFY `rcons (betwn r' (HD p) (LAST p')) (LAST p') = ifbetwn r' (HD p) (LAST p')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ifbetwn;Seq.mem_rot]);
  TYPIFY `cat ((HD p :: ifbetwn r (HD p) (LAST p'))) post = r'` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_ASSUM_ST `((HD p) :: v) = r'` (SUBST1_TAC o GSYM);
    REWRITE_TAC[Seq.cat_cons;CONS_11];
    AP_THM_TAC THEN AP_TERM_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT (FIRST_X_ASSUM_ST `betwn` kill);
  INTRO_TAC core_cat [`L`;`(HD p :: ifbetwn r (HD p) (LAST p'))`;`post`];
  ASM_SIMP_TAC[NOT_CONS_NIL];
  DISCH_THEN MATCH_MP_TAC;
  TYPIFY `(LAST (HD p :: ifbetwn r (HD p) (LAST p'))) = LAST p'` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC last_ifbetwn;
    BY(ASM_REWRITE_TAC[]);
  FIRST_ASSUM_ST `rot k n = (r':(A#A)list)` (SUBST1_TAC o GSYM);
  ASM_SIMP_TAC[Seq2.next_el_rot_eq];
  GMATCH_SIMP_TAC Tame_list.normal_list_parts_next_last;
  TYPIFY `L` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (LAST p') (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.mem_rot;normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  BY(ASM_MESON_TAC[edge_nondeg_f_xor_ni])
  ]);;
  (* }}} *)

let indexf_inj = prove_by_refinement(
  `!s x y z. MEM x s /\ MEM y s /\ MEM z s ==>
    (indexf x y s = indexf x z s <=> (y = z))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `y = z` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[arith `a + b - c = (b-c) + a:num`];
  REPEAT (GMATCH_SIMP_TAC Ocbicby.MOD_EQ_MOD_SHIFT);
  REPEAT (GMATCH_SIMP_TAC MOD_LT);
  nCONJ_TAC 3;
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  ASM_REWRITE_TAC[Seq.index_mem;Seq.size_eq0];
  BY(ASM_MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let ifbetwn_indexf = prove_by_refinement(
  `!s x y z. MEM x s /\ MEM y s /\ MEM z s /\ uniq s ==>
    (MEM y (ifbetwn s x z) <=> 
       (0 < indexf x y s /\ indexf x y s <= indexf x z s))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `x = z` ASM_CASES_TAC THEN ASM_SIMP_TAC[MEM;Tame_list.indexf_refl];
    BY(ARITH_TAC);
  REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat;MEM];
  TYPIFY `y = z` ASM_CASES_TAC THEN ASM_REWRITE_TAC[arith `n <= n:num`];
    BY(ASM_MESON_TAC[arith `0 < n <=> ~(n=0)`;indexf0]);
  TYPIFY `~(indexf x y s = indexf x z s)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC indexf_inj;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC indexf_betwn_eq [`s`;`x`;`y`;`z`];
  ASM_SIMP_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let flatten_rot1 = prove_by_refinement(
  `!ss. ~(ss = []) ==>
    flatten (rot 1 ss) = rot (sizel (HD ss)) (flatten ss)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.rot1_cons;NOT_CONS_NIL;HD];
  REWRITE_TAC[Seq.flatten_cons;Seq.rot_size_cat;GSYM Seq.cats1];
  BY(REWRITE_TAC[Seq.flatten_cat;Aq1.flatten_sing])
  ]);;
  (* }}} *)

let flatten_rot = prove_by_refinement(
  `!k ss. ?k'. 
    flatten (rot k ss) = (rot k' (flatten ss))`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    GEN_TAC;
    BY(TYPIFY `0` EXISTS_TAC THEN REWRITE_TAC[Seq.rot0]);
  GEN_TAC;
  TYPIFY `ss = []` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[Seq.rot;Seq.flatten0;Seq.drop;Seq.take;Seq.cat0s]);
  REWRITE_TAC[arith `SUC k = 1 + k`];
  TYPIFY `1 + k <= sizel ss` ASM_CASES_TAC;
    GMATCH_SIMP_TAC Seq.rot_addn;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC flatten_rot1;
    ASM_SIMP_TAC[rot_eq_nil];
    FIRST_X_ASSUM (C INTRO_TAC [`ss`]) THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    BY(MESON_TAC[Seq2.rot_rot_eq_rot]);
  TYPIFY `0` EXISTS_TAC;
  BY(ASM_MESON_TAC[Seq.rot_oversize;arith `~(n <= s) ==> (s <= n:num)`;Seq.rot0])
  ]);;
  (* }}} *)

let rot_parts = prove_by_refinement(
  `!L N r p.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) ==>    
    (?k. take (sizel p) (rot k r) = p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  TYPIFY `MEM (HD p) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP]);
  TYPIFY `uniq (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Tame_list.uniq_parts]);
  TYPIFY `?k. HD (rot k (parts L r)) = p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.uniq_parts;Pwssrat.rotate_rot_indexl;Tame_list.hd_rotate_to]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC flatten_rot [`k`;`parts L r`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN GMATCH_SIMP_TAC parts_flatten;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `~(flatten (rot k (parts L r)) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[rot_eq_nil]);
  TYPIFY `k'` EXISTS_TAC;
  FIRST_X_ASSUM_ST `x = rot k' r` (SUBST1_TAC o GSYM);
  INTRO_TAC CONS_HD_TL [`(rot k (parts L r))`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Tame_list.parts_nonnil;rot_eq_nil]);
  DISCH_THEN SUBST1_TAC;
  ASM_REWRITE_TAC[Seq.flatten_cons];
  BY(ASM_MESON_TAC[Seq.take_size_cat])
  ]);;
  (* }}} *)

let mem_ifbetwn_hd_extend = prove_by_refinement(
  `!L N r p (x:A#A) y z.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) /\
    MEM x p /\
    MEM z r /\
    MEM y r /\
    ~(FST x = FST y) /\ ~(FST x = FST z) ==>
    (MEM y (ifbetwn r x z) <=> MEM y (ifbetwn r (HD p) z))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC ifbetwn_indexf);
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD p) r /\ MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_HD]);
  ASM_SIMP_TAC[];
  REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
  TYPIFY `~(indexf x y r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  TYPIFY `FST x = FST (HD p)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Tame_list.parts_fst;
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(indexf (HD p) y r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  ASM_REWRITE_TAC[];
  TYPIFY `!u. MEM u p ==> (FST u = FST (HD p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  TYPIFY `!u. MEM u r /\ ~(FST u = FST (HD p)) ==> indexf (HD p) u r = indexf (HD p) x r + indexf x u r` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_ASSUM (C INTRO_TAC [`y`]);
    FIRST_X_ASSUM (C INTRO_TAC [`z`]);
    DISCH_THEN GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_THEN GMATCH_SIMP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ARITH_TAC);
  COMMENT "u";
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC Tame_list.indexf_add_left;
  ASM_SIMP_TAC[];
  TYPIFY `~MEM u p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC rot_parts [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexf (HD p) x (rot k r) <= indexf (HD p) u (rot k r)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Reduction2.indexf_rotn_alt]);
  TYPIFY `HD p = HD (rot k r)` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC HD_take;
    BY(ASM_REWRITE_TAC[rot_eq_nil;Seq.size_eq0]);
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC indexf_hd);
  ASM_REWRITE_TAC[Seq.mem_rot];
  TYPIFY `rot k r = cat p  (dropl (sizel p) (rot k r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.cat_take_drop]);
  FIRST_ASSUM (SUBST1_TAC);
  REWRITE_TAC[Seq.index_cat];
  ASM_REWRITE_TAC[];
  TYPIFY `indexl x p <= sizel p` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(REWRITE_TAC[Seq.index_size])
  ]);;
  (* }}} *)

let mem_ifbetwn_tl_extend = prove_by_refinement(
  `!L N r p (x:A#A) y z.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) /\
    MEM z p /\
    MEM x r /\
    MEM y r /\
    ~(FST y = FST z) /\ ~(FST x = FST z) ==>
    (MEM y (ifbetwn r x z) <=> MEM y (ifbetwn r x (LAST p)))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC ifbetwn_indexf);
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) p /\ MEM (LAST p) r /\ MEM z r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST]);
  ASM_SIMP_TAC[];
  REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
  TYPIFY `(indexf x y r = 0)` asmcase
    BY(ASM_MESON_TAC[arith `0<=n`]);
    art[]
  TYPIFY `FST z = FST (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  TYPIFY `!u. MEM u p ==> (FST u = FST (LAST p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  typ `?k a b. HD(rot k r ) = x /\ (rot k r) = cat (cat a p) b` ets
  st/r
  typ `indexf x y (rot k r) <= indexf x z (rot k r) <=> indexf x y (rot k r) <= indexf x (LAST p) (rot k r)` ets
    BY(ASM_MESON_TAC[Reduction2.indexf_rotn_alt]);
  fast `HD` (sub1 o sym)
  REPEAT (GMATCH_SIMP_TAC indexf_hd);
  rt[Seq.mem_rot]
  art[]
  art[Seq.index_cat;Seq.mem_cat;Seq.size_cat]
  typ `~(MEM y p)` sat
  amt[]
  art[]
  typ `uniq (rot k r)` smp
  rt[Seq.rot_uniq] then art[]
  art[Seq.cat_uniq;sym Seq.hasP;Seq.mem_cat]
  st/r
  typ `~MEM z a /\ ~MEM (LAST p) a` sat
  amt[]
  art[]
  condcase then art[]
  asimp[Tame_list.indexl_LAST]
  intro Seq.index_mem [`y`;`a`] then art[] 
  ARITH_TAC
  intro Seq.index_mem [`z`;`p`] then art[] 
  asimp[Tame_list.indexl_LAST]
  ARITH_TAC

xxd


  typ `indexf x (LAST p) r = indexf x z r + indexf z (LAST p) r` ets
  ARITH_TAC
  TYPIFY `!u. MEM u r /\ ~(FST u = FST (HD p)) ==> indexf (HD p) u r = indexf (HD p) x r + indexf x u r` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_ASSUM (C INTRO_TAC [`y`]);
    FIRST_X_ASSUM (C INTRO_TAC [`z`]);
    DISCH_THEN GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_THEN GMATCH_SIMP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ARITH_TAC);
  COMMENT "u";
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC Tame_list.indexf_add_left;
  ASM_SIMP_TAC[];
  TYPIFY `~MEM u p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC rot_parts [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexf (HD p) x (rot k r) <= indexf (HD p) u (rot k r)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Reduction2.indexf_rotn_alt]);
  TYPIFY `HD p = HD (rot k r)` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC HD_take;
    BY(ASM_REWRITE_TAC[rot_eq_nil;Seq.size_eq0]);
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC indexf_hd);
  ASM_REWRITE_TAC[Seq.mem_rot];
  TYPIFY `rot k r = cat p  (dropl (sizel p) (rot k r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.cat_take_drop]);
  FIRST_ASSUM (SUBST1_TAC);
  REWRITE_TAC[Seq.index_cat];
  ASM_REWRITE_TAC[];
  TYPIFY `indexl x p <= sizel p` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(REWRITE_TAC[Seq.index_size])
  ]);;
  (* }}} *)



parts_fst;;
parts_uniq_nonnil;;
Aq8.MEM_PARTS_IMP;;
normal_list_list_of_darts;;
edge_nondeg_f_xor_ni;;
core_cat;;
f_last;;
loop_list;;
normal_list;;
rot_size_cat;;
core;;
parts_cat;;





UNFINISHED;;

