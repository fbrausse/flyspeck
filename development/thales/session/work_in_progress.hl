
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;


(* ............... NEW DEFS *)

let restricted_hypermaps_are_planegraphs = new_definition
  `restricted_hypermaps_are_planegraphs <=>
  (!Ln:((num)list)list. 
  good_list Ln /\ good_list_nodes Ln /\
  is_restricted (hypermap_of_list Ln) ==>
  (?gn. PlaneGraphs gn /\ 
     good_graph gn /\
     iso (hypermap_of_list Ln) (hypermap_of_list (fgraph gn))))`;;

let newvertex = new_definition'
  `newvertex L r (x:A#A) =
    (let f = find_face L x in
      let f' = rotate_to f x in
	MAP FST (filter (\d. ~MEM d r) f'))`;;

let newvertex_prepped = new_definition'
  `newvertex_prepped L (N:((num#num)list)list) r x <=>
  (final_list L r \/
      let n = sizel (undup (MAP FST (flatten N))) in
      let news = newvertex L r x in
	news = iota n (sizel news))`;;

(* 2014-04-07 planegraph -> planegraphP p, p-> p - 3,
   2014-04-09 remove planegraphP from concl, add marked_list hyp. *)

let generatePolygon_reduction = new_definition'
  `generatePolygon_reduction_v3 <=> (!L:((num)list)list N N' g p fs f v k r x.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
              ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) -3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      (r,x) = loop_choice g L N   /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k 
    ==>
      (?g' i. 
	 match_quotient_list g' L N' /\
	 // planegraphP p g' /\
	 3 <= i /\ i <= maxGon p /\
	 (!v. v IN vertices_set2 g'
              ==> facesAt g' v = FILTER (\f. MEM v (FST f)) (faces g')) /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  ))`;;

let next_g_exists = prove_by_refinement(
  `!L N g. ?next_g next_gon. 
    (let rx = loop_choice g L N in
     let           p = foldr maxn 0 (MAP sizel L) -3 in
     let  fs = nonFinals g in
     let f = minimalFace fs in
     let  v = minimalVertex g f in
     let  r = FST rx in
     let x = SND rx in
     let  k = transform_count L N r x in
     let  N' = ntrans L N r x k in
      (generatePolygon_reduction_v3 /\
	 good_list L /\
	 good_list_nodes L /\
	 is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
	  marked_list L N r x /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
          (!v. v IN vertices_set2 g
               ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
          vertices_set2 g = elements_of_list (fgraph g) ==>
      (match_quotient_list next_g L N' /\
                  // planegraphP p next_g /\
                   3 <= next_gon /\
                   next_gon <= maxGon p /\
                   (!v. v IN vertices_set2 next_g
                        ==> facesAt next_g v =
                            FILTER (\f. MEM v (FST f)) (faces next_g)) /\
                   vertices_set2 next_g = elements_of_list (fgraph next_g) /\
                   MEM next_g (generatePolygon next_gon v f g))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[RIGHT_EXISTS_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon_reduction_v3` MP_TAC THEN REWRITE_TAC[generatePolygon_reduction];
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    REWRITE_TAC[PAIR_EQ2];
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`g'`;`i`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

new_specification ["next_g_v3";"next_gon_v3"]
  (REWRITE_RULE[SKOLEM_THM] next_g_exists);;

(* ............... END NEW DEFS *)

let f_mono_pair = prove_by_refinement(
  `!(f:num->num) n. (!i. SUC i < n ==> f i <= f (SUC i)) ==>
    (!j i. i <= j /\ j < n ==> f i <= f j )`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  DISCH_TAC;
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `i = 0` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = SUC j` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
  MATCH_MP_TAC LE_TRANS;
  TYPIFY `f j` EXISTS_TAC;
  CONJ_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let f_mono_lt_pair = prove_by_refinement(
  `!(f:num->num) n. (!i. SUC i < n ==> f i < f (SUC i)) ==>
    (!j i. i < j /\ j < n ==> f i < f j )`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  DISCH_TAC;
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = SUC j` ASM_CASES_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `i = j` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[] THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
  MATCH_MP_TAC LT_TRANS;
  TYPIFY `f j` EXISTS_TAC;
  CONJ_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mem_enumAppend = prove_by_refinement(
  `!iss nmax a u. MEM a iss /\ LAST a <= u /\ u <= nmax ==>
    MEM (cat a [u]) (enumAppend nmax iss)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[enumAppend;Seq2.mem_flatten;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP (\n. APPEND a [n]) (upt (LAST a) (SUC nmax))` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP;Tame_defs.upt;lower_case];
  TYPIFY `u` EXISTS_TAC;
  REWRITE_TAC[];
  REWRITE_TAC[Seq.mem_iota];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let hd_cat = prove_by_refinement(
  `!a b. ~(a=[])==> HD (cat a b) = HD a`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL;HD;Seq.cat_cons])
  ]);;
  (* }}} *)

let hd_rcons = prove_by_refinement(
  `!t h. HD (rcons t h) = if (t=[]) then h else HD t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.rcons;HD];
  REWRITE_TAC[GSYM Seq.cats1];
  BY(MATCH_MP_TAC hd_cat THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let el_rcons = prove_by_refinement(
  `!t h i. i < sizel t ==> EL i (rcons t h) = EL i t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.cats1];
  INTRO_TAC Seq2.EL_nth [`h`];
  DISCH_THEN (REPEAT o GMATCH_SIMP_TAC);
  ASM_REWRITE_TAC[Seq.nth_cat;Seq.size_cat];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_rcons_size = prove_by_refinement(
  `!t h. EL (sizel t) (rcons t h) = h`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.cats1];
  INTRO_TAC Seq2.EL_nth [`h`];
  DISCH_THEN (REPEAT o GMATCH_SIMP_TAC);
  ASM_REWRITE_TAC[Seq.nth_cat;Seq.size_cat;arith `~(t:num < t)`;arith `n - n = 0`];
  CONJ_TAC;
    BY(REWRITE_TAC[Seq2.size1] THEN ARITH_TAC);
  REWRITE_TAC[Seq.nth0];
  GMATCH_SIMP_TAC Seq2.head_HD;
  REWRITE_TAC[HD;Seq2.size1];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_enumAppend_pow = prove_by_refinement(
  `!us k iss nmax a. MEM a iss /\ LAST a <= HD us /\ LAST us <= nmax /\
    (!i. SUC i < sizel us ==> EL i us <= EL (SUC i) us) /\ sizel us = k /\
      ~(k=0) ==>
      MEM (cat a us) ((enumAppend nmax POWER k) iss)`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC LISTR_INDUCT;
  CONJ_TAC;
    REWRITE_TAC[Seq.size;LENGTH];
    BY(MESON_TAC[]);
  REWRITE_TAC[Seq.size_rcons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?k'. SUC k' = k` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `PRE k` EXISTS_TAC;
    BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "k";
  TYPIFY `k' =0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[arith `SUC 0 = 1`];
    REWRITE_TAC[POWER_1];
    TYPIFY `sizel t = 0` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[Seq.size_eq0];
    DISCH_TAC THEN REPEAT (FIRST_X_ASSUM_ST `rcons` MP_TAC) THEN ASM_REWRITE_TAC[Seq.rcons;HD;LAST] THEN REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC mem_enumAppend;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.COM_POWER];
  RULE_ASSUM_TAC(REWRITE_RULE[LAST_rcons;arith `SUC i = SUC j <=> i = j`;arith `SUC i < SUC j <=> i < j`]);
  TYPIFY `~(t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[GSYM Seq.size_eq0] THEN ASM_REWRITE_TAC[]);
  TYPIFY `LAST (a:num list) <= HD t` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `HD` MP_TAC;
    BY(ASM_REWRITE_TAC[hd_rcons]);
  TYPIFY `LAST t <= h:num` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (C INTRO_TAC [`PRE (sizel t)`]);
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    TYPIFY `SUC (PRE k') = sizel t` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[el_rcons_size];
    GMATCH_SIMP_TAC el_rcons;
    CONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    TYPIFY `PRE k' = sizel t - 1` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[Seq.size] THEN GMATCH_SIMP_TAC (GSYM LAST_EL);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (cat a t) ((enumAppend nmax POWER k') iss)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    CONJ2_TAC;
      REPEAT WEAKER_STRIP_TAC;
      FIRST_X_ASSUM (C INTRO_TAC [`i`]);
      ASM_REWRITE_TAC[];
      SUBANTS_TAC;
        BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
      DISCH_TAC;
      REPEAT (GMATCH_SIMP_TAC el_rcons);
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_TAC THEN ARITH_TAC);
  ONCE_REWRITE_TAC[o_THM];
  REWRITE_TAC[GSYM Seq.rcons_cat];
  REWRITE_TAC[GSYM Seq.cats1];
  MATCH_MP_TAC mem_enumAppend;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC LAST_cat;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let LAST_TL = prove_by_refinement(
  `!xs. 2 <= sizel xs ==> LAST xs = LAST (TL xs)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(2 <= 0)`]);
  REWRITE_TAC[TL;LAST;Seq.size_cons;arith `2 <= SUC n <=> ~(n=0)`;Seq.size_eq0];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let BUTLAST_NIL = prove_by_refinement(
  `!xs. 1 < sizel xs ==> ~(BUTLAST xs = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.size;LENGTH;BUTLAST];
    BY(ARITH_TAC);
  REWRITE_TAC[lower_case;arith `1 < SUC n <=> ~(n=0)`;GSYM Seq.size_eq0;Seq.size_cons];
  DISCH_TAC THEN ASM_REWRITE_TAC[Seq.size_cons];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let size_tail = prove_by_refinement(
  `!xs. ~(sizel xs = 0) ==> sizel (TL xs) = sizel xs  - 1`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[Seq.size_eq0;TL;Seq.size_cons];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rcons_butlast = prove_by_refinement(
  `!xs. ~(xs = []) ==> (xs = rcons (butlast xs) (LAST xs))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REWRITE_TAC[LAST;Seq2.butlast];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.butlast];
    BY(REWRITE_TAC[Seq.rcons]);
  INTRO_TAC list_CASES [`t`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[Seq2.butlast];
  REWRITE_TAC[Seq.rcons];
  REWRITE_TAC[CONS_11];
  TYPIFY `t'=[]` ASM_CASES_TAC THEN ASM_REWRITE_TAC[LAST;Seq2.butlast;Seq.rcons];
  BY(FIRST_X_ASSUM_ST `rcons` MP_TAC THEN ASM_REWRITE_TAC[LAST])
  ]);;
  (* }}} *)

let EL_BUTLAST = prove_by_refinement(
  `!xs i. SUC i < sizel xs ==> EL i (BUTLAST xs) = EL i xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[BUTLAST;Seq.size_cons];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.size1;Seq.size_cons];
    BY(ASM_MESON_TAC[Seq.size_eq0;arith `~(SUC i < SUC 0)`]);
  REWRITE_TAC[EL_CONS];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)


let mem_enumerator = prove_by_refinement(
  `!xs inner outer.  
    sizel xs = inner /\ 3 <= inner /\ HD xs = 0 /\ LAST xs = outer - 1 /\
      (!i. SUC i < sizel xs ==> EL i xs <= EL (SUC i) xs) /\
      EL (inner - 2) xs <= outer - 2 ==> MEM xs (enumerator inner outer)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[enumerator;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  TYPIFY `BUTLAST (TL xs)` EXISTS_TAC;
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `LAST` (SUBST1_TAC o GSYM);
    TYPIFY `LAST xs  = LAST (TL xs)` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC LAST_TL;
      BY(ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC APPEND_BUTLAST_LAST;
    REWRITE_TAC[APPEND_SING];
    FIRST_X_ASSUM_ST `0` (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC (GSYM CONS_HD_TL);
    TYPIFY `sizel xs = LENGTH xs` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REWRITE_TAC[Seq.size]);
    TYPIFY `~(sizel xs = 0) /\ ~(LENGTH (TL xs) = 0)` (C SUBGOAL_THEN ASSUME_TAC);
      GMATCH_SIMP_TAC LENGTH_TL;
      REWRITE_TAC[GSYM Seq.size_eq0];
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0;Seq.size]);
  TYPIFY `inner = 3` ASM_CASES_TAC;
    ASM_REWRITE_TAC[arith `n - n = 0`;POWER_0;I_THM];
    INTRO_TAC Basics.LENGTH3 [`xs`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[Seq.size]);
    DISCH_THEN SUBST1_TAC;
    REWRITE_TAC[TL;BUTLAST;NOT_CONS_NIL];
    REWRITE_TAC[enumBase];
    REWRITE_TAC[MEM_MAP];
    REWRITE_TAC[CONS_11];
    TYPIFY `EL 1 xs` EXISTS_TAC;
    REWRITE_TAC[Tame_list.upt0;Seq.mem_iota];
    REWRITE_TAC[arith `0 <= n`];
    FIRST_X_ASSUM_ST `EL` MP_TAC THEN ASM_REWRITE_TAC[arith ` 3 - 2 = 1`];
    BY(ARITH_TAC);
  TYPIFY `sizel (BUTLAST (TL xs)) = inner - 2` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[GSYM Seq2.butlast_BUTLAST;Seq2.size_butlast];
    GMATCH_SIMP_TAC size_tail;
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC CONS_HD_TL [`BUTLAST (TL xs)`];
  SUBANTS_TAC;
    REWRITE_TAC[GSYM Seq.size_eq0];
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  DISCH_THEN SUBST1_TAC;
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  MATCH_MP_TAC mem_enumAppend_pow;
  nCONJ_TAC 5;
    BY(ASM_TAC THEN ARITH_TAC);
  nCONJ_TAC 4;
    GMATCH_SIMP_TAC size_tail;
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[LAST];
  REWRITE_TAC[GSYM EL];
  REWRITE_TAC[RIGHT_AND_FORALL_THM];
  GEN_TAC;
  TYPIFY `SUC i < inner - 3 ==> SUC (SUC i) < sizel (TL xs) /\ SUC (SUC (SUC i)) < sizel (TL xs)` (C SUBGOAL_THEN ASSUME_TAC);
    DISCH_TAC;
    REPEAT (GMATCH_SIMP_TAC size_tail);
    ASM_REWRITE_TAC[];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  ASM_SIMP_TAC[EL_BUTLAST];
  REPEAT (GMATCH_SIMP_TAC EL_BUTLAST);
  POP_ASSUM kill;
  TYPIFY_GOAL_THEN `SUC (SUC 0) < sizel (TL xs) /\  SUC 0 < sizel (TL xs)` (unlist REWRITE_TAC);
    REPEAT (GMATCH_SIMP_TAC size_tail);
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM_ST `3` MP_TAC) THEN ARITH_TAC);
  GMATCH_SIMP_TAC (GSYM LAST_TL);
  CONJ_TAC;
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM_ST `3` MP_TAC) THEN ARITH_TAC);
  GMATCH_SIMP_TAC LAST_EL;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[lower_case];
  GMATCH_SIMP_TAC EL_BUTLAST;
  CONJ_TAC;
    GMATCH_SIMP_TAC size_tail;
    BY(ASM_REWRITE_TAC[] THEN REPEAT (FIRST_X_ASSUM_ST `3` MP_TAC) THEN ARITH_TAC);
  REWRITE_TAC[EL_TL];
  NUM_REDUCE_TAC;
  REWRITE_TAC[arith `n + 1 = SUC n`];
  TYPIFY `SUC (inner - 2 - 1) = inner - 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(FIRST_X_ASSUM_ST `3 <= inner` MP_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    REWRITE_TAC[enumBase;MEM_MAP;Tame_list.upt0;Seq.mem_iota;CONS_11];
    TYPIFY `EL 1 xs` EXISTS_TAC;
    REWRITE_TAC[arith `0 <= n`];
    TYPIFY `EL 1 xs <= outer - 2` ENOUGH_TO_SHOW_TAC;
      BY(ARITH_TAC);
    INTRO_TAC f_mono_pair [`\i. EL i xs`;`sizel xs`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_THEN (C INTRO_TAC [`inner-2`;`1`]);
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(FIRST_X_ASSUM_ST `3 <= inner` MP_TAC THEN ARITH_TAC);
    BY(FIRST_X_ASSUM_ST `EL (inner-2)` MP_TAC THEN ARITH_TAC);
  CONJ_TAC;
    TYPIFY `2 = SUC 1` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ARITH_TAC);
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    BY(FIRST_X_ASSUM_ST `3 <= inner` MP_TAC THEN ARITH_TAC);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
   ]);;
  (* }}} *)

let iota_enumerator = prove_by_refinement(
  `!l. 3 <= l ==> MEM (iota 0 l) (enumerator (l) l)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_enumerator;
  ASM_REWRITE_TAC[Seq.size_iota];
  REWRITE_TAC[GSYM EL];
  REWRITE_TAC[RIGHT_AND_FORALL_THM;LEFT_AND_FORALL_THM];
  GEN_TAC;
  GMATCH_SIMP_TAC LAST_EL;
  REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  ASM_SIMP_TAC[el_iota;arith `SUC i < l ==> i < l`;arith `3 <= l ==> 0 < l`];
  REWRITE_TAC[GSYM Seq.size;Seq.size_iota];
  ASM_SIMP_TAC[el_iota;arith `3 <= l ==> l - 1 < l`;arith `3<=l ==> l-2 < l`];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let dart_neighbors = prove_by_refinement(
  `!g w v. 
    all (uniq) (fgraph g) /\
   (!v. v IN vertices_set2 g
              ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
         vertices_set2 g = elements_of_list (fgraph g) ==>
    (v IN (vertices_set2 g) /\
	      w IN set_of_list (neighbors g v) <=>
    MEM (v,w) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN_SET_OF_LIST;neighbors;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[EQ_EXPAND];
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    POP_ASSUM MP_TAC;
    GMATCH_SIMP_TAC nextVertex_next_el;
    POP_ASSUM MP_TAC;
    FIRST_X_ASSUM_ST `FILTER` GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MEM_FILTER];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC next_el_list_pairs_eq [`v`;`FST x`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;fgraph;MEM_MAP];
      DISCH_THEN MATCH_MP_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    MATCH_MP_TAC List_hypermap.dart_in_darts;
    REWRITE_TAC[fgraph;MEM_MAP];
    BY(ASM_MESON_TAC[]);
  TYPIFY` MEM v (list_of_elements (fgraph g))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.mem_list_of_elements];
    BY(ASM_MESON_TAC[]);
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
  REWRITE_TAC[Rxokskc.MEM_LIST_DARTS];
  ASM_SIMP_TAC[];
  REWRITE_TAC[MEM_FILTER;fgraph;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `(=)` (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "x";
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists]);
  DISCH_TAC;
  ASM_SIMP_TAC[nextVertex_next_el];
  MATCH_MP_TAC List_hypermap.mem_list_pairs_explicit;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[fgraph;GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let card_le_size = prove_by_refinement(
  `!s. CARD (set_of_list s) <= sizel s`,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `CARD (set_of_list s) = CARD (set_of_list (undup s))` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Seq2.set_of_list_undup]);
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  REWRITE_TAC[Seq.undup_uniq];
  BY(REWRITE_TAC[Seq.size_undup])
  ]);;
  (* }}} *)

let betwn_nil = prove_by_refinement(
  `!f a b. uniq f /\ ~(a = b) /\ MEM a f /\ MEM b f ==>
    (betwn f a b = [] <=> b = next_el f a)`,
  (* {{{ proof *)
  [
  SIMP_TAC[GSYM Seq.size_eq0;size_betwn];
  REWRITE_TAC[EQ_EXPAND];
  REPEAT STRIP_TAC;
    TYPIFY `~(indexf a b f = 0)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[indexf0]);
    TYPIFY `indexf a b f = 1` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[indexf1]);
  TYPIFY `indexf a b f = 1` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  MATCH_MP_TAC next_el_indexf;
  ASM_REWRITE_TAC[];
  TYPIFY `CARD (set_of_list f) > 1` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[card_le_size;arith `c > 1 /\ c <= s ==> 1 < s`]);
  MATCH_MP_TAC Counting_spheres.TWO_IMP_HAS_SIZE_GE_2;
  ASM_REWRITE_TAC[IN_SET_OF_LIST;FINITE_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let directedLength_next = prove_by_refinement(
  `!f a b. uniq (FST f) /\ MEM a (FST f) /\ MEM b (FST f) ==>
    (2 <= directedLength f a b /\ 2 <= directedLength f b a <=>
    ~(a = b) /\ ~(b = next_el (FST f) a) /\ ~(a = next_el (FST f) b))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[directedLength];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `a = b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  REWRITE_TAC[arith `2 <= l + 1 <=> ~(l = 0)`];
  REWRITE_TAC[GSYM Seq.size;Seq.size_eq0];
  BY(ASM_SIMP_TAC[betwn_nil])
  ]);;
  (* }}} *)

let duplicateEdge_next = prove_by_refinement(
  `!g f v w. uniq (FST f) /\ MEM v (FST f) /\ MEM w (FST f) /\
      MEM (FST f) (fgraph g) /\
       all (uniq) (fgraph g) /\
   (!v. v IN vertices_set2 g
              ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
         vertices_set2 g = elements_of_list (fgraph g)
    ==>
    (duplicateEdge g f v w <=>
       ~(v=w) /\ ~(w = next_el (FST f) v) /\ ~(v = next_el (FST f) w) /\
    MEM (v,w) (list_of_darts (fgraph g))       
    )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[duplicateEdge];
  REWRITE_TAC[CONJ_ASSOC];
  GMATCH_SIMP_TAC directedLength_next;
  ASM_REWRITE_TAC[];
  TYPIFY `v=w` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `~(w=next_el (FST f) v)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `~(v=next_el (FST f) w)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC dart_neighbors [`g`;`w`;`v`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  TYPIFY `w IN set_of_list (neighbors g v)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[List_hypermap.list_of_elements;Seq.mem_undup];
  BY(ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let containsUnacceptableEdgeSnd_explicit = prove_by_refinement(
  `!N e v. (!i. SUC i < sizel e ==> (EL i e <= EL (SUC i) e)) /\
     (~(e=[]) ==> ((v < HD e) <=> ~(v = HD e))) ==>
    (containsUnacceptableEdgeSnd N v e <=> 
    (2 <= sizel e /\ 
       (((~(v = HD e) /\ ~(HD e = EL 1 e) /\ N (HD e) (EL 1 e))) \/
    (?i. SUC (SUC i) < sizel e /\ ~(EL i e = EL (SUC i) e) /\
      ~(EL (SUC i) e = EL (SUC (SUC i)) e) /\ N (EL (SUC i) e) (EL (SUC (SUC i)) e)))))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[containsUnacceptableEdgeSnd];
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(2 <= 0)`]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.size1;arith `~(2 <= 1)`];
  REWRITE_TAC[LET_THM;HD;EL;TL;Seq.size_cons];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[EL];
    ASM_REWRITE_TAC[arith `2 <= SUC n <=> ~(n = 0)`;Seq.size_eq0];
    DISJ1_TAC;
    BY(ASM_SIMP_TAC[EL;arith `1 = SUC 0`;TL;arith `h < u:num ==> ~(h = u)`]);
  RULE_ASSUM_TAC (REWRITE_RULE[NOT_CONS_NIL;HD]);
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    ASM_REWRITE_TAC[EL;HD;TL;Seq.size_cons;arith `SUC 0 < SUC n <=> ~(n=0)`;Seq.size_eq0];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`SUC i`]);
    BY(ASM_REWRITE_TAC[EL;TL;Seq.size_cons;arith `SUC n < SUC m <=> n < m`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  COMMENT "size1";
  TYPIFY `sizel t  = 1` ASM_CASES_TAC;
    ASM_REWRITE_TAC[arith `~(2 <= 1)`;arith `2 <= SUC 1`;arith `~(SUC (SUC i) < SUC 1)`];
    ASM_REWRITE_TAC[arith `1 = SUC 0`;EL;TL;HD];
    REPEAT WEAKER_STRIP_TAC;
    BY(FIRST_X_ASSUM_ST ` ( /\ )` MP_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `2 <= sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `~(sizel t = 0)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_REWRITE_TAC[Seq.size_eq0]);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  TYPIFY `2 <= SUC (sizel t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  TYPIFY `~(h = HD t) /\ ~(HD t = EL 1 t) /\ N (HD t) (EL 1 t)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISJ2_TAC;
    TYPIFY `0` EXISTS_TAC;
    POP_ASSUM MP_TAC;
    ASM_SIMP_TAC[EL;TL;HD;arith `1 = SUC 0`];
    DISCH_TAC;
    BY(REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  TYPIFY `(?i. SUC (SUC i) < sizel t /\      ~(EL i t = EL (SUC i) t) /\      ~(EL (SUC i) t = EL (SUC (SUC i)) t) /\      N (EL (SUC i) t) (EL (SUC (SUC i)) t))` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    DISJ2_TAC;
    TYPIFY `SUC i` EXISTS_TAC;
    REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[EL;TL;HD];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[DE_MORGAN_THM];
  CONJ_TAC;
    FIRST_X_ASSUM_ST `a /\ N h (HD t)` MP_TAC;
    BY(ASM_SIMP_TAC[DE_MORGAN_THM;EL;TL;arith `1 = SUC 0`;HD]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i=0` ASM_CASES_TAC;
    POP_ASSUM (ASSUME_TAC o GSYM);
    FULL_EXPAND_TAC "i";
    FIRST_X_ASSUM_ST `N (HD t) (EL 1 t)` MP_TAC THEN REWRITE_TAC[];
    BY(REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[arith `1 = SUC 0`;HD;TL;EL]);
  TYPIFY `?j. i = SUC j` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `PRE i` EXISTS_TAC;
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "i";
  FIRST_X_ASSUM_ST `?i. P i` MP_TAC THEN REWRITE_TAC[];
  TYPIFY `j` EXISTS_TAC;
  REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[HD;TL;EL];
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let containsUnacceptableEdge_explicit = prove_by_refinement(
  `!N e. (!i. SUC i < sizel e ==> (EL i e <= EL (SUC i) e)) ==>
    (containsUnacceptableEdge N e <=> 
    (2 <= sizel e /\ 
       ((~(HD e = EL 1 e) /\ N (HD e) (EL 1 e)) \/
    (?i. SUC (SUC i) < sizel e /\ ~(EL i e = EL (SUC i) e) /\
      ~(EL (SUC i) e = EL (SUC (SUC i)) e) /\ N (EL (SUC i) e) (EL (SUC (SUC i)) e))))) `,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[containsUnacceptableEdge];
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(SUC i < 0)`;arith `~(2 <= 0)`]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.size1;arith `~(2 <= 1)`];
  REWRITE_TAC[LET_THM;HD;EL;TL;Seq.size_cons];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN REWRITE_TAC[GSYM Seq.size_eq0] THEN ARITH_TAC);
    DISJ1_TAC;
    ASM_REWRITE_TAC[arith `1 = SUC 0`;EL;TL;HD];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC containsUnacceptableEdgeSnd_explicit;
  nCONJ_TAC 0;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [ `SUC i`]);
    BY(ASM_SIMP_TAC[EL;TL;HD;Seq.size_cons;arith `SUC m < SUC n <=> m < n`]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    POP_ASSUM kill;
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    ASM_SIMP_TAC[EL;TL;HD;Seq.size_cons;arith `SUC 0 < SUC n <=> ~(n=0)`;Seq.size_eq0];
    BY(ARITH_TAC);
  DISCH_TAC;
  TYPIFY `~(2 <= SUC (sizel t))` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY_GOAL_THEN `~(2 <= sizel t)` (unlist REWRITE_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  ASM_REWRITE_TAC[];
  TYPIFY `~(2 <= sizel t)` ASM_CASES_TAC;
    TYPIFY `sizel t = 1` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    ASM_REWRITE_TAC[arith `~(SUC (SUC i) < SUC 1)`];
    ASM_SIMP_TAC[arith `1 = SUC 0`;EL;HD;TL];
    BY(ASM_MESON_TAC[]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  ASM_REWRITE_TAC[];
  (FIRST_X_ASSUM_ST `containsUnacceptableEdge` kill);
  TYPIFY `~(h = HD t) /\ ~(HD t = EL 1 t) /\ N (HD t) (EL 1 t)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISJ2_TAC;
    TYPIFY `0` EXISTS_TAC;
    POP_ASSUM MP_TAC;
    ASM_SIMP_TAC[EL;TL;HD;arith `1=SUC 0`];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  TYPIFY ` ~(h = EL 1 (h :: t)) /\ N h (EL 1 (h :: t))` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    POP_ASSUM MP_TAC;
    ASM_SIMP_TAC[arith `1 = SUC 0`;EL;TL;HD];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[EQ_EXPAND];
  REPEAT STRIP_TAC;
    TYPIFY `SUC i` EXISTS_TAC;
    BY(REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[EL;TL;HD;arith `SUC m < SUC n <=> m < n`]);
  TYPIFY `i=0` ASM_CASES_TAC;
    POP_ASSUM (ASSUME_TAC o GSYM);
    FULL_EXPAND_TAC "i";
    REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[arith `1 = SUC 0`;HD;TL;EL];
    BY(ASM_MESON_TAC[]);
  TYPIFY `?j. SUC j = i` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `PRE i` EXISTS_TAC;
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "i";
  TYPIFY `j` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN ASM_SIMP_TAC[HD;TL;EL;arith `SUC m < SUC n <=> m < n`])
  ]);;
  (* }}} *)

let size_showDups0 = prove_by_refinement(
  `!vs v. sizel (showDups0 v vs) = sizel vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[showDups0];
    BY(REWRITE_TAC[Seq.size;LENGTH]);
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.size_cons])
  ]);;
  (* }}} *)

let size_showDups = prove_by_refinement(
  `!vs. sizel (showDups vs) = sizel vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[showDups];
    BY(REWRITE_TAC[Seq.size;LENGTH]);
  BY(REWRITE_TAC[size_showDups0])
  ]);;
  (* }}} *)

let size_enum_of_VertexList = prove_by_refinement(
  `!v f vs. sizel (enum_of_VertexList f v vs) = sizel vs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[enum_of_VertexList;Seq.size_map;lower_case];
  BY(REWRITE_TAC[size_showDups])
  ]);;
  (* }}} *)

let hd_enum_of_vertexlist = prove_by_refinement(
  `!vs f v. ~(vs = []) /\ HD vs = SOME v /\ MEM v f
    ==> HD (enum_of_VertexList f v vs) = 0`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[enum_of_VertexList];
  REWRITE_TAC[showDups;showDups0];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC HD_MAP;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[HD;NOT_CONS_NIL];
    BY(ASM_MESON_TAC[HD;not_some_none]);
  RULE_ASSUM_TAC(REWRITE_RULE[HD]);
  ASM_REWRITE_TAC[the_some];
  MATCH_MP_TAC indexf_refl;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let showDups0_mono = prove_by_refinement(
  `!vs vs' f v w. uniq f /\ MEM v f /\
    vs' = MAP the (filter isSome vs) /\
    (!i. SUC i < sizel vs' ==> indexf v (EL i vs') f < indexf v (EL (SUC i) vs') f) /\ 
    (~(vs' = []) ==> indexf v w f <= indexf v (HD vs') f) ==>
    (!i. SUC i < sizel vs ==> 
       indexf v (EL i (showDups0 w vs)) f <= 
       indexf v (EL (SUC i) (showDups0 w vs)) f)
    `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[showDups0];
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Seq.filter_nil];
    BY(POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[Seq.size;LENGTH;arith `~(SUC n < 0)`]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM_ST `SUC` MP_TAC THEN ASM_MESON_TAC[Seq.size_cons;arith `SUC i < SUC n ==> ~(n=0)`;Seq.size_eq0]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MAP` MP_TAC THEN ASM_REWRITE_TAC[Seq.filter_cons;Ssrbool.isSome];
    ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN DISCH_TAC THEN FULL_EXPAND_TAC "vs'";
    TYPIFY `i=0` ASM_CASES_TAC;
      POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "i";
      REWRITE_TAC[EL;HD;TL];
      INTRO_TAC list_CASES [`t`] THEN ASM_REWRITE_TAC[];
      ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "t";
      REWRITE_TAC[showDups0];
      COND_CASES_TAC THEN ASM_REWRITE_TAC[HD];
        BY(ARITH_TAC);
      FIRST_X_ASSUM_ST `indexf` MP_TAC THEN REWRITE_TAC[Seq.filter_cons];
      ASM_REWRITE_TAC[not_isSome_NONE];
      GMATCH_SIMP_TAC HD_MAP;
      BY(REWRITE_TAC[MAP;HD;NOT_CONS_NIL]);
    TYPIFY `?j. SUC j = i` (C SUBGOAL_THEN MP_TAC);
      TYPIFY `PRE i` EXISTS_TAC;
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "i";
    REWRITE_TAC[EL;TL];
    REWRITE_TAC[GSYM EL];
    FIRST_X_ASSUM (C INTRO_TAC [`MAP the (filter isSome t)`;`f`;`v`;`w`]);
    ASM_REWRITE_TAC[];
    DISCH_THEN MATCH_MP_TAC;
    FIRST_X_ASSUM_ST `sizel` MP_TAC THEN ASM_SIMP_TAC[Seq.size_cons];
    BY((ARITH_TAC));
  FIRST_X_ASSUM_ST `MAP` MP_TAC THEN ASM_REWRITE_TAC[Seq.filter_cons;not_isSome_NONE];
  REWRITE_TAC[MAP];
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN DISCH_TAC THEN FULL_EXPAND_TAC "vs'";
  FIRST_X_ASSUM (C INTRO_TAC [`MAP the (filter isSome t)`;`f`;`v`;`the h`]);
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    CONJ2_TAC;
      DISCH_TAC;
      (FIRST_X_ASSUM (C INTRO_TAC [`0`]));
      ASM_REWRITE_TAC[Seq.size_cons;arith `SUC 0 < SUC n <=> ~(n=0)`;Seq.size_eq0];
      REWRITE_TAC[EL;HD;TL];
      BY(ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`SUC i'`]);
    REWRITE_TAC[EL;HD;TL];
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[Seq.size_cons];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `i > 0` ASM_CASES_TAC;
    TYPIFY `?j. SUC j = i` (C SUBGOAL_THEN MP_TAC);
      TYPIFY `PRE i` EXISTS_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "i";
    REWRITE_TAC[EL;HD;TL];
    REWRITE_TAC[GSYM EL];
    FIRST_X_ASSUM MATCH_MP_TAC;
    REPLICATE_TAC 3 (POP_ASSUM kill);
    FIRST_X_ASSUM_ST `sizel` MP_TAC;
    BY(REWRITE_TAC[Seq.size_cons] THEN ARITH_TAC);
  TYPIFY `0=i` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  FULL_EXPAND_TAC "i";
  REWRITE_TAC[EL;HD;TL];
  REPLICATE_TAC 4 (POP_ASSUM kill);
  FIRST_X_ASSUM_ST `MAP` (C INTRO_TAC [`0`]);
  REWRITE_TAC[EL;HD;TL;Seq.size_cons];
  FIRST_X_ASSUM_ST `indexf` kill;
  REWRITE_TAC[arith `SUC 0 < SUC n <=> ~(n = 0)`;Seq.size_eq0];
  DISCH_TAC;
  INTRO_TAC list_CASES [`t`] THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "t";
  REWRITE_TAC[showDups0];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[HD];
    BY(ARITH_TAC);
  FIRST_X_ASSUM_ST `MAP` MP_TAC;
  ASM_REWRITE_TAC[Seq.filter_cons;not_isSome_NONE;MAP;NOT_CONS_NIL];
  REWRITE_TAC[HD];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let enum_of_VertexList_mono = prove_by_refinement(
  `!vs vs' f v.  HD vs = SOME v /\
    uniq f /\ MEM v f /\
    vs' = MAP the (filter isSome vs) /\
    (!i. SUC i < sizel vs'
          ==> indexf v (EL i vs') f < indexf v (EL (SUC i) vs') f) ==>
    (!i. SUC i < sizel vs
      ==> EL i (enum_of_VertexList f v vs) <=
          EL (SUC i) (enum_of_VertexList f v vs))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[enum_of_VertexList];
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(SUC i < 0)`]);
  REWRITE_TAC[Seq.size_cons;showDups;showDups0];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[HD;not_some_none]);
  RULE_ASSUM_TAC(REWRITE_RULE[HD]);
  ASM_REWRITE_TAC[the_some];
  REPEAT (GMATCH_SIMP_TAC EL_MAP);
  ASM_REWRITE_TAC[lower_case;Seq.size_cons;size_showDups0];
  CONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[MAP];
  TYPIFY `i=0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[EL;HD;TL];
    ASM_SIMP_TAC[indexf_refl];
    BY(ARITH_TAC);
  TYPIFY `?j. SUC j = i` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `PRE i` EXISTS_TAC;
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "i";
  REWRITE_TAC[EL;HD;TL];
  REWRITE_TAC[GSYM EL];
  INTRO_TAC showDups0_mono [`t`;`MAP the (filter isSome t)`;`f`;`v`;`v`];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC indexf_refl;
  ASM_REWRITE_TAC[arith `0 <= n`];
  ANTS_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`SUC i`]);
    ASM_REWRITE_TAC[Seq.size_cons];
    ASM_REWRITE_TAC[Seq.size_cons;EL;HD;TL;MAP;Seq.filter_cons;Ssrbool.isSome];
    DISCH_THEN MATCH_MP_TAC;
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  DISCH_THEN MATCH_MP_TAC;
  BY(REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_showDups0 = prove_by_refinement(
  `!t v f h j. j < sizel t /\ isSome (EL j t) ==> 
    EL j (MAP (\u. indexf v u f) (showDups0 (the h) t)) = 
      indexf v (the (EL j t)) f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(j<0)`]);
  REWRITE_TAC[showDups0;Seq.size_cons] THEN REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  INTRO_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ] num_CASES) [`j`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "j" THEN ASM_REWRITE_TAC[] THEN FIRST_X_ASSUM_ST `isSome` MP_TAC THEN SIMP_TAC[EL;TL;HD;Ssrbool.isSome;MAP];
    DISCH_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_enum_of_vertex_list = prove_by_refinement(
  `!vs f v i. i < sizel vs /\ isSome (EL i vs) ==>
    EL i (enum_of_VertexList f v vs) = indexf v (the (EL i vs)) f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[enum_of_VertexList];
    BY(REWRITE_TAC[Seq.size;LENGTH;arith `~(i <0)`]);
  REWRITE_TAC[showDups;EL;TL;HD;Seq.size_cons;showDups0];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[COND_ID];
  INTRO_TAC num_CASES [`i`];
  DISCH_THEN DISJ_CASES_TAC;
    ASM_REWRITE_TAC[HD;EL];
    BY(ASM_REWRITE_TAC[HD;MAP;HD_MAP]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "i";
  TYPIFY `n` (RENAME_TAC "j");
  TYPIFY `EL (SUC j) (MAP (\u. indexf v u f) (if h = NONE  then the h :: showDups0 (the h) t  else the h :: showDups0 (the h) t)) = EL j  (MAP (\u. indexf v u f) (showDups0 (the h) t))` (C SUBGOAL_THEN SUBST1_TAC);
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[HD;TL;EL;MAP]);
  REWRITE_TAC[EL;TL;MAP];
  GMATCH_SIMP_TAC el_showDups0;
  ASM_TAC THEN SIMP_TAC[EL;TL];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let last_filter = prove_by_refinement(
  `!f xs.  ~(xs = []) /\ f (LAST xs) ==> LAST (filter f xs) = LAST xs`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC LISTR_INDUCT;
  BY(SIMP_TAC[LAST_rcons;Seq.filter_rcons])
  ]);;
  (* }}} *)

let enum_of_VertexList_enumerator = prove_by_refinement(
  `!vs vs' f (v:A) inner outer.
    2 <= sizel vs' /\
        2 <= outer /\
    sizel vs = inner /\
    sizel f = outer /\
    vs' = MAP the (filter (isSome) vs) /\
    3 <= inner /\
    uniq f /\          MEM v f /\
    image_hideDups vs /\
    HD vs = SOME v /\
    isSome (LAST vs) /\
    (!i. SUC i < sizel vs' 
       ==> indexf v (EL i vs') f < indexf v (EL (SUC i) vs') f) /\
    indexf v (the (LAST vs)) f  = outer  - 1 /\
    all (\t. MEM t f) vs' 
  ==>
    MEM (enum_of_VertexList f v vs) (enumerator inner outer)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `all (\t. MEM (the t) f) (filter isSome vs)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `all (\t. MEM (the t) f) (filter isSome vs) = all (\t. MEM t f) vs'` ENOUGH_TO_SHOW_TAC;
      BY(ASM_REWRITE_TAC[]);
    FIRST_X_ASSUM kill;
    ASM_REWRITE_TAC[GSYM Seq.allP];
    ASM_REWRITE_TAC[GSYM Seq.allP;Seq.mem_filter;MEM_MAP];
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC mem_enumerator;
  ASM_REWRITE_TAC[size_enum_of_VertexList];
  GMATCH_SIMP_TAC hd_enum_of_vertexlist;
  ASM_REWRITE_TAC[];
  INTRO_TAC enum_of_VertexList_mono [`vs`;`vs'`;`f`;`v`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  ASM_SIMP_TAC[GSYM Seq.size_eq0;arith `3 <= i ==> ~(i=0)`];
  SUBCONJ_TAC;
    FIRST_X_ASSUM_ST `outer-1` (SUBST1_TAC o GSYM);
    FIRST_X_ASSUM_ST `LAST` MP_TAC;
    REPEAT (GMATCH_SIMP_TAC LAST_EL) THEN REWRITE_TAC[lower_case];
    REWRITE_TAC[size_enum_of_VertexList;GSYM Seq.size_eq0];
    SUBCONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    DISCH_TAC;
    GMATCH_SIMP_TAC el_enum_of_vertex_list;
    ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  (DISCH_TAC)
    mmp (arith `2 <= out /\ a < out - 1 ==> a <= out - 2`)
  art[]
    fxast `indexf` mp
  fxa (sub1 o sym)
  dthen (sub1 o sym)
    typ `~(vs = [])` sat
  asimp[sym Seq.size_eq0;arith `3 <= i ==> ~(i=0)`]
  typ `~(filter isSome vs = [])` sat
  rt[List_hypermap.mem_not_nil]
  typ `HD vs` ex
  rt[Seq.mem_filter]
  art[Ssrbool.isSome]
  fxast `SOME v` (sub1 o sym)
  asimp[MEM_HD]
  intro last_filter [`isSome:(A)option -> bool`;`vs`]
  art[]  
  dthen (sub1 o sym)
  typ `LAST vs' = the (LAST (filter isSome vs))` smp
  art[]
  gm LAST_MAP
  art[]
  dthen (sub1 o sym)
  fxa (C intro [`sizel vs' - 2`])
  typ  `SUC (sizel vs'  - 2) = sizel vs' - 1 /\ SUC (sizel vs' - 2) < sizel vs'` sat
  fxast `2 <= sizel vs'` mp then ARITH_TAC
  pop mp then simp[]
  dt
  gm LAST_EL
  conj
  art[]
  art[MAP_EQ_NIL]   
  rt[lower_case]
  mmp (arith `e <= i2:num ==> (i2 < l ==> e < l)`)

xxd...need a lemma to this effect.


  ]);;
  (* }}} *)


LAST_EL;;
LAST_MAP;;
last_filter;;
enum_of_VertexList;;
xxd;;

let containsUnacceptableDuplicateEdge_explicit = prove_by_refinement(
  `!g f e v vs. 

    (!i. SUC i < sizel e ==> (EL i e <= EL (SUC i) e)) /\
    vs = indexToVertexList f v e /\
      MEM (FST f) (fgraph g) /\
       all (uniq) (fgraph g) /\
   (!v. v IN vertices_set2 g
              ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
         vertices_set2 g = elements_of_list (fgraph g)
  ==>
    (containsUnacceptableEdge
           (\i j.
                duplicateEdge g f (nextVertices f i v) (nextVertices f j v))
           e <=> X )`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let containsDuplicateEdge = prove_by_refinement(
  `!N e v vs. (!i. SUC i < sizel e ==> (EL i e <= EL (SUC i) e)) /\
  vs = indexToVertexList f v e ==>
    (~containsDuplicateEdge g f v e = X)`,
  (* {{{ proof *)
  [
  rt[containsDuplicateEdge]

  ]);;
  (* }}} *)


let enumeration_vertex_list = prove_by_refinement(
  `!n v f g vs vs'.
    vs' = MAP the (filter (isSome) vs) /\
    HD vs' = v /\
    isSome (HD vs) /\
    isSome (LAST vs) /\
    uniq (FST f) /\
    MEM v (FST f) /\
    image_hideDups vs /\
    all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
    (!i. SUC i < sizel vs' ==> indexf v (EL i vs') (FST f) < indexf v (EL (SUC i) vs') (FST f)) /\
    (!i. let d = (the (EL i vs),the (EL (SUC i) vs)) in
       isSome (EL i vs) /\ isSome (EL (SUC i) vs) /\
       SUC i < sizel vs /\ MEM d (list_of_darts (fgraph g)) ==>
	 MEM d (list_pairs (FST f)))
    ==>
    (?e. MEM e (enumerator n (LENGTH (FST f))) /\
       ~containsDuplicateEdge g f v e /\
       vs = indexToVertexList f v e)`,

  (* {{{ proof *)
  [
  st/r
  abbrev `e = enum_of_VertexList (FST f) v vs` 
  typ `e` ex
  nconj 2
  fexp "e"
  gm indexToVertexList_enum
  art[]
  art[]
  conj2
  rt[containsDuplicateEdge]
  fexp "e"
  rt[enum_of_VertexList]

  ...
  ]);;
  (* }}} *)

(* next: conditions on vs. st. *)

  `XX ==> MEM (subdivFace g f vs) (generatePolgon n v f g)`;;

(* if vs = full face, then MEM subdiv generatePolygon,
     and subdivFace = mk1face final on g. *)


good_graph;;
neighbors;;
nextVertices;;
duplicateEdge;;
containsUnacceptableEdge;;
showDups;;
image_hideDups;;

let oldvertex = prove_by_refinement(
  `!L N g.
    good_list L /\
    normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
    set_of_list (MAP FST (flatten N)) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_SIMP_TAC[quotient_list_elements])
  ]);;
  (* }}} *)

let set_of_list_newvertex = prove_by_refinement(
  `!L r x. good_list L /\ 
    MEM x (list_of_darts L) ==>
    set_of_list (newvertex L r x) = 
    IMAGE FST { t | MEM t (find_face L x) /\ ~MEM t r}`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex;LET_THM;EXTENSION;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_MAP;IN_IMAGE;IN_ELIM_THM];
  REWRITE_TAC[Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
  REWRITE_TAC[Seq.mem_rot];
  CONJ2_TAC;
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  MATCH_MP_TAC List_hypermap.uniq_find_face;
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let oldnew_vertex_disjoint = prove_by_refinement(
  `!L N r x. good_list L /\
    good_list_nodes L /\
    transform_assumption_v2 L /\
    marked_list L N r x 
    ==>
    set_of_list (MAP FST (flatten N)) INTER set_of_list (newvertex L r x)
    = {}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC set_of_list_newvertex;
  ASM_REWRITE_TAC[EXTENSION;IN_IMAGE;IN_ELIM_THM;IN_SET_OF_LIST;IN_INTER;NOT_IN_EMPTY];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x'' (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC;
    FIRST_X_ASSUM_ST `MAP` MP_TAC;
    ASM_REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC MEM_hypermap_of_list_node [`L`;`x''`;`x'''`];
    SUBANTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_mem_darts;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[marked_list]);
    TYPIFY `MEM x''' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      FIRST_ASSUM_ST `normal_list` (ASSUME_TAC o MATCH_MP normal_list_list_of_darts);
      BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    FIRST_ASSUM_ST `normal_list` MP_TAC;
    REWRITE_TAC[normal_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x'' IN node (hypermap_of_list L) x'''` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[lemma_node_identity;node_refl]);
    FIRST_X_ASSUM (C INTRO_TAC [`x'''`]);
    ANTS_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_flatten]);
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`x''`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  INTRO_TAC Obdatyb.OBDATYB [`L`;`N`;`r`;`x`;`x''`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let inj_on_union = prove_by_refinement(
  `!fs ft s t. inj_on fs s /\ inj_on ft t /\ 
    (s INTER t = {}) /\
    (!x y. x IN s /\ y IN t ==> ~(fs x = ft y)) ==> 
    (?f. inj_on f (s UNION t) /\ 
       (!x. x IN s ==> f x = fs x) /\ (!y. y IN t ==> f y = ft y))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `f = (\x. if (x IN s) then fs x else ft x)`;
  TYPIFY `f` EXISTS_TAC;
  nCONJ_TAC 1;
    FULL_EXPAND_TAC "f";
    BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `!y. y IN t ==> ~(y IN s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM_ST `INTER` MP_TAC THEN SET_TAC[]);
  nCONJ_TAC 2;
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "f";
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `inj_on` MP_TAC) THEN REWRITE_TAC[inj_on_ALT;IN_UNION];
  FULL_EXPAND_TAC "f" THEN REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let inj_on_union3 = prove_by_refinement(
  `!fs1 fs2 fs3 s1 s2 s3. inj_on fs1 s1 /\ inj_on fs2 s2 /\
    inj_on fs3 s3 /\
    (s1 INTER s2 = {}) /\ (s2 INTER s3 = {}) /\ (s1 INTER s3 = {}) /\
    (!x1 x2. x1 IN s1 /\ x2 IN s2 ==> ~(fs1 x1 = fs2 x2)) /\
    (!x1 x3. x1 IN s1 /\ x3 IN s3 ==> ~(fs1 x1 = fs3 x3)) /\
    (!x2 x3. x2 IN s2 /\ x3 IN s3 ==> ~(fs2 x2 = fs3 x3))
 ==> 
    (?f. inj_on f (s1 UNION s2 UNION s3) /\ 
       (!x1. x1 IN s1 ==> f x1 = fs1 x1) /\ 
       (!x2. x2 IN s2 ==> f x2 = fs2 x2) /\ 
       (!x3. x3 IN s3 ==> f x3 = fs3 x3))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union [`fs1`;`fs2`;`s1`;`s2`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union [`f`;`fs3`;`s1 UNION s2`;`s3`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_TAC THEN SET_TAC[]);
    REWRITE_TAC[IN_UNION];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM UNION_ASSOC;IN_UNION];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let INJ_inj_on = prove_by_refinement(
  `!f s t. INJ f s t ==> inj_on f s`,
  (* {{{ proof *)
  [
  SIMP_TAC[INJ;inj_on_ALT];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let set_of_list_iota_alt = prove_by_refinement(
  `!m n. set_of_list (iota m n) = {i | m <= i /\ i < m + n}`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST;Seq.mem_iota])
  ]);;
  (* }}} *)

let vertices_normal_list = prove_by_refinement(
  `!g L N. good_list L /\ normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
     (set_of_list (MAP FST (flatten N))) = 
	set_of_list (iota 0 (countVertices g))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM quotient_list_elements);
  TYPIFY `L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `quotient_list` (SUBST1_TAC o GSYM);
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  REWRITE_TAC[vertices_set2;vertices_graph;upt0];
  ]);;
  (* }}} *)

(* was card_vertices_set2 *)
(* let card_vertices_set2 = 0;; *)

let card_vertices_normal_list = prove_by_refinement(
  `!g L N. good_list L /\ normal_list L N /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) ==>
    CARD (set_of_list (MAP FST (flatten N))) = countVertices g`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC vertices_normal_list;
  TYPIFY `g` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  BY(REWRITE_TAC[Seq.size_iota;Seq.iota_uniq])
  ]);;
  (* }}} *)

let uniq_bij_map = prove_by_refinement(
  `!u v. sizel u = sizel v /\ uniq u /\ uniq v ==>
    (?f. BIJ f (set_of_list u) (set_of_list v) /\ v = MAP f u)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC uniq_inj_on [`u`;`v`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[SET_OF_LIST_MAP];
  MATCH_MP_TAC inj_on_BIJ;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let simple_list = prove_by_refinement(
  `!L u v x. 
    good_list L /\
    good_list_nodes L /\
    MEM x (list_of_darts L) /\
    MEM u (find_face L x) /\ MEM v (find_face L x) /\
    FST u = FST v /\
    all uniq L  ==>
    u = v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC good_face_rep [`L`;`find_face L x`];
  ANTS_TAC;
    ASM_SIMP_TAC[simple_hypermap_uniq];
    MATCH_MP_TAC List_hypermap.mem_find_face;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of_unique [`L`;`f0`;`FST u`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FULL_EXPAND_TAC "f0";
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
    TYPIFY `find_face L x = find_face L u` (C SUBGOAL_THEN SUBST1_TAC);
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[good_list]);
    BY(REWRITE_TAC[List_hypermap.find_face_alt;fst_list_pairs]);
  INTRO_TAC dart_of_unique [`L`;`f0`;`FST v`;`v`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FULL_EXPAND_TAC "f0";
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
    TYPIFY `find_face L x = find_face L v` (C SUBGOAL_THEN SUBST1_TAC);
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[good_list]);
    BY(REWRITE_TAC[List_hypermap.find_face_alt;fst_list_pairs]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let newvertex_uniq = prove_by_refinement(
  `!L r x. MEM x (list_of_darts L) /\
    good_list L /\
    good_list_nodes L /\
    all uniq L
  ==> uniq (newvertex L r x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  MATCH_MP_TAC uniq_map;
  GMATCH_SIMP_TAC Seq.filter_uniq;
  REWRITE_TAC[Seq.mem_filter];
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  REWRITE_TAC[Seq.mem_rot;Seq.rot_uniq];
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  ASM_SIMP_TAC[List_hypermap.uniq_find_face];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC simple_list;
  GEXISTL_TAC [`L`;`x`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let rotate_to_map = prove_by_refinement(
  `!phi f x. uniq f /\ MEM x f /\ inj_on phi (set_of_list f) ==>
    rotate_to (MAP phi f) (phi x) = MAP phi (rotate_to f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    CONJ_TAC;
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[lower_case];
    GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
    ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC THEN REWRITE_TAC[inj_on;IN_ELIM_SET_OF_LIST];
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC indexl_map;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[inj_on;IN_ELIM_SET_OF_LIST]);
  BY(REWRITE_TAC[lower_case;Seq.map_rot])
  ]);;
  (* }}} *)

let map_newvertex = prove_by_refinement(
  `!phi L r x. 
    good_list L /\
    MEM x (list_of_darts L) /\
    (set_of_list r SUBSET (darts_of_list L)) /\
    inj_on phi (elements_of_list L) ==>
    newvertex (MAP (MAP phi) L) 
    (MAP (\x. (phi (FST x)), (phi (SND x))) r)  (phi (FST x), phi (SND x)) 
      = MAP phi (newvertex L r x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex];
  REWRITE_TAC[LET_THM;GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC find_face_map;
  ASM_REWRITE_TAC[];
  INTRO_TAC (rotate_to_map) [`\d. phi (FST d),phi (SND d)`;`find_face L x`;`x`];
  REWRITE_TAC[];
  DISCH_THEN GMATCH_SIMP_TAC;
  GMATCH_SIMP_TAC List_hypermap.uniq_find_face;
  REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[good_list]);
  CONJ_TAC;
    MATCH_MP_TAC inj_on_subset;
    TYPIFY `darts_of_list L` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.darts_of_list];
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  REWRITE_TAC[lower_case;Seq.filter_map;Seq.preim];
  TYPED_ABBREV_TAC `l = rotate_to (find_face L x) x`;
  TYPIFY `filter  (\x. ~MEM (phi (FST x),phi (SND x)) (map (\x. phi (FST x),phi (SND x)) r)) l = filter (\d. ~MEM d r) l` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_in_filter);
    REWRITE_TAC[upper_case];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[EQ_EXPAND];
    REPEAT STRIP_TAC;
      FIRST_X_ASSUM_ST `MAP` MP_TAC;
      REWRITE_TAC[];
      TYPIFY `phi (FST x'),phi (SND x') = (\x. phi (FST x),phi (SND x)) x'` (C SUBGOAL_THEN SUBST1_TAC);
        BY(REWRITE_TAC[]);
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    POP_ASSUM MP_TAC;
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    DISCH_THEN (C INTRO_TAC [`x'`;`x''`]);
    ASM_REWRITE_TAC[];
    DISCH_THEN MP_TAC THEN ANTS_TAC;
      CONJ_TAC;
        REWRITE_TAC[List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
        REPLICATE_TAC 3 (FIRST_X_ASSUM_ST `MEM` MP_TAC);
        FULL_EXPAND_TAC "l";
        GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
        REWRITE_TAC[Seq.mem_rot];
        CONJ_TAC;
          GMATCH_SIMP_TAC List_hypermap.uniq_find_face;
          CONJ_TAC;
            BY(ASM_MESON_TAC[good_list]);
          BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
        BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
      FIRST_X_ASSUM_ST `SUBSET` MP_TAC THEN REWRITE_TAC[SUBSET;IN_SET_OF_LIST];
      BY(ASM_MESON_TAC[IN]);
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[upper_case;GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ;
  BY(REWRITE_TAC[lower_case;GSYM Seq.allP;o_THM])
  ]);;
  (* }}} *)

let FST_o_FST = prove_by_refinement(
  `!f g. FST o (\u. f (FST u),g u) = f o FST`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;o_THM])
  ]);;
  (* }}} *)

let map_vertices_normal_list = prove_by_refinement(
  `!N f.
    MAP FST (flatten (MAP (MAP (\u. f (FST u),f(SND u) )) N)) = 
    MAP f (MAP FST (flatten N))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[GSYM MAP_flatten;GSYM MAP_o;FST_o_FST])
  ]);;
  (* }}} *)

let final_list_snd_is_fst = prove_by_refinement(
  `!L N r d. final_list L r /\ 
    normal_list L N /\ all uniq L /\ MEM r N /\ MEM d r ==>
    MEM (SND d) (MAP FST (flatten N))
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[final_list];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC f_list_fst_snd [`L`;`d`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  MATCH_MP_TAC MEMf_MAP;
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `r` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `f_list` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Seq2.mem_next_el;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let match_quotient_list_map = prove_by_refinement(
  `!g L N f. 
   is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    good_list L /\ normal_list L N /\
   (!x. MEM x (MAP FST (flatten N)) ==> f x = x) /\
    inj_on f (elements_of_list L) ==>
    match_quotient_list g (MAP (MAP f) L) (MAP (MAP (\u. f (FST u),f (SND u))) N) = match_quotient_list g L N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso_list (L,N) (MAP (MAP f) L, (MAP (MAP (\u. f (FST u),f (SND u))) N))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[iso_list];
    BY(TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `(filter (final_list (MAP (MAP f) L)) (MAP (MAP (\u. f (FST u),f (SND u))) N)) = MAP (MAP (\u. f (FST u),f (SND u)) ) (filter (final_list L) N)` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[Seq.filter_map;lower_case;Seq.preim];
    AP_TERM_TAC;
    MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_in_filter);
    REWRITE_TAC[upper_case];
    GEN_TAC;
    DISCH_TAC;
    INTRO_TAC iso_list_final_list_eq [`L`;`MAP (MAP f) L`;`N`;`MAP (MAP (\u. f (FST u),f (SND u))) N`;`x`;`(MAP (\u. f (FST u),f (SND u)) x)`];
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[iso_list;CONS_11];
    BY(TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[CONS_11;MAP]);
  TYPIFY `quotient_list (MAP (MAP f) L) (MAP (MAP (\u. f (FST u),f (SND u))) N) = quotient_list L N` (C SUBGOAL_THEN SUBST1_TAC);
    INTRO_TAC isop_list_quotient [`f`;`L`;`N`;`MAP (MAP f) L`;`MAP (MAP (\u. f (FST u),f (SND u))) N`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[isop_list]);
    ASM_REWRITE_TAC[isop_list];
    DISCH_THEN (unlist REWRITE_TAC);
    TYPIFY `MAP (MAP f) (quotient_list L N) = MAP I (quotient_list L N)` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `MAP f x = MAP I x` ENOUGH_TO_SHOW_TAC;
        BY(SIMP_TAC[MAP_I;I_THM;upper_case]);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
      X_GENv_TAC "d";
      DISCH_TAC;
      TYPIFY `d IN (elements_of_list (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
        REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements;IN_SET_OF_LIST;Seq.mem_undup;Seq2.mem_flatten];
        BY(ASM_MESON_TAC[]);
      FIRST_X_ASSUM MP_TAC;
      GMATCH_SIMP_TAC quotient_list_elements;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
    BY(REWRITE_TAC[I_THM;MAP_I]);
  TYPIFY `fgraph g = quotient_list L N` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `(MAP (MAP (\u. f (FST u),f (SND u))) (filter (final_list L) N)) = MAP I (filter (final_list L) N)` (C SUBGOAL_THEN MP_TAC);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[GSYM MAP_I];
    REWRITE_TAC[upper_case];
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM];
    X_GENv_TAC "d";
    DISCH_TAC;
    INTRO_TAC final_list_snd_is_fst [`L`;`N`;`x`;`d`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(FIRST_X_ASSUM_ST `filter` MP_TAC THEN REWRITE_TAC[Seq.mem_filter]);
    DISCH_TAC;
    REWRITE_TAC[PAIR_EQ2];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    MATCH_MP_TAC MEMf_MAP;
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `x` EXISTS_TAC;
    BY(ASM_MESON_TAC[Seq.mem_filter]);
  REWRITE_TAC[MAP_I;I_THM];
  DISCH_THEN SUBST1_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let iso_list_newvertex_lemma = prove_by_refinement(
  `!L N r x g. 
    good_list L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    good_list_nodes L /\
    transform_assumption_v2 L /\
    marked_list L N r x /\
    match_quotient_list g L N /\
    vertices_set2 g = elements_of_list (fgraph g) 
   ==>
    (?L' N' r' x'. 
         iso_list (L,([x]::r::N)) (L',([x']::r'::N')) /\
	 match_quotient_list g L' N' /\
	 newvertex_prepped L' N' r' x')
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  INTRO_TAC oldnew_vertex_disjoint [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[iso_list];
  TYPED_ABBREV_TAC `s1 = set_of_list (MAP FST (flatten N))`;
  TYPED_ABBREV_TAC `s2 = set_of_list (newvertex L r x)`;
  TYPED_ABBREV_TAC `s3 = elements_of_list L DIFF (s1 UNION s2)`;
  TYPIFY `s1 INTER s3 = {} /\ s2 INTER s3 = {}` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN SET_TAC[]);
  TYPIFY `s1 SUBSET (elements_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s1";
    GMATCH_SIMP_TAC (GSYM quotient_list_elements);
    TYPIFY `L` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC elements_of_list_quotient_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(ASM_MESON_TAC[]);
  TYPIFY `s2 SUBSET (elements_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s2";
    ASM_SIMP_TAC[SUBSET;set_of_list_newvertex;IN_IMAGE;IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST];
    REWRITE_TAC[List_hypermap.mem_list_of_elements];
    TYPIFY `SND x''` EXISTS_TAC;
    ASM_REWRITE_TAC[GSYM PAIR];
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  TYPIFY `elements_of_list L = s1 UNION s2 UNION s3` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN SET_TAC[]);
  TYPED_ABBREV_TAC `fs1 = (I:num->num)`;
  TYPED_ABBREV_TAC `n = CARD s1`;
  COMMENT "redo here";
  TYPIFY `?fs2. BIJ fs2 s2 (set_of_list (iota n (CARD s2))) /\ iota n (CARD s2) =  MAP fs2 (newvertex L r x)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "s2";
    MATCH_MP_TAC uniq_bij_map;
    REWRITE_TAC[Seq.size_iota;Seq.iota_uniq];
    GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
    MATCH_MP_TAC newvertex_uniq;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "redone";
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `n' = CARD s1 + CARD s2`;
  TYPIFY `?fs3. BIJ fs3 s3 (set_of_list (iota n' (CARD s3)))` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Counting_spheres.BIJ_EXTENDS_INJ [`s3`;`set_of_list (iota n' (CARD s3))`;`{}:num->bool`;`fs1`];
    ASM_REWRITE_TAC[INJ_EMPTY];
    ANTS_TAC;
      CONJ_TAC;
        FULL_EXPAND_TAC "s3";
        MATCH_MP_TAC FINITE_DIFF;
        BY(REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST]);
      REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST];
      CONJ_TAC;
        BY(SET_TAC[]);
      GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
      REWRITE_TAC[Seq.size_iota];
      BY(REWRITE_TAC[Seq.iota_uniq]);
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC inj_on_union3 [`fs1`;`fs2`;`fs3`;`s1`;`s2`;`s3`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    CONJ_TAC;
      REWRITE_TAC[inj_on];
      FULL_EXPAND_TAC "fs1";
      BY(SIMP_TAC[I_THM]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[INJ_inj_on;BIJ]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[INJ_inj_on;BIJ]);
    RULE_ASSUM_TAC(REWRITE_RULE[set_of_list_iota_alt]);
    FULL_EXPAND_TAC "fs1" THEN REWRITE_TAC[I_THM];
    FULL_EXPAND_TAC "n'";
    FULL_EXPAND_TAC "n";
    FIRST_X_ASSUM_ST `flatten` MP_TAC;
    INTRO_TAC card_vertices_normal_list [`g`;`L`;`N`];
    ASM_REWRITE_TAC[];
    INTRO_TAC vertices_normal_list [`g`;`L`;`N`];
    ASM_REWRITE_TAC[];
    DISCH_THEN SUBST1_TAC;
    DISCH_TAC;
    DISCH_TAC;
    TYPIFY `!x1. x1 IN s1 ==> x1 < CARD s1` (C SUBGOAL_THEN ASSUME_TAC);
      FULL_EXPAND_TAC "s1";
      REWRITE_TAC[IN_SET_OF_LIST;Seq.mem_iota];
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    REPEAT (FIRST_X_ASSUM_ST `BIJ` MP_TAC) THEN REWRITE_TAC[BIJ;SURJ;IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    REPEAT CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
        TYPIFY `x1 < CARD s1 /\ CARD s1 <= fs2 x2` (C SUBGOAL_THEN MP_TAC);
          BY(ASM_MESON_TAC[]);
        BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
      TYPIFY `x1 < CARD s1 /\ CARD s1 + CARD s2 <= fs3 x3` (C SUBGOAL_THEN MP_TAC);
        BY(ASM_MESON_TAC[]);
      BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
    TYPIFY `fs2 x2 < CARD s1 + CARD s2 /\ CARD s1 + CARD s2 <= fs3 x3` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    BY(ASM_REWRITE_TAC[] THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP (MAP f) L` EXISTS_TAC;
  TYPED_ABBREV_TAC `nf = (\u. f (FST u),f (SND u))`;
  GEXISTL_TAC [`MAP (MAP nf) N`;`MAP nf r`;`nf x`];
  CONJ_TAC;
    TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[MAP;CONS_11];
    BY(FULL_EXPAND_TAC "nf" THEN REWRITE_TAC[]);
  COMMENT "newvertex_prepped";
  SUBCONJ2_TAC;
    REWRITE_TAC[newvertex_prepped];
    TYPIFY `final_list (MAP (MAP f) L) (MAP nf r)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    (REWRITE_TAC[LET_THM]);
    TYPIFY `sizel (undup (MAP FST (flatten N))) = n` (C SUBGOAL_THEN SUBST1_TAC);
      FULL_EXPAND_TAC "n";
      FULL_EXPAND_TAC "s1";
      GMATCH_SIMP_TAC (GSYM Seq2.card_set_of_list_uniq);
      REWRITE_TAC[Seq.undup_uniq];
      BY(REWRITE_TAC[Seq2.set_of_list_undup]);
    TYPIFY `newvertex (MAP (MAP f) L) (MAP nf r) (nf x) = MAP fs2 (newvertex L r x)` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM_ST `newvertex` (SUBST1_TAC o GSYM);
      REWRITE_TAC[Seq.size_iota];
      REWRITE_TAC[GSYM MAP_flatten;GSYM MAP_o;FST_o_FST];
      FULL_EXPAND_TAC "nf" THEN REWRITE_TAC[FST_o_FST];
      ASM_REWRITE_TAC[MAP_o];
      TYPIFY `sizel (undup (MAP f (MAP FST (flatten N)))) = n` (C SUBGOAL_THEN SUBST1_TAC) THEN REWRITE_TAC[];
      FULL_EXPAND_TAC "n";
      FULL_EXPAND_TAC "s1";
      GMATCH_SIMP_TAC (GSYM Seq2.card_set_of_list_uniq);
      REWRITE_TAC[Seq.undup_uniq];
      REWRITE_TAC[Seq2.set_of_list_undup];
      TYPIFY_GOAL_THEN `!u. set_of_list (MAP f u) = IMAGE f (set_of_list u)` (unlist REWRITE_TAC);
        BY(REWRITE_TAC[SET_OF_LIST_MAP]);
      ASM_REWRITE_TAC[];
      AP_TERM_TAC;
      REWRITE_TAC[EXTENSION;IN_IMAGE];
      BY(ASM_MESON_TAC[I_THM]);
    INTRO_TAC map_newvertex [`f`;`L`;`r`;`x`];
    FULL_EXPAND_TAC "nf";
    TYPIFY `MAP fs2 (newvertex L r x) = MAP f (newvertex L r x)` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MAP_EQ;
      REWRITE_TAC[lower_case;GSYM Seq.allP];
      REWRITE_TAC[GSYM IN_SET_OF_LIST];
      BY(ASM_MESON_TAC[]);
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
      BY(FIRST_X_ASSUM_ST `marked_list` MP_TAC THEN MESON_TAC[marked_list]);
    REWRITE_TAC[SUBSET;List_hypermap.darts_of_list;IN_SET_OF_LIST];
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  (DISCH_TAC);
  FULL_EXPAND_TAC "nf";
  GMATCH_SIMP_TAC match_quotient_list_map;
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "s1";
  FIRST_X_ASSUM_ST `flatten` MP_TAC;
  REWRITE_TAC[IN_SET_OF_LIST];
  FULL_EXPAND_TAC "fs1";
  BY(REWRITE_TAC[I_THM])
  ]);;
  (* }}} *)

let SHXWKXQ = iso_list_newvertex_lemma;;

let final_face_seed = prove_by_refinement(
  `!p. filter SND (faces (Seed p)) = [upt 0 (maxGon p),T]`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[SEED;graphl;LET_THM;faces;GRAPH;filter_rec])
  ]);;
  (* }}} *)

let face_iota = prove_by_refinement(
  `!L f. 
    all uniq L /\
    MEM f0 L ==>
    (?phi L'. isop_list phi (L,[]) (L',[]) /\ MAP phi f0 = iota 0 (sizel f0))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[isop_list;MAP];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC uniq_bij_map [`f0`;`iota 0 (sizel f0)`];
  REWRITE_TAC[Seq.size_iota;Seq.iota_uniq];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.allP]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Counting_spheres.INJ_EXTENSION [`elements_of_list L`;`0..(CARD (elements_of_list L))`;`set_of_list f0`;`f`];
  ANTS_TAC;
    REWRITE_TAC[FINITE_NUMSEG;CARD_NUMSEG];
    nCONJ_TAC 3;
      BY(ARITH_TAC);
    nCONJ_TAC 2;
      BY(REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST]);
    ASM_REWRITE_TAC[];
    TYPIFY `CARD (elements_of_list L) = sizel (list_of_elements L)` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[List_hypermap.elements_of_list];
      GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
      BY(REWRITE_TAC[List_hypermap.uniq_list_of_elements]);
    SUBCONJ2_TAC;
      REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.elements_of_list];
      REWRITE_TAC[List_hypermap.list_of_elements;Seq.mem_undup];
      BY(ASM_MESON_TAC[Seq2.mem_flatten]);
    DISCH_TAC;
    TYPIFY `CARD (set_of_list f0) <= CARD (elements_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC CARD_SUBSET;
      BY(ASM_REWRITE_TAC[]);
    TYPIFY `set_of_list (iota 0 (sizel f0)) SUBSET (0.. CARD (elements_of_list L))` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[set_of_list_iota_alt;SUBSET;IN_NUMSEG;IN_ELIM_THM];
      REPEAT WEAKER_STRIP_TAC;
      REWRITE_TAC[arith `0 <= x`];
      TYPIFY `CARD (set_of_list f0) = sizel f0` (C SUBGOAL_THEN ASSUME_TAC);
        MATCH_MP_TAC Seq2.card_set_of_list_uniq;
        BY(ASM_MESON_TAC[Seq.allP]);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM_ST `BIJ` MP_TAC THEN REWRITE_TAC[BIJ;INJ];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN SET_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`j`;`MAP (MAP j) L`];
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[INJ_inj_on]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP];
  BY(ASM_MESON_TAC[IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let is_restricted_size_face = prove_by_refinement(
  `!L f. good_list L /\ is_restricted (hypermap_of_list L) /\
     MEM f (list_of_faces L) ==> 3 <= sizel f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[is_restricted];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.mem_face_lemma[`f`;`L`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.card_face_of_list [`L`;`d`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let UYOUIXG = prove_by_refinement(
  `!L f .  is_restricted (hypermap_of_list L) /\
    all uniq L /\
    good_list L /\ 
    good_list_nodes L /\
    MEM f (list_of_faces L) 
    ==>
     (?L' N' r. iso_list (L,[f;r]) (L',N') /\
	normal_list L' N' /\ 
	match_quotient_list (Seed (sizel f -3)) L' N')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list;fgraph_seed;maxGon;final_face_seed];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MAP;o_THM;FST];
  REWRITE_TAC[set_of_list;SING_SUBSET;IN_SET_OF_LIST];
  INTRO_TAC face_rep [`L`;`f`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC face_iota [`L`;`f0`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `L'` EXISTS_TAC;
  FIRST_ASSUM_ST `isop_list` MP_TAC THEN REWRITE_TAC[isop_list] THEN REWRITE_TAC[MAP] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `good_list L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[map_good_list]);
  TYPIFY `iso_list (L,[]) (L',[])` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[iso_list;MAP];
    BY(ASM_MESON_TAC[]);
  TYPIFY `good_list_nodes L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_good_list_nodes]);
  TYPIFY `is_restricted (hypermap_of_list L')` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC iso_list_restricted [`L`;`L'`];
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[iso_list_sym_nil]);
  TYPIFY `~(f = [])` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f";
    ASM_REWRITE_TAC[List_hypermap.list_pairs_empty];
    BY(ASM_MESON_TAC[good_list;Seq.allP]);
  TYPIFY `MEM (HD f) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.list_of_darts_alt;Seq.mem_undup;Seq2.mem_flatten];
    TYPIFY `f` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[ MEM_HD]);
  INTRO_TAC Auqtzyz_list.AUQTZYZ_list [`L`;`f`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC[ `MAP (MAP (\u. phi (FST u),phi (SND u))) [f;r]`;`r`];
  SUBCONJ_TAC;
    REWRITE_TAC[iso_list];
    BY(TYPIFY `phi` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[iso_list_normal]);
  DISCH_TAC;
  TYPIFY `3 <= sizel f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted_size_face]);
  TYPIFY `sizel f - 3 + 3 = sizel f` (C SUBGOAL_THEN SUBST1_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  COMMENT "final_list";
  TYPIFY `sizel f = sizel f0` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f0";
    BY(REWRITE_TAC[Seq.size_map;lower_case]);
  TYPIFY `final_list (MAP (MAP phi) L) (MAP (\u. phi (FST u),phi (SND u)) f)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC iso_list_final_list [`L`;`L'`;`[f;r]`;`MAP (MAP (\u. phi (FST u),phi (SND u))) [f;r]`;`f`;`MAP (\u. phi (FST u),phi (SND u)) f`];
    ASM_REWRITE_TAC[MEM];
    DISCH_THEN MATCH_MP_TAC;
    ASM_SIMP_TAC[final_list_face];
    ASM_REWRITE_TAC[iso_list];
    BY(TYPIFY `phi` EXISTS_TAC THEN ASM_REWRITE_TAC[MAP;CONS_11]);
  CONJ_TAC;
    REWRITE_TAC[Seq.filter_cons;MAP];
    COND_CASES_TAC;
      REWRITE_TAC[MEM];
      DISJ1_TAC;
      ASM_REWRITE_TAC[upt0];
      FIRST_X_ASSUM_ST `iota` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[map_list_pairs]);
    PROOF_BY_CONTR_TAC THEN POP_ASSUM kill;
    BY(POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[]);
  COMMENT "quotient_list";
  ASM_REWRITE_TAC[];
  INTRO_TAC iso_list_quotient [`L`;`[f;r]`;`L'`;`MAP (MAP (\u. phi (FST u),phi (SND u))) [f;r]`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[is_restricted]);
  DISCH_TAC;
  INTRO_TAC iso_list_imp_dih2k [`quotient_list L [f;r]`;`quotient_list L' (MAP (MAP (\u. phi (FST u),phi (SND u))) [f;r])`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[dih2k_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `u = iota 0 (sizel f0)` ENOUGH_TO_SHOW_TAC;
    BY(DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[quotient_list_core];
  REWRITE_TAC[MAP;CONS_11];
  REPEAT WEAKER_STRIP_TAC;
  (FULL_EXPAND_TAC "u");
  GMATCH_SIMP_TAC final_list_core;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[is_restricted]);
  ASM_REWRITE_TAC[];
  TYPIFY `!u. MEM u f ==> darts_of_list L u` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
    REWRITE_TAC[List_hypermap.list_of_darts_alt;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_face]);
  nCONJ_TAC 1;
    REWRITE_TAC[lower_case] THEN GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
    INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[inj_on];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    REWRITE_TAC[GSYM Seq.allP];
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[List_hypermap.list_of_darts_alt;Seq.mem_undup;Seq2.mem_flatten];
    TYPIFY `MAP (\u. phi (FST u),phi (SND u)) f` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `MEM x' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST]);
    SUBCONJ2_TAC;
      TYPIFY_GOAL_THEN `(phi (FST (x')),phi (SND x')) = (\x. phi (FST x),phi (SND x)) (x')` SUBST1_TAC;
        BY(ASM_REWRITE_TAC[]);
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    TYPIFY `find_face L' (phi (FST (x')),phi (SND (x'))) = MAP (\u. phi (FST u),phi (SND u)) f` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN (SUBST1_TAC o GSYM);
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC List_hypermap.mem_find_face;
      REWRITE_TAC[map_list_of_darts];
      TYPIFY_GOAL_THEN `(phi (FST (x')),phi (SND (x'))) = (\x. phi (FST x),phi (SND x)) (x')` SUBST1_TAC;
        BY(REWRITE_TAC[]);
      (MATCH_MP_TAC MEMf_MAP);
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC find_face_map;
    (ASM_REWRITE_TAC[]);
    AP_TERM_TAC;
    GMATCH_SIMP_TAC List_hypermap.find_face_eq;
    ASM_SIMP_TAC[];
    BY(ASM_MESON_TAC[good_list]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM MAP_o;FST_o_FST];
  REWRITE_TAC[MAP_o];
  BY(ASM_REWRITE_TAC[MAP_o])
  ]);;
  (* }}} *)

let subdivFace0_final = prove_by_refinement(
  `!vos f g n hh. ( \ (f,g). makeFaceFinal f g) 
    (subdivFace0_alt g f hh n vos) = 
    subdivFace0 g f hh n vos`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[subdivFace0;subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT LET_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let subdivFaceFinal_eq = prove_by_refinement(
  `!vos g f. ~(vos = []) ==> subdivFace g f vos = subdivFaceFinal g f vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFaceFinal;subdivFace;LET_THM];
  GEN_TAC;
  REWRITE_TAC[RIGHT_FORALL_IMP_THM];
  DISCH_TAC;
  TYPIFY `?h vos'. vos = h::vos'` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[list_CASES]);
  WEAKER_STRIP_TAC;
  BY(ASM_REWRITE_TAC[HD;TL;subdivFace0_final])
  ]);;
  (* }}} *)

let hideDups_nil = prove_by_refinement(
  `!vv. hideDups vv = [] <=> vv = []`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[hideDups;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let indexToVertexList_nil = prove_by_refinement(
  `!f v is. indexToVertexList f v is = [] <=> is = []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexToVertexList;hideDups_nil];
  BY(REWRITE_TAC[MAP_EQ_NIL])
  ]);;
  (* }}} *)

let enumerator_nil = prove_by_refinement(
  `!x i n. MEM x (enumerator i n) ==> ~(x = [])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[enumerator;LET_THM;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[lower_case;Seq.cat1s;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let subdivFace0_alt_mem = prove_by_refinement(
  `!vs g f r n.  MEM f (faces g) ==> 
    (let fg' = subdivFace0_alt g f r n vs in
       MEM (FST fg') (faces (SND fg')))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM];
  LIST_INDUCT_TAC THEN ASM_SIMP_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  LET_TAC;
  LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT LET_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  INTRO_TAC MEM_splitFace2 [`g`;`r`;`v`;`f`;`ws`];
  ASM_REWRITE_TAC[];
  LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let filter_replace = prove_by_refinement(
  `!fs P f xs. ~(P f) /\ all (\x. ~(P x)) xs ==>
    filter P (replace f xs fs) =  (filter P fs)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;Seq.filter_nil;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[filter_rec;Seq.filter_cat];
    TYPIFY `filter P xs = []` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[Seq.cat0s]);
    TYPIFY `~(has P xs)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[Seq.has_filter]);
    REWRITE_TAC[GSYM Seq.hasP];
    BY(ASM_MESON_TAC[Seq.allP]);
  REWRITE_TAC[filter_rec];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[CONS_11];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let splitFace_finals = prove_by_refinement(
  `!g r v f ws. ~SND f ==>
    finals (SND (SND (splitFace g r v f ws))) = finals g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[splitFace;finals];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[faces_graph];
  FIRST_X_ASSUM_ST `split_face` MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  REWRITE_TAC[split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[];
  REWRITE_TAC[lower_case];
  REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "f1" THEN FULL_EXPAND_TAC "f2";
  REWRITE_TAC[Seq.filter_cat];
  REWRITE_TAC[FACE];
  REWRITE_TAC[filter_rec;Seq.cats0];
  GMATCH_SIMP_TAC filter_replace;
  ASM_REWRITE_TAC[GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let split_face_nonfinal1 = prove_by_refinement(
  `!f u v ws. (let f1,f2 = split_face f u v ws in ~(SND f1))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[split_face];
  LET_TAC THEN POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[FACE];
  BY(REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "f1" THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[])
  ]);;
  (* }}} *)

let split_face_nonfinal2 = prove_by_refinement(
  `!f u v ws. (let f1,f2 = split_face f u v ws in ~(SND f2))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[split_face];
  LET_TAC THEN POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[FACE];
  BY(REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "f2" THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[])
  ]);;
  (* }}} *)

let subdivFace0_alt_finals = prove_by_refinement(
  `!vs g f u n. MEM f (faces g) /\ ~SND f ==>
     (finals g) =  (finals (SND (subdivFace0_alt g f u n vs)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `finals g = finals g'` (C SUBGOAL_THEN SUBST1_TAC);
    FIRST_X_ASSUM_ST `splitFace` MP_TAC;
    ONCE_REWRITE_TAC[PAIR_EQ2];
    REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2] THEN REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "g'";
    BY(ASM_MESON_TAC[splitFace_finals]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  INTRO_TAC splitFace_split_face [`g`;`u`;`v`;`f`;`ws`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC split_face_nonfinal2 [`f`;`u`;`v`;`ws`];
  LET_TAC;
  DISCH_TAC;
  CONJ2_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[PAIR_EQ2]);
    RULE_ASSUM_TAC (REWRITE_RULE[]);
    ASM_SIMP_TAC[];
    DISCH_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`];
  ASM_REWRITE_TAC[] THEN LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let size_filter_replace_mono = prove_by_refinement(
  `!P xs x x'. MEM x xs /\ ~P x /\ P x' ==>
    sizel (filter P xs) < sizel (filter P (replace x [x'] xs))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;MEM;filter_rec];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[lower_case;Seq.cat1s;filter_rec;Seq.size_cons];
    BY(ARITH_TAC);
  REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[lower_case;Seq.cat1s;filter_rec;Seq.size_cons;arith `SUC m < SUC n <=> m < n`];
        BY(ASM_MESON_TAC[]);
      BY(ASM_MESON_TAC[]);
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let snd_setFinal = prove_by_refinement(
  `!f. SND (setFinal f)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;setFinal])
  ]);;
  (* }}} *)

let makeFaceFinal_mono = prove_by_refinement(
  `!g f. MEM f (faces g) /\ ~(SND f) ==>
    sizel (finals g) < sizel (finals (makeFaceFinal f g))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;finals;faces_graph;makeFaceFinalFaceList];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[lower_case];
  MATCH_MP_TAC size_filter_replace_mono;
  BY(ASM_REWRITE_TAC[snd_setFinal])
  ]);;
  (* }}} *)

let subdivFace0_alt_final = prove_by_refinement(
  `!vs g f h n. ~SND f ==> ~(SND (FST (subdivFace0_alt g f h n vs)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  INTRO_TAC splitFace_split_face [`g`;`h'`;`v`;`f`;`ws`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  INTRO_TAC split_face_nonfinal2 [`f`;`h'`;`v`;`ws`];
  LET_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let generatePolygon_mono = prove_by_refinement(
  `!i v g f fs g' p.
    planegraph g /\
    ~finalGraph g /\
    nonFinals g = fs /\
    minimalFace fs = f /\
    MEM g' (generatePolygon i v f g) ==>
    sizel (finals g) < sizel (finals g')
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[generatePolygon;LET_THM;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC subdivFaceFinal_eq;
  REWRITE_TAC[indexToVertexList_nil];
  SUBCONJ_TAC;
    MATCH_MP_TAC enumerator_nil;
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    BY(MESON_TAC[MEM_FILTER]);
  REWRITE_TAC[subdivFaceFinal];
  DISCH_TAC;
  LET_TAC;
  TYPED_ABBREV_TAC `vs = (TL (indexToVertexList f v x'))`;
  TYPED_ABBREV_TAC `h = (the (HD (indexToVertexList f v x')))`;
  INTRO_TAC subdivFace0_alt_finals [`vs`;`g`;`f`;`h`;`0`];
  SUBANTS_TAC;
    INTRO_TAC Dpzgbyf.mem_minimalFace_nonFinals [`g`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[finalGraph]);
    ASM_SIMP_TAC[];
    FIRST_X_ASSUM_ST `nonFinals` MP_TAC THEN REWRITE_TAC[nonFinals];
    DISCH_TAC THEN FULL_EXPAND_TAC "fs";
    REWRITE_TAC[MEM_FILTER];
    BY(SIMP_TAC[]);
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `x = a,b` MP_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  (REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[]);
  MATCH_MP_TAC makeFaceFinal_mono;
  INTRO_TAC subdivFace0_alt_mem [`vs`;`g`;`f`;`h`;`0`];
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[LET_THM];
  DISCH_THEN (unlist REWRITE_TAC);
  FULL_EXPAND_TAC "f'";
  MATCH_MP_TAC subdivFace0_alt_final;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let filter_nil = prove_by_refinement(
  `!P s. filter P s = [] <=> ~has P s`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.has_filter])
  ]);;
  (* }}} *)

let finalGraph_filter = prove_by_refinement(
  `!g. finalGraph g <=> (finals g = faces g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[finalGraph;finals;nonFinals;lower_case;Seq.all_filterP;filter_nil];
  REWRITE_TAC[GSYM Seq.allP;GSYM Seq.hasP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let size_flatten_le = prove_by_refinement(
  `!ss. all (\x. ~(x=[])) ss ==> sizel ss <= sizel (flatten ss)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_flatten;Seq.shape];
  LIST_INDUCT_TAC;
    REWRITE_TAC[upper_case;Seq.flatten0;MAP;sumn_cons;LENGTH;Seq.sumn0];
    BY(ARITH_TAC);
  REWRITE_TAC[Seq.map_MAP;Seq.size_cons;MAP];
  REWRITE_TAC[sumn_cons;Seq.all_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel h = 0)` ENOUGH_TO_SHOW_TAC;
    FIRST_X_ASSUM_ST `sumn` MP_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[upper_case] THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.size_eq0])
  ]);;
  (* }}} *)

let size_flatten_eq = prove_by_refinement(
  `!ss. all (\x. ~(x=[])) ss /\ sizel (flatten ss) = sizel ss ==>
    ss = MAP (\x. [x]) (flatten ss)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_flatten;Seq.shape];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0;MAP]);
  REWRITE_TAC[Seq.map_MAP;Seq.size_cons;MAP];
  REWRITE_TAC[sumn_cons;Seq.all_cons;Seq.flatten_cons];
  REWRITE_TAC[lower_case;Seq.map_cat];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[upper_case];
  FIRST_X_ASSUM_ST `flatten` (GMATCH_SIMP_TAC o GSYM);
  nCONJ_TAC 0;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC size_flatten_le [`t`];
  ASM_REWRITE_TAC[Seq.all_cons;Seq.flatten_cons;Seq.size_cons];
  REWRITE_TAC[Seq.size_cat];
  REWRITE_TAC[Seq.size_flatten;Seq.shape];
  DISCH_TAC;
  TYPIFY `sizel h <= 1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `0 < sizel h` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n <=> ~(n=0)`]);
  SUBCONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  REWRITE_TAC[lower_case];
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  REWRITE_TAC[Seq.cats0];
  AP_THM_TAC THEN AP_TERM_TAC;
  REWRITE_TAC[upper_case;MAP];
  TYPIFY `sizel h = 1` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq2.size1_eq];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[MAP])
  ]);;
  (* }}} *)

let poioj = prove_by_refinement(
  `!L N.
    good_list L /\
    normal_list L N /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    (!x. MEM x (MAP list_pairs (quotient_list L N)) ==>
      MEM x (filter (final_list L) N)) ==> 
    all (final_list L) N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[quotient_list_core;GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`list_pairs (core L x)`]);
  ANTS_TAC;
    REWRITE_TAC[ MEM_MAP;o_THM];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `list_pairs (core L x) = x` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `?d. MEM d x /\ MEM d (list_pairs (core L x))` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `uniq (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[normal_list]);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique]);
  INTRO_TAC parts_list_pairs [`L`;`N`;`x`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[core];
  TYPIFY `MAP (\x. FST (HD x)) (parts L x) = MAP (FST o HD) (parts L x)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(MATCH_MP_TAC MAP_EQ THEN REWRITE_TAC[lower_case;GSYM Seq.allP;o_THM]);
  DISCH_THEN SUBST1_TAC;
  TYPIFY `LAST (LAST (parts L x))` EXISTS_TAC;
  TYPIFY `uniq x /\ ~(x=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil;Seq.allP;Seq2.mem_flatten]);
  SUBCONJ2_TAC;
    MATCH_MP_TAC MEMf_MAP;
    MATCH_MP_TAC MEM_LAST;
    BY(ASM_MESON_TAC[parts_nonnil]);
  DISCH_TAC;
  TYPIFY `!d. MEM d (MAP LAST (parts L x)) ==> MEM d x` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `x = flatten (parts L x)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC MEM_LAST;
  BY(ASM_MESON_TAC[parts_uniq_nonnil])
  ]);;
  (* }}} *)

let match_quotient_list_finalGraph = prove_by_refinement(
  `!g L N. 
               good_list L /\
            normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            all uniq L /\
            connected_hypermap (hypermap_of_list L) /\
            ~(N = []) /\
    match_quotient_list g L N /\
    finalGraph g ==>  
     (hypermap_of_list (fgraph g)) =  (hypermap_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REWRITE_TAC[upper_case;GSYM finals];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC finalGraph_filter [`g`] THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `FILTER` MP_TAC THEN ASM_REWRITE_TAC[SUBSET;IN_SET_OF_LIST];
  ASM_REWRITE_TAC[MAP_o;GSYM fgraph];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC hypermap_of_quotient_list_final;
  ASM_REWRITE_TAC[];
  CONJ2_TAC;
    BY(ASM_REWRITE_TAC[upper_case]);
  MATCH_MP_TAC poioj;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[lower_case])
  ]);;
  (* }}} *)

let restricted_match_finalGraph = prove_by_refinement(
  `!g L N.
         good_list L /\
         good_list_nodes L /\
         normal_list L N /\
         is_restricted (hypermap_of_list L) /\
         match_quotient_list g L N /\
         finalGraph g /\
         ~(N = []) 
         ==> hypermap_of_list (fgraph g) = hypermap_of_list L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC match_quotient_list_finalGraph [`g`;`L`;`N`];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[is_restricted]);
  BY(ASM_MESON_TAC[simple_hypermap_uniq;is_restricted])
  ]);;
  (* }}} *)

let inj_on_list_of_faces = prove_by_refinement(
  `!L phi. inj_on phi (elements_of_list L) ==>
  list_of_faces (MAP (MAP phi) L) =
      MAP (MAP (\u. phi (FST u),phi (SND u))) (list_of_faces L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP;o_THM];
  BY(REWRITE_TAC[upper_case;map_list_pairs])
  ]);;
  (* }}} *)

let inj_on_list_of_darts = prove_by_refinement(
  `!L phi. inj_on phi (elements_of_list L) ==>
    list_of_darts (MAP (MAP phi) L) = 
      (MAP (\u. phi (FST u),phi(SND u)) (list_of_darts L))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_darts_alt];
  REWRITE_TAC[MAP_flatten];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  GMATCH_SIMP_TAC inj_on_list_of_faces;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let bounded_size_finals = prove_by_refinement(
  `!L. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) ==>
    (?n.  !g L' N'.
       iso_list (L,[]) (L',[]) /\
       normal_list L' N' /\
       match_quotient_list g L' N' ==>
       sizel (finals g) <= n)
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `n = sizel (list_of_darts L)`;
  TYPIFY `n` EXISTS_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel (list_of_darts L') = sizel (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `iso_list` MP_TAC;
    REWRITE_TAC[iso_list;MAP];
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[ inj_on_list_of_darts];
    BY(ASM_REWRITE_TAC[Seq.size_map;lower_case]);
  INTRO_TAC normal_list_size_bound [`L'`;`N'`];
  ASM_REWRITE_TAC[];
  TYPIFY `sizel (finals g) <= sizel N'` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  MATCH_MP_TAC LE_TRANS;
  TYPIFY `CARD (set_of_list (undup (filter (final_list L') N')))` EXISTS_TAC;
  CONJ2_TAC;
    GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
    REWRITE_TAC[Seq.undup_uniq];
    MATCH_MP_TAC LE_TRANS;
    TYPIFY `sizel (filter (final_list L') N')` EXISTS_TAC;
    REWRITE_TAC[Seq.size_undup];
    BY(REWRITE_TAC[GSYM Seq.count_filter;Seq.count_size]);
  MATCH_MP_TAC LE_TRANS;
  TYPIFY `CARD (set_of_list (MAP (list_pairs o FST) (filter SND (faces g))))` EXISTS_TAC;
  CONJ2_TAC;
    MATCH_MP_TAC CARD_SUBSET;
    BY(ASM_REWRITE_TAC[FINITE_SET_OF_LIST;Seq2.set_of_list_undup]);
  REWRITE_TAC[GSYM finals;upper_case];
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  REWRITE_TAC[lower_case;Seq.size_map;arith `n:num <= n`];
  REWRITE_TAC[finals];
  REWRITE_TAC[lower_case];
  GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
  GMATCH_SIMP_TAC Seq.filter_uniq;
  TYPIFY `good_list L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_good_list]);
  TYPIFY `iso_list (L',[]) (L,[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_sym_nil]);
  TYPIFY `is_restricted (hypermap_of_list L')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_restricted]);
  TYPIFY `good_list_nodes L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_good_list_nodes]);
  CONJ_TAC;
    INTRO_TAC Seq.map_uniq [`FST:((num)list)#bool->(num)list`];
    DISCH_THEN MATCH_MP_TAC;
    ASM_REWRITE_TAC[upper_case;GSYM fgraph];
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    MATCH_MP_TAC good_list_quotient;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[is_restricted;simple_hypermap_uniq]);
  REWRITE_TAC[Seq.mem_filter;o_THM];
  REWRITE_TAC[FORALL_PAIR_THM];
  SIMP_TAC[PAIR_EQ];
  BY(MESON_TAC[List_hypermap.list_pairs_inj])
  ]);;
  (* }}} *)

let maxn_MAX = prove_by_refinement(
  `maxn = MAX`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM;MAX;Ssrnat.maxn];
  BY(REPEAT WEAKER_STRIP_TAC THEN REPEAT COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let minimal_min_num = prove_by_refinement(
  `(minimal) = min_num`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM;minimal;min_num;IN];
  GEN_TAC;
  AP_TERM_TAC;
  REWRITE_TAC[FUN_EQ_THM];
  BY(MESON_TAC[arith `m < x:num <=> ~(x <= m)`])
  ]);;
  (* }}} *)

Counting_spheres.FINITE_MAX_EXISTS;;

let foldr_maxn_maximal = prove_by_refinement(
  `!xs n. MEM n xs /\ 0 <= n ==> n <= foldr maxn 0 xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.foldr;MEM];
  REPEAT STRIP_TAC;
    ASM_REWRITE_TAC[Ssrnat.maxn];
    BY(COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[Ssrnat.maxn];
  TYPIFY `n <= foldr maxn 0 t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
  BY(COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let foldr_maxn_exists = prove_by_refinement(
  `!xs. ~(xs = []) ==> (?n. MEM n xs /\ n = foldr maxn 0 xs)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.foldr;MEM;NOT_CONS_NIL];
  TYPIFY `~(t =[])` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `MEM` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    TYPIFY `maxn h n` EXISTS_TAC;
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Ssrnat.maxn];
    BY(ASM_MESON_TAC[]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  ASM_REWRITE_TAC[MEM;Seq.foldr;Ssrnat.maxn];
  TYPIFY `h` EXISTS_TAC;
  BY(REWRITE_TAC[arith `~(h < 0)`])
  ]);;
  (* }}} *)

let seed_finals = prove_by_refinement(
  `!p. finals (Seed p) = [iota 0 (maxGon p),T]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[SEED;finals;graphl;LET_THM;faces_graph];
  BY(REWRITE_TAC[FILTER;upt0])
  ]);;
  (* }}} *)

let seed_planeGraphP = 0;;

let seed_planegraphP = prove_by_refinement(
  `!p. planegraphP p (Seed p)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[planegraphP];
  BY(REWRITE_TAC[RTranCl_REFL])
  ]);;
  (* }}} *)

let max_finals_g_exists = prove_by_refinement(
  `!L p.      good_list L /\
     good_list_nodes L /\
     foldr maxn 0 (MAP sizel L) - 3 = p /\
     is_restricted (hypermap_of_list L) ==>
   (?g' L' N'.  
      match_quotient_list g' L' N' /\
      normal_list L' N' /\
      all uniq (quotient_list L' N') /\
      ~(N' = []) /\
      iso_list (L,[]) (L',[]) /\
        planegraphP p g' /\
          vertices_set2 g' = elements_of_list (fgraph g')  /\
   (!v. v IN vertices_set2 g'
              ==> facesAt g' v = FILTER (\f. MEM v (FST f)) (faces g')) /\    
   (!g'' L'' N''.
      match_quotient_list g'' L'' N'' /\
      normal_list L'' N'' /\
      all uniq (quotient_list L'' N'') /\
      ~(N'' = []) /\
      iso_list (L,[]) (L'',[]) /\
        planegraphP p g'' /\
          vertices_set2 g'' = elements_of_list (fgraph g'')  /\
   (!v. v IN vertices_set2 g''
              ==> facesAt g'' v = FILTER (\f. MEM v (FST f)) (faces g'')) ==>
   sizel (finals g'') <= sizel (finals g')))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `S = IMAGE (\ u. sizel (finals (FST u))) { (g',L',N') | match_quotient_list g' L' N' /\     normal_list L' N' /\  all uniq (quotient_list L' N') /\    ~(N' = []) /\     iso_list (L,[]) (L',[]) /\     planegraphP p g' /\     vertices_set2 g' = elements_of_list (fgraph g') /\     (!v. v IN vertices_set2 g'          ==> facesAt g' v = FILTER (\f. MEM v (FST f)) (faces g'))}`;
  INTRO_TAC Rogers.NUM_FINITE_IMP_MAX_EXISTS [`S`];
  TYPIFY `FINITE S /\ ~(S = {})` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    DISCH_THEN kill;
    FULL_EXPAND_TAC "S";
    POP_ASSUM kill;
    REWRITE_TAC[IN_IMAGE;IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`g'`;`L'`;`N'`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `/\` MP_TAC THEN ASM_REWRITE_TAC[];
    DISCH_THEN MATCH_MP_TAC;
    TYPIFY `g'',L'',N''` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    GEXISTL_TAC [`g''`;`L''`;`N''`];
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    FULL_EXPAND_TAC "S";
    MATCH_MP_TAC FINITE_SUBSET;
    INTRO_TAC bounded_size_finals [`L`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `0..n` EXISTS_TAC;
    REWRITE_TAC[FINITE_NUMSEG];
    REWRITE_TAC[SUBSET;IN_IMAGE;IN_ELIM_THM;IN_NUMSEG;arith `0 <= n`];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
  FULL_EXPAND_TAC "S";
  REWRITE_TAC[IN_ELIM_THM;IN_IMAGE];
  (COMMENT "seed exists");
  REBIND_TAC (`x:num`,"n");
  INTRO_TAC foldr_maxn_exists [`MAP sizel L`];
  REWRITE_TAC[MAP_EQ_NIL];
  ASM_REWRITE_TAC[MEM_MAP];
  ANTS_TAC;
    MATCH_MP_TAC is_restricted_nonnil;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "l");
  TYPIFY `sizel l -3 = p` (C SUBGOAL_THEN MP_TAC);
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "p";
    BY(MESON_TAC[]);
  REPLICATE_TAC 2 (POP_ASSUM kill);
  DISCH_TAC;
  TYPIFY `1` EXISTS_TAC;
  TYPED_ABBREV_TAC `f = list_pairs l`;
  INTRO_TAC UYOUIXG [`L`;`f`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ASM_MESON_TAC[is_restricted;simple_hypermap_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `g' = Seed (sizel f - 3)`;
  TYPIFY `g',L',N'` EXISTS_TAC;
  REWRITE_TAC[];
  SUBCONJ_TAC;
    FULL_EXPAND_TAC "g'";
    REWRITE_TAC[seed_finals];
    REWRITE_TAC[Seq.size;LENGTH];
    BY(ARITH_TAC);
  DISCH_TAC;
  GEXISTL_TAC [`g'`;`L'`;`N'`];
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "g'";
  COMMENT "add all uniq quot";
  CONJ_TAC;
    FIRST_X_ASSUM_ST `IMAGE` kill;
    FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC;
    REWRITE_TAC[match_quotient_list];
    BY(ASM_MESON_TAC[ all_uniq_seed]);
  nCONJ_TAC 4;
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC good_facesAt_seed;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  (REWRITE_TAC[good_vertices_set2_seed]);
  nCONJ_TAC 2;
    TYPIFY `sizel f - 3 = p` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[seed_planegraphP]);
    FULL_EXPAND_TAC "p";
    FULL_EXPAND_TAC "f";
    BY(REWRITE_TAC[List_hypermap.size_list_pairs]);
  ASM_REWRITE_TAC[];
  SUBCONJ2_TAC;
    FIRST_X_ASSUM_ST `iso_list` MP_TAC THEN REWRITE_TAC[iso_list;MAP];
    BY(MESON_TAC[]);
  DISCH_TAC;
  REPLICATE_TAC 2( FIRST_X_ASSUM_ST `iso_list` MP_TAC);
  REWRITE_TAC[iso_list;MAP] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MAP` kill;
  BY(FIRST_X_ASSUM_ST `MAP` MP_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL])
  ]);;
  (* }}} *)

let planegraph_P = prove_by_refinement(
  `!g. planegraph g <=> (?p. planegraphP p g)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[planegraph;planegraphP])
  ]);;
  (* }}} *)

let mem_minimalVertex = prove_by_refinement(
  `!g f. ~(FST f=[]) ==> MEM (minimalVertex g f) (FST f)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[minimalVertex];
  BY(MESON_TAC[mem_minimal_el])
  ]);;
  (* }}} *)

let minimalFace_face = prove_by_refinement(
  `!g. ~finalGraph g ==> MEM (minimalFace(nonFinals g)) (faces g)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Dpzgbyf.mem_minimalFace_nonFinals [`g`];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[finalGraph]);
  REWRITE_TAC[nonFinals;MEM_FILTER];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let minimalFace_nonnil = prove_by_refinement(
  `!g L N.
    good_list L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    normal_list L N /\
    match_quotient_list g L N /\ ~finalGraph g ==>
    ~(FST (minimalFace (nonFinals g)) = [])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[match_quotient_list];
  REWRITE_TAC[fgraph];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC minimalFace_face [`g`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (FST (minimalFace (nonFinals g))) (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `quotient_list` (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[MEM_MAP]);
  POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `good_list (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC good_list_quotient;
    BY(ASM_REWRITE_TAC[]);
  POP_ASSUM MP_TAC;
  REWRITE_TAC[good_list];
  REWRITE_TAC[GSYM Seq.allP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let next_el_list_pairs_eq = prove_by_refinement(
  `!x s. uniq s /\ MEM x s ==> MEM (x, next_el s x) (list_pairs s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.nth_index);
  REWRITE_TAC[GSYM Seq.index_mem];
  TYPIFY `sizel (zip s (rot 1 s)) = sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Seq.size_zip;Seq.size_rot;Ssrnat.minnn]);
  TYPIFY `indexl (x,next_el s x) (zip s (rot 1 s)) = indexl x s` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  TYPIFY `EL (indexl x s) (zip s (rot 1 s)) = (x,next_el s x)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (SUBST1_TAC o GSYM);
    MATCH_MP_TAC index_el;
    BY(ASM_MESON_TAC[List_hypermap.uniq_list_pairs;List_hypermap.list_pairs;Seq.index_mem]);
  GMATCH_SIMP_TAC Seq2.EL_nth;
  TYPIFY `x,x` EXISTS_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[PAIR_EQ];
  ASM_REWRITE_TAC[Seq.size_rot];
  GMATCH_SIMP_TAC Seq2.next_el_alt;
  BY(TYPIFY `x` EXISTS_TAC THEN ASM_REWRITE_TAC[Seq.index_mem])
  ]);;
  (* }}} *)

xxd

let not_containsDuplicateEdge_iota = prove_by_refinement(
  `!g f v. ~containsDuplicateEdge g f v (iota 0 (sizel (FST f)))`,
  (* {{{ proof *)
  [
  rt[containsDuplicateEdge]
  rt[containsUnacceptableEdge]
  ...
  ]);;
  (* }}} *)

containsUnacceptableEdge;;

let iota_generatePolygon = prove_by_refinement(
  `!g f v n. 
  (let vs = indexToVertexList f v (iota 0 (sizel (FST f))) in
    MEM (subdivFace g f vs) (generatePolygon (SUC (sizel (FST f))) v f g))`,
  (* {{{ proof *)
  [
  st/r then rt[generatePolygon]
  repeat LET_TAC
  rt[ETA_AX]
  mmp MEMf_MAP
  fexp "vertexLists"
  fexp "vs"
  rt[ETA_AX]
  mmp MEMf_MAP
  fexp "enumeration'"
  rt[MEM_FILTER]
  fexp "enumeration"
  ...
  ]);;
  (* }}} *)

generatePolygon;;
next_plane;;

(* we put ~final_list L r into the hypotheses.
   If ~finalGraph g /\ final_list L r, then we
  produce a matched list using a trivial_enumeration on generatePolygon
  enumeration
*)

let HKBGWJI = prove_by_refinement(
  `!L N r x g.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\
    ~(finalGraph g) /\
    ~final_list L r /\
    all uniq (quotient_list L N) /\
    all (\v. sizel (filter (MEM v) (quotient_list L N)) > 1) 
       (flatten (quotient_list L N)) /\
    flag_list L N /\
    match_quotient_list g L N /\
    (r,x) = loop_choice g L N ==>
  marked_list L N r x`,
  (* {{{ proof *)
  [
  rt[marked_list;LET_THM]
  st/r then art[]
  pop mp then rt[loop_choice] then repeat LET_TAC
  rt[PAIR_EQ]
  st/r
  fexp "r'"
  intro Dpzgbyf.mem_minimalFace_nonFinals [`g`]
  art[]
  subants
  amt[finalGraph]
  st/r
  intro mem_minimalVertex [`g`;`f`]
  typ `    is_edge_nondegenerate (hypermap_of_list L) /\     all uniq L` sat
  conj
  amt[is_restricted]
  amt[is_restricted;simple_hypermap_uniq]
   subants
  amt[minimalFace_nonnil]
  art[]
  st/r  
  fxast `nextVertex` mp
  asimp[nextVertex_next_el]
  dt
  intro next_el_list_pairs_eq [`v`;`FST f`]
  art[]
  fxast `LAST` (assume o sym)
  art[]

  typ `~*

xxd...
  ]);;
  (* }}} *)

flag_list;;
upt0;;
planegraphP;;
next_plane;;

generatePolygon_reduction;;
minimalFace;;
marked_list;;
flag_list;;
s_flag_list;;
loop_choice;;

let restricted_hypermaps_are_planegraphs_reduction1 = prove_by_refinement(
  `generatePolygon_reduction_v3  /\
    (!(L:((num)list)list). good_list L /\ good_list_nodes L ==>
  	   transform_assumption_v2 L) 
  ==>
    restricted_hypermaps_are_planegraphs`,
  (* {{{ proof *)
  [
  rt[restricted_hypermaps_are_planegraphs;planegraph_PlaneGraphs]
  st/r
  rt[good_graph;planegraph_P]
    typ `Ln` (name "L")
   abbrev `p = foldr maxn 0 (MAP sizel L) - 3`
  intro max_finals_g_exists [`L`;`p`]
  st/r
  fxa mp
  art[]
  st/r
  typ `g'` ex
  art[]
  typ `fgraph g' = quotient_list L' N'` sat
  amt[match_quotient_list]
  art[]
  nconj 0
  amt[]
  TYPIFY `good_list L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_good_list]);
  TYPIFY `iso_list (L',[]) (L,[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_sym_nil]);
  TYPIFY `is_restricted (hypermap_of_list L')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_restricted]);
  TYPIFY `good_list_nodes L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[iso_list_good_list_nodes]);
  typ `is_edge_nondegenerate (hypermap_of_list L')` sat
  amt[is_restricted] 
  typ `all uniq L'` sat
  amt[is_restricted;simple_hypermap_uniq]
  nconj 2
  mmp good_list_quotient
  art[]  
  art[]
  nconj 1
  mmp good_list_nodes_quotient  
  art[]
  art[]
  intro restricted_match_finalGraph [`g'`;`L'`;`N'`]
  art[]
  dthen gm
  gm GNBEVVU
  conj
  amt[]
  contr
  comment "now construct next step"
  fxast `generatePolygon_reduction_v3` mp
  rt[generatePolygon_reduction]
  dt
  abbrev `rx = loop_choice g' L' N'`
  intro iso_list_newvertex_lemma [`L'`;`N'`;`FST rx`;`SND rx`;`g'`]
  subants
  art[]
  subconj
  fxa mmp
  art[]
  dt
  .... xxd need HKBGWJI to continue.
  ]);;
  (* }}} *)



finalGraph;;
good_graph;;
normal_list_size_bound;;

let match_quotient_list_size = prove_by_refinement(
  `!g L N. match_quotient_list g L N ==> 
    sizel (filter SND (faces g)) <= sizel N`,
  (* {{{ proof *)
  [
  rt[match_quotient_list]
  ]);;
  (* }}} *)

match_quotient_list;;

1;;

(* then XZAJELF *)
(* come back *)




1;;
(* SET ASIDE A BIT:::: *)



(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)



(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)
