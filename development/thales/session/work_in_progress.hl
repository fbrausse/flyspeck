
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;


generatePolygon_reduction;;
generatePolygon;;

(* ............... NEW DEFS *)

(* May 11, 2014.  triple_data removed *)

let subdivFace_reduction = new_definition'
  `subdivFace_reduction_v2 <=> (!L N N' g g' p fs f v k r x uvns.
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
          marked_list L N r x /\
          ~final_list L r /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
          (!v. v IN vertices_set2 g
               ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          uvns = core_triple g L N /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          g' = subdivFaceFinal2 g f uvns
      ==>
      fgraph g' = quotient_list L N' /\ 
      vertices_set2 g' = elements_of_list (fgraph g') /\
      (!v. v IN vertices_set2 g'
       ==> facesAt g' v =
           FILTER (\f. MEM v (FST f)) (faces g'))

   )`;;

subdivFaceFinal2;;
generatePolygon;;
match_quotient_list;;

(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)

let subdivFace0_alt_next_el = prove_by_refinement(
  `!g f u  v w vos.
    isSome v /\ 
    nextVertex f u = (the v) ==>
    subdivFace0_alt g f u 0 (v:: vos) = 
    subdivFace0_alt g f (the v) 0 vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v:(num)option. isSome v ==> ~(v = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GSYM not_isSome_NONE]);
  BY(ASM_SIMP_TAC[LET_THM])
  ]);;
  (* }}} *)

let subdivFace0_alt_nil = prove_by_refinement(
  `!g f u n. subdivFace0_alt g f u n [] = f,g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt]
  ]);;
  (* }}} *)

(* XX HLT ? *)

let core_split_normal_list_concl = `!L N r x.
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    ~final_list L r 
  ==>
    (let y =  l'y L r x in
     let z = l'z L N r x in
     let z' =  prev_el r z in
     let f = find_face L y in
     let vs = core L r in 
     let newVs = MAP FST (betwn f y z) in
     let (f1,f2) = split_normal_list L r f y z' in
       core L f1 = cat (rev newVs) (cat [FST y] (cat (betwn vs (FST y) (FST z')) [FST z'])) /\
       core L f2 = cat (cat [FST z'] (cat (betwn vs (FST z') (FST y)) [FST y])) newVs)
`;;

g core_split_normal_list_concl;;
let csnlc = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  rt[split_normal_list]
  st/r
  repeat (LET_TAC orelse fxa mp)
  rt[PAIR_EQ;lower_case]
  st/r
  fexp "f1'"
  fexp "f2'"
  ]);;
  (* }}} *)

ntrans;;
transform_list;;
split_normal_list;;
split_face;;
subdivFace0;;
subdivFace;;
generatePolygon;;

let split_normal_list_split_list = prove_by_refinement(
  `!L N r x b. 
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    ~final_list L r ==> 
    (let y =  l'y L r x in
     let z = l'z L N r x in
     let z' =  prev_el r z in
     let f = find_face L y in
     let newVs = MAP FST (betwn f y z) in
     let (f1,f2) = split_normal_list L r f y z' in
     let vs = core L r in 
     let fvs = (core L r,b) in
       (core L f1 = cat (rev newVs) (cat [FST y] (cat (betwn vs (FST y) (FST z')) [FST z'])) /\
       core L f2 = cat (cat [FST z'] (cat (betwn vs (FST z') (FST y)) [FST y])) newVs) 
       ==> 
	 split_face fvs (FST y) (FST z') newVs = 
	   Face (core L f1) F,Face (core L f2) F)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[split_normal_list;split_face;lower_case];
  REPEAT (LET_TAC ORELSE FIRST_X_ASSUM_ST `LET_END` MP_TAC );
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY_GOAL_THEN `!a b. Face a F = Face b F <=> a = b` (unlist REWRITE_TAC);
    BY(ASM_REWRITE_TAC[FACE;PAIR_EQ]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "f2'";
  FULL_EXPAND_TAC "f1'";
  TYPIFY `vs' = vs` ENOUGH_TO_SHOW_TAC;
    BY(SIMP_TAC[]);
  FULL_EXPAND_TAC "vs'";
  FULL_EXPAND_TAC "vs";
  FULL_EXPAND_TAC "fvs";
  REWRITE_TAC[FST];
(*
  REWRITE_TAC[upper_case];
  MATCH_MP_TAC final_list_core;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[is_restricted]);
  TYPIFY `MEM y (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_lemma_yz_in_face]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `MEM y (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  TYPIFY `MEM f (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f";
    MATCH_MP_TAC List_hypermap.mem_find_face;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[List_hypermap.uniq_face]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[final_list_face]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[List_hypermap.list_of_darts_alt;Seq2.mem_flatten])
*)
  ]);;
  (* }}} *)

let transform_list_final_list_id = prove_by_refinement(
  `!L N r x. final_list L r ==> transform_list L x (N,r) = (N,r)`,
  (* {{{ proof *)
  [
  BY(SIMP_TAC[transform_list;LET_THM])
  ]);;
  (* }}} *)

let transform_list_pow_final_list_id = prove_by_refinement(
  `!i L N r x. final_list L r ==> (transform_list L x POWER i) (N,r) = (N,r)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[POWER_0;I_THM];
  BY(ASM_SIMP_TAC[POWER;o_THM;transform_list_final_list_id])
  ]);;
  (* }}} *)

let rtrans_final_prop = prove_by_refinement(
  `!L N r x i.
    marked_list L N r x /\ final_list L r ==> final_list L (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[rtrans];
  BY(ASM_SIMP_TAC[transform_list_pow_final_list_id])
  ]);;
  (* }}} *)

let iota_m_cat = prove_by_refinement(
  `!a b m. iota m (sizel a + sizel b) = cat a b ==> b = iota (m + sizel a) (sizel b)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.iota_add];
  REPEAT GEN_TAC;
  GMATCH_SIMP_TAC Seq.eqseq_cat;
  BY(SIMP_TAC[Seq.size_iota])
  ]);;
  (* }}} *)

let newvertex_prepped_transform = prove_by_refinement(
  `!L N r x.
    transform_assumption_v2 L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x ==>
    newvertex_prepped L (ntrans L N r x 1) (rtrans L N r x 1) x`,
  (* {{{ proof *)
  [
  rt[newvertex_prepped]
  rt[newvertex]
  st/r
  repeat (LET_TAC orelse (fxast `LET_END` mp))
  fexp "f'"
  typ `final_list L r` asmcase then art[] then st/r
  asimp[rtrans_final_prop]
  typ `final_list L (rtrans L N r x 1)` asmcase then art[]
  typ `n'` (name "m")
  typ `n` (name "m'")
  typ `news'` (name "vs")
  typ `news` (name "vs'")
  typ `?b. m' = m + sizel (b) /\ vs = cat b vs'` ets
  st/r then art[]
  mmp iota_m_cat
  fa (sub1 o sym)
  amt[Seq.size_cat]
  abbrev `b = iota m (sizel (betwn f (l'y L r x) (l'z L N r x)))` 
  typ `b` ex
  intro Lebhirj.LEBHIRJ [`L`;`N`;`ntrans L N r x 1`;`r`;`rtrans L N r x 1`;`x`]
  art[]
  dt
  typ `set_of_list (MAP FST (flatten N)) INTER set_of_list (MAP FST ((filter (\d. ~MEM d r) (rtrans L N r x 1)))) = {}` sat
  rt[EXTENSION;IN_SET_OF_LIST;NOT_IN_EMPTY;IN_INTER]
  gv "v"
  st/r
  intro Hojodcm.HOJODCM3 [`L`;`N`;`r`;`rtrans L N r x 1`;`x`;`v`]
  art[]
  dt
  fxast `filter` mp
  rt[MEM_MAP;Seq.mem_filter]
  st/r
xxd ...
  ]);;
  (* }}} *)


newvertex;;
newvertex_prepped;;


let subdivFace0_alt_next_el_k = prove_by_refinement(
  `!g f u  v w vos vos'.
    all (isSome) vos /\
    nextVertex f u = the (HD vos) /\
    (!i. i < ...
    all (nextVertex (
    nextVertex f u = (the v) ==>
    subdivFace0_alt g f u 0 (cat vos vos') = 
    subdivFace0_alt g f (the v) 0 vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v:(num)option. isSome v ==> ~(v = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GSYM not_isSome_NONE]);
  BY(ASM_SIMP_TAC[LET_THM])
  ]);;
  (* }}} *)

subdivFace0_alt;;

let subdivFace0_alt_none_segment = prove_by_refinement(
  `!g f u n vs.
    vs = cat vs' vs'' /\
    isSome v /\ isSome v3 /\
    vs' = v :: (rcons v2 v3) /\
    ~(v2 = []) /\
    all (\t. t = NONE) v2 ==>
    sbudivFace0_alt g f u 0 vs = 
	(let ws = iota (countVertices g) (n) in 
	 let f1,f2,g' = splitFace g u (the v3) f ws in
	   subdivFace0_alt g' f2 (the v3) 0 vs''`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let core_triple = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let subdivFaceFinal2_subdivFace = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  subdivFaceFinal2 g f uvns = subdivFaceFinal
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)

triple_data;;
subdivFace0_alt2;;
subdivFaceFinal2;;
subdivFace;;

let match_quotient_list_reduction = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET
         set_of_list (filter (final_list L) N')
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)

let subdivFace_generatePolygon_reduction = prove_by_refinement(
  `subdivFace_reduction_v2 /\    
    (!(L:((num)list)list). good_list L /\ good_list_nodes L ==>
  	   transform_assumption_v2 L) // AQ
  ==>
    generatePolygon_reduction_v4`,
  (* {{{ proof *)
  [
  rt[generatePolygon_reduction;subdivFace_reduction]
  st/r
  rep 7 (pop (mp o sym))
  st/r
  abbrev `uvns = core_triple g L N`
  abbrev `g' = subdivFaceFinal2 g f uvns`
  typ `g'` ex
  fxa (C intro [`L`;`N`;`N'`;`g`;`g'`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`])
  art[]
  simp[]
  st/r
  rt[generatePolygon]
  art[match_quotient_list]
  ]);;
  (* }}} *)

subdivFace_reduction;;
match_quotient_list;;


