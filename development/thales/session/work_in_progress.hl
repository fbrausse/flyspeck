
needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Work_in_progress = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;

(* ............... NEW DEFS *)

(* May 11, 2014.  triple_data removed *)

let subdivFace_reduction = new_definition'
  `subdivFace_reduction_v3 <=> 
  (!L N N' g g' p fs f v k r x uvns.
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
          marked_list L N r x /\
          ~final_list L r /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
	  good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          uvns = core_triple g L N /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          g' = subdivFaceFinal2 g f uvns
      ==>
      fgraph g' = quotient_list L N' /\ 
      vertices_set2 g' = elements_of_list (fgraph g') /\
      good_faces_v3 g')
   `;;

(* *************************************************************************** *)
(* WORK IN PROGRESS *)
(* *************************************************************************** *)

let subdivFace0_alt_next_el = prove_by_refinement(
  `!g f u  v w vos.
    isSome v /\ 
    nextVertex f u = (the v) ==>
    subdivFace0_alt g f u 0 (v:: vos) = 
    subdivFace0_alt g f (the v) 0 vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v:(num)option. isSome v ==> ~(v = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GSYM not_isSome_NONE]);
  BY(ASM_SIMP_TAC[LET_THM])
  ]);;
  (* }}} *)

let subdivFace0_alt_nil = prove_by_refinement(
  `!g f u n. subdivFace0_alt g f u n [] = f,g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt]
  ]);;
  (* }}} *)

(* XX HLT ? *)

let core_split_normal_list_concl = `!L N r x.
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    ~final_list L r 
  ==>
    (let y =  l'y L r x in
     let z = l'z L N r x in
     let z' =  prev_el r z in
     let f = find_face L y in
     let vs = core L r in 
     let newVs = MAP FST (betwn f y z) in
     let (f1,f2) = split_normal_list L r f y z' in
       core L f1 = cat (rev newVs) (cat [FST y] (cat (betwn vs (FST y) (FST z')) [FST z'])) /\
       core L f2 = cat (cat [FST z'] (cat (betwn vs (FST z') (FST y)) [FST y])) newVs)
`;;

let LET_PAIR = prove_by_refinement(
  `!f Q.
  (let (f1,f2) = f in Q f1 f2) <=> (let f1 = FST f in let f2 = SND f in Q f1 f2)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  ASM_TAC THEN REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let split_normal_list_split_list = prove_by_refinement(
  `!L N r x b. 
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    ~final_list L r ==> 
    (let y =  l'y L r x in
     let z = l'z L N r x in
     let z' =  prev_el r z in
     let f = find_face L y in
     let newVs = MAP FST (betwn f y z) in
     let (f1,f2) = split_normal_list L r f y z' in
     let vs = core L r in 
     let fvs = (core L r,b) in
       (core L f1 = cat (rev newVs) (cat [FST y] (cat (betwn vs (FST y) (FST z')) [FST z'])) /\
       core L f2 = cat (cat [FST z'] (cat (betwn vs (FST z') (FST y)) [FST y])) newVs) 
       ==> 
	 split_face fvs (FST y) (FST z') newVs = 
	   Face (core L f1) F,Face (core L f2) F)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[split_normal_list;split_face;lower_case];
  REPEAT (LET_TAC ORELSE FIRST_X_ASSUM_ST `LET_END` MP_TAC );
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY_GOAL_THEN `!a b. Face a F = Face b F <=> a = b` (unlist REWRITE_TAC);
    BY(ASM_REWRITE_TAC[FACE;PAIR_EQ]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "f2'";
  FULL_EXPAND_TAC "f1'";
  TYPIFY `vs' = vs` ENOUGH_TO_SHOW_TAC;
    BY(SIMP_TAC[]);
  FULL_EXPAND_TAC "vs'";
  FULL_EXPAND_TAC "vs";
  FULL_EXPAND_TAC "fvs";
  REWRITE_TAC[FST];
(*
  REWRITE_TAC[upper_case];
  MATCH_MP_TAC final_list_core;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[is_restricted]);
  TYPIFY `MEM y (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_lemma_yz_in_face]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `MEM y (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts]);
  TYPIFY `MEM f (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f";
    MATCH_MP_TAC List_hypermap.mem_find_face;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[List_hypermap.uniq_face]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[final_list_face]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[List_hypermap.list_of_darts_alt;Seq2.mem_flatten])
*)
  ]);;
  (* }}} *)

let transform_list_final_list_id = prove_by_refinement(
  `!L N r x. final_list L r ==> transform_list L x (N,r) = (N,r)`,
  (* {{{ proof *)
  [
  BY(SIMP_TAC[transform_list;LET_THM])
  ]);;
  (* }}} *)

let transform_list_pow_final_list_id = prove_by_refinement(
  `!i L N r x. final_list L r ==> (transform_list L x POWER i) (N,r) = (N,r)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[POWER_0;I_THM];
  BY(ASM_SIMP_TAC[POWER;o_THM;transform_list_final_list_id])
  ]);;
  (* }}} *)

let rtrans_final_prop = prove_by_refinement(
  `!L N r x i.
    marked_list L N r x /\ final_list L r ==> final_list L (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[rtrans];
  BY(ASM_SIMP_TAC[transform_list_pow_final_list_id])
  ]);;
  (* }}} *)

let iota_m_cat = prove_by_refinement(
  `!a b m. iota m (sizel a + sizel b) = cat a b ==> b = iota (m + sizel a) (sizel b)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.iota_add];
  REPEAT GEN_TAC;
  GMATCH_SIMP_TAC Seq.eqseq_cat;
  BY(SIMP_TAC[Seq.size_iota])
  ]);;
  (* }}} *)

let ntrans_id = prove_by_refinement(
  `!L N r x. final_list L r ==> ntrans L N r x 1 = N`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[ntrans;transform_list_final_list_id;POWER_1])
  ]);;
  (* }}} *)

let rtrans_id = prove_by_refinement(
  `!L N r x. final_list L r ==> rtrans L N r x 1 = r`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[rtrans;transform_list_final_list_id;POWER_1])
  ]);;
  (* }}} *)

let rtrans_cat = prove_by_refinement(
  `!L N r x.
    ~final_list L r /\ uniq r ==>
    (let y = l'y L r x in
     let z = l'z L N r x in
     let f = find_face L y in
       rtrans L N r x 1 = cat (cat (cat [z] (betwn r z y)) [y]) (betwn f y z))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[rtrans;POWER_1;transform_list];
  REPEAT LET_TAC;
  FULL_EXPAND_TAC "y";
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "split";
  REWRITE_TAC[split_normal_list];
  REPEAT LET_TAC;
  REWRITE_TAC[];
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "new2";
  REWRITE_TAC[lower_case];
  REWRITE_TAC[Seq.catA];
  TYPIFY `ram2' = z` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "ram2'";
  FULL_EXPAND_TAC "ram2";
  TYPIFY `z' = z` ((C SUBGOAL_THEN SUBST1_TAC));
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC Seq2.next_prev_id;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let find_face_x_eq_y = prove_by_refinement(
  `!L N r x.
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r ==>
    find_face L (l'y L r x) = find_face L x `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_lemma_yz_in_face [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let mem_y_r = prove_by_refinement(
  `!L N r x. good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r ==>
     MEM (l'y L r x) r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hojodcm.ytrans_mem_rtrans_v0 [`L`;`N`;`r`;`x`];
  BY(ASM_REWRITE_TAC[ytrans;rtrans;POWER_0;I_THM])
  ]);;
  (* }}} *)

let mem_z_r = prove_by_refinement(
  `!L N r x. good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r ==>
     MEM (l'z L N r x) r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hojodcm.mem_ztrans_rtrans_v0  [`L`;`N`;`r`;`x`];
  BY(ASM_REWRITE_TAC[ztrans;rtrans;ntrans;POWER_0;I_THM])
  ]);;
  (* }}} *)

let rtrans_diff_r = prove_by_refinement(
  `!L N r x. 
   good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r ==>
    filter (\d. ~MEM d r) (rtrans L N r x 1) = betwn (find_face L x) (l'y L r x) (l'z L N r x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC rtrans_cat [`L`;`N`;`r`;`x`];
  REPEAT LET_TAC;
  TYPIFY `uniq r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REWRITE_TAC[Seq.filter_cat];
  REWRITE_TAC[Seq.filter_cons;Seq.filter_nil];
  INTRO_TAC find_face_x_eq_y [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  DISCH_THEN (ASSUME_TAC o GSYM);
  INTRO_TAC marked_lemma_yz_in_face [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM z r /\ MEM y r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_y_r;mem_z_r]);
  ASM_REWRITE_TAC[Seq.cat0s;Seq.cats0];
  TYPIFY `filter (\d. ~MEM d r) (betwn r z y) = []` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[filter_nil;GSYM Seq.hasP];
    BY(MESON_TAC[betwn_mem]);
  REWRITE_TAC[Seq.cat0s];
  REWRITE_TAC[Seq.all_filterP];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq1.betwn_not_in_rtrans) [`f`;`x'`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[ytrans;ztrans;rtrans;ntrans;POWER_0;I_THM])
  ]);;
  (* }}} *)

let cat_eq = prove_by_refinement(
  `!a b c d. a = c /\ b = d ==> cat a b = cat c d`,
  (* {{{ proof *)
  [
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rotate1_rcons = prove_by_refinement(
  `!x. ~(x=[]) ==> rotate1 x = rcons (TL x) (HD x)`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[rotate1;lower_case;TL;HD;Seq.cats1])
  ]);;
  (* }}} *)

let betwn_rot = prove_by_refinement(
  `!x y s n. uniq s /\ MEM x s /\ MEM y s /\ ~(x = y) /\ n <= sizel s
  ==> betwn s x y = betwn (rot n s) x y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_from_nth);
  TYPIFY `HD s` EXISTS_TAC;
  SUBCONJ_TAC;
    REPEAT (GMATCH_SIMP_TAC Tame_list.size_betwn);
    ASM_REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
    GMATCH_SIMP_TAC (GSYM indexf_rotn);
    BY(ASM_REWRITE_TAC[]);
  DISCH_THEN (ASSUME_TAC o GSYM);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (betwn s x y)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Ohcgkfu.uniq_betwn;
    BY(ASM_REWRITE_TAC[]);
  TYPED_ABBREV_TAC `z = nth (HD s) (betwn s x y) i`;
  TYPIFY `MEM z (betwn s x y)` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[GSYM Seq.index_mem];
    FULL_EXPAND_TAC "z";
    GMATCH_SIMP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.index_uniq);
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC Seq.index_uniq [`HD s`;`i`;`betwn s x y`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM z (betwn (rot n s) x y)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC indexf_betwn_eq;
    ASM_REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
    REPEAT (GMATCH_SIMP_TAC (GSYM indexf_rotn));
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[betwn_mem]);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `MEM z (betwn s x y)` MP_TAC;
    BY(ASM_MESON_TAC[indexf_betwn_eq]);
  TYPIFY `indexl z (betwn (rot n s) x y) = i` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (SUBST1_TAC o GSYM);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC Seq.nth_index;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `indexl` MP_TAC;
  ONCE_REWRITE_TAC[arith `i  = j <=> SUC i = SUC j`];
  REPEAT (GMATCH_SIMP_TAC indexl_betwn);
  GMATCH_SIMP_TAC (GSYM indexf_rotn);
  ASM_REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
  BY(ASM_MESON_TAC[betwn_mem])
  ]);;
  (* }}} *)

let betwn_rotate_to_face = prove_by_refinement(
  `!L f N r x w. 
   good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
    ~final_list L r /\
    MEM w (find_face L x) /\
    rotate_to (find_face L x) w = f ==>
    betwn f (l'y L r x) (l'z L N r x) = 
	betwn (find_face L x) (l'y L r x) (l'z L N r x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f";
  GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
  GMATCH_SIMP_TAC (GSYM betwn_rot);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    MATCH_MP_TAC List_hypermap.uniq_find_face;
    BY(ASM_MESON_TAC[good_list]);
  ASM_REWRITE_TAC[];
  INTRO_TAC marked_lemma_yz_in_face [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[Seq.index_size];
  BY(ASM_MESON_TAC[HQYMRTX3_list])
  ]);;
  (* }}} *)

let indexl_y_lt_z = prove_by_refinement(
  `!L fw N r x w. 
   good_list L /\
    is_restricted (hypermap_of_list L) /\
            good_list_nodes L /\
            marked_list L N r x /\
      next_el (find_face L x) x = w /\
    rotate_to (find_face L x) w = fw /\
            ~final_list L r ==>
	    indexl (l'y L r x) fw < indexl (l'z L N r x) fw`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `y = l'y L r x`;
  TYPED_ABBREV_TAC `z = l'z L N r x`;
  TYPED_ABBREV_TAC `f = find_face L x`;
  INTRO_TAC (GEN_ALL Hojodcm.PPLHULJ3_v0) [`next_el f x`;`f`;`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[ytrans;ztrans;rtrans;ntrans;POWER_0;I_THM];
  TYPIFY `MEM x f /\ MEM w f /\ MEM z f /\ MEM y f` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f";
    nCONJ_TAC 0;
      ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
      MATCH_MP_TAC Pplhulj.marked_list_of_dart;
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      FULL_EXPAND_TAC "w";
      BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[marked_lemma_yz_in_face]);
  INTRO_TAC List_hypermap.mem_find_face [`x`;`L`];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
  TYPIFY `!u. MEM u f ==> indexl u fw = indexf w u f` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `?n. rot n fw = f` (C SUBGOAL_THEN MP_TAC);
      ONCE_REWRITE_TAC[rot_sym];
      FULL_EXPAND_TAC "fw";
      (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
      ASM_REWRITE_TAC[];
      BY(MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM x fw /\ MEM u fw /\ uniq fw /\ MEM w fw` (C SUBGOAL_THEN ASSUME_TAC);
      TYPIFY `?m. rot m f = fw` (C SUBGOAL_THEN MP_TAC);
        BY(ASM_MESON_TAC[rot_sym]);
      BY(REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "fw" THEN ASM_SIMP_TAC[Seq.mem_rot;Seq.rot_uniq]);
    TYPIFY `indexf w u f = indexf w u fw` (C SUBGOAL_THEN ASSUME_TAC);
      FULL_EXPAND_TAC "f";
      TYPIFY `sizel fw <= n` ASM_CASES_TAC;
        BY(ASM_MESON_TAC[Seq.rot_oversize]);
      GMATCH_SIMP_TAC (GSYM indexf_rotn);
      ASM_REWRITE_TAC[];
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "fw";
    INTRO_TAC (GEN_ALL Ohcgkfu.indexf_indexl_hd) [`u`;`rotate_to f w`];
    DISCH_THEN (SUBST1_TAC o GSYM);
    BY(REWRITE_TAC[hd_rotate_to]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(*
  TYPIFY `indexf x w f = 1` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC next_el_indexf;
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "f";
    ASM_REWRITE_TAC[];  
    INTRO_TAC is_restricted_size_face [`L`;`find_face L x`];
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  INTRO_TAC indexf_add_left [`x`;`w`;`y`;`f`];
  INTRO_TAC indexf_add_left [`x`;`w`;`z`;`f`];
  (ASM_REWRITE_TAC[]);
  TYPIFY `(!u. MEM u f /\ ~(u = x) ==> 1 <= indexf x u f)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `(1 <= i) <=> ~(i = 0)`];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC index0 [];
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  POP_ASSUM (REPEAT o GMATCH_SIMP_TAC);
  ASM_REWRITE_TAC[];
*)

let rotate_to2 = prove_by_refinement(
  `!f x w. uniq f /\ next_el f x = w /\ MEM x f  ==>
    rotate1 (rotate_to f x) = rotate_to f w`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq2.mem_next_el]);
  DISCH_TAC;
  FULL_EXPAND_TAC "w";
  GMATCH_SIMP_TAC Tame_list.indexl_next_el;
  ASM_REWRITE_TAC[rotate1_rot1];
  GMATCH_SIMP_TAC Seq.rot_add_mod;
  nCONJ_TAC 0;
    ASM_REWRITE_TAC[arith `1 <= i <=> ~(i=0)`;Seq.size_eq0];
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  ASM_REWRITE_TAC[Seq.index_size];
  TYPIFY `indexl x f < sizel f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  REPEAT (COND_CASES_TAC) THEN ASM_SIMP_TAC[arith `1 <= i ==> 1 + i - 1 = i`;arith `1 + i = i + 1`;arith `1 <= i ==> i - 1 + 1 = i`;arith `i - i = 0`;];
    BY(REWRITE_TAC[Seq.rot_size;Seq.rot0]);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let newvertex_alt = prove_by_refinement(
  `!r L x w. 
    (let f = find_face L x  in
     let w = next_el f x in
     let fw = rotate_to f w in
           uniq f /\ MEM x f /\ MEM x r ==>
	     newvertex L r x = 
       MAP FST (filter (\d. ~MEM d r) fw))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  ASM_REWRITE_TAC[newvertex;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  FULL_EXPAND_TAC "fw";
  INTRO_TAC (GSYM rotate_to2) [`f`;`x`;`w`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  GMATCH_SIMP_TAC rotate1_rcons;
  SUBCONJ_TAC;
    GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl;
    ASM_REWRITE_TAC[rot_eq_nil];
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  DISCH_TAC;
  INTRO_TAC CONS_HD_TL [`rotate_to f x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `filter (\d. ~MEM d r) (rotate_to f x) = filter (\d. ~MEM d r) (HD (rotate_to f x) :: TL (rotate_to f x))` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.filter_cons;Seq.filter_rcons];
  TYPIFY `HD (rotate_to f x) = x` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[hd_rotate_to]);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mem_rotate_to = prove_by_refinement(
  `!f x u. MEM x f /\ uniq f ==> (MEM u (rotate_to f x) <=> MEM u f)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[Pwssrat.rotate_rot_indexl];
  BY(REWRITE_TAC[Seq.mem_rot])
  ]);;
  (* }}} *)

let rotate_to_uniq = prove_by_refinement(
  `!f x. MEM x f /\ uniq f ==> uniq (rotate_to f x)`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[Seq.rot_uniq;Pwssrat.rotate_rot_indexl])
  ]);;
  (* }}} *)

let rotate_to_size = prove_by_refinement(
  `!f x. MEM x f /\ uniq f ==> sizel (rotate_to f x) = sizel f`,
  (* {{{ proof *)
  [
  SIMP_TAC[Seq.size_rot;Pwssrat.rotate_rot_indexl]
  ]);;
  (* }}} *)

let rotate_to_nil = prove_by_refinement(
  `!f x. MEM x f /\ uniq f ==> ~(rotate_to f x = [])`,
  (* {{{ proof *)
  [
  SIMP_TAC[Pwssrat.rotate_rot_indexl;rot_eq_nil];
  BY(ASM_MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let indexf_rotn_alt = prove_by_refinement(
  `!n x y s. MEM x s /\ MEM y s /\ uniq s ==>
    indexf x y s = indexf x y (rot n s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `n <= sizel s` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[indexf_rotn]);
  GMATCH_SIMP_TAC Seq.rot_oversize;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_rotate_to = prove_by_refinement(
  `!f w z x. MEM x f /\ MEM w f /\ MEM z f /\ uniq f ==> indexf w z (rotate_to f x) = indexf w z f`,
  (* {{{ proof *)
  [
  SIMP_TAC[Pwssrat.rotate_rot_indexl;GSYM indexf_rotn_alt];  
  ]);;
  (* }}} *)

let indexf_rotate_to_indexl = prove_by_refinement(
  `!f w z. MEM z f /\ MEM w f /\ uniq f ==> indexf w z f = indexl z (rotate_to f w)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl z (rotate_to f w) = indexf w z (rotate_to f w)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[indexf_rotate_to]);
  TYPIFY `HD (rotate_to f w) = w` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Ohcgkfu.indexf_indexl_hd]);
  BY(REWRITE_TAC[hd_rotate_to])
  ]);;
  (* }}} *)

let mem_take_index2 = prove_by_refinement(
  `!k v s. uniq s /\ k <= sizel s  ==> (MEM v (take k s) <=> indexl v s < k)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v s` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[mem_take_index]);
  TYPIFY `MEM v (take k s)` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.mem_take]);
  ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC (REWRITE_RULE[GSYM Seq.index_mem]);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let marked_x_find_face = prove_by_refinement(
  `!L N r x. marked_list L N r x ==>
    MEM x (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  DISCH_TAC;
  MATCH_MP_TAC Pplhulj.marked_list_of_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let l_m_lt_size_face = prove_by_refinement(
  `!L N r x.
    good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r
   ==>
    SUC (l'm L r x) < sizel (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_bound_hyp_m [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate;marked_conclusion];
  GMATCH_SIMP_TAC List_hypermap.card_face_of_list;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pplhulj.marked_list_of_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let le_y_in_r = prove_by_refinement(
  `!L fw N r x w x'. 
   good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
    next_el (find_face L x) x = w /\
    rotate_to (find_face L x) w = fw /\
            ~final_list L r /\
	    indexl x' fw <= indexl (l'y L r x) fw
    ==> MEM x' r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `HD (fw) = w` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[hd_rotate_to]);
  TYPIFY `MEM x (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_x_find_face]);
  TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
  TYPED_ABBREV_TAC `y = l'y L r x`;
  TYPIFY `MEM w fw /\ uniq fw /\ MEM y fw` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[rotate_to_uniq;mem_rotate_to;Seq2.mem_next_el;marked_lemma_yz_in_face]);
  ASM_REWRITE_TAC[];
  TYPIFY `MEM w (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.mem_next_mark_inface]);
  TYPIFY `~(fw = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ rotate_to_nil]);
  TYPIFY `indexl w fw = 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_hd0]);
  INTRO_TAC (GEN_ALL Ncvibwu.l_y_rep_power_le ) [`L`;`r`;`x`];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (C INTRO_TAC [`indexl x' fw`]);
  FIRST_X_ASSUM_ST `l'y` MP_TAC THEN REWRITE_TAC[Tame_defs2.l_y];
  TYPIFY `(uniq (list_of_darts L) /\ MEM x (list_of_darts L))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[List_hypermap.dart_in_face];
    BY(ASM_MESON_TAC[good_list]);
  INTRO_TAC l_m_lt_size_face [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `sizel (find_face L x) = sizel fw` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[size_rotate_to]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!i. i <= l'm L r x ==> indexl ((f_list L POWER SUC (i)) x) fw = i` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC Pwssrat.f_list_power_next_el;
    ASM_REWRITE_TAC[POWER;o_THM];
    GMATCH_SIMP_TAC Pwssrat.next_el_power_rotate;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Seq2.next_el_power;
    TYPIFY `w` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[arith `0 + n = n`];
    TYPIFY `i < sizel fw` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    ASM_SIMP_TAC[MOD_LT];
    GMATCH_SIMP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.index_uniq);
    BY(ASM_REWRITE_TAC[]);
  COMMENT "back to 1";
  FIRST_ASSUM (C INTRO_TAC [`indexl x' fw`]);
  FIRST_X_ASSUM (C INTRO_TAC [`l'm L r x`]);
  ASM_REWRITE_TAC[arith `n <= n:num`];
  DISCH_TAC;
  SUBANTS_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  GMATCH_SIMP_TAC Seq2.uniq_index_inj;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    FULL_EXPAND_TAC "fw";
    GMATCH_SIMP_TAC mem_rotate_to;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Pwssrat.mem_f_list_power;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[];
  CONJ2_TAC;
    DISCH_THEN (SUBST1_TAC o GSYM);
    MATCH_MP_TAC Aq8.MEM_POWER_NEXT_EL;
    BY(ASM_MESON_TAC[marked_list]);
  REWRITE_TAC[GSYM Seq.index_mem];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let rtrans0 =0;;

let trans0 = prove_by_refinement(
  `!L N r x. rtrans L N r x 0 = r /\ ntrans L N r x 0 = N /\
    ytrans L N r x 0 = l'y L r x /\ ztrans L N r x 0 = l'z L N r x`,
  (* {{{ proof *)
  [
   BY (REWRITE_TAC[rtrans;ntrans;ytrans;ztrans;transform_list;POWER_0;I_THM])
  ]);;
  (* }}} *)

(*
let indexf_const_le_indexf_ytrans_v0_alt = prove_by_refinement(
  `!w f L N r x d.
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         find_face L x = f /\
         next_el f x = w /\
         ~final_list L r /\
         MEM d r /\
         indexf w d r <= indexf w (l'y L r x) r
         ==> indexf w d r = indexf w d f`,
  (* {{{ proof *)
  [
  MESON_TAC[Aq7.indexf_const_le_indexf_ytrans_v0;trans0]
  ]);;
  (* }}} *)
*)

let r_rtrans_eq_above_z_concl = 
  `!L N r x x' w f. 
    transform_assumption_v2 L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    find_face L x = f /\
    next_el f x = w /\
  ~final_list L r /\
  MEM x' f /\
  indexf w (l'z L N r x) f <= indexf w x' f ==>
  (MEM x' r <=> MEM x' (rtrans L N r x 1))`;;

let r_rtrans_eq = new_definition'
  `r_rtrans_eq L N r (x:A#A) <=> 
  (let w = next_el (find_face L x) x in
  (!x'. MEM x' (find_face L x) /\
               indexf w (l'z L N r x) (find_face L x) <=
               indexf w x' (find_face L x)
               ==> (MEM x' r <=> MEM x' (rtrans L N r x 1))  ))`;;

let face_diff_r = prove_by_refinement(
  `!L fw N r x w. 
    // temp assumption:
    //
    //(!x'. MEM x' (find_face L x) /\ indexf w (l'z L N r x) (find_face L x) <= indexf w x' (find_face L x) ==>
    //   (MEM x' r <=> MEM x' (rtrans L N r x 1))) /\
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    is_restricted (hypermap_of_list L) /\
    next_el (find_face L x) x = w /\
    rotate_to (find_face L x) w = fw /\
    ~final_list L r ==>
    filter (\d. ~MEM d r) fw = 
	cat
	  (filter (\d. ~MEM d r) (rtrans L N r x 1))
	  (filter (\d. ~MEM d (rtrans L N r x 1)) fw)
		  `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC rtrans_diff_r;
  ASM_SIMP_TAC[];
  TYPED_ABBREV_TAC `n = indexl (l'z L N r x) fw`;
  INTRO_TAC Seq.cat_take_drop [`n`;`fw`];
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[Seq.filter_cat];
  MATCH_MP_TAC cat_eq;
  INTRO_TAC (GSYM betwn_rotate_to_face) [`L`;`fw`;`N`;`r`;`x`;`w`];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[Pplhulj.mem_next_mark_inface]);
  ASM_SIMP_TAC[];
  TYPED_ABBREV_TAC `y = l'y L r x`;
  TYPED_ABBREV_TAC `z = l'z L N r x`;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl y fw < indexl z fw` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[indexl_y_lt_z]);
  TYPIFY `betwn fw y z = filter (\d.  ~MEM d r) (betwn fw y z)` (C SUBGOAL_THEN SUBST1_TAC);
    FIRST_X_ASSUM_ST `betwn` (SUBST1_TAC o GSYM);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    REWRITE_TAC[Seq.all_filterP];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC (GEN_ALL Aq1.betwn_not_in_rtrans) [`find_face L x`;`x'`;`L`;`N`;`r`;`x`];
    ASM_REWRITE_TAC[];
    BY(ASM_REWRITE_TAC[ytrans;ztrans;rtrans;ntrans;POWER_0;I_THM]);
  TYPIFY `MEM x (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC List_hypermap.mem_find_face [`x`;`L`];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
  TYPIFY `MEM w fw /\ uniq fw /\ MEM z fw /\ MEM y fw /\ MEM z (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[rotate_to_uniq;mem_rotate_to;Seq2.mem_next_el;marked_lemma_yz_in_face]);
  COMMENT "filter on betwn";
  CONJ_TAC;
    GMATCH_SIMP_TAC betwn_take_drop;
    ASM_REWRITE_TAC[];
    TYPIFY `PRE (n - indexl y fw) = n - SUC (indexl y fw)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC (GSYM drop_take_commute);
    SUBCONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    DISCH_TAC;
    INTRO_TAC Seq.cat_take_drop [`SUC (indexl y fw)`;`take n fw`];
    DISCH_TAC;
    TYPIFY `filter (\d. ~MEM d r) (take n fw) = filter (\d. ~MEM d r) (cat (take (SUC (indexl y fw)) (take n fw)) (dropl (SUC (indexl y fw)) (take n fw)))` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[Seq.filter_cat];
    ASM_SIMP_TAC[take_take];
    TYPIFY `(filter (\d. ~MEM d r) (take (SUC (indexl y fw)) fw)) = []` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[Seq.cat0s]);
    REWRITE_TAC[filter_nil;GSYM Seq.hasP];
    REPEAT WEAKER_STRIP_TAC;
    POP_ASSUM MP_TAC THEN REWRITE_TAC[] THEN POP_ASSUM MP_TAC;
    GMATCH_SIMP_TAC mem_take_index2;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      MATCH_MP_TAC (arith `x < z ==> SUC x <= z`);
      BY(ASM_REWRITE_TAC[Seq.index_mem]);
    (DISCH_TAC);
    MATCH_MP_TAC le_y_in_r;
    GEXISTL_TAC [`L`;`fw`;`N`;`x`;`w`];
    ASM_REWRITE_TAC[];
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  COMMENT "back to 1";
  TYPIFY `(filter (\d. ~MEM d (rtrans L N r x 1)) (take n fw)) = []` (C SUBGOAL_THEN SUBST1_TAC) THEN REWRITE_TAC[Seq.cat0s];
    REWRITE_TAC[filter_nil;GSYM Seq.hasP];
    REPEAT WEAKER_STRIP_TAC;
    POP_ASSUM MP_TAC THEN REWRITE_TAC[] THEN POP_ASSUM MP_TAC;
    GMATCH_SIMP_TAC mem_take_index2;
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[Seq.index_size]);
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC Ncvibwu.NCVIBWU [`L`;`N`;`r`;`find_face L x`;`w`;`x`;`0`;`indexl x' fw`];
    ASM_REWRITE_TAC[trans0;arith `SUC 0 = 1`];
    TYPIFY `indexf w z (find_face L x) = n` (C SUBGOAL_THEN ASSUME_TAC);
      FULL_EXPAND_TAC "n";
      FULL_EXPAND_TAC "fw";
      GMATCH_SIMP_TAC (GSYM indexf_rotate_to_indexl);
      BY(ASM_REWRITE_TAC[]);
    ANTS_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    TYPIFY `((next_el (find_face L x) POWER indexl x' fw) w) = x'` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    INTRO_TAC indexf_n [`w`;`x'`;`find_face L x`];
    ASM_REWRITE_TAC[];
    TYPIFY `MEM x' fw` (C SUBGOAL_THEN ASSUME_TAC);
      ASM_REWRITE_TAC[GSYM Seq.index_mem];
      INTRO_TAC Seq.index_size [`z`;`fw`];
      BY(ASM_TAC THEN ARITH_TAC);
    SUBANTS_TAC;
      BY(ASM_MESON_TAC[mem_rotate_to]);
    DISCH_TAC;
    TYPIFY `indexf w x' (find_face L x) = indexl x' fw` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    FULL_EXPAND_TAC "fw";
    GMATCH_SIMP_TAC (GSYM indexf_rotate_to_indexl);
    BY(ASM_REWRITE_TAC[]);
  COMMENT "back to 1";
  MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_in_filter);
  REWRITE_TAC[TAUT `(~a <=> ~b) <=> (a <=> b)`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x' fw` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.mem_drop]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  FIRST_X_ASSUM_ST `dropl` MP_TAC;
  GMATCH_SIMP_TAC mem_drop_index;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FULL_EXPAND_TAC "n";
  COMMENT "use r_rtrans_eq";
  FIRST_X_ASSUM_ST `r_rtrans_eq` MP_TAC THEN ASM_REWRITE_TAC[LET_THM;r_rtrans_eq];
  (DISCH_THEN MATCH_MP_TAC);
  CONJ_TAC;
    BY(ASM_MESON_TAC[mem_rotate_to]);
  POP_ASSUM MP_TAC;
  FULL_EXPAND_TAC "fw";
  REPEAT (GMATCH_SIMP_TAC (GSYM indexf_rotate_to_indexl));
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[mem_rotate_to])
  ]);;
  (* }}} *)

let sizel_undup_card = prove_by_refinement(
  `!a. CARD (set_of_list a) = sizel (undup a) `,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `set_of_list a = set_of_list (undup a)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Seq2.set_of_list_undup]);
  MATCH_MP_TAC Seq2.card_set_of_list_uniq;
  BY(REWRITE_TAC[Seq.undup_uniq])
  ]);;
  (* }}} *)

let set_of_list_numseg = prove_by_refinement(
  `!a. set_of_list a = 0.. PRE (sizel (undup a)) <=> (?k. set_of_list a = 0..k)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[EQ_EXPAND];
  CONJ_TAC;
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[GSYM sizel_undup_card];
  REWRITE_TAC[CARD_NUMSEG];
  AP_TERM_TAC;
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let take_iota = prove_by_refinement(
  `!i j n. i <=j  ==> take i (iota n j) = iota n i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `j = (i:num) + (j-i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.iota_add];
  MATCH_MP_TAC Seq.take_size_cat;
  BY(REWRITE_TAC[Seq.size_iota])
  ]);;
  (* }}} *)

let elements_of_list_ntrans = prove_by_refinement(
  `!L N r x.
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N)))) ==>
    elements_of_list (quotient_list L (ntrans L N r x 1)) = 
	0 .. PRE(sizel (undup (MAP FST (flatten (ntrans L N r x 1)))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[newvertex_prepped];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (LET_TAC ORELSE (FIRST_X_ASSUM_ST `LET_END` MP_TAC));
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `final_list L r` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[ntrans_id]);
  FIRST_X_ASSUM_ST `elements_of_list` MP_TAC THEN (REPEAT (GMATCH_SIMP_TAC quotient_list_elements));
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[marked_list]);
  nCONJ_TAC 0;
    MATCH_MP_TAC Tame_list.AQIUNPP1;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Lebhirj.LEBHIRJ [`L`;`N`;`ntrans L N r x 1`;`r`;`rtrans L N r x 1`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `iota n (sizel news) = news` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ONCE_REWRITE_TAC[set_of_list_numseg];
  ASM_REWRITE_TAC[];
  TYPIFY `set_of_list (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1))) = {}` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[UNION_EMPTY];
    BY(MESON_TAC[]);
  TYPIFY `?k. n <= k /\ set_of_list (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1))) = n..k` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `k` EXISTS_TAC;
    REWRITE_TAC[EXTENSION;IN_UNION;IN_NUMSEG];
    GEN_TAC;
    BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x`;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  INTRO_TAC face_diff_r [`L`;`fw`;`N`;`r`;`x`;`w`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC newvertex_alt [`r`;`L`;`x`;`w`];
  ASM_REWRITE_TAC[LET_THM];
  SUBANTS_TAC;
    TYPIFY `MEM x (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[marked_x_find_face]);
    TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[marked_list]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[Seq.map_cat;lower_case];
  REWRITE_TAC[Seq.map_MAP];
  DISCH_TAC;
  TYPED_ABBREV_TAC `l = sizel (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)))`;
  INTRO_TAC Seq.take_size_cat [`l`;`(MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)))`; `(MAP FST (filter (\d. ~MEM d (rtrans L N r x 1)) fw))`];
  ASM_REWRITE_TAC[];
  TYPIFY `l <= sizel news` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "l";
    REWRITE_TAC[Seq.size_cat];
    BY(ARITH_TAC);
  FIRST_X_ASSUM_ST `cat` (SUBST1_TAC o GSYM);
  DISCH_THEN (SUBST1_TAC o GSYM);
  FULL_EXPAND_TAC "news";
  GMATCH_SIMP_TAC take_iota;
  POP_ASSUM MP_TAC THEN SIMP_TAC[Seq.size_iota];
  REWRITE_TAC[Seq2.set_of_list_iota];
  TYPIFY `~(l = 0)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `n+l - 1` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  ASM_REWRITE_TAC[];
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `set_of_list` MP_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)) = []` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  BY(ASM_REWRITE_TAC[set_of_list])
  ]);;
  (* }}} *)

let newvertex_prepped_transform_lemma = prove_by_refinement(
  `!L N r x.
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N)))) /\
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    newvertex_prepped L N r x ==>
    sizel (undup (MAP FST (flatten (ntrans L N r x 1)))) =
    sizel (undup (MAP FST (flatten N))) +
    sizel (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC elements_of_list_ntrans [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `newvertex_prepped` MP_TAC;
  ASM_REWRITE_TAC[newvertex_prepped];
  REPEAT (LET_TAC ORELSE (FIRST_X_ASSUM_ST `LET_END` MP_TAC));
  TYPED_ABBREV_TAC `n' = sizel (undup (MAP FST (flatten (ntrans L N r x 1))))`;
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x `;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  TYPED_ABBREV_TAC `b = MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1))`;
  TYPIFY `MAP FST (cat (filter (\d. ~MEM d r) (rtrans L N r x 1)) (filter (\d. ~MEM d (rtrans L N r x 1)) fw)) = MAP FST (filter (\d. ~MEM d r) fw)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[face_diff_r]);
  REPEAT (FIRST_X_ASSUM_ST `newvertex` MP_TAC) THEN (REPEAT (GMATCH_SIMP_TAC (REWRITE_RULE[LET_THM] newvertex_alt)));
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (find_face L x) /\ MEM x r /\ MEM x (find_face L x) /\ MEM x (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[marked_list]);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[marked_x_find_face]);
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq7.AQ7;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `sizel` MP_TAC);
  REWRITE_TAC[GSYM sizel_undup_card];
  INTRO_TAC Lebhirj.LEBHIRJ [`L`;`N`;`ntrans L N r x 1`;`r`;`rtrans L N r x 1`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `b = []` ASM_CASES_TAC;
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "b";
    REWRITE_TAC[Seq.size_nil;arith `m + 0 = m`];
    FIRST_X_ASSUM_ST `MAP` MP_TAC THEN REWRITE_TAC[GSYM Seq.map_MAP;Seq.map_cat] THEN ASM_REWRITE_TAC[Seq.map_MAP];
    BY(SIMP_TAC[set_of_list;UNION_EMPTY]);
  COMMENT "now b is nonnil";
  TYPED_ABBREV_TAC `l = sizel b`;
  TYPED_ABBREV_TAC `vs' = MAP FST (filter (\d. ~MEM d (rtrans L N r x 1)) fw)`;
  INTRO_TAC Seq.take_size_cat [`l`;`b`; `vs'`];
  ASM_REWRITE_TAC[];
  TYPIFY `news` (RENAME_TAC "vs");
  TYPIFY `l <= sizel vs` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "l";
    FULL_EXPAND_TAC "vs";
    FIRST_X_ASSUM_ST `cat` (SUBST1_TAC o GSYM);
    ASM_REWRITE_TAC[Seq.size_cat];
    ASM_REWRITE_TAC[Seq.size_cat;lower_case;Seq.map_cat];
    ASM_REWRITE_TAC[Seq.map_MAP];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `take` MP_TAC;
  FIRST_X_ASSUM_ST `cat` MP_TAC;
  ASM_REWRITE_TAC[Seq.size_cat;lower_case;Seq.map_cat];
  ASM_REWRITE_TAC[Seq.map_MAP];
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `iota` MP_TAC THEN ASM_SIMP_TAC[] THEN DISCH_TAC;
  TYPIFY `take l (iota n (sizel vs)) = b` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC take_iota;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `uniq b` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.iota_uniq]);
  TYPIFY `sizel b = CARD (set_of_list b)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.card_set_of_list_uniq]);
  TYPED_ABBREV_TAC `M' = set_of_list (MAP FST (flatten (ntrans L N r x 1)))`;
  TYPED_ABBREV_TAC `M = set_of_list (MAP FST (flatten N))`;
  TYPED_ABBREV_TAC `B = set_of_list (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)))`;
  TYPIFY `M UNION B = M' /\ M INTER B = {}` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC CARD_UNION_GEN [`M`;`B`];
    SUBANTS_TAC;
      BY(ASM_MESON_TAC[FINITE_SET_OF_LIST]);
    ASM_REWRITE_TAC[CARD_CLAUSES];
    TYPIFY `CARD B = sizel b` ENOUGH_TO_SHOW_TAC;
      BY(REPEAT (FIRST_X_ASSUM_ST `sizel b = l` MP_TAC) THEN ARITH_TAC);
    BY(ASM_MESON_TAC[]);
  COMMENT "now inter and union";
  REPEAT (FIRST_X_ASSUM_ST `elements_of_list` MP_TAC) THEN REPEAT (GMATCH_SIMP_TAC quotient_list_elements);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[Aq8.AQ_normal_list]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[marked_list]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    TYPIFY `B = set_of_list b` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    BY(SET_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `B = set_of_list b` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "b";
  REWRITE_TAC[EXTENSION;IN_INTER;IN_NUMSEG;NOT_IN_EMPTY;set_of_list_iota_alt;IN_ELIM_THM];
  GEN_TAC;
  TYPIFY `~(n = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  FULL_EXPAND_TAC "n";
  FULL_EXPAND_TAC "M";
  GMATCH_SIMP_TAC CARD_EQ_0;
  REWRITE_TAC[FINITE_SET_OF_LIST];
  REWRITE_TAC[SET_OF_LIST_EQ_EMPTY];
  REWRITE_TAC[MAP_EQ_NIL];
  MATCH_MP_TAC Aq4.nil_flatten;
  CONJ2_TAC;
    BY(ASM_MESON_TAC[marked_list;normal_list]);
  BY(ASM_MESON_TAC[marked_list;Dangeyj.mem_imp_not_nil])
  ]);;
  (* }}} *)

(*
let newvertex_prepped_transform = prove_by_refinement(
  `!L N r x.
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N)))) /\
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x ==>
    newvertex_prepped L (ntrans L N r x 1) (rtrans L N r x 1) x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC elements_of_list_ntrans [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `newvertex_prepped` MP_TAC;
  REWRITE_TAC[newvertex_prepped];
  REPEAT (LET_TAC ORELSE (FIRST_X_ASSUM_ST `LET_END` MP_TAC));
  TYPIFY `final_list L r` ASM_CASES_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    BY(ASM_SIMP_TAC[rtrans_final_prop]);
  TYPIFY `final_list L (rtrans L N r x 1)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `n'` (RENAME_TAC "m");
  TYPIFY `n` (RENAME_TAC "m'");
  TYPIFY `news'` (RENAME_TAC "vs");
  TYPIFY `news` (RENAME_TAC "vs'");
  TYPIFY `?b. m' = m + sizel (b) /\ vs = cat b vs'` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC iota_m_cat;
    FIRST_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[Seq.size_cat]);
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x `;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  TYPED_ABBREV_TAC `b = MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1))`;
  TYPIFY `b` EXISTS_TAC;
  TYPIFY `MAP FST (cat (filter (\d. ~MEM d r) (rtrans L N r x 1)) (filter (\d. ~MEM d (rtrans L N r x 1)) fw)) = MAP FST (filter (\d. ~MEM d r) fw)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[face_diff_r]);
  REPEAT (FIRST_X_ASSUM_ST `newvertex` MP_TAC) THEN (REPEAT (GMATCH_SIMP_TAC (REWRITE_RULE[LET_THM] newvertex_alt)));
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (find_face L x) /\ MEM x r /\ MEM x (find_face L x) /\ MEM x (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[marked_list]);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[marked_x_find_face]);
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq7.AQ7;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ2_TAC;
    BY(ASM_MESON_TAC[Seq.map_MAP;Seq.map_cat]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REPEAT (FIRST_X_ASSUM_ST `sizel` MP_TAC);
  REWRITE_TAC[GSYM sizel_undup_card];
  INTRO_TAC Lebhirj.LEBHIRJ [`L`;`N`;`ntrans L N r x 1`;`r`;`rtrans L N r x 1`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `b = []` ASM_CASES_TAC;
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "b";
    REWRITE_TAC[Seq.size_nil;arith `m + 0 = m`];
    FIRST_X_ASSUM_ST `MAP` MP_TAC THEN REWRITE_TAC[GSYM Seq.map_MAP;Seq.map_cat] THEN ASM_REWRITE_TAC[Seq.map_MAP];
    BY(SIMP_TAC[set_of_list;UNION_EMPTY]);
  COMMENT "now b is nonnil";
  TYPED_ABBREV_TAC `l = sizel b`;
  INTRO_TAC Seq.take_size_cat [`l`;`b`; `vs'`];
  ASM_REWRITE_TAC[];
  TYPIFY `l <= sizel vs` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "l";
    REWRITE_TAC[Seq.size_cat];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `take` MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `vs = cat b vs'` (ASSUME_TAC o GSYM);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `iota` MP_TAC THEN ASM_SIMP_TAC[] THEN DISCH_TAC;
  TYPIFY `take l (iota m (sizel vs)) = b` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC take_iota;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `uniq b` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.iota_uniq]);
  TYPIFY `sizel b = CARD (set_of_list b)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.card_set_of_list_uniq]);
  TYPED_ABBREV_TAC `M' = set_of_list (MAP FST (flatten (ntrans L N r x 1)))`;
  TYPED_ABBREV_TAC `M = set_of_list (MAP FST (flatten N))`;
  TYPED_ABBREV_TAC `B = set_of_list (MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1)))`;
  TYPIFY `M UNION B = M' /\ M INTER B = {}` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC CARD_UNION_GEN [`M`;`B`];
    SUBANTS_TAC;
      BY(ASM_MESON_TAC[FINITE_SET_OF_LIST]);
    ASM_REWRITE_TAC[CARD_CLAUSES];
    TYPIFY `CARD B = sizel b` ENOUGH_TO_SHOW_TAC;
      BY(REPEAT (FIRST_X_ASSUM_ST `sizel b = l` MP_TAC) THEN ARITH_TAC);
    BY(ASM_MESON_TAC[]);
  COMMENT "now inter and union";
  REPEAT (FIRST_X_ASSUM_ST `elements_of_list` MP_TAC) THEN REPEAT (GMATCH_SIMP_TAC quotient_list_elements);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[Aq8.AQ_normal_list]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[marked_list]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    TYPIFY `B = set_of_list b` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    BY(SET_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `B = set_of_list b` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "b";
  REWRITE_TAC[EXTENSION;IN_INTER;IN_NUMSEG;NOT_IN_EMPTY;set_of_list_iota_alt;IN_ELIM_THM];
  GEN_TAC;
  TYPIFY `~(m = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  FULL_EXPAND_TAC "m";
  FULL_EXPAND_TAC "M";
  GMATCH_SIMP_TAC CARD_EQ_0;
  REWRITE_TAC[FINITE_SET_OF_LIST];
  REWRITE_TAC[SET_OF_LIST_EQ_EMPTY];
  REWRITE_TAC[MAP_EQ_NIL];
  MATCH_MP_TAC Aq4.nil_flatten;
  CONJ2_TAC;
    BY(ASM_MESON_TAC[marked_list;normal_list]);
  BY(ASM_MESON_TAC[marked_list;Dangeyj.mem_imp_not_nil])
  ]);;
  (* }}} *)
*)

let newvertex_prepped_transform = prove_by_refinement(
  `!L N r x.
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N)))) /\
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x ==>
    newvertex_prepped L (ntrans L N r x 1) (rtrans L N r x 1) x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC elements_of_list_ntrans [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_ASSUM_ST `newvertex_prepped` MP_TAC;
  REWRITE_TAC[newvertex_prepped];
  REPEAT (LET_TAC ORELSE (FIRST_X_ASSUM_ST `LET_END` MP_TAC));
  TYPIFY `final_list L r` ASM_CASES_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    BY(ASM_SIMP_TAC[rtrans_final_prop]);
  TYPIFY `final_list L (rtrans L N r x 1)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `n'` (RENAME_TAC "m");
  TYPIFY `n` (RENAME_TAC "m'");
  TYPIFY `news'` (RENAME_TAC "vs");
  TYPIFY `news` (RENAME_TAC "vs'");
  TYPIFY `?b. m' = m + sizel (b) /\ vs = cat b vs'` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC iota_m_cat;
    FIRST_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[Seq.size_cat]);
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x `;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  TYPED_ABBREV_TAC `b = MAP FST (filter (\d. ~MEM d r) (rtrans L N r x 1))`;
  TYPIFY `b` EXISTS_TAC;
  TYPIFY `MAP FST (cat (filter (\d. ~MEM d r) (rtrans L N r x 1)) (filter (\d. ~MEM d (rtrans L N r x 1)) fw)) = MAP FST (filter (\d. ~MEM d r) fw)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[face_diff_r]);
  REPEAT (FIRST_X_ASSUM_ST `newvertex` MP_TAC) THEN (REPEAT (GMATCH_SIMP_TAC (REWRITE_RULE[LET_THM] newvertex_alt)));
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (find_face L x) /\ MEM x r /\ MEM x (find_face L x) /\ MEM x (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;good_list]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[marked_list]);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[marked_x_find_face]);
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq7.AQ7;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ2_TAC;
    BY(ASM_MESON_TAC[Seq.map_MAP;Seq.map_cat]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC newvertex_prepped_transform_lemma [`L`;`N`;`r`;`x`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let undup_eq_nil = prove_by_refinement(
  `!x. undup x = [] <=> x = []`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC [Seq2.undup;NOT_CONS_NIL];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
  BY(ASM_MESON_TAC[Dangeyj.mem_imp_not_nil])
  ]);;
  (* }}} *)

let elements_of_list_vertices_set2 = prove_by_refinement(
  `!L N r x g.
    marked_list L N r x /\
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N)))) /\
    // match_quotient_list g L N /\ 
    fgraph g = quotient_list L N /\
    countVertices g = sizel (undup (MAP FST (flatten N)))
   ==>
      vertices_set2 g = elements_of_list (fgraph g)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[EXTENSION;IN_NUMSEG;GSYM vertices_set2_countVertices];
  GEN_TAC;
  TYPIFY `~(sizel (undup (MAP FST (flatten N))) = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  REWRITE_TAC[Seq.size_eq0;undup_eq_nil;MAP_EQ_NIL];
  MATCH_MP_TAC Aq4.nil_flatten;
  CONJ2_TAC;
    BY(ASM_MESON_TAC[marked_list;normal_list]);
  BY(ASM_MESON_TAC[marked_list;Dangeyj.mem_imp_not_nil])
  ]);;
  (* }}} *)

let undup_undup = prove_by_refinement(
  `!s. undup (undup s) = undup s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Seq.undup_id;
  BY(REWRITE_TAC[Seq.undup_uniq])
  ]);;
  (* }}} *)

let elements_of_list_vertices_set2_converse = prove_by_refinement(
  `!L N r x g.
    good_list L /\ 
    marked_list L N r x /\
    fgraph g = quotient_list L N /\
    vertices_set2 g = elements_of_list (fgraph g) 
    ==>
    countVertices g = sizel (undup (MAP FST (flatten N))) /\
    elements_of_list (quotient_list L N) =  0 .. PRE(sizel (undup (MAP FST (flatten N))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  ASM_TAC THEN ASM_REWRITE_TAC[EXTENSION;IN_NUMSEG;GSYM vertices_set2_countVertices];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel (undup (MAP FST (flatten N))) = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq.size_eq0;undup_eq_nil;MAP_EQ_NIL];
    MATCH_MP_TAC Aq4.nil_flatten;
    CONJ2_TAC;
      BY(ASM_MESON_TAC[marked_list;normal_list]);
    BY(ASM_MESON_TAC[marked_list;Dangeyj.mem_imp_not_nil]);
  INTRO_TAC quotient_list_elements [`L`;`N`] THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `countVertices` MP_TAC THEN ASM_REWRITE_TAC[];
  TYPED_ABBREV_TAC `fn = MAP FST (flatten N)`;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `countVertices g = sizel (undup fn)` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `IN` MP_TAC;
    ASM_REWRITE_TAC[];
    DISCH_THEN (ASSUME_TAC o GSYM);
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `CARD (set_of_list (iota 0 (countVertices g))) = CARD (set_of_list (undup fn))` ENOUGH_TO_SHOW_TAC;
    REWRITE_TAC[sizel_undup_card;undup_undup];
    GMATCH_SIMP_TAC Seq.undup_id;
    BY(REWRITE_TAC[Seq.iota_uniq;Seq.size_iota]);
  AP_TERM_TAC;
  POP_ASSUM MP_TAC;
  BY(REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;Seq.mem_undup;Seq.mem_iota;arith `0 <= x /\ 0+n = n`])
  ]);;
  (* }}} *)

let splitFace_countVertices = prove_by_refinement(
  `!g u v f ws.
    countVertices (SND (SND (splitFace g u v f ws))) = countVertices g + sizel ws`,
  (* {{{ proof *)
  [
  REWRITE_TAC[splitFace];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  BY(REWRITE_TAC[countVertices;lower_case])
  ]);;
  (* }}} *)

let fgraph_splitFace = prove_by_refinement(
  `!g u v h ws.
    (let (f1,f2) = split_face h u v ws in
       fgraph (SND (SND (splitFace g u v h ws))) = 
	      MAP FST (cat (replace h [f2] (faces g)) [f1]))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[splitFace];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[fgraph_graph];
  BY(REWRITE_TAC[lower_case])
  ]);;
  (* }}} *)

let splitFace_good_vertices_set2 = prove_by_refinement(
  `!L N r x N' fw w g' g u v f ws.
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    fgraph g = quotient_list L N /\
    ~(final_list L r) /\
    ntrans L N r x 1 = N' /\
    next_el (find_face L x) x = w /\
    rotate_to (find_face L x) w = fw /\
    SND (SND (splitFace g u v f ws)) = g' /\
    fgraph g' = quotient_list L N' /\
    sizel ws = sizel  (betwn (find_face L x) (l'y L r x) (l'z L N r x)) /\
    vertices_set2 g = elements_of_list (fgraph g)
    ==> vertices_set2 g' = elements_of_list (fgraph g')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC elements_of_list_vertices_set2;
  GEXISTL_TAC [`L`;`N'`;`rtrans L N r x 1`;`x`];
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    INTRO_TAC AQIUNPP3 [`L`;`1`;`N`;`r`;`x`];
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  INTRO_TAC elements_of_list_vertices_set2_converse [`L`;`N`;`r`;`x`;`g`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 0;
    INTRO_TAC elements_of_list_ntrans [`L`;`N`;`r`;`x`];
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "g'";
  REWRITE_TAC[splitFace_countVertices];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM rtrans_diff_r);
  ASM_REWRITE_TAC[];
  INTRO_TAC newvertex_prepped_transform_lemma [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  BY(REWRITE_TAC[lower_case;Seq.size_map])
  ]);;
  (* }}} *)

let ntrans1 = prove_by_refinement(
  `!L N r x.
   (
     let y = l'y L r x in
     let (f1,f2) = split_normal_list L r (find_face L y) y (prev_el r (l'z L N r x)) in
       ~final_list L r ==> ntrans L N r x 1 = cat (replace r [f2] N) [f1])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_PAIR];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[ntrans;POWER_1;transform_list];
  REPEAT LET_TAC;
  SIMP_TAC[];
  FULL_EXPAND_TAC "N'";
  FULL_EXPAND_TAC "split";
  ASM_REWRITE_TAC [lower_case];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let map_replace = prove_by_refinement(
  `!ys f x xs. 
    (!y. MEM y ys /\ f x = f y ==> x = y) ==>
    MAP f (replace x xs ys) = replace (f x) (MAP f xs) (MAP f ys)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[replace;MAP]);
  REWRITE_TAC[MAP;replace];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[MAP_APPEND]);
  REWRITE_TAC[MAP];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[MEM]);
  REWRITE_TAC[CONS_11];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[MEM])
  ]);;
  (* }}} *)

let fgraph_quotient_list_transform = prove_by_refinement(
    `!L N r x g N' h fw g' w  y z z' f newVs.
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    fgraph g = quotient_list L N /\
    ~(final_list L r) /\
    ntrans L N r x 1 = N' /\
    core L r = FST h /\
    MEM h (faces g) /\
    next_el (find_face L x) x = w /\
    rotate_to (find_face L x) w = fw /\
    SND (SND (splitFace g (FST y) (FST z') h newVs)) = g' /\
    (let (f1,f2) = split_normal_list L r f y z' in
       core L f1 = cat (rev newVs) (cat [FST y] (cat (betwn (FST h) (FST y) (FST z')) [FST z'])) /\
       core L f2 = cat (cat [FST z'] (cat (betwn (FST h) (FST z') (FST y)) [FST y])) newVs) /\
    sizel newVs = sizel  (betwn (find_face L x) (l'y L r x) (l'z L N r x)) /\
    vertices_set2 g = elements_of_list (fgraph g) /\
    l'y L r x = y /\
    l'z L N r x = z /\
    prev_el r z = z' /\
    find_face L y = f /\
    MAP FST (betwn f y z) = newVs
    ==> fgraph g' = quotient_list L N' 
 `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `h1 = FST (splitFace g (FST y) (FST z') h newVs)`;
  TYPED_ABBREV_TAC `h2 = FST (SND (splitFace g (FST y) (FST z') h newVs))`;
  INTRO_TAC splitFace_split_face [`g`;`FST y`;`FST z'`;`h`;`newVs`;`h1`;`h2`;`g'`];
  SUBANTS_TAC;
    ONCE_REWRITE_TAC[PAIR_EQ2];
    ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[PAIR_EQ2];
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_normal_list_split_list [`L`;`N`;`r`;`x`;`SND h`];
  ASM_REWRITE_TAC[LET_PAIR];
  ASM_REWRITE_TAC[LET_THM];
  TYPED_ABBREV_TAC `f1 = (FST (split_normal_list L r f y z'))`;
  TYPED_ABBREV_TAC `f2 = (SND (split_normal_list L r f y z'))`;
  SUBANTS_TAC;
    FIRST_X_ASSUM_ST `LET_END` MP_TAC THEN ASM_REWRITE_TAC[LET_PAIR];
    BY(ASM_REWRITE_TAC[LET_THM]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `LET_END` kill;
  REWRITE_TAC[quotient_list_core];
  FIRST_X_ASSUM_ST `split_face` MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC fgraph_splitFace [`g`;`FST y`;`FST z'`;`h`;`newVs`];
  REWRITE_TAC[LET_PAIR];
  ASM_REWRITE_TAC[LET_THM];
  DISCH_THEN SUBST1_TAC;
  FULL_EXPAND_TAC "N'";
  INTRO_TAC ntrans1 [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[LET_PAIR];
  ASM_SIMP_TAC[LET_THM];
  DISCH_THEN kill;
  REWRITE_TAC[lower_case;Seq.map_cat;Seq.map];
  REPEAT (FIRST_X_ASSUM_ST `core L f = u` (MP_TAC o GSYM)) THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `Face` MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[vertices_face_FST];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[Seq.map_MAP];
  TYPIFY `MAP FST (replace h [Face (core L f2) F] (faces g)) = replace (FST h) [core L f2] (MAP FST (faces g)) /\ MAP (core L) (replace r [f2] N) = replace (core L r) [core L f2] (MAP (core L) N)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    ASM_REWRITE_TAC[];
    AP_TERM_TAC;
    ASM_REWRITE_TAC[GSYM fgraph];
    BY(REWRITE_TAC[quotient_list_core]);
  REPEAT (GMATCH_SIMP_TAC map_replace);
  ASM_REWRITE_TAC[MAP;vertices_face_FST];
  INTRO_TAC List_hypermap.good_list_uniq [`quotient_list L N`];
  SUBANTS_TAC;
    MATCH_MP_TAC good_list_quotient;
    ASM_SIMP_TAC[is_restricted_all_uniq];
    BY(ASM_MESON_TAC[marked_list;is_restricted]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REWRITE_TAC[quotient_list_core];
  DISCH_TAC;
  SUBCONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_MESON_TAC[Aq8.uniq_imp_inj]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (MAP FST (faces g))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[GSYM fgraph;quotient_list_core]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP Aq8.uniq_imp_inj);
  POP_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


(* ------------------------------------------------------------ *)
(*  OLDER STUFF *)
(* ------------------------------------------------------------ *)



let subdivFace0_alt_next_el_k = prove_by_refinement(
  `!g f u  v w vos vos'.
    all (isSome) vos /\
    nextVertex f u = the (HD vos) /\
    (!i. i < ...
    all (nextVertex (
    nextVertex f u = (the v) ==>
    subdivFace0_alt g f u 0 (cat vos vos') = 
    subdivFace0_alt g f (the v) 0 vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v:(num)option. isSome v ==> ~(v = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GSYM not_isSome_NONE]);
  BY(ASM_SIMP_TAC[LET_THM])
  ]);;
  (* }}} *)

subdivFace0_alt;;

let subdivFace0_alt_none_segment = prove_by_refinement(
  `!g f u n vs.
    vs = cat vs' vs'' /\
    isSome v /\ isSome v3 /\
    vs' = v :: (rcons v2 v3) /\
    ~(v2 = []) /\
    all (\t. t = NONE) v2 ==>
    sbudivFace0_alt g f u 0 vs = 
	(let ws = iota (countVertices g) (n) in 
	 let f1,f2,g' = splitFace g u (the v3) f ws in
	   subdivFace0_alt g' f2 (the v3) 0 vs''`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let core_triple = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let subdivFaceFinal2_subdivFace = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  subdivFaceFinal2 g f uvns = subdivFaceFinal
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)

triple_data;;
subdivFace0_alt2;;
subdivFaceFinal2;;
subdivFace;;

let match_quotient_list_reduction = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET
         set_of_list (filter (final_list L) N')
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)

let subdivFace_generatePolygon_reduction = prove_by_refinement(
  `subdivFace_reduction_v3 /\    
    (!(L:((num)list)list). good_list L /\ good_list_nodes L ==>
  	   transform_assumption_v2 L) // AQ
  ==>
    generatePolygon_reduction_v4`,
  (* {{{ proof *)
  [
  rt[generatePolygon_reduction;subdivFace_reduction]
  st/r
  rep 7 (pop (mp o sym))
  st/r
  abbrev `uvns = core_triple g L N`
  abbrev `g' = subdivFaceFinal2 g f uvns`
  typ `g'` ex
  fxa (C intro [`L`;`N`;`N'`;`g`;`g'`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`])
  art[]
  simp[]
  st/r
  rt[generatePolygon]
  art[match_quotient_list]
  ]);;
  (* }}} *)

subdivFace_reduction;;
match_quotient_list;;


