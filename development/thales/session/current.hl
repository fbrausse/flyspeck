(* Stuff July 2014 on Bauer-Nipkow compatibility checks *)


needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Current = struct
end;;


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;

(* ********************************************************************** *)
(* NEW DEFS *)
(* ********************************************************************** *)


let triple_data = new_definition'
  `!g L N. triple_data_v3 g L N = 
    (
      let (r,x) = loop_choice2 g L N in
      let k = transform_count L N r x in
	MAP (\i. (ytrans L N r x i,ztrans L N r x i, 
		  betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) 
	  (iota 0 k))`;;

let core_triple = new_definition'
  `core_triple_v3 g L N = 
  MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) (triple_data_v3 g L N)`;;

(* subdivFace0C *)

let subdivFace0C = 0;; (* now subdivFace0_beta *)

let subdivFace0_beta = new_recursive_definition list_RECURSION
  `subdivFace0_beta g f uo n [] = ((uo,n),f,g) /\
    subdivFace0_beta g f uo n (vo :: vos) = 
      if (uo = NONE) then subdivFace0_beta g f vo 0 vos else
      if (vo = NONE) then subdivFace0_beta g f uo (SUC n) vos else
	(let v = the vo in
	 let u = the uo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace0_beta g f vo 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		subdivFace0_beta g' f2 vo 0 vos))`;;

let subdivFace0i = 0;; (* now subdiv_single_step *)

let subdiv_single_step = new_definition'
  `subdiv_single_step ((uo,n),f,g) vo = 
    (if (uo = NONE) then ((vo,0),(f,g)) else
       if (vo = NONE) then ((uo,SUC n),f,g) else
	 (let v = the vo in
	  let u = the uo in
	    if (nextVertex f u = v /\ n = 0) then ((vo,0),f,g) else
	      (let ws = upt (countVertices g) (countVertices g + n) in
	       let (f1,f2,g') = splitFace g u v f ws in
		 ((vo,0),f2,g'))))`;;

let subdivFace0altj = 0;; (* now subdiv_triple_step *)

let subdiv_triple_step = new_definition'
  `subdiv_triple_step (n0,f,g) uvn = 
    (let (u,v,n) = uvn in
     let ws = upt n0 (n0+n) in
     let (f1,f2,g') = splitFace g u v f ws in
       (n+n0,f2,g'))`;;

(* dest_triple1 deleted, replaced with this *)

let dest_triple1A = 0;;  (* now dest_triple0_step *)

let dest_triple0_step = new_definition'
  `dest_triple0_step f s ((u:A),v,n) =
    (let ns = nseq n NONE in
       if (flatten s = []) then [(flatten[[SOME u];ns;[SOME v]])]
       else 
	 (let u0 = the (LAST (LAST s)) in
	  let b = MAP SOME (betwn f u0 u) in
	    if (u0 = u) then rcons s (flatten[ns;[SOME v]])
	    else if (next_el f u0 = u) then rcons s (flatten[[SOME u];ns;[SOME v]])
	    else rcons s (flatten[b;[SOME u];ns;[SOME v]])))`;;

let generatePolygon_explicit = new_definition'
  `generatePolygon_explicit_v3 <=> (!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v3 g L N /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
	 match_quotient_list g' L N' /\
	 good_faces_v3 g' /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  ))`;;

let generateNonfinalPolygon_explicit = new_definition'
  `generateNonfinalPolygon_explicit_v6 <=> (!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v3 g L N /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
	transform_assumption_v2 L /\					   
	  list_pairs (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) = rtrans L N r x k /\ 
	  fgraph g' = quotient_list L N' /\
	  good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
	  MEM g' (generatePolygon i v f g)
  ))`;;


(* ********************************************************************** *)
(* SMALL LEMMAS *)
(* ********************************************************************** *)

let LAMBDA_TRIPLE = prove
 (`(\(x,y,z). P x y z) = (\p. P (FST p) (FST (SND p)) (SND (SND p)))`,
  REWRITE_TAC[FUN_EQ_THM; FORALL_PAIR_THM] THEN
  CONV_TAC(ONCE_DEPTH_CONV GEN_BETA_CONV) THEN REWRITE_TAC[]);;

let foldl_flatten = prove_by_refinement(
  `!lls f a. foldl (foldl f) a lls = foldl f a (flatten lls)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.foldl;Seq.flatten0];
  BY(ASM_REWRITE_TAC[Seq.flatten_cons;Seq.foldl_cat])
  ]);;
  (* }}} *)

let nil_flatten2 = prove_by_refinement(
  `!t. all (\r. ~(r=[])) t ==> (flatten t = [] <=> t = [])`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.flatten0;Aq4.nil_flatten])
  ]);;
  (* }}} *)

let flatten_rcons_flatten = prove_by_refinement(
  `!A B. flatten (rcons A (flatten B)) = flatten (flatten A :: B)`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.flatten0;concat_flatten;APPEND;Seq.rcons;APPEND_NIL;APPEND_ASSOC])
  ]);;
  (* }}} *)


let AQ6_INDUCT = prove_by_refinement(
  `!i L N r x.  transform_assumption_v2 L /\ good_list L /\ good_list_nodes L /\
    marked_list L N r x ==> MEM (rtrans L N r x i) (ntrans L N r x i)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.AQIUNPP3 [`L`;`i`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let trans_add = prove_by_refinement(
  `!L N r x a b.
    ntrans L N r x (b+a) = ntrans L (ntrans L N r x a) (rtrans L N r x a) x b /\
    rtrans L N r x (b+a) = rtrans L (ntrans L N r x a) (rtrans L N r x a) x b 
    `,

  (* {{{ proof *)
  [
      BY(REWRITE_TAC[rtrans;ntrans;GSYM PAIR_EQ;Hypermap.addition_exponents;o_THM])
  ]);;
  (* }}} *)

let min_num_translate = prove_by_refinement(
  `!a P. (?n. P n) ==> min_num { i | P i } + a = min_num {i + a | P i}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `(a <= b) /\ b <= a ==> (a = b:num)`);
  CONJ_TAC;
    TYPED_ABBREV_TAC `b = min_num {i + a | P i}`;
    INTRO_TAC Tame_list.min_num_in [`{i + a | P (i:num) }`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      ASM_REWRITE_TAC[IN_ELIM_THM;EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    TYPIFY `a <= b:num` (C SUBGOAL_THEN ASSUME_TAC);
      POP_ASSUM MP_TAC THEN REWRITE_TAC[IN_ELIM_THM];
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    TYPIFY_GOAL_THEN `!m. m + a <= b <=> m <= b - a:num` (unlist REWRITE_TAC);
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    MATCH_MP_TAC Tame_list.min_num_le;
    REWRITE_TAC[IN_ELIM_THM];
    FIRST_X_ASSUM_ST `IN` MP_TAC THEN REWRITE_TAC[IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `b - a = i:num` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_REWRITE_TAC[]);
  TYPED_ABBREV_TAC `b = min_num {i  | P i}`;
  MATCH_MP_TAC Tame_list.min_num_le;
  REWRITE_TAC[IN_ELIM_THM];
  TYPIFY `b` EXISTS_TAC;
  REWRITE_TAC[];
  INTRO_TAC Tame_list.min_num_in [`{i | P (i:num) }`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    ASM_REWRITE_TAC[IN_ELIM_THM;EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
    BY(ASM_MESON_TAC[]);
  BY(ASM_REWRITE_TAC[IN_ELIM_THM])
  ]);;
  (* }}} *)

let rtrans1 = prove_by_refinement(
  `!L N r x.
     ~final_list L r ==> 
    rtrans L N r x 1 = 
	 SND (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)
             (prev_el r (l'z L N r x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[transform_list;rtrans;Hypermap.POWER_1;LET_THM];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let zip_eq_nil = prove_by_refinement(
  `!s t. ~(s = []) /\ ~(t = []) ==> ~(zip s t = [])`,
  (* {{{ proof *)
  [
      BY(LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.zip;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let prev_el_rotate_to = prove_by_refinement(
  `!r y x. MEM x r /\ uniq r
            ==> prev_el r y = prev_el (rotate_to r x) y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. rotate_to r x = rot n r` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq2.prev_el_rot_eq]);
  BY(ASM_MESON_TAC[Pwssrat.rotate_rot_indexl])
  ]);;
  (* }}} *)

let nseq_suc = prove_by_refinement(
  `!n x. nseq (SUC n) x = x:: (nseq n x)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.nseq;Ssrnat.iter;Seq.ncons])
  ]);;
  (* }}} *)


(* ********************************************************************** *)
(* MAIN REDUCTIONS *)
(* ********************************************************************** *)

let generatePolygon_explicit_reduction = prove_by_refinement(
  `generatePolygon_explicit_v3 ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  REWRITE_TAC[generatePolygon_reduction;generatePolygon_explicit];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `uvns = core_triple_v3 g L N`;
  TYPED_ABBREV_TAC `g' = subdivFaceFinal2 g f uvns`;
  TYPED_ABBREV_TAC `i = sizel (find_face L x)`;
  GEXISTL_TAC [`g'`;`i`];
  TYPIFY `3 <= i /\ i <= maxGon p` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    DISCH_THEN kill;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`N`;`p`;`fs`;`k`;`r`;`x`;`uvns`];
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "i";
  TYPIFY `MEM (find_face L x) (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.mem_find_face;
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(GEXISTL_TAC [`N`;`r`] THEN ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    MATCH_MP_TAC Tame_list.is_restricted_size_face;
    TYPIFY `L` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  ASM_REWRITE_TAC[maxGon];
  ONCE_REWRITE_TAC[GSYM Tame_list.map_size_list_of_faces];
  INTRO_TAC Tame_list.foldr_size_max [`list_of_faces L`;`find_face L x`];
  ASM_REWRITE_TAC[];
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let subdivFace0_alt2_finals = prove_by_refinement(
  `!vs g f n.
            MEM f (faces g) /\ ~SND f
            ==> finals g = finals (SND (subdivFace0_alt2 g f n vs))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[subdivFace0_alt2];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `finals g = finals g'` (C SUBGOAL_THEN SUBST1_TAC);
    FIRST_X_ASSUM_ST `splitFace` MP_TAC;
    ONCE_REWRITE_TAC[PAIR_EQ2];
    REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2] THEN REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "g'";
    BY(ASM_MESON_TAC[Reduction1.splitFace_finals]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  INTRO_TAC splitFace_split_face [`g`;`u`;`v`;`f`;`ws`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Reduction1.split_face_nonfinal2 [`f`;`u`;`v`;`ws`];
  LET_TAC;
  DISCH_TAC;
  CONJ2_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[PAIR_EQ2]);
    RULE_ASSUM_TAC (REWRITE_RULE[]);
    ASM_SIMP_TAC[];
    DISCH_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`];
  ASM_REWRITE_TAC[] THEN LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let subdivFaceFinal2_finals = prove_by_refinement(
  `!vs g f n. MEM f (faces g) /\ ~SND f
            ==> set_of_list (finals (subdivFaceFinal2 g f vs)) SUBSET 
		set_of_list (finals g) UNION {setFinal(FST (subdivFace0_alt2 g f (countVertices g) vs))} `,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFaceFinal2];
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC subdivFace0_alt2_finals [`vs`;`g`;`f`;`(countVertices g)`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REWRITE_TAC[IN_SET_OF_LIST;SUBSET;IN_UNION;IN_SING];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction1.mem_faces_makeFaceFinal [`g'`;`f'`;`x`];
  ASM_REWRITE_TAC[REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let transform_count_add = prove_by_refinement(
  `!L N r x a b.
    transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      marked_list L N r x /\
    a <= transform_count L N r x ==> 
    transform_count L (ntrans L N r x a) (rtrans L N r x a) x = transform_count L N r x - a`,
  (* {{{ proof *)
  [
  REWRITE_TAC[transform_count;GSYM trans_add];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `(a <= b) /\ b <= a ==> (a = b:num)`);
  CONJ_TAC;
    TYPED_ABBREV_TAC `b = min_num {i | final_list L (rtrans L N r x i)}`;
    MATCH_MP_TAC Tame_list.min_num_le;
    REWRITE_TAC[IN_ELIM_THM];
    TYPIFY `b - a + a = b:num` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    INTRO_TAC Tame_list.min_num_in [`{i | final_list L (rtrans L N r x i)}`];
    ASM_REWRITE_TAC[IN_ELIM_THM];
    DISCH_THEN MATCH_MP_TAC;
    TYPED_ABBREV_TAC `t = transform_count L N r x`;
    REWRITE_TAC[EXTENSION;IN_ELIM_THM;NOT_IN_EMPTY;NOT_FORALL_THM];
    TYPIFY `t` EXISTS_TAC;
    MATCH_MP_TAC (GEN_ALL Kbwpbhq.final_list_transform_count);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY_GOAL_THEN `!x u. a <= x ==> (x - a <= u <=> x <= u + a:num)` (unlist ASM_SIMP_TAC);
    BY(ARITH_TAC);
  GMATCH_SIMP_TAC (min_num_translate);
  SUBCONJ_TAC;
    INTRO_TAC Kbwpbhq.KBWPBHQ0 [`L`;`N`;`r`;`x`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `i` EXISTS_TAC;
    ONCE_REWRITE_TAC[arith `a + b = b + a:num`];
    REWRITE_TAC[trans_add];
    MATCH_MP_TAC rtrans_final_prop;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Tame_list.AQIUNPP3;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Uaghhbm.MIN_NUM_SUBSET);
  TYPIFY `n+a:num` EXISTS_TAC;
  REWRITE_TAC[SUBSET;IN_ELIM_THM];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let ntrans_final_list1 = prove_by_refinement(
  `!L N r x f. 
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\ ~final_list L r /\
    ~(f = r) /\ MEM f N  ==>
     ~(f = rtrans L N r x 1) /\ MEM f (ntrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq9.fst_not_eq_rtrans_split) [`f`;`L`;`N`;`r`;`x`];
  INTRO_TAC (GEN_ALL Aq9.snd_not_eq_rtrans_split) [`f`;`L`;`N`;`r`;`x`];
  INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
  INTRO_TAC Aq9.r_not_eq_split_norm_v0 [`L`;`N`;`ntrans L N r x 1`;`r`;`r`;`x`];
  INTRO_TAC ntrans1 [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
  TYPIFY `MEM r N` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `fs =         (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)        (prev_el r (l'z L N r x)))`;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[rtrans1]);
  DISCH_TAC;
  ASM_REWRITE_TAC[Seq.mem_cat;MEM];
  BY(ASM_MESON_TAC[Tame_list.MEM3_replace])
  ]);;
  (* }}} *)

let ntrans_final_list = prove_by_refinement(
  `!k L N r x f. 
    transform_assumption_v2 L /\
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\ ~final_list L r /\
    ~(f = r) /\ MEM f N /\ k <= transform_count L N r x ==>
     ~(f = rtrans L N r x k) /\ MEM f (ntrans L N r x k)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_SIMP_TAC[trans0];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k=0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[arith`SUC 0 = 1`];
    MATCH_MP_TAC ntrans_final_list1;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[arith `SUC k = k +1`;trans_add];
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `~(f = rtrans L N r x 1) /\ MEM f (ntrans L N r x 1)` (unlist REWRITE_TAC);
    MATCH_MP_TAC ntrans_final_list1;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Tame_defs2.transform_assumption]);
  CONJ_TAC;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let generateNonfinalPolygon_reduction = prove_by_refinement(
  `generateNonfinalPolygon_explicit_v6 ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC generatePolygon_explicit_reduction;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[generateNonfinalPolygon_explicit;generatePolygon_explicit;match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(transform_assumption_v2 L /\ list_pairs               (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =              rtrans L N r x k /\ fgraph g' = quotient_list L N') ==> set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET   set_of_list (filter (final_list L) N')` ENOUGH_TO_SHOW_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
    DISCH_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`]);
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon` kill;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "g'";
  REWRITE_TAC[REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  MATCH_MP_TAC SUBSET_TRANS;
  TYPIFY `set_of_list (MAP (list_pairs o FST) (setFinal(FST (subdivFace0_alt2 g f (countVertices g) uvns)) :: (finals g)))` EXISTS_TAC;
  CONJ_TAC;
    REWRITE_TAC[SET_OF_LIST_MAP];
    MATCH_MP_TAC IMAGE_SUBSET;
    INTRO_TAC subdivFaceFinal2_finals [`uvns`;`g`;`f`;`(countVertices g)`];
    ANTS_TAC;
      CONJ_TAC;
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.minimalFace_face;
        BY(ASM_REWRITE_TAC[]);
      DISCH_TAC;
      TYPIFY `MEM f (nonFinals g)` (C SUBGOAL_THEN MP_TAC);
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.mem_minimalFace_nonFinals;
        BY(ASM_MESON_TAC[Tame_defs.finalGraph]);
      REWRITE_TAC[nonFinals;MEM_FILTER];
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[set_of_list];
    BY(SET_TAC[]);
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;MEM;o_THM;Tame_list.fst_setFinal;MAP];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[];
    POP_ASSUM kill;
    FIRST_X_ASSUM_ST `rtrans` (SUBST1_TAC o GSYM);
    REWRITE_TAC[upper_case;MEM_FILTER];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Kbwpbhq.final_list_transform_count]);
    FULL_EXPAND_TAC "N'";
    MATCH_MP_TAC AQ6_INDUCT;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `SUBSET` MP_TAC;
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  DISCH_THEN (C INTRO_TAC [`x'`]);
  ASM_REWRITE_TAC[];
  INTRO_TAC ntrans_final_list [`k`;`L`;`N`;`r`;`x`;`x'`];
  FIRST_X_ASSUM_ST `rtrans` (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[arith `k <= k:num`];
  REWRITE_TAC[Seq.mem_filter];
  SIMP_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let reduction_subdivFace = prove_by_refinement(
  `(!L N N' g p fs f v k r x uvns g' i vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v3 g L N /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      g' = subdivFaceFinal2 g f uvns /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      i = sizel (find_face L x)
      ==> transform_assumption_v2 L /\
                  fgraph g' = quotient_list L N' /\
          good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
	  3 <= sizel vs /\ // sizel_3_concl
          (HD vs = SOME v) /\ // hd_vs_some_v
          isSome (LAST vs) /\ // last_vs_some_prev
          (prev_el (FST f) v = the (LAST vs)) /\  // last_vs_some_prev
	  all (\t. MEM t (FST f)) (MAP the (filter isSome vs)) /\ // dest_triple_full_all_filter
          (!i. SUC i < sizel vs'
           ==> indexf v (EL i vs') (FST f) <
           indexf v (EL (SUC i) vs') (FST f)) /\
	  (i = sizel vs) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (fgraph g))
             ==> MEM d (list_pairs (FST f)))) /\
	  (subdivFace g f vs = g') /\
         list_pairs
      (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =
          rtrans L N r x k 
  ) 
  ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC generateNonfinalPolygon_reduction;
  REWRITE_TAC[generateNonfinalPolygon_explicit];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  TYPED_ABBREV_TAC `vs = dest_triple_full (FST f) v uvns`;
  TYPED_ABBREV_TAC `vs' = MAP the (filter isSome vs)`;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`;`vs`;`vs'`]);
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `sizel vs = i` (SUBST1_TAC o GSYM);
  MATCH_MP_TAC Reduction1.generatePolygon_criteria;
  TYPIFY `vs'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
  BY(ASM_MESON_TAC[Tame_list.quotient_all_uniq;match_quotient_list])
  ]);;
  (* }}} *)

let transform_count_non0 = prove_by_refinement(
  `!g L N r x. 
    transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       ~(final_list L r)  ==>
       ~(transform_count L N r x = 0)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Kbwpbhq.final_list_transform_count) [`0`;`L`;`N`;`r`;`x`];
  BY(ASM_REWRITE_TAC[trans0])
  ]);;
  (* }}} *)

let triple_data_nonnil = prove_by_refinement(
  `!g L N r x. 
    transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       loop_choice2 g L N = r,x /\
       ~(final_list L r) 
  ==> ~(triple_data_v3 g L N = [])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[triple_data];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  REWRITE_TAC[MAP_EQ_NIL];
  REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  DISCH_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[PAIR_EQ]);
  BY(ASM_MESON_TAC[transform_count_non0])
  ]);;
  (* }}} *)

let core_triple_nonnil = prove_by_refinement(
  `!g L N r x. transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       loop_choice2 g L N = r,x /\
       ~(final_list L r)  ==>
       ~(core_triple_v3 g L N = [])`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[core_triple;MAP_EQ_NIL;triple_data_nonnil])
  ]);;
  (* }}} *)

let sizel_3_concl = prove_by_refinement(
  `!L N r x. good_list L /\
      is_restricted (hypermap_of_list L) /\ marked_list L N r x ==>
    3 <= sizel (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (find_face L x) (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.mem_find_face;
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(GEXISTL_TAC [`N`;`r`] THEN ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Tame_list.is_restricted_size_face;
  TYPIFY `L` EXISTS_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple0_nonnil = prove_by_refinement(
  `!uvns f s. (~(uvns = []) \/ ~(s = [])) ==> ~(dest_triple0 (f) s uvns = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  DISJ2_TAC;
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let hd_dest_triple0 = prove_by_refinement(
  `!uvns f s. ~(s = []) ==> HD (dest_triple0 (f) s uvns) = HD s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `HD s = HD (flatten [s; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `HD s = HD (flatten [s; [SOME u]; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  TYPIFY `HD s = HD (flatten [s; b; [SOME u]; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let last_dest_triple0 = prove_by_refinement(
  `!uvns f s. ~(uvns = []) ==> LAST (dest_triple0 (f) s uvns) = SOME (FST(SND (LAST uvns)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[LAST];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
    BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let hd_core_triple=0;;

let el_core_triple = prove_by_refinement(
  `!L N r x g i. good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
     loop_choice2 g L N = r,x /\
     i < transform_count L N r x 
    ==>
    EL i (core_triple_v3 g L N) = (FST (ytrans L N r x i),FST(ztrans L N r x i),
				 sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core_triple;triple_data];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REPEAT (GMATCH_SIMP_TAC EL_MAP);
  REWRITE_TAC[LENGTH_MAP];
  REPEAT (GMATCH_SIMP_TAC Tame_list.el_iota);
  FIRST_X_ASSUM_ST `r',x' = r,x` MP_TAC THEN REWRITE_TAC[PAIR_EQ;lower_case;Seq.size_iota;arith`0+i=i` ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let size_core_triple = prove_by_refinement(
  `!L N r x g. 
     loop_choice2 g L N = r,x    ==>
    sizel (core_triple_v3 g L N) = transform_count L N r x`,
  (* {{{ proof *)
  [
  BY(SIMP_TAC[core_triple;lower_case;Seq.size_map;triple_data;LET_THM;LAMBDA_PAIR;Seq.size_iota])
  ]);;
  (* }}} *)

let last_core_triple = prove_by_refinement(
  `!L N r x g k'. transform_assumption_v2 L /\ good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
     loop_choice2 g L N = r,x /\
     PRE (transform_count L N r x)  = k'
    ==>
    LAST (core_triple_v3 g L N) = (FST (ytrans L N r x k'),FST(ztrans L N r x k'),
				 sizel (betwn (find_face L x) (ytrans L N r x k') (ztrans L N r x k')))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC LAST_EL;
  GMATCH_SIMP_TAC el_core_triple;
  GEXISTL_TAC [`r`;`x`] THEN ASM_REWRITE_TAC[lower_case];
  REPEAT (GMATCH_SIMP_TAC size_core_triple);
  GEXISTL_TAC [`r`;`x`] THEN ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    MATCH_MP_TAC core_triple_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[PAIR_EQ];
  ASM_REWRITE_TAC[arith `t - 1 = PRE t`];
  INTRO_TAC transform_count_non0 [`g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let hd_vs_some_v = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
      transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v3 g L N /\
      vs = dest_triple_full (FST f) v uvns 
  ==> HD vs = SOME v)`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[Tame_list.concat_flatten];
  TYPIFY `~(initial_seg = [])` ASM_CASES_TAC;
    ONCE_REWRITE_TAC[HD_APPEND];
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "initial_seg";
    POP_ASSUM MP_TAC;
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[HD]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[APPEND];
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "initial_seg";
  FIRST_X_ASSUM_ST `x = []` kill;
  FIRST_X_ASSUM_ST `x = []` MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `HD uvns = t` MP_TAC;
  REWRITE_TAC[GSYM EL];
  FULL_EXPAND_TAC "uvns";
  GMATCH_SIMP_TAC el_core_triple;
  GEXISTL_TAC [`r`;`x`];
  ASM_REWRITE_TAC[PAIR_EQ];
  SUBCONJ_TAC;
    REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  DISCH_TAC;
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ1_TAC;
  FULL_EXPAND_TAC "u";
  DISCH_TAC;
  FIRST_X_ASSUM_ST `HD` MP_TAC;
  INTRO_TAC CONS_HD_TL [`core_triple_v3 g L N`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[core_triple_nonnil]);
  DISCH_THEN SUBST1_TAC;
  REWRITE_TAC[dest_triple0];
  REWRITE_TAC[GSYM EL];
  GMATCH_SIMP_TAC el_core_triple;
  GEXISTL_TAC [`r`;`x`];
  REPEAT LET_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[EL];
  REWRITE_TAC[HD_APPEND];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[dest_triple0_nonnil;Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  GMATCH_SIMP_TAC hd_dest_triple0;
  REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL;APPEND;HD];
  BY(REPEAT (FIRST_X_ASSUM_ST `betwn` MP_TAC) THEN REWRITE_TAC[PAIR_EQ] THEN ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let last_vs_some_prev = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
      transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v3 g L N /\
      vs = dest_triple_full (FST f) v uvns 
  ==> LAST vs = SOME (prev_el (FST f) v))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[Tame_list.concat_flatten];
  TYPIFY `~(final_seg = [])` ASM_CASES_TAC;
    ASM_REWRITE_TAC[APPEND_NIL;APPEND_ASSOC];
    ONCE_REWRITE_TAC[LAST_APPEND];
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "final_seg";
    POP_ASSUM MP_TAC;
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Tame_list.LAST_rcons]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[APPEND;APPEND_NIL];
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "final_seg";
  FIRST_X_ASSUM_ST `x = []` kill;
  FIRST_X_ASSUM_ST `x = []` MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
    TYPIFY `~(uvns = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[core_triple_nonnil]);
    TYPIFY `uvns = APPEND (BUTLAST uvns) [LAST uvns]` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[APPEND_BUTLAST_LAST]);
    TYPED_ABBREV_TAC `k = transform_count L N r x`;
    FIRST_X_ASSUM_ST `LAST uvns = t` (MP_TAC o GSYM);
    INTRO_TAC last_core_triple [`L`;`N`;`r`;`x`;`g`;`PRE k`];
    ASM_SIMP_TAC[PAIR_EQ];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[LAST_APPEND];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      INTRO_TAC dest_triple0_nonnil [`(APPEND (BUTLAST uvns)      [FST (ytrans L N r x (PRE k)),       FST (ztrans L N r x (PRE k)),       sizel       (betwn (find_face L x) (ytrans L N r x (PRE k))       (ztrans L N r x (PRE k)))])`;`(FST f)`;`[]:((num)option)list`];
      ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL]);
    GMATCH_SIMP_TAC last_dest_triple0;
    BY(REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL;LAST_APPEND;APPEND_EQ_NIL;LAST]);
  BY(REWRITE_TAC[Tame_list.rcons_nonnil])
  ]);;
  (* }}} *)

let dest_triple0_mem = prove_by_refinement(
  `!uvns f s x. (!y. MEM y s /\ isSome y ==> (MEM (the y) f)) /\ 
    (!uvn. MEM uvn uvns ==> (MEM (FST uvn) f /\ MEM (FST (SND uvn)) f)) /\ 
    isSome x ==> 
    MEM x (dest_triple0 f s uvns) ==> MEM (the x) f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[dest_triple0;MEM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nseq` MP_TAC THEN REPEAT LET_TAC;
  FULL_EXPAND_TAC "ns";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
  ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`h`]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "b";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y (MAP SOME (betwn f u0 u))` ASM_CASES_TAC;
    POP_ASSUM MP_TAC;
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
    BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
  BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some])
  ]);;
  (* }}} *)

let minimalFace_core = prove_by_refinement(
  `(!L N r x g fs f v.
      transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      match_quotient_list g L N /\ 
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x  ==>
       (core L r = FST f))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (core L r) (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Tame_list.quotient_list_core];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (FST f) (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC THEN REWRITE_TAC[match_quotient_list];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
  TYPIFY `normal_list L N /\ is_edge_nondegenerate (hypermap_of_list L) /\ good_list L /\ all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;is_restricted;Tame_list.is_restricted_all_uniq]);
  TYPIFY `good_list (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC good_list_quotient;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (list_of_darts (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  TYPIFY `find_pair_list (quotient_list L N) x =  (FST f) /\ find_pair_list (quotient_list L N) x =  (core L r)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[List_hypermap.list_pairs_inj;List_hypermap.find_face_alt]);
  FIRST_ASSUM_ST `loop_choice2` MP_TAC THEN REWRITE_TAC[loop_choice];
  REPEAT LET_TAC THEN ASM_REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "r'";
  FULL_EXPAND_TAC "p";
  TYPIFY `f = f'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "f'";
  TYPIFY `v = w` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  REPEAT (FIRST_X_ASSUM_ST `T` kill);
  REPLICATE_TAC 10 (FIRST_X_ASSUM MP_TAC) THEN RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN SIMP_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[Tame_list.LYNVPSU]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "x";
  CONJ_TAC;
    TYPIFY `quotient_list L N = fgraph g` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[match_quotient_list]);
    ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC List_hypermap.find_pair_list_unique;
    CONJ_TAC;
      BY(ASM_MESON_TAC[match_quotient_list]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
    FIRST_X_ASSUM_ST `v',w = d` (SUBST1_TAC o GSYM);
    FULL_EXPAND_TAC "v'";
    MATCH_MP_TAC prev_el_list_pairs_eq;
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.allP]);
    RULE_ASSUM_TAC(REWRITE_RULE[]);
    FIRST_X_ASSUM_ST `minimalVertex` (SUBST1_TAC o GSYM);
    MATCH_MP_TAC Tame_list.mem_minimalVertex;
    BY(ASM_MESON_TAC[Reduction1.minimalFace_nonnil]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Tame_list.list_pairs_core;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP];
  TYPIFY `(find_list (parts L r) d)` EXISTS_TAC;
  CONJ2_TAC;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC List_hypermap.mem_find_list;
  GMATCH_SIMP_TAC Tame_list.parts_flatten;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil;Seq.allP])
  ]);;
  (* }}} *)

let mem_core_triple_minimalFace = prove_by_refinement(
  `(!L N r x g fs f v uvns uvn .
      transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
       match_quotient_list g L N /\
      uvns = core_triple_v3 g L N /\
    MEM uvn uvns ==> 
    (MEM (FST uvn) (FST f) /\ MEM (FST (SND uvn)) (FST f)))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "uvns";
  RULE_ASSUM_TAC(REWRITE_RULE[MEM_EXISTS_EL;lower_case]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  GMATCH_SIMP_TAC el_core_triple;
  GEXISTL_TAC [`r`;`x`];
  ASM_REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  GMATCH_SIMP_TAC size_core_triple;
  GEXISTL_TAC [`r`;`x`];
  ASM_SIMP_TAC[];
  INTRO_TAC minimalFace_core [`L`;`N`;`r`;`x`;`g`;`fs`;`f`;`v`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_THEN (ASSUME_TAC o GSYM) THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Tame_list.mem_core) [`N`;`L`;`r`];
  REWRITE_TAC[RIGHT_FORALL_IMP_THM];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  ASM_SIMP_TAC[];
  REPEAT STRIP_TAC THEN MATCH_MP_TAC MEMf_MAP;
    MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not])
  ]);;
  (* }}} *)

let dest_triple_full_all_filter = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
      transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      match_quotient_list g L N /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v3 g L N /\
      vs = dest_triple_full (FST f) v uvns 
  ==> all (\t. MEM t (FST f)) (MAP the (filter isSome vs)))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[MEM_MAP;Seq.mem_filter;Tame_list.concat_flatten;MEM_APPEND;MEM];
  X_GENv_TAC "p";
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `MEM x' (dest_triple0 (FST f) [] uvns)` ASM_CASES_TAC;
    POP_ASSUM MP_TAC;
    MATCH_MP_TAC dest_triple0_mem;
    ASM_REWRITE_TAC[MEM];
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC mem_core_triple_minimalFace;
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(FST f = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction1.minimalFace_nonnil;is_restricted;Tame_list.is_restricted_all_uniq;marked_list]);
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.mem_minimalVertex]);
  REPEAT (FIRST_X_ASSUM_ST `\/` DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[]);
    FULL_EXPAND_TAC "initial_seg";
    COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
    REWRITE_TAC[MEM_MAP] THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
    FIRST_X_ASSUM (MP_TAC o MATCH_MP Tame_list.betwn_mem);
    BY(SIMP_TAC[]);
  FULL_EXPAND_TAC "final_seg";
  TYPIFY `MEM u0 (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u0";
    BY(ASM_SIMP_TAC[Seq2.mem_prev_el]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  REWRITE_TAC[MEM_MAP;Seq.mem_rcons;MEM] THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
  FIRST_X_ASSUM (MP_TAC o MATCH_MP Tame_list.betwn_mem);
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let reduction_subdivFace2 = prove_by_refinement(
  `(!L N N' g p fs f v k r x uvns g' i vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v3 g L N /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      g' = subdivFaceFinal2 g f uvns /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      i = sizel (find_face L x)
      ==> transform_assumption_v2 L /\
      fgraph g' = quotient_list L N' /\
          good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
          (!i. SUC i < sizel vs'
           ==> indexf v (EL i vs') (FST f) <
           indexf v (EL (SUC i) vs') (FST f)) /\
	  (i = sizel vs) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (fgraph g))
             ==> MEM d (list_pairs (FST f)))) /\
	  (subdivFace g f vs = g') /\
         list_pairs
      (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =
          rtrans L N r x k 
  ) 
  ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_subdivFace;
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`;`vs`;`vs'`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[sizel_3_concl]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[hd_vs_some_v]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[dest_triple_full_all_filter]);
  ASM_REWRITE_TAC[];
  TYPIFY `LAST vs = SOME (prev_el (FST f) v)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[Tame_list.the_some;Ssrbool.isSome]);
  BY(ASM_MESON_TAC[last_vs_some_prev])
  ]);;
  (* }}} *)

(* ********************************************************************** *)
(* folding results. *)
(* ********************************************************************** *)

let subdivFace0_beta_subdivFace0_alt = prove_by_refinement(
  `!vos g f u n.  
      (~(vos = []) /\ SOME u = (HD vos) 
       ==>   SND( subdivFace0_beta g f NONE 0 vos) = subdivFace0_alt g f (u) 0 (TL vos) ) /\
    (SND(subdivFace0_beta g f (SOME u) n vos) = subdivFace0_alt g f u n vos)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL;HD;TL;subdivFace0_beta;subdivFace0_alt;Tame_list.not_some_none];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT LET_TAC;
  TYPIFY `u' = u` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[the_some]);
  TYPIFY `f1 = f1' /\ f2 = f2' /\ g' = g''` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u";
    BY(REPLICATE_TAC 2 ( POP_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[PAIR_EQ]);
  ASM_REWRITE_TAC[];
  TYPIFY `h = SOME v` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Tame_list.some_the])
  ]);;
  (* }}} *)

let subdivFace_subdivFace0_beta = prove_by_refinement(
  `!vos g f.  ~(vos = []) /\ isSome (HD vos) ==>
    subdivFace g f vos = 
    (let (uon,f',g') = subdivFace0_beta g f NONE 0 vos in makeFaceFinal f' g') `,
  (* {{{ proof *)
  [
  SIMP_TAC[Reduction1.subdivFaceFinal_eq];
  REWRITE_TAC[subdivFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE;LAMBDA_PAIR];
  TYPIFY `SND (subdivFace0_beta g f NONE 0 vos) = subdivFace0_alt g f (the (HD vos)) 0 (TL vos)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INTRO_TAC subdivFace0_beta_subdivFace0_alt [`vos`;`g`;`f`;`the (HD vos)`;`0`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Tame_list.some_the;
  BY(ASM_MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

let subdiv_single_step_paired = prove_by_refinement(
  `!p vo.
         subdiv_single_step p vo =
         (if FST (FST p) = NONE
          then (vo,0),FST (SND p),SND (SND p)
          else if vo = NONE
               then (FST (FST p),SUC (SND (FST p))),FST (SND p),SND (SND p)
               else let v = the vo in
                    let u = the (FST (FST p)) in
                    if nextVertex (FST (SND p)) u = v /\ SND (FST p) = 0
                    then (vo,0),FST (SND p),SND (SND p)
                    else let ws =
                             upt (countVertices (SND (SND p)))
                             (countVertices (SND (SND p)) + SND (FST p)) in
                         let f1,f2,g' =
                             splitFace (SND (SND p)) u v (FST (SND p)) ws in
                         (vo,0),f2,g')`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;subdiv_single_step])
  ]);;
  (* }}} *)

(* was foldl_subdivFace0_beta sym *)
let foldl_subdivFace0_beta = 0;;

let subdivFace0_beta_foldl_steps = GSYM (prove_by_refinement(
  `!vos p.
    foldl subdiv_single_step p vos = subdivFace0_beta (SND (SND p)) (FST (SND p)) (FST (FST p)) (SND (FST p)) vos`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdivFace0_beta];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_single_step_paired];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]));;
  (* }}} *)

let foldl_subdivFace =0;;

let subdivFace_foldl_steps = prove_by_refinement(
  `!vos g f.  ~(vos = []) /\ isSome (HD vos) ==>
    subdivFace g f vos = 
    (let (uon,f',g') = foldl subdiv_single_step ((NONE,0),f,g) vos in makeFaceFinal f' g') `,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM subdivFace0_beta_foldl_steps];
  BY(MESON_TAC[subdivFace_subdivFace0_beta])
  ]);;
  (* }}} *)

let subdiv_triple_step_paired = prove_by_refinement(
  `!p uvn. subdiv_triple_step p uvn = 
    (let (u,v,n) = uvn in
     let ws = upt (FST p) (FST p +n) in
     let (f1,f2,g') = splitFace (SND(SND p)) u v (FST(SND p)) ws in
       (n+(FST p),f2,g'))`,
  (* {{{ proof *)
  [
        BY(REWRITE_TAC[FORALL_PAIR_THM;subdiv_triple_step])
  ]);;
  (* }}} *)

let subdiv_triple_step_foldl = 0;;

let subdivFace0_alt2_foldl_steps = GSYM (prove_by_refinement(
  `!uvns p.
    SND(foldl subdiv_triple_step p uvns) = subdivFace0_alt2 (SND (SND p)) (FST (SND p)) (FST p) uvns`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdivFace0_alt2];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_triple_step_paired];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
  ]));;
  (* }}} *)

let dest_triple0_step_paired = prove_by_refinement(
  `!f s uvn.
         dest_triple0_step (f:(A)list) s uvn =
         (let ns = nseq (SND (SND uvn)) NONE in
          if flatten s = []
          then 
               [(flatten [[SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]])]
          else let u0 = the (LAST (LAST s)) in
               let b = MAP SOME (betwn f u0 (FST uvn)) in
               if u0 = FST uvn
               then rcons s (flatten [ns; [SOME (FST (SND uvn))]])
               else if next_el f u0 = FST uvn
                    then rcons s
                         (flatten
                         [[SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]])
                    else rcons s
                         (flatten
                         [b; [SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]]))`,
  (* {{{ proof *)
  [
        BY(REWRITE_TAC[FORALL_PAIR_THM;dest_triple0_step])
  ]);;
  (* }}} *)

let dest_triple0_step_nonnil = prove_by_refinement(
  `! f s uvn. (~(s=[])==> ~(LAST s = [])) ==>
    (~(dest_triple0_step f s uvn = []) ==> ~(LAST (dest_triple0_step f s uvn) = []))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0_step_paired];
  REPEAT WEAKER_STRIP_TAC;
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC);
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL;LAST;concat_flatten;APPEND_EQ_NIL;APPEND_NIL;GSYM Seq.cats1;GSYM Seq2.APPEND_cat];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL;LAST_APPEND;LAST];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL;LAST_APPEND;LAST])
  ]);;
  (* }}} *)

let dest_triple0_step_foldl = 0;;

let dest_triple0_foldl_steps = GSYM(prove_by_refinement(
  `!uvns (f:(A)list) s. (~(s=[]) ==> ~(LAST s = [])) ==>
    flatten(foldl (dest_triple0_step f) s uvns)  = dest_triple0 f (flatten s) uvns
    `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;dest_triple0];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` (REPEAT o GMATCH_SIMP_TAC);
  CONJ_TAC;
    BY(ASM_MESON_TAC[dest_triple0_step_nonnil]);
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE;dest_triple0_step_paired];
  REWRITE_TAC [MESON[COND_RAND] `!b x y. flatten (if b then x else y) = if b then flatten x else flatten y`];
  REWRITE_TAC[flatten_rcons_flatten];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;APPEND_ASSOC;APPEND;APPEND_NIL]);
  TYPIFY `the (LAST (flatten s)) = the (LAST (LAST s))` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC Aq23.LAST_FLATTEN_2;
    BY(ASM_MESON_TAC[Seq.flatten0]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]));;
  (* }}} *)

let subdiv_single_step_betwn = prove_by_refinement(
  `!b f g u v. uniq (FST f) /\ b = betwn (FST f) u v /\
    MEM u (FST f) /\ MEM v (FST f) /\ ~(u = v) /\ ~(next_el (FST f) u  = v) ==>
    foldl subdiv_single_step ((SOME u,0),f,g) (MAP SOME (betwn (FST f) u v)) = 
      ((SOME(prev_el (FST f) v),0),f,g)`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(betwn (FST f) u v = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.betwn_nil]);
  INTRO_TAC Dangeyj.HD_BETWN2 [`(FST f)`;`u`;`v`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC (GEN_ALL Aq12.betwn_cap_point) [`u`;`FST f`;`next_el (FST f) u`;`v`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    MATCH_MP_TAC MEM_HD;
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  REWRITE_TAC[upper_case;GSYM APPEND_ASSOC];
  TYPIFY `betwn (FST f) u (next_el (FST f) u) = []` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC Tame_list.betwn_nil;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      DISCH_TAC;
      INTRO_TAC Tame_list.next_el_refl [`u`;`FST f`];
      ASM_SIMP_TAC[];
      BY(ASM_MESON_TAC[MEM]);
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  REWRITE_TAC[APPEND];
  REWRITE_TAC[MAP];
  REWRITE_TAC[Seq.foldl];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_single_step];
  REWRITE_TAC[Tame_list.not_some_none];
  REWRITE_TAC[the_some];
  REWRITE_TAC[LET_THM];
  ASM_SIMP_TAC[Tame_list.nextVertex_next_el];
  FIRST_X_ASSUM (C INTRO_TAC [`betwn (FST f) (next_el (FST f) u) v`]);
  ANTS_TAC;
    FULL_EXPAND_TAC "i";
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.size_cons];
    BY(ARITH_TAC);
  DISCH_TAC;
  TYPED_ABBREV_TAC `u' = next_el (FST f) u`;
  TYPIFY `next_el (FST f) u' = v` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) u' v = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      ASM_REWRITE_TAC[];
      FULL_EXPAND_TAC "u'";
      BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
    REWRITE_TAC[MAP;subdiv_single_step;Seq.foldl];
    FULL_EXPAND_TAC "u'";
    FULL_EXPAND_TAC "v";
    BY(ASM_MESON_TAC[Seq2.prev_next_id]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Seq2.mem_next_el])
  ]);;
  (* }}} *)

let subdiv_single_step_nseg = prove_by_refinement(
  `!n u k f g.
       foldl subdiv_single_step ((SOME u,k),f,g)
             (nseq n NONE) =
             ((SOME u,n+k),f,g)`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.nseq;Seq.ncons;Ssrnat.iter;Seq.foldl;arith `0+k=k`]);
  BY(ASM_REWRITE_TAC[nseq_suc;Seq.foldl;subdiv_single_step;Tame_list.not_some_none;arith `n + SUC k = SUC n + k`])
  ]);;
  (* }}} *)

let subdiv_single_step_initial_seg = prove_by_refinement(
  `!f g u v0.
    uniq (FST f) /\
      MEM v0 (FST f) /\
      MEM u (FST f) ==>
    (let initial_seg = (if (v0=u) then [] else (SOME v0) :: ( MAP SOME (betwn (FST f) v0 u))) in
    foldl subdiv_single_step ((NONE,0),f,g) initial_seg = 
	 if (v0=u) then ((NONE,0),f,g) else (SOME (prev_el (FST f) u),0),f,g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[Seq.foldl;subdiv_single_step];
  TYPIFY `next_el (FST f) v0 = u` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) v0 u = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[MAP;Seq.foldl];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    FULL_EXPAND_TAC "u";
    BY(ASM_MESON_TAC[Seq2.prev_next_id]);
  GMATCH_SIMP_TAC subdiv_single_step_betwn;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let subdiv_single_step_final_seg = prove_by_refinement(
  `!f g u0 v'.
    uniq (FST f) /\
      MEM u0 (FST f) /\
      MEM v' (FST f) ==>
    (let final_seg = if (v'=u0) then [] else rcons (MAP SOME (betwn (FST f) v' u0)) (SOME u0) in
    foldl subdiv_single_step ((SOME v',0),f,g) final_seg = (SOME u0,0),f,g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdiv_single_step];
  REWRITE_TAC[GSYM Seq.cats1];
  REWRITE_TAC[Seq.foldl_cat];
  TYPIFY `next_el (FST f) v' = u0` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) v' u0 = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[MAP;Seq.foldl;subdiv_single_step;not_some_none;the_some;LET_THM];
    BY(ASM_SIMP_TAC[Tame_list.nextVertex_next_el]);
  GMATCH_SIMP_TAC subdiv_single_step_betwn;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.foldl;subdiv_single_step;not_some_none;the_some;LET_THM];
  GMATCH_SIMP_TAC Tame_list.nextVertex_next_el;
  CONJ_TAC;
    BY(ASM_SIMP_TAC[Seq2.mem_prev_el]);
  BY(ASM_SIMP_TAC[Seq2.next_prev_id])
  ]);;
  (* }}} *)

