(* Stuff July 2014 on Bauer-Nipkow compatibility checks *)


needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)
flyspeck_needs "tame/more_tame_concl.hl";;
flyspeck_needs "tame/tame_defs2.hl";;


module Current = struct
end;;

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;

(* ********************************************************************** *)
(* NEW DEFS *)
(* ********************************************************************** *)


let triple_data = new_definition'
  `!L N r (x:A#A). triple_data_v4 L N r x = 
    (
      let k = transform_count L N r x in
	MAP (\i. (ytrans L N r x i,ztrans L N r x i, 
		  betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) 
	  (iota 0 k))`;;

let core_triple = new_definition'
  `!L N r x. core_triple_v4 L N r (x:A#A) = 
  MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) (triple_data_v4 L N r x)`;;

let core_split_normal_list = new_definition'
  `!L N r (x:A#A). core_split_normal_list L N r x <=>
     ( let y = l'y L r x in
       let z = l'z L N r x in
       let z' = prev_el r z in
       let fx = find_face L x in
       let f1,f2 = split_normal_list L r fx y z' in
       let newVs = MAP FST (betwn fx y z) in
	 (core L f1 =
             cat (rev newVs)
             (cat [FST y] (cat (betwn (core L r) (FST y) (FST z')) [FST z'])) /\
             core L f2 =
             cat
             (cat [FST z'] (cat (betwn (core L r) (FST z') (FST y)) [FST y]))
             newVs))`;;

let core_split_normal_list_assumption = new_definition'
  `!L.  core_split_normal_list_assumption L <=> 
  (! N r (x:A#A).  good_list L /\
  good_list_nodes L /\
  marked_list L N r x /\
  ~final_list L r 
     ==> core_split_normal_list L N r x)`;;

let r_trans_eq_assumption = new_definition'
  `!L.  r_trans_eq_assumption L <=> 
  (! N r (x:A#A).  good_list L /\
  good_list_nodes L /\
  marked_list L N r x /\
  ~final_list L r 
     ==> r_rtrans_eq L N r x)`;;

let element_pre = new_definition'
  `!L N. element_pre L N <=>
    (elements_of_list (quotient_list L N) = 0..PRE (sizel (undup (MAP FST (flatten N)))))`;;


(* subdivFace0C *)

let subdivFace0_beta = new_recursive_definition list_RECURSION
  `subdivFace0_beta g f uo n [] = ((uo,n),f,g) /\
    subdivFace0_beta g f uo n (vo :: vos) = 
      if (uo = NONE) then subdivFace0_beta g f vo 0 vos else
      if (vo = NONE) then subdivFace0_beta g f uo (SUC n) vos else
	(let v = the vo in
	 let u = the uo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace0_beta g f vo 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		subdivFace0_beta g' f2 vo 0 vos))`;;

let subdiv_single_step = new_definition'
  `subdiv_single_step ((uo,n),f,g) vo = 
    (if (uo = NONE) then ((vo,0),(f,g)) else
       if (vo = NONE) then ((uo,SUC n),f,g) else
	 (let v = the vo in
	  let u = the uo in
	    if (nextVertex f u = v /\ n = 0) then ((vo,0),f,g) else
	      (let ws = upt (countVertices g) (countVertices g + n) in
	       let (f1,f2,g') = splitFace g u v f ws in
		 ((vo,0),f2,g'))))`;;

let subdiv_triple_step = new_definition'
  `subdiv_triple_step (n0,f,g) uvn = 
    (let (u,v,n) = uvn in
     let ws = upt n0 (n0+n) in
     let (f1,f2,g') = splitFace g u v f ws in
       (n+n0,f2,g'))`;;

(*
let fgtrans = new_definition'
  `!g L N r x i. 
    fgtrans_v1 g L N r x i = 
      subdivFace0_alt2 g (minimalFace (nonFinals g)) 0 (take (SUC i) (core_triple_v4 L N r x))`;;

let fgtrans = new_definition'
  `!g L N r x i. 
    fgtrans g L N r x i = 
      subdivFace0_alt2 g (minimalFace (nonFinals g)) 0 (take i (core_triple_v4 L N r x))`;;

let fgtrans = new_definition'
  `!g L N r x i. 
    fgtrans_v2 g L N r x i = 
      subdivFace0_alt2 g (minimalFace (nonFinals g)) (countVertices g) (take i (core_triple_v4 L N r x))`;;

let nfgtrans = new_definition'
  `!g f n L N r x i. 
    nfgtrans n f g L N r x i = 
     foldl subdiv_triple_step (n,f,g) (take i (core_triple_v4 L N r x))`;;

*)


let dest_triple0_step = new_definition'
  `dest_triple0_step f s ((u:A),v,n) =
    (let ns = nseq n NONE in
       if (flatten s = []) then [(flatten[[SOME u];ns;[SOME v]])]
       else 
	 (let u0 = the (LAST (LAST s)) in
	  let b = MAP SOME (betwn f u0 u) in
	    if (u0 = u) then rcons s (flatten[ns;[SOME v]])
	    else if (next_el f u0 = u) then rcons s (flatten[[SOME u];ns;[SOME v]])
	    else rcons s (flatten[b;[SOME u];ns;[SOME v]])))`;;

(* Added July 10, 2014 *)

let nfgtrans = new_definition'
  `!p L N r x i. 
    nfgtrans' p L N r x i = 
     foldl subdiv_triple_step p (take i (core_triple_v4 L N r x))`;;

(* dest_triple0_step does not update f ??
   Batch gives absolute indexing from the minimalFace.  *)

let batch = new_definition'
  `!f0 L N r (x:A#A) i.
     batch0 f0 L N r x i = flatten (foldl (dest_triple0_step f0) [] (take i (core_triple_v4 L N r x)))`;;

(* f0 absolutely grounded, ((u0,n),(f,g)) updated in every iteration.
   They (f and f0) diverge after the first iteration.  *)

let b_nfgtrans = new_definition'
  `!f0 g L N r x i.
     b_nfgtrans0 f0 g L N r x i = 
      (let fx = find_face L x in
       let fst_u0 = (if (FST (next_el fx x) = FST (ytrans L N r x 0)) then NONE 
		       else SOME (prev_el (FST f0) (FST (ytrans L N r x 0)))) in
	 foldl subdiv_single_step ((fst_u0,0),f0,g) (batch0 (FST f0) L N r x i))`;;





(* ********************************************************************** *)
(* SMALL LEMMAS *)
(* ********************************************************************** *)

let take_el = prove_by_refinement(
  `!n s. n < sizel s ==> take (SUC n) s = rcons (take n s) (EL n s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[Seq2.EL_nth;Seq.take_nth])
  ]);;
  (* }}} *)


let butlast_rcons = prove_by_refinement(
  `!xs x. butlast (rcons xs x) = xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.rcons;Seq2.butlast];
  POP_ASSUM MP_TAC;
  TYPIFY `t` SPEC1_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.rcons;Seq2.butlast];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let take1 = prove_by_refinement(
  `!xs. ~(xs=[]) ==> take 1 xs = [HD xs]`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.take;arith `1 = SUC 0`;HD])
  ]);;
  (* }}} *)

let LAMBDA_TRIPLE = prove
 (`(\(x,y,z). P x y z) = (\p. P (FST p) (FST (SND p)) (SND (SND p)))`,
  REWRITE_TAC[FUN_EQ_THM; FORALL_PAIR_THM] THEN
  CONV_TAC(ONCE_DEPTH_CONV GEN_BETA_CONV) THEN REWRITE_TAC[]);;

let foldl_flatten = prove_by_refinement(
  `!lls f a. foldl (foldl f) a lls = foldl f a (flatten lls)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.foldl;Seq.flatten0];
  BY(ASM_REWRITE_TAC[Seq.flatten_cons;Seq.foldl_cat])
  ]);;
  (* }}} *)

let nil_flatten2 = prove_by_refinement(
  `!t. all (\r. ~(r=[])) t ==> (flatten t = [] <=> t = [])`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.flatten0;Aq4.nil_flatten])
  ]);;
  (* }}} *)

let flatten_rcons_flatten = prove_by_refinement(
  `!A B. flatten (rcons A (flatten B)) = flatten (flatten A :: B)`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.flatten0;concat_flatten;APPEND;Seq.rcons;APPEND_NIL;APPEND_ASSOC])
  ]);;
  (* }}} *)

let AQ6_INDUCT = prove_by_refinement(
  `!i L N r x.  good_list L /\ good_list_nodes L /\
    marked_list L N r x ==> MEM (rtrans L N r x i) (ntrans L N r x i)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.AQIUNPP3 [`L`;`i`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let trans_add = prove_by_refinement(
  `!L N r x a b.
    ntrans L N r x (b+a) = ntrans L (ntrans L N r x a) (rtrans L N r x a) x b /\
    rtrans L N r x (b+a) = rtrans L (ntrans L N r x a) (rtrans L N r x a) x b /\
    ytrans L N r x (b+a) = ytrans L (ntrans L N r x a) (rtrans L N r x a) x b /\
    ztrans L N r x (b+a) = ztrans L (ntrans L N r x a) (rtrans L N r x a) x b 
    `,

  (* {{{ proof *)
  [
      BY(REWRITE_TAC[rtrans;ntrans;ytrans;ztrans;GSYM PAIR_EQ;Hypermap.addition_exponents;o_THM])
  ]);;
  (* }}} *)

let min_num_translate = prove_by_refinement(
  `!a P. (?n. P n) ==> min_num { i | P i } + a = min_num {i + a | P i}`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `(a <= b) /\ b <= a ==> (a = b:num)`);
  CONJ_TAC;
    TYPED_ABBREV_TAC `b = min_num {i + a | P i}`;
    INTRO_TAC Tame_list.min_num_in [`{i + a | P (i:num) }`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      ASM_REWRITE_TAC[IN_ELIM_THM;EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    TYPIFY `a <= b:num` (C SUBGOAL_THEN ASSUME_TAC);
      POP_ASSUM MP_TAC THEN REWRITE_TAC[IN_ELIM_THM];
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    TYPIFY_GOAL_THEN `!m. m + a <= b <=> m <= b - a:num` (unlist REWRITE_TAC);
      BY(REPEAT WEAKER_STRIP_TAC THEN ASM_TAC THEN ARITH_TAC);
    MATCH_MP_TAC Tame_list.min_num_le;
    REWRITE_TAC[IN_ELIM_THM];
    FIRST_X_ASSUM_ST `IN` MP_TAC THEN REWRITE_TAC[IN_ELIM_THM];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `b - a = i:num` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_REWRITE_TAC[]);
  TYPED_ABBREV_TAC `b = min_num {i  | P i}`;
  MATCH_MP_TAC Tame_list.min_num_le;
  REWRITE_TAC[IN_ELIM_THM];
  TYPIFY `b` EXISTS_TAC;
  REWRITE_TAC[];
  INTRO_TAC Tame_list.min_num_in [`{i | P (i:num) }`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    ASM_REWRITE_TAC[IN_ELIM_THM;EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
    BY(ASM_MESON_TAC[]);
  BY(ASM_REWRITE_TAC[IN_ELIM_THM])
  ]);;
  (* }}} *)

let rtrans1 = prove_by_refinement(
  `!L N r x.
     ~final_list L r ==> 
    rtrans L N r x 1 = 
	 SND (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)
             (prev_el r (l'z L N r x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[transform_list;rtrans;Hypermap.POWER_1;LET_THM];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let zip_eq_nil = prove_by_refinement(
  `!s t. ~(s = []) /\ ~(t = []) ==> ~(zip s t = [])`,
  (* {{{ proof *)
  [
      BY(LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.zip;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let prev_el_rotate_to = prove_by_refinement(
  `!r y x. MEM x r /\ uniq r
            ==> prev_el r y = prev_el (rotate_to r x) y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. rotate_to r x = rot n r` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq2.prev_el_rot_eq]);
  BY(ASM_MESON_TAC[Pwssrat.rotate_rot_indexl])
  ]);;
  (* }}} *)

let nseq0 = prove_by_refinement(
  `!x. nseq 0 x = []`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.nseq;Seq.ncons;Ssrnat.iter;])
  ]);;
  (* }}} *)

let nseq_suc = prove_by_refinement(
  `!n x. nseq (SUC n) x = x:: (nseq n x)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.nseq;Ssrnat.iter;Seq.ncons])
  ]);;
  (* }}} *)

let REPLICATE_nseq = prove_by_refinement(
  `REPLICATE = nseq`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  BY(INDUCT_TAC THEN ASM_REWRITE_TAC[nseq_suc;nseq0;REPLICATE])
  ]);;
  (* }}} *)

let el_nseq = prove_by_refinement(
  `!n x i. i < n ==> EL i (nseq n x) = x`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[EL;HD;arith `~(i < 0)`;nseq_suc];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC num_CASES [`i`];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)


(* ********************************************************************** *)
(* MAIN REDUCTIONS *)
(* ********************************************************************** *)


let generatePolygon_explicit_reduction = prove_by_refinement(
  `(!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v4 L N r x /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
	 match_quotient_list g' L N' /\
	 good_faces_v3 g' /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  )) ==> // generatePolygon_reduction_v7
    restricted_hypermaps_are_planegraphs_v4
`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC Reduction1.restricted_hypermaps_are_planegraphs_reduction1;
  REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  POP_ASSUM MP_TAC;
  REWRITE_TAC[generatePolygon_reduction;];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `uvns = core_triple_v4 L N r x`;
  TYPED_ABBREV_TAC `g' = subdivFaceFinal2 g f uvns`;
  TYPED_ABBREV_TAC `i = sizel (find_face L x)`;
  GEXISTL_TAC [`g'`;`i`];
  TYPIFY `3 <= i /\ i <= maxGon p` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    DISCH_THEN kill;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`N`;`p`;`fs`;`k`;`r`;`x`;`uvns`];
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "i";
  TYPIFY `MEM (find_face L x) (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.mem_find_face;
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(GEXISTL_TAC [`N`;`r`] THEN ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    MATCH_MP_TAC Tame_list.is_restricted_size_face;
    TYPIFY `L` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  ASM_REWRITE_TAC[maxGon];
  ONCE_REWRITE_TAC[GSYM Tame_list.map_size_list_of_faces];
  INTRO_TAC Tame_list.foldr_size_max [`list_of_faces L`;`find_face L x`];
  ASM_REWRITE_TAC[];
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let subdivFace0_alt2_finals = prove_by_refinement(
  `!vs g f n.
            MEM f (faces g) /\ ~SND f
            ==> finals g = finals (SND (subdivFace0_alt2 g f n vs))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[subdivFace0_alt2];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `finals g = finals g'` (C SUBGOAL_THEN SUBST1_TAC);
    FIRST_X_ASSUM_ST `splitFace` MP_TAC;
    ONCE_REWRITE_TAC[PAIR_EQ2];
    REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2] THEN REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC THEN FULL_EXPAND_TAC "g'";
    BY(ASM_MESON_TAC[Reduction1.splitFace_finals]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  INTRO_TAC splitFace_split_face [`g`;`u`;`v`;`f`;`ws`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Reduction1.split_face_nonfinal2 [`f`;`u`;`v`;`ws`];
  LET_TAC;
  DISCH_TAC;
  CONJ2_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[PAIR_EQ2]);
    RULE_ASSUM_TAC (REWRITE_RULE[]);
    ASM_SIMP_TAC[];
    DISCH_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`];
  ASM_REWRITE_TAC[] THEN LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let subdivFaceFinal2_finals = prove_by_refinement(
  `!vs g f n. MEM f (faces g) /\ ~SND f
            ==> set_of_list (finals (subdivFaceFinal2 g f vs)) SUBSET 
		set_of_list (finals g) UNION {setFinal(FST (subdivFace0_alt2 g f (countVertices g) vs))} `,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFaceFinal2];
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC subdivFace0_alt2_finals [`vs`;`g`;`f`;`(countVertices g)`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REWRITE_TAC[IN_SET_OF_LIST;SUBSET;IN_UNION;IN_SING];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction1.mem_faces_makeFaceFinal [`g'`;`f'`;`x`];
  ASM_REWRITE_TAC[REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let transform_count_add = prove_by_refinement(
  `!L N r x a b.
    // transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      marked_list L N r x /\
    a <= transform_count L N r x ==> 
    transform_count L (ntrans L N r x a) (rtrans L N r x a) x = transform_count L N r x - a`,
  (* {{{ proof *)
  [
  REWRITE_TAC[transform_count;GSYM trans_add];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `(a <= b) /\ b <= a ==> (a = b:num)`);
  CONJ_TAC;
    TYPED_ABBREV_TAC `b = min_num {i | final_list L (rtrans L N r x i)}`;
    MATCH_MP_TAC Tame_list.min_num_le;
    REWRITE_TAC[IN_ELIM_THM];
    TYPIFY `b - a + a = b:num` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    INTRO_TAC Tame_list.min_num_in [`{i | final_list L (rtrans L N r x i)}`];
    ASM_REWRITE_TAC[IN_ELIM_THM];
    DISCH_THEN MATCH_MP_TAC;
    TYPED_ABBREV_TAC `t = transform_count L N r x`;
    REWRITE_TAC[EXTENSION;IN_ELIM_THM;NOT_IN_EMPTY;NOT_FORALL_THM];
    TYPIFY `t` EXISTS_TAC;
    MATCH_MP_TAC (GEN_ALL Kbwpbhq.final_list_transform_count);
    BY(ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  TYPIFY_GOAL_THEN `!x u. a <= x ==> (x - a <= u <=> x <= u + a:num)` (unlist ASM_SIMP_TAC);
    BY(ARITH_TAC);
  GMATCH_SIMP_TAC (min_num_translate);
  SUBCONJ_TAC;
    INTRO_TAC Kbwpbhq.KBWPBHQ0 [`L`;`N`;`r`;`x`];
    ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `i` EXISTS_TAC;
    ONCE_REWRITE_TAC[arith `a + b = b + a:num`];
    REWRITE_TAC[trans_add];
    MATCH_MP_TAC Reduction2.rtrans_final_prop;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Tame_list.AQIUNPP3;
    BY(ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Uaghhbm.MIN_NUM_SUBSET);
  TYPIFY `n+a:num` EXISTS_TAC;
  REWRITE_TAC[SUBSET;IN_ELIM_THM];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let ntrans_final_list1 = prove_by_refinement(
  `!L N r x f. 
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\ ~final_list L r /\
    ~(f = r) /\ MEM f N  ==>
     ~(f = rtrans L N r x 1) /\ MEM f (ntrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq9.fst_not_eq_rtrans_split) [`f`;`L`;`N`;`r`;`x`];
  INTRO_TAC (GEN_ALL Aq9.snd_not_eq_rtrans_split) [`f`;`L`;`N`;`r`;`x`];
  INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
  INTRO_TAC Aq9.r_not_eq_split_norm_v0 [`L`;`N`;`ntrans L N r x 1`;`r`;`r`;`x`];
  INTRO_TAC Reduction2.ntrans1 [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
  TYPIFY `MEM r N` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `fs =         (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)        (prev_el r (l'z L N r x)))`;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[rtrans1]);
  DISCH_TAC;
  ASM_REWRITE_TAC[Seq.mem_cat;MEM];
  BY(ASM_MESON_TAC[Tame_list.MEM3_replace])
  ]);;
  (* }}} *)

let ntrans_final_list = prove_by_refinement(
  `!k L N r x f. 
//    transform_assumption_v2 L /\
    good_list L /\ good_list_nodes L /\ marked_list L N r x /\ ~final_list L r /\
    ~(f = r) /\ MEM f N /\ k <= transform_count L N r x ==>
     ~(f = rtrans L N r x k) /\ MEM f (ntrans L N r x k)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_SIMP_TAC[Reduction2.trans0];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k=0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[arith`SUC 0 = 1`];
    MATCH_MP_TAC ntrans_final_list1;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[arith `SUC k = k +1`;trans_add];
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `~(f = rtrans L N r x 1) /\ MEM f (ntrans L N r x 1)` (unlist REWRITE_TAC);
    MATCH_MP_TAC ntrans_final_list1;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Tame_defs2.transform_assumption;Reduction2.transform_assumption_v2_lemma]);
  CONJ_TAC;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let generateNonfinalPolygon_reduction = prove_by_refinement(
  `(!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v4 L N r x /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
//	transform_assumption_v2 L /\					   
	  list_pairs (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) = rtrans L N r x k /\ 
	  fgraph g' = quotient_list L N' /\
	  good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
	  MEM g' (generatePolygon i v f g)
  )) ==> restricted_hypermaps_are_planegraphs_v4
    // generatePolygon_reduction_v7
   `,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC generatePolygon_explicit_reduction;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[(* generateNonfinalPolygon_explicit;generatePolygon_explicit; *) match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(list_pairs               (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =              rtrans L N r x k /\ fgraph g' = quotient_list L N') ==> set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET   set_of_list (filter (final_list L) N')` ENOUGH_TO_SHOW_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
    DISCH_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`]);
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon` kill;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "g'";
  REWRITE_TAC[REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  MATCH_MP_TAC SUBSET_TRANS;
  TYPIFY `set_of_list (MAP (list_pairs o FST) (setFinal(FST (subdivFace0_alt2 g f (countVertices g) uvns)) :: (finals g)))` EXISTS_TAC;
  CONJ_TAC;
    REWRITE_TAC[SET_OF_LIST_MAP];
    MATCH_MP_TAC IMAGE_SUBSET;
    INTRO_TAC subdivFaceFinal2_finals [`uvns`;`g`;`f`;`(countVertices g)`];
    ANTS_TAC;
      CONJ_TAC;
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.minimalFace_face;
        BY(ASM_REWRITE_TAC[]);
      DISCH_TAC;
      TYPIFY `MEM f (nonFinals g)` (C SUBGOAL_THEN MP_TAC);
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.mem_minimalFace_nonFinals;
        BY(ASM_MESON_TAC[Tame_defs.finalGraph]);
      REWRITE_TAC[nonFinals;MEM_FILTER];
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[set_of_list];
    BY(SET_TAC[]);
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;MEM;o_THM;Tame_list.fst_setFinal;MAP];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[];
    POP_ASSUM kill;
    FIRST_X_ASSUM_ST `rtrans` (SUBST1_TAC o GSYM);
    REWRITE_TAC[upper_case;MEM_FILTER];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Kbwpbhq.final_list_transform_count;Reduction2.transform_assumption_v2_lemma]);
    FULL_EXPAND_TAC "N'";
    MATCH_MP_TAC AQ6_INDUCT;
    BY(ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  FIRST_X_ASSUM_ST `SUBSET` MP_TAC;
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  DISCH_THEN (C INTRO_TAC [`x'`]);
  ASM_REWRITE_TAC[];
  INTRO_TAC ntrans_final_list [`k`;`L`;`N`;`r`;`x`;`x'`];
  FIRST_X_ASSUM_ST `rtrans` (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[arith `k <= k:num`];
  REWRITE_TAC[Seq.mem_filter];
  SIMP_TAC[];
  BY(ASM_MESON_TAC[Reduction2.transform_assumption_v2_lemma])
  ]);;
  (* }}} *)

let reduction_subdivFace = prove_by_refinement(
  `(!L N N' g p fs f v k r x uvns g' i vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      g' = subdivFaceFinal2 g f uvns /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      i = sizel (find_face L x)
      ==> 
      // transform_assumption_v2 L /\
                  fgraph g' = quotient_list L N' /\
          good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
	  3 <= sizel vs /\ // sizel_3_concl
          (HD vs = SOME v) /\ // hd_vs_some_v
          isSome (LAST vs) /\ // last_vs_some_prev
          (prev_el (FST f) v = the (LAST vs)) /\  // last_vs_some_prev
	  all (\t. MEM t (FST f)) (MAP the (filter isSome vs)) /\ // dest_triple_full_all_filter
          (!i. SUC i < sizel vs'
           ==> indexf v (EL i vs') (FST f) <
           indexf v (EL (SUC i) vs') (FST f)) /\
	  (i = sizel vs) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (fgraph g))
             ==> MEM d (list_pairs (FST f)))) /\
	  (subdivFace g f vs = g') /\
         list_pairs
      (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =
          rtrans L N r x k 
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4
   // generatePolygon_reduction_v7
   `,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC generateNonfinalPolygon_reduction;
(*  REWRITE_TAC[generateNonfinalPolygon_explicit]; *)
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  TYPED_ABBREV_TAC `vs = dest_triple_full (FST f) v uvns`;
  TYPED_ABBREV_TAC `vs' = MAP the (filter isSome vs)`;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`;`vs`;`vs'`]);
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `sizel vs = i` (SUBST1_TAC o GSYM);
  MATCH_MP_TAC Reduction1.generatePolygon_criteria;
  TYPIFY `vs'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
  BY(ASM_MESON_TAC[Tame_list.quotient_all_uniq;match_quotient_list])
  ]);;
  (* }}} *)

let transform_count_non0 = prove_by_refinement(
  `!L N r x. 
   // transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       ~(final_list L r)  ==>
       ~(transform_count L N r x = 0)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Kbwpbhq.final_list_transform_count) [`0`;`L`;`N`;`r`;`x`];
  BY(ASM_REWRITE_TAC[Reduction2.trans0;Reduction2.transform_assumption_v2_lemma])
  ]);;
  (* }}} *)

let triple_data_nonnil = prove_by_refinement(
  `!L N r x. 
  //  transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       ~(final_list L r) 
  ==> ~(triple_data_v4 L N r x = [])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[triple_data];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  REWRITE_TAC[MAP_EQ_NIL];
  REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  DISCH_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[PAIR_EQ]);
  BY(ASM_MESON_TAC[transform_count_non0])
  ]);;
  (* }}} *)

let core_triple_nonnil = prove_by_refinement(
  `!L N r x. // transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       ~(final_list L r)  ==>
       ~(core_triple_v4 L N r x = [])`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[core_triple;MAP_EQ_NIL;triple_data_nonnil])
  ]);;
  (* }}} *)

let sizel_3_concl = prove_by_refinement(
  `!L N r x. good_list L /\
      is_restricted (hypermap_of_list L) /\ marked_list L N r x ==>
    3 <= sizel (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (find_face L x) (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.mem_find_face;
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(GEXISTL_TAC [`N`;`r`] THEN ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Tame_list.is_restricted_size_face;
  TYPIFY `L` EXISTS_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple0_nonnil = prove_by_refinement(
  `!uvns f s. (~(uvns = []) \/ ~(s = [])) ==> ~(dest_triple0 (f) s uvns = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    DISJ2_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  DISJ2_TAC;
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let hd_dest_triple0 = prove_by_refinement(
  `!uvns f s. ~(s = []) ==> HD (dest_triple0 (f) s uvns) = HD s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `HD s = HD (flatten [s; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `HD s = HD (flatten [s; [SOME u]; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  TYPIFY `HD s = HD (flatten [s; b; [SOME u]; ns; [SOME v]])` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;HD_APPEND]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let last_dest_triple0 = prove_by_refinement(
  `!uvns f s. ~(uvns = []) ==> LAST (dest_triple0 (f) s uvns) = SOME (FST(SND (LAST uvns)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT GEN_TAC;
  REPEAT LET_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[LAST];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
      BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
    BY(ASM_SIMP_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[dest_triple0];
    BY((ASM_REWRITE_TAC[Tame_list.concat_flatten;LAST_APPEND;APPEND_EQ_NIL;NOT_CONS_NIL;LAST]));
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let el_core_triple = prove_by_refinement(
  `!L N r (x:A#A) i. good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
     i < transform_count L N r x 
    ==>
    EL i (core_triple_v4 L N r x) = (FST (ytrans L N r x i),FST(ztrans L N r x i),
				 sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core_triple;triple_data];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REPEAT (GMATCH_SIMP_TAC EL_MAP);
  REWRITE_TAC[LENGTH_MAP];
  REPEAT (GMATCH_SIMP_TAC Tame_list.el_iota);
  REWRITE_TAC[PAIR_EQ;lower_case;Seq.size_iota;arith`0+i=i` ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let size_core_triple = prove_by_refinement(
  `!L N r x. 
    sizel (core_triple_v4 L N r x) = transform_count L N r x`,
  (* {{{ proof *)
  [
  BY(SIMP_TAC[core_triple;lower_case;Seq.size_map;triple_data;LET_THM;LAMBDA_PAIR;Seq.size_iota])
  ]);;
  (* }}} *)

let last_core_triple = prove_by_refinement(
  `!L N r x g k'. // transform_assumption_v2 L /\ 
    good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
     PRE (transform_count L N r x)  = k'
    ==>
    LAST (core_triple_v4 L N r x) = (FST (ytrans L N r x k'),FST(ztrans L N r x k'),
				 sizel (betwn (find_face L x) (ytrans L N r x k') (ztrans L N r x k')))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC LAST_EL;
  GMATCH_SIMP_TAC el_core_triple;
  ASM_REWRITE_TAC[lower_case];
  REWRITE_TAC[size_core_triple;arith `t - 1 = PRE t`];
  nCONJ_TAC 1;
    MATCH_MP_TAC core_triple_nonnil;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[PAIR_EQ];
  INTRO_TAC transform_count_non0 [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let hd_vs_some_v = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
     //  transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns 
  ==> HD vs = SOME v)`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[Tame_list.concat_flatten];
  TYPIFY `~(initial_seg = [])` ASM_CASES_TAC;
    ONCE_REWRITE_TAC[HD_APPEND];
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "initial_seg";
    POP_ASSUM MP_TAC;
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[HD]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[APPEND];
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "initial_seg";
  FIRST_X_ASSUM_ST `x = []` kill;
  FIRST_X_ASSUM_ST `x = []` MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `HD uvns = t` MP_TAC;
  REWRITE_TAC[GSYM EL];
  FULL_EXPAND_TAC "uvns";
  GMATCH_SIMP_TAC el_core_triple;
(*  GEXISTL_TAC [`r`;`x`];
  ASM_REWRITE_TAC[PAIR_EQ]; *)
  SUBCONJ_TAC;
    REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  DISCH_TAC;
  REWRITE_TAC[DE_MORGAN_THM;PAIR_EQ];
  DISJ1_TAC;
  FULL_EXPAND_TAC "u";
  DISCH_TAC;
  FIRST_X_ASSUM_ST `HD` MP_TAC;
  INTRO_TAC CONS_HD_TL [`core_triple_v4 L N r x`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[core_triple_nonnil]);
  DISCH_THEN SUBST1_TAC;
  REWRITE_TAC[dest_triple0];
  REWRITE_TAC[GSYM EL];
  GMATCH_SIMP_TAC el_core_triple;
(*  GEXISTL_TAC [`r`;`x`]; *)
  REPEAT LET_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[EL];
  REWRITE_TAC[HD_APPEND];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[dest_triple0_nonnil;Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL]);
  GMATCH_SIMP_TAC hd_dest_triple0;
  REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;NOT_CONS_NIL;APPEND;HD];
  BY(REPEAT (FIRST_X_ASSUM_ST `betwn` MP_TAC) THEN REWRITE_TAC[PAIR_EQ] THEN ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let last_vs_some_prev = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
   //   transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns 
  ==> LAST vs = SOME (prev_el (FST f) v))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[Tame_list.concat_flatten];
  TYPIFY `~(final_seg = [])` ASM_CASES_TAC;
    ASM_REWRITE_TAC[APPEND_NIL;APPEND_ASSOC];
    ONCE_REWRITE_TAC[LAST_APPEND];
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "final_seg";
    POP_ASSUM MP_TAC;
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Tame_list.LAST_rcons]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_REWRITE_TAC[APPEND;APPEND_NIL];
  POP_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "final_seg";
  FIRST_X_ASSUM_ST `x = []` kill;
  FIRST_X_ASSUM_ST `x = []` MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
    TYPIFY `~(uvns = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[core_triple_nonnil]);
    TYPIFY `uvns = APPEND (BUTLAST uvns) [LAST uvns]` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[APPEND_BUTLAST_LAST]);
    TYPED_ABBREV_TAC `k = transform_count L N r x`;
    FIRST_X_ASSUM_ST `LAST uvns = t` (MP_TAC o GSYM);
    INTRO_TAC last_core_triple [`L`;`N`;`r`;`x`;`g`;`PRE k`];
    ASM_SIMP_TAC[PAIR_EQ];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[LAST_APPEND];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      INTRO_TAC dest_triple0_nonnil [`(APPEND (BUTLAST uvns)      [FST (ytrans L N r x (PRE k)),       FST (ztrans L N r x (PRE k)),       sizel       (betwn (find_face L x) (ytrans L N r x (PRE k))       (ztrans L N r x (PRE k)))])`;`(FST f)`;`[]:((num)option)list`];
      ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL]);
    GMATCH_SIMP_TAC last_dest_triple0;
    BY(REWRITE_TAC[APPEND_EQ_NIL;NOT_CONS_NIL;LAST_APPEND;APPEND_EQ_NIL;LAST]);
  BY(REWRITE_TAC[Tame_list.rcons_nonnil])
  ]);;
  (* }}} *)

let dest_triple0_mem = prove_by_refinement(
  `!uvns f s x. (!y. MEM y s /\ isSome y ==> (MEM (the y) f)) /\ 
    (!uvn. MEM uvn uvns ==> (MEM (FST uvn) f /\ MEM (FST (SND uvn)) f)) /\ 
    isSome x ==> 
    MEM x (dest_triple0 f s uvns) ==> MEM (the x) f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[dest_triple0;MEM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nseq` MP_TAC THEN REPEAT LET_TAC;
  FULL_EXPAND_TAC "ns";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`h`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq;];
  ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;Seq2.mem_nseq];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`h`]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "b";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y (MAP SOME (betwn f u0 u))` ASM_CASES_TAC;
    POP_ASSUM MP_TAC;
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
    BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
  BY(ASM_MESON_TAC[Ssrbool.isSome;Tame_list.the_some])
  ]);;
  (* }}} *)

let minimalFace_core = prove_by_refinement(
  `(!L N r x g fs f v.
    //  transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      match_quotient_list g L N /\ 
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x  
       ==>
       (core L r = FST f))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (core L r) (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Tame_list.quotient_list_core];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (FST f) (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC THEN REWRITE_TAC[match_quotient_list];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
  TYPIFY `normal_list L N /\ is_edge_nondegenerate (hypermap_of_list L) /\ good_list L /\ all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;Hypermap.is_restricted;Tame_list.is_restricted_all_uniq]);
  TYPIFY `good_list (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC good_list_quotient;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (list_of_darts (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  TYPIFY `find_pair_list (quotient_list L N) x =  (FST f) /\ find_pair_list (quotient_list L N) x =  (core L r)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[List_hypermap.list_pairs_inj;List_hypermap.find_face_alt]);
  FIRST_ASSUM_ST `loop_choice2` MP_TAC THEN REWRITE_TAC[loop_choice];
  REPEAT LET_TAC THEN ASM_REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "r'";
  FULL_EXPAND_TAC "p";
  TYPIFY `f = f'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "f'";
  TYPIFY `v = w` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  REPEAT (FIRST_X_ASSUM_ST `T` kill);
  REPLICATE_TAC 10 (FIRST_X_ASSUM MP_TAC) THEN RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN SIMP_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[Tame_list.LYNVPSU]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "x";
  CONJ_TAC;
    TYPIFY `quotient_list L N = fgraph g` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[match_quotient_list]);
    ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC List_hypermap.find_pair_list_unique;
    CONJ_TAC;
      BY(ASM_MESON_TAC[match_quotient_list]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[Tame_list.mem_minimalFace_fgraph]);
    FIRST_X_ASSUM_ST `v',w = d` (SUBST1_TAC o GSYM);
    FULL_EXPAND_TAC "v'";
    MATCH_MP_TAC Reduction1.prev_el_list_pairs_eq;
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.allP]);
    RULE_ASSUM_TAC(REWRITE_RULE[]);
    FIRST_X_ASSUM_ST `minimalVertex` (SUBST1_TAC o GSYM);
    MATCH_MP_TAC Tame_list.mem_minimalVertex;
    BY(ASM_MESON_TAC[Reduction1.minimalFace_nonnil]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Tame_list.list_pairs_core;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP];
  TYPIFY `(find_list (parts L r) d)` EXISTS_TAC;
  CONJ2_TAC;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC List_hypermap.mem_find_list;
  GMATCH_SIMP_TAC Tame_list.parts_flatten;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil;Seq.allP])
  ]);;
  (* }}} *)

let mem_core_triple_minimalFace = prove_by_refinement(
  `(!L N r x g fs f v uvns uvn .
    //  transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
       match_quotient_list g L N /\
      uvns = core_triple_v4 L N r x /\
    MEM uvn uvns ==> 
    (MEM (FST uvn) (FST f) /\ MEM (FST (SND uvn)) (FST f)))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  GEN_TAC;
  TYPIFY `transform_assumption_v2 L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "uvns";
  RULE_ASSUM_TAC(REWRITE_RULE[MEM_EXISTS_EL;lower_case]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  GMATCH_SIMP_TAC el_core_triple;
(*  GEXISTL_TAC [`r`;`x`]; *)
  ASM_REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  REWRITE_TAC[size_core_triple];
(*  GEXISTL_TAC [`r`;`x`]; *)
  ASM_SIMP_TAC[];
  INTRO_TAC minimalFace_core [`L`;`N`;`r`;`x`;`g`;`fs`;`f`;`v`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_THEN (ASSUME_TAC o GSYM) THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Tame_list.mem_core) [`N`;`L`;`r`];
  REWRITE_TAC[RIGHT_FORALL_IMP_THM];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  ASM_SIMP_TAC[];
  REPEAT STRIP_TAC THEN MATCH_MP_TAC MEMf_MAP;
    MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not])
  ]);;
  (* }}} *)

let dest_triple_full_all_filter = prove_by_refinement(
  `(!L N r x g fs f v uvns vs.
    //  transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      match_quotient_list g L N /\
      ~final_list L r /\
      ~finalGraph g /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
     loop_choice2 g L N = r,x /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns 
  ==> all (\t. MEM t (FST f)) (MAP the (filter isSome vs)))`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[MEM_MAP;Seq.mem_filter;Tame_list.concat_flatten;MEM_APPEND;MEM];
  X_GENv_TAC "p";
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `MEM x' (dest_triple0 (FST f) [] uvns)` ASM_CASES_TAC;
    POP_ASSUM MP_TAC;
    MATCH_MP_TAC dest_triple0_mem;
    ASM_REWRITE_TAC[MEM];
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC mem_core_triple_minimalFace;
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(FST f = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction1.minimalFace_nonnil;Hypermap.is_restricted;Tame_list.is_restricted_all_uniq;marked_list]);
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.mem_minimalVertex]);
  REPEAT (FIRST_X_ASSUM_ST `\/` DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[]);
    FULL_EXPAND_TAC "initial_seg";
    COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
    REWRITE_TAC[MEM_MAP] THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
    FIRST_X_ASSUM (MP_TAC o MATCH_MP Tame_list.betwn_mem);
    BY(SIMP_TAC[]);
  FULL_EXPAND_TAC "final_seg";
  TYPIFY `MEM u0 (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u0";
    BY(ASM_SIMP_TAC[Seq2.mem_prev_el]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  REWRITE_TAC[MEM_MAP;Seq.mem_rcons;MEM] THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[Tame_list.the_some];
  FIRST_X_ASSUM (MP_TAC o MATCH_MP Tame_list.betwn_mem);
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let reduction_subdivFace2 = prove_by_refinement(
  `(!L N N' g p fs f v k r x uvns g' i vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      g' = subdivFaceFinal2 g f uvns /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      i = sizel (find_face L x)
      ==> 
      // transform_assumption_v2 L /\
      fgraph g' = quotient_list L N' /\
          good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
          (!i. SUC i < sizel vs'
           ==> indexf v (EL i vs') (FST f) <
           indexf v (EL (SUC i) vs') (FST f)) /\
	  (i = sizel vs) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (fgraph g))
             ==> MEM d (list_pairs (FST f)))) /\
	  (subdivFace g f vs = g') /\
         list_pairs
      (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =
          rtrans L N r x k 
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4
  // generatePolygon_reduction_v7 
    `,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_subdivFace;
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`;`vs`;`vs'`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[sizel_3_concl]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[hd_vs_some_v]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[dest_triple_full_all_filter]);
  ASM_REWRITE_TAC[];
  TYPIFY `LAST vs = SOME (prev_el (FST f) v)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[Tame_list.the_some;Ssrbool.isSome]);
  BY(ASM_MESON_TAC[last_vs_some_prev])
  ]);;
  (* }}} *)

(* ********************************************************************** *)
(* folding results. *)
(* ********************************************************************** *)

let subdivFace0_beta_subdivFace0_alt = prove_by_refinement(
  `!vos g f u n.  
      (~(vos = []) /\ SOME u = (HD vos) 
       ==>   SND( subdivFace0_beta g f NONE 0 vos) = subdivFace0_alt g f (u) 0 (TL vos) ) /\
    (SND(subdivFace0_beta g f (SOME u) n vos) = subdivFace0_alt g f u n vos)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL;HD;TL;subdivFace0_beta;subdivFace0_alt;Tame_list.not_some_none];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT LET_TAC;
  TYPIFY `u' = u` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[the_some]);
  TYPIFY `f1 = f1' /\ f2 = f2' /\ g' = g''` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u";
    BY(REPLICATE_TAC 2 ( POP_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[PAIR_EQ]);
  ASM_REWRITE_TAC[];
  TYPIFY `h = SOME v` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Tame_list.some_the])
  ]);;
  (* }}} *)

let subdivFace_subdivFace0_beta = prove_by_refinement(
  `!vos g f.  ~(vos = []) /\ isSome (HD vos) ==>
    subdivFace g f vos = 
    (let (uon,f',g') = subdivFace0_beta g f NONE 0 vos in makeFaceFinal f' g') `,
  (* {{{ proof *)
  [
  SIMP_TAC[Reduction1.subdivFaceFinal_eq];
  REWRITE_TAC[subdivFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE;LAMBDA_PAIR];
  TYPIFY `SND (subdivFace0_beta g f NONE 0 vos) = subdivFace0_alt g f (the (HD vos)) 0 (TL vos)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INTRO_TAC subdivFace0_beta_subdivFace0_alt [`vos`;`g`;`f`;`the (HD vos)`;`0`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Tame_list.some_the;
  BY(ASM_MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

let subdiv_single_step_paired = prove_by_refinement(
  `!p vo.
         subdiv_single_step p vo =
         (if FST (FST p) = NONE
          then (vo,0),FST (SND p),SND (SND p)
          else if vo = NONE
               then (FST (FST p),SUC (SND (FST p))),FST (SND p),SND (SND p)
               else let v = the vo in
                    let u = the (FST (FST p)) in
                    if nextVertex (FST (SND p)) u = v /\ SND (FST p) = 0
                    then (vo,0),FST (SND p),SND (SND p)
                    else let ws =
                             upt (countVertices (SND (SND p)))
                             (countVertices (SND (SND p)) + SND (FST p)) in
                         let f1,f2,g' =
                             splitFace (SND (SND p)) u v (FST (SND p)) ws in
                         (vo,0),f2,g')`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;subdiv_single_step])
  ]);;
  (* }}} *)

let subdivFace0_beta_foldl_steps = GSYM (prove_by_refinement(
  `!vos p.
    foldl subdiv_single_step p vos = subdivFace0_beta (SND (SND p)) (FST (SND p)) (FST (FST p)) (SND (FST p)) vos`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdivFace0_beta];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_single_step_paired];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]));;
  (* }}} *)

let subdivFace0_beta_foldl_steps_alt = (prove_by_refinement(
  `!f g n u0 vos.
    subdivFace0_beta g f u0 n vos = foldl subdiv_single_step ((u0,n),(f,g)) vos`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC subdivFace0_beta_foldl_steps [`vos`;`((u0,n),(f,g))`];
  BY(SIMP_TAC[])
  ]));;
  (* }}} *)

let subdivFace_foldl_steps = prove_by_refinement(
  `!vos g f.  ~(vos = []) /\ isSome (HD vos) ==>
    subdivFace g f vos = 
    (let (uon,f',g') = foldl subdiv_single_step ((NONE,0),f,g) vos in makeFaceFinal f' g') `,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM subdivFace0_beta_foldl_steps];
  BY(MESON_TAC[subdivFace_subdivFace0_beta])
  ]);;
  (* }}} *)

let subdiv_triple_step_paired = prove_by_refinement(
  `!p uvn. subdiv_triple_step p uvn = 
    (let (u,v,n) = uvn in
     let ws = upt (FST p) (FST p +n) in
     let (f1,f2,g') = splitFace (SND(SND p)) u v (FST(SND p)) ws in
       (n+(FST p),f2,g'))`,
  (* {{{ proof *)
  [
        BY(REWRITE_TAC[FORALL_PAIR_THM;subdiv_triple_step])
  ]);;
  (* }}} *)

let subdivFace0_alt2_foldl_steps = GSYM (prove_by_refinement(
  `!uvns p.
    SND(foldl subdiv_triple_step p uvns) = subdivFace0_alt2 (SND (SND p)) (FST (SND p)) (FST p) uvns`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdivFace0_alt2];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_triple_step_paired];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
  ]));;
  (* }}} *)

let subdivFace0_alt2_foldl_steps_alt = prove_by_refinement(
  `!uvns g f n uvns.
    subdivFace0_alt2 g f n uvns = SND (foldl subdiv_triple_step (n,f,g) uvns)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC subdivFace0_alt2_foldl_steps [`uvns`;`(n,f,g)`;];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let dest_triple0_step_paired = prove_by_refinement(
  `!f s uvn.
         dest_triple0_step (f:(A)list) s uvn =
         (let ns = nseq (SND (SND uvn)) NONE in
          if flatten s = []
          then 
               [(flatten [[SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]])]
          else let u0 = the (LAST (LAST s)) in
               let b = MAP SOME (betwn f u0 (FST uvn)) in
               if u0 = FST uvn
               then rcons s (flatten [ns; [SOME (FST (SND uvn))]])
               else if next_el f u0 = FST uvn
                    then rcons s
                         (flatten
                         [[SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]])
                    else rcons s
                         (flatten
                         [b; [SOME (FST uvn)]; ns; [SOME (FST (SND uvn))]]))`,
  (* {{{ proof *)
  [
        BY(REWRITE_TAC[FORALL_PAIR_THM;dest_triple0_step])
  ]);;
  (* }}} *)

let dest_triple0_step_nonnil = prove_by_refinement(
  `!f s uvn.
    ~(dest_triple0_step f s uvn = [])`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  REWRITE_TAC[FORALL_PAIR_THM];
  REWRITE_TAC[dest_triple0_step];
  REWRITE_TAC[dest_triple0_step;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Tame_list.rcons_nonnil];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Tame_list.rcons_nonnil])
  ]);;
  (* }}} *)

let dest_triple0_step_last_nonnil = prove_by_refinement(
  `! f s uvn. 
       (~(LAST (dest_triple0_step f s uvn) = []))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0_step_paired];
  REPEAT WEAKER_STRIP_TAC;
  (POP_ASSUM MP_TAC);
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC THEN REWRITE_TAC[Tame_list.LAST_rcons;LAST];
    BY(ASM_REWRITE_TAC[NOT_CONS_NIL;LAST;concat_flatten;APPEND_EQ_NIL;APPEND_NIL;GSYM Seq.cats1;GSYM Seq2.APPEND_cat]);
  COND_CASES_TAC THEN REWRITE_TAC[Tame_list.LAST_rcons;LAST];
    BY(ASM_REWRITE_TAC[NOT_CONS_NIL;LAST;concat_flatten;APPEND_EQ_NIL;APPEND_NIL;GSYM Seq.cats1;GSYM Seq2.APPEND_cat]);
  COND_CASES_TAC THEN REWRITE_TAC[Tame_list.LAST_rcons;LAST];
    BY(ASM_REWRITE_TAC[NOT_CONS_NIL;LAST;concat_flatten;APPEND_EQ_NIL;APPEND_NIL;GSYM Seq.cats1;GSYM Seq2.APPEND_cat]);
  BY(ASM_REWRITE_TAC[NOT_CONS_NIL;LAST;concat_flatten;APPEND_EQ_NIL;APPEND_NIL;GSYM Seq.cats1;GSYM Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let dest_triple0_foldl_steps = GSYM(prove_by_refinement(
  `!uvns (f:(A)list) s.   (~(s=[]) ==> ~(LAST s = [])) ==>
    flatten(foldl (dest_triple0_step f) s uvns)  = dest_triple0 f (flatten s) uvns
    `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.foldl;dest_triple0];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` (REPEAT o GMATCH_SIMP_TAC);
  CONJ_TAC;
    BY(ASM_MESON_TAC[dest_triple0_step_last_nonnil]); 
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE;dest_triple0_step_paired];
  REWRITE_TAC [MESON[COND_RAND] `!b x y. flatten (if b then x else y) = if b then flatten x else flatten y`];
  REWRITE_TAC[flatten_rcons_flatten];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_REWRITE_TAC[Tame_list.concat_flatten;MEM_APPEND;MEM;APPEND_ASSOC;APPEND;APPEND_NIL]);
  TYPIFY `the (LAST (flatten s)) = the (LAST (LAST s))` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC Aq23.LAST_FLATTEN_2;
    BY(ASM_MESON_TAC[Seq.flatten0]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]));;
  (* }}} *)

let foldl_step_last_nonnil = prove_by_refinement(
  `!a f s. (LAST (foldl (dest_triple0_step f) s a) = []) ==> (a = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[dest_triple0_step;Seq.foldl];
  REWRITE_TAC[NOT_CONS_NIL];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`f`;`(dest_triple0_step f s h)`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `LAST` MP_TAC THEN ASM_REWRITE_TAC[Seq.foldl];
  BY(ASM_MESON_TAC[dest_triple0_step_last_nonnil])
  ]);;
  (* }}} *)

let subdiv_single_step_betwn = prove_by_refinement(
  `!b f g u v. uniq (FST f) /\ b = betwn (FST f) u v /\
    MEM u (FST f) /\ MEM v (FST f) /\ ~(u = v) /\ ~(next_el (FST f) u  = v) ==>
    foldl subdiv_single_step ((SOME u,0),f,g) (MAP SOME (betwn (FST f) u v)) = 
      ((SOME(prev_el (FST f) v),0),f,g)`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(betwn (FST f) u v = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.betwn_nil]);
  INTRO_TAC Dangeyj.HD_BETWN2 [`(FST f)`;`u`;`v`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC (GEN_ALL Aq12.betwn_cap_point) [`u`;`FST f`;`next_el (FST f) u`;`v`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    MATCH_MP_TAC MEM_HD;
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  REWRITE_TAC[upper_case;GSYM APPEND_ASSOC];
  TYPIFY `betwn (FST f) u (next_el (FST f) u) = []` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC Tame_list.betwn_nil;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      DISCH_TAC;
      INTRO_TAC Tame_list.next_el_refl [`u`;`FST f`];
      ASM_SIMP_TAC[];
      BY(ASM_MESON_TAC[MEM]);
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  REWRITE_TAC[APPEND];
  REWRITE_TAC[MAP];
  REWRITE_TAC[Seq.foldl];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdiv_single_step];
  REWRITE_TAC[Tame_list.not_some_none];
  REWRITE_TAC[the_some];
  REWRITE_TAC[LET_THM];
  ASM_SIMP_TAC[Tame_list.nextVertex_next_el];
  FIRST_X_ASSUM (C INTRO_TAC [`betwn (FST f) (next_el (FST f) u) v`]);
  ANTS_TAC;
    FULL_EXPAND_TAC "i";
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.size_cons];
    BY(ARITH_TAC);
  DISCH_TAC;
  TYPED_ABBREV_TAC `u' = next_el (FST f) u`;
  TYPIFY `next_el (FST f) u' = v` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) u' v = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      ASM_REWRITE_TAC[];
      FULL_EXPAND_TAC "u'";
      BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
    REWRITE_TAC[MAP;subdiv_single_step;Seq.foldl];
    FULL_EXPAND_TAC "u'";
    FULL_EXPAND_TAC "v";
    BY(ASM_MESON_TAC[Seq2.prev_next_id]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Seq2.mem_next_el])
  ]);;
  (* }}} *)

let subdiv_single_step_nseg = prove_by_refinement(
  `!n u k f g.
       foldl subdiv_single_step ((SOME u,k),f,g)
             (nseq n NONE) =
             ((SOME u,n+k),f,g)`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.nseq;Seq.ncons;Ssrnat.iter;Seq.foldl;arith `0+k=k`]);
  BY(ASM_REWRITE_TAC[nseq_suc;Seq.foldl;subdiv_single_step;Tame_list.not_some_none;arith `n + SUC k = SUC n + k`])
  ]);;
  (* }}} *)

let subdiv_single_step_initial_seg = prove_by_refinement(
  `!f g u v0.
    uniq (FST f) /\
      MEM v0 (FST f) /\
      MEM u (FST f) ==>
    (let initial_seg = (if (v0=u) then [] else (SOME v0) :: ( MAP SOME (betwn (FST f) v0 u))) in
    foldl subdiv_single_step ((NONE,0),f,g) initial_seg = 
	 if (v0=u) then ((NONE,0),f,g) else (SOME (prev_el (FST f) u),0),f,g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[Seq.foldl;subdiv_single_step];
  TYPIFY `next_el (FST f) v0 = u` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) v0 u = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[MAP;Seq.foldl];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    FULL_EXPAND_TAC "u";
    BY(ASM_MESON_TAC[Seq2.prev_next_id]);
  GMATCH_SIMP_TAC subdiv_single_step_betwn;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let subdiv_single_step_final_seg = prove_by_refinement(
  `!f g u0 v'.
    uniq (FST f) /\
      MEM u0 (FST f) /\
      MEM v' (FST f) ==>
    (let final_seg = if (v'=u0) then [] else rcons (MAP SOME (betwn (FST f) v' u0)) (SOME u0) in
    foldl subdiv_single_step ((SOME v',0),f,g) final_seg = (SOME u0,0),f,g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.foldl;subdiv_single_step];
  REWRITE_TAC[GSYM Seq.cats1];
  REWRITE_TAC[Seq.foldl_cat];
  TYPIFY `next_el (FST f) v' = u0` ASM_CASES_TAC;
    TYPIFY `betwn (FST f) v' u0 = []` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC Tame_list.betwn_nil;
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[MAP;Seq.foldl;subdiv_single_step;not_some_none;the_some;LET_THM];
    BY(ASM_SIMP_TAC[Tame_list.nextVertex_next_el]);
  GMATCH_SIMP_TAC subdiv_single_step_betwn;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.foldl;subdiv_single_step;not_some_none;the_some;LET_THM];
  GMATCH_SIMP_TAC Tame_list.nextVertex_next_el;
  CONJ_TAC;
    BY(ASM_SIMP_TAC[Seq2.mem_prev_el]);
  BY(ASM_SIMP_TAC[Seq2.next_prev_id])
  ]);;
  (* }}} *)


(* ********************************************************************** *)
(* SIZE_VS LEMMAS *)
(* ********************************************************************** *)

(* set1 deleted *)

let assumption_set2 = new_definition'
  `assumption_set2 <=> (!L N r x k uvns vs vs' fx v.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      core_triple_v4 L N r x = uvns /\
      dest_triple_full (core L r) v uvns = vs /\
      MAP the (filter isSome vs) = vs' /\
       transform_count L N r x = k /\
        find_face L x = fx /\
      prev_el (core L r) v,v = x 
//      FST (next_el fx x) = v
      ==> 
               ~(transform_count L N r x = 0) /\
         0 < transform_count L N r x /\
         FST x = prev_el (core L r) v /\
         MEM x fx /\
         uniq fx /\
         1 <= sizel fx /\
         1 < sizel (core L r) /\
         (!i. SUC i < k
              ==> indexf (ytrans L N r x 0) (ztrans L N r x i) fx <=
                  indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx) /\
         (!i. SUC i < k
              ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx <=
                  indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) fx) /\
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx <=
         indexf (next_el fx x) x fx /\
         indexf (next_el fx x) (ytrans L N r x 0) fx <=
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx /\
         MEM (next_el fx x) r /\
         (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\
         (!i. i < k ==> MEM (ztrans L N r x i) r) /\
         (!i. i < k ==> MEM (ytrans L N r x i) r) /\
         MEM (next_el fx x) fx /\
         (!i. i < k ==> MEM (ytrans L N r x i) fx) /\
         (!i. i < k ==> MEM (ztrans L N r x i) fx) /\
         uniq (core L r) /\
         FST (next_el fx x) = v /\
         (!u. MEM u r ==> MEM (FST u) (core L r)) /\
         indexf v (FST (ytrans L N r x 0)) (core L r) =
         indexf (next_el fx x) (ytrans L N r x 0) fx /\
         indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x fx /\
         (!i. SUC i < k
              ==> indexf (FST (ztrans L N r x i))
                  (FST (ytrans L N r x (SUC i)))
                  (core L r) =
                  indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) fx) /\
	   (!i. SUC i < sizel vs'
            ==> indexf v (EL i vs') (core L r) <
           indexf v (EL (SUC i) vs') (core L r)) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (quotient_list L N))
             ==> MEM d (list_pairs (core L r))))
  )`;;


(*
let size_assumptions = (* notation of reductions *)
  `indexf (FST v) (FST (ytrans L N r x 0)) (core L r) = 
  indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) /\
    indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) = 
  indexf (ztrans L N r x (PRE k)) x (find_face L x) /\
    (!i. SUC i < k ==>
       indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) = 
	 indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x))`;;
*)

let size_initial_seg = prove_by_refinement(
  `!f u v s.
    MEM v f /\ MEM u f /\ uniq f /\
          s = (if v = u then [] else SOME v :: MAP SOME (betwn f v u))
  ==> sizel s = indexf v u f`,
  (* {{{ proof *)
  [
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Tame_list.indexf_refl;Seq.size_nil]);
  REWRITE_TAC[Seq.size_cons;Seq.size_map;lower_case];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  TYPIFY `~(indexf v u f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Tame_list.indexf0])
  ]);;
  (* }}} *)

let size_final_seg = prove_by_refinement(
  `!f v' u0 s.
    MEM v' (f) /\ MEM u0 (f) /\ uniq f /\
          s = (if v' = u0
               then []
               else rcons (MAP SOME (betwn f v' u0)) (SOME u0))
  ==> sizel s = indexf v' u0 (f)`,
  (* {{{ proof *)
  [
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[Tame_list.indexf_refl;Seq.size_nil]);
  REWRITE_TAC[Seq.size_rcons;Seq.size_map;lower_case];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  TYPIFY `~(indexf v' u0 f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Tame_list.indexf0])
  ]);;
  (* }}} *)

let size_dest_triple0_nil = prove_by_refinement(
  `!f s . sizel (dest_triple0 f s []) = sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0]
  ]);;
  (* }}} *)

let dest_triple0_cat = prove_by_refinement(
  `!uvns f s s' . ~(s' = []) ==> dest_triple0 f (cat s s') uvns = cat s (dest_triple0 f s' uvns)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(ASM_REWRITE_TAC[dest_triple0]);
  REPEAT WEAKER_STRIP_TAC THEN REWRITE_TAC[dest_triple0] THEN REPEAT LET_TAC;
  TYPIFY `u0 = u0'` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u0";
    FULL_EXPAND_TAC "u0'";
    AP_TERM_TAC;
    BY(ASM_SIMP_TAC[Tame_list.last_cat]);
  FULL_EXPAND_TAC "u0'";
  TYPIFY `b = b'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "b'";
  ASM_REWRITE_TAC[Tame_list.cat_eq_nil];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `flatten [cat s s';ns;[SOME v]] = cat s (flatten [s';ns;[SOME v]])` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `flatten [cat s s'; [SOME u]; ns; [SOME v]] = cat s (flatten [s'; [SOME u]; ns; [SOME v]])` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  TYPIFY `flatten [cat s s'; b; [SOME u]; ns; [SOME v]] = cat s (flatten [s'; b; [SOME u]; ns; [SOME v]])` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL]);
  BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC])
  ]);;
  (* }}} *)

let dest_triple0_cat2 = prove_by_refinement(
  `!f s a b a' h. ~(a = []) /\
    (~(s=[]) ==> ~(LAST s = [])) /\ 
    dest_triple0 f (flatten s) a = rcons a' (SOME h) ==>
       dest_triple0 f (flatten s) (cat a b) = cat a' (dest_triple0 f [SOME h] b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(LAST (foldl (dest_triple0_step f) s a) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[foldl_step_last_nonnil]);
  INTRO_TAC dest_triple0_foldl_steps[`cat a b`;`f`;`s`];
  ASM_SIMP_TAC[];
  REWRITE_TAC[Seq.foldl_cat];
  DISCH_THEN kill;
  INTRO_TAC (GSYM dest_triple0_foldl_steps) [`b`;`f`;`foldl (dest_triple0_step f) s a`];
  INTRO_TAC (GSYM dest_triple0_foldl_steps) [`a`;`f`;`s`];
  ASM_SIMP_TAC[];
  REWRITE_TAC[GSYM Seq.cats1];
  REPEAT (DISCH_THEN kill);
  GMATCH_SIMP_TAC dest_triple0_cat;
  BY(REWRITE_TAC[NOT_CONS_NIL])
  ]);;
  (* }}} *)

let size_dest_triple0_cons = prove_by_refinement(
  `!f u v n uvns.  MEM u f /\ MEM v f ==>
     sizel (dest_triple0 f [] ((u,v,n)::uvns)) = 
      SUC n + sizel (dest_triple0 f [SOME v] uvns)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  TYPIFY `flatten [[]; [SOME u]; ns; [SOME v]] = cat (APPEND [SOME u] ns) [SOME v]` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Tame_list.concat_flatten;APPEND_EQ_NIL;APPEND;NOT_CONS_NIL;upper_case;APPEND_ASSOC]);
  GMATCH_SIMP_TAC dest_triple0_cat;
  REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat];
  REWRITE_TAC[lower_case;Seq.size_cat];
  FULL_EXPAND_TAC "ns";
  REWRITE_TAC[Seq.size_nseq;Seq2.size1];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let size_dest_triple0_cons2 = prove_by_refinement(
  `!f u v w n uvns. uniq f /\ 1 < sizel f /\  MEM u f /\ MEM v f /\  MEM w f ==>
     sizel (dest_triple0 f [SOME w] ((u,v,n)::uvns)) = 
      SUC n + indexf w u f + sizel (dest_triple0 f [SOME v] uvns)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple0;NOT_CONS_NIL];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  REWRITE_TAC[LAST;the_some];
  DISCH_TAC THEN FULL_EXPAND_TAC "u0";
  TYPIFY `sizel ns = n` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "ns";
    BY(REWRITE_TAC[Seq.size_nseq]);
  REWRITE_TAC[Tame_list.concat_flatten;APPEND_ASSOC;APPEND_NIL];
  REWRITE_TAC[lower_case];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC dest_triple0_cat;
    ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
    BY(ASM_SIMP_TAC[indexf_refl] THEN ARITH_TAC);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC dest_triple0_cat;
    ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
    GMATCH_SIMP_TAC Tame_list.next_el_indexf;
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  GMATCH_SIMP_TAC dest_triple0_cat;
  ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.size_cat;Seq2.size1];
  TYPIFY `sizel b = indexf w u f - 1 /\ ~(indexf w u f = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  FULL_EXPAND_TAC "b";
  REWRITE_TAC[lower_case;Seq.size_map];
  ASM_SIMP_TAC[Tame_list.size_betwn];
  SUBCONJ2_TAC;
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let size_vs = prove_by_refinement(
  `(!L N k r x fx v uvns vs.
     // transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      core_triple_v4 L N r x  = uvns /\
      dest_triple_full (core L r) v uvns = vs /\
      transform_count L N r x = k /\
      find_face L x = fx /\
      ~(transform_count L N r x = 0) /\
      0 < transform_count L N r x /\
      FST x = prev_el (core L r) v  /\
      MEM x fx /\
      uniq fx /\
      1 <= sizel fx /\
      1 < sizel (core L r) /\
      (!i. SUC i < k ==> indexf (ytrans L N r x 0) (ztrans L N r x i) fx <=
	 indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx) /\
      (!i. SUC i < k ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx <=
	 indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) fx) /\
      indexf (next_el fx x) (ztrans L N r x (PRE k)) fx <=
      indexf (next_el fx x) x fx /\
      indexf (next_el fx x) (ytrans L N r x 0) fx <=
      indexf (next_el fx x) (ztrans L N r x (PRE k)) fx /\
      MEM (next_el fx x) r /\
//      MEM (ytrans L N r x 0) r /\
	(!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\
      (!i. i < k ==> MEM (ztrans L N r x i) r) /\
      (!i. i < k ==> MEM (ytrans L N r x i) r) /\
	MEM (next_el fx x) fx /\
     (!i. i < k ==>  MEM (ytrans L N r x i) fx) /\
	(!i. i < k ==> MEM (ztrans L N r x i) fx) /\
      uniq (core L r) /\
      FST (next_el fx x) = v /\
	  (!u. MEM u r ==> MEM (FST u) (core L r)) /\
      indexf v (FST (ytrans L N r x 0)) (core L r) = 
      indexf (next_el (fx) x) (ytrans L N r x 0) (fx) /\
	indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) = 
      indexf (ztrans L N r x (PRE k)) x (fx)    /\
	(!i. SUC i < k ==>
	   indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) = 
	     indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (fx))
      ==> sizel (fx) = sizel vs  )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "vs";
  REWRITE_TAC[dest_triple_full];
  ASM_REWRITE_TAC[];
  REPEAT LET_TAC;
  REWRITE_TAC[Seq.flatten_cons];
  REWRITE_TAC[Seq.size_cat];
  FULL_EXPAND_TAC "initial_seg";
  GMATCH_SIMP_TAC size_initial_seg;
  GEXISTL_TAC [`v`;`u`;`core L r`];
  ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM Seq2.EL]);
  FIRST_X_ASSUM_ST `EL 0` MP_TAC;
  FULL_EXPAND_TAC "uvns";
  GMATCH_SIMP_TAC el_core_triple;
  ASM_SIMP_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FULL_EXPAND_TAC "final_seg";
  INTRO_TAC size_final_seg [`core L r`;`v''`;`u0`;`(if v'' = u0      then []      else rcons (MAP SOME (betwn (core L r) v'' u0)) (SOME u0))`];
  REWRITE_TAC[];
  DISCH_THEN GMATCH_SIMP_TAC;
  REWRITE_TAC[Seq.flatten0;Seq.size_nil];
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  GMATCH_SIMP_TAC last_core_triple;
  TYPIFY `PRE k` EXISTS_TAC;
  ASM_REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC (PRE k) = transform_count L N r x /\ PRE k < transform_count L N r x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT (FIRST_X_ASSUM_ST `transform_count` MP_TAC);
    BY(ARITH_TAC);
  SUBCONJ_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    FULL_EXPAND_TAC "u0";
    MATCH_MP_TAC Seq2.mem_prev_el;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "induction";
  TYPIFY `(!i. i < transform_count L N r x ==> sizel (dest_triple0 (core L r) [] (take (SUC i) (core_triple_v4 L N r x))) = 1 + indexf (ytrans L N r x 0) (ztrans L N r x i) fx /\ LAST (dest_triple0 (core L r) [] (take (SUC i) (core_triple_v4 L N r x))) = SOME (FST(ztrans L N r x i)))` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (C INTRO_TAC [`PRE k`]);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Seq.take_oversize;
    ASM_SIMP_TAC[size_core_triple;arith `k <= k:num`];
    DISCH_THEN kill;
    FULL_EXPAND_TAC "u";
    ASM_REWRITE_TAC[];
    REWRITE_TAC[arith `a + (1 + b) +c +0 = 1 + (a+b ) + c`];
    GMATCH_SIMP_TAC Tame_list.indexf_add_left;
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `indexf v'' u0 (core L r) = indexf (ztrans L N r x (PRE k)) x fx` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC Tame_list.indexf_add_left;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Tame_list.indexf_prev;
    ASM_REWRITE_TAC[];
    BY(FIRST_X_ASSUM_ST `1 <= sizel fx` MP_TAC THEN ARITH_TAC);
  COMMENT "0 case";
  INDUCT_TAC;
    ASM_REWRITE_TAC[arith `SUC 0 = 1`];
    REPEAT (GMATCH_SIMP_TAC take1);
    ASM_SIMP_TAC[core_triple_nonnil];
    REWRITE_TAC[GSYM EL];
    ASM_SIMP_TAC[el_core_triple];
    GMATCH_SIMP_TAC size_dest_triple0_cons;
    GMATCH_SIMP_TAC last_dest_triple0;
    REWRITE_TAC[NOT_CONS_NIL;LAST;SND;FST];
    ASM_REWRITE_TAC[dest_triple0;Seq.size_cons;Seq.size_nil];
    FULL_EXPAND_TAC "n";
    FULL_EXPAND_TAC "v'";
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC Tame_list.size_betwn;
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[];
    TYPIFY `MEM (ytrans L N r x 0) fx /\  MEM (ztrans L N r x 0) fx` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    TYPIFY `~(indexf (ytrans L N r x 0) (ztrans L N r x 0) fx = 0)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[Tame_list.indexf0]);
    BY(ARITH_TAC);
  COMMENT "SUC INDUC";
  DISCH_TAC;
  INTRO_TAC take_el [`SUC i`;`(core_triple_v4 L N r x)`];
  POP_ASSUM MP_TAC THEN SIMP_TAC[size_core_triple];
  DISCH_TAC THEN DISCH_THEN kill;
  REWRITE_TAC[GSYM Seq.cats1];
  INTRO_TAC dest_triple0_cat2 [`core L r`;`[]:(((num)option)list)list`];
  REWRITE_TAC[Seq.flatten0];
  DISCH_THEN (REPEAT o GMATCH_SIMP_TAC);
  FIRST_X_ASSUM_ST `sizel` MP_TAC;
  SUBANTS_TAC;
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?a'. dest_triple0 (core L r) [] (take (SUC i) (core_triple_v4 L N r x)) = rcons a' (SOME (FST (ztrans L N r x i)))` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `butlast (dest_triple0 (core L r) [] (take (SUC i) (core_triple_v4 L N r x)))` EXISTS_TAC;
    POP_ASSUM (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC (GSYM rcons_butlast);
    ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC dest_triple0_nonnil;
    DISJ1_TAC;
    REWRITE_TAC[Pwssrat.sizel0_not_nil];
    GMATCH_SIMP_TAC Seq.size_takel;
    REWRITE_TAC[size_core_triple];
    BY(REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`a'`;`(FST (ztrans L N r x i))`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Pwssrat.sizel0_not_nil];
  GMATCH_SIMP_TAC Seq.size_takel;
  REWRITE_TAC[size_core_triple];
  REWRITE_TAC[arith `0 < SUC i`];
  CONJ_TAC;
    BY(REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  TYPIFY `sizel a' = indexf (ytrans L N r x 0) (ztrans L N r x i) fx` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `sizel (dest_triple0 (core L r) [] (take (SUC i) (core_triple_v4 L N r x))) = sizel (rcons a' (SOME (FST (ztrans L N r x i))))` (C SUBGOAL_THEN MP_TAC);
      BY(POP_ASSUM SUBST1_TAC THEN REWRITE_TAC[]);
    POP_ASSUM kill;
    ASM_REWRITE_TAC[Seq.size_rcons];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[Seq.size_cat];
  REPEAT (GMATCH_SIMP_TAC el_core_triple);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC size_dest_triple0_cons2;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Tame_list.last_cat;
  GMATCH_SIMP_TAC last_dest_triple0;
  REWRITE_TAC[LAST;SND;FST;NOT_CONS_NIL];
  CONJ_TAC;
    MATCH_MP_TAC dest_triple0_nonnil;
    BY(REWRITE_TAC[NOT_CONS_NIL]);
  REWRITE_TAC[dest_triple0;Seq.size_nil;Seq.size_cons];
  CONJ_TAC;
    FIRST_X_ASSUM_ST `x ==> MEM u (core L r)` MP_TAC;
    DISCH_THEN (REPEAT o GMATCH_SIMP_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `indexf (FST (ztrans L N r x i))` MP_TAC;
  DISCH_THEN GMATCH_SIMP_TAC;
  REWRITE_TAC[arith `a + b + c + SUC 0 = 1 + u <=> (a + c) + b = u`];
  GMATCH_SIMP_TAC Tame_list.indexf_add_left;
  GMATCH_SIMP_TAC Tame_list.size_betwn;
  SIMP_TAC[];
  ASM_REWRITE_TAC[];
  nCONJ_TAC 2;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN SIMP_TAC[]);
  GMATCH_SIMP_TAC (arith `~(i = 0) ==> (SUC (PRE i) = i)`);
  GMATCH_SIMP_TAC Tame_list.indexf_add_left;
  TYPIFY `MEM (ytrans L N r x 0) fx /\  MEM (ytrans L N r x (SUC i)) fx /\  MEM (ztrans L N r x (SUC i)) fx /\   MEM (ztrans L N r x i) fx` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `SUC i < k` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN SIMP_TAC[]);
  nCONJ_TAC 2;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let reduction_A = prove_by_refinement(
  `assumption_set2 /\ 
    (!L N N' g p fs f v k r x fx uvns g' vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      g' = subdivFaceFinal2 g f uvns /\
      k = transform_count L N r x /\
	N' = ntrans L N r x k /\ 
	fx = find_face L x
      ==> 
      // transform_assumption_v2 L /\
      fgraph g' = quotient_list L N' /\
          good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
//          (!i. SUC i < sizel vs'
//           ==> indexf v (EL i vs') (FST f) <
 //          indexf v (EL (SUC i) vs') (FST f)) /\
	  (subdivFace g f vs = g') /\
         list_pairs
      (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =
          rtrans L N r x k 
  ) 
  ==> // generatePolygon_reduction_v7
    restricted_hypermaps_are_planegraphs_v4
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_subdivFace2;
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  TYPED_ABBREV_TAC `fx = find_face L x`;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`fx`;`uvns`;`g'`;`vs`;`vs'`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `assumption_set2` MP_TAC;
  INTRO_TAC minimalFace_core [`L`;`N`;`r`;`x`;`g`;`fs`;`f`;`v`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (ASSUME_TAC o GSYM);
  REWRITE_TAC[assumption_set2];
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`vs`;`vs'`;`fx`;`v`]);
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[Tame_list.quotient_all_uniq;marked_list]);
    BY(SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[];
  CONJ2_TAC;
    POP_ASSUM MP_TAC;
    TYPIFY `quotient_list L N = fgraph g` (C SUBGOAL_THEN SUBST1_TAC) THEN SIMP_TAC[];
    BY(FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC THEN MESON_TAC[match_quotient_list]);
  FULL_EXPAND_TAC "i";
  MATCH_MP_TAC size_vs;
  GEXISTL_TAC [`L`;`N`;`k`;`r`;`x`;`v`;`uvns`];
  ASM_REWRITE_TAC[];
  BY(FIRST_X_ASSUM_ST `dest_triple_full` MP_TAC THEN ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let uniq_replace_map = prove_by_refinement(
  `!fs x y. uniq fs ==> replace x [y] fs = MAP (\ p. if p=x then y else p) fs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;MAP;Seq.cons_uniq];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[APPEND_SING;CONS_11];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC MAP_EQ_DEGEN;
  REWRITE_TAC[lower_case;GSYM Seq.allP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let facesAt_v2_makeFaceFinal = prove_by_refinement(
  `!f g v. facesAt_v2 (makeFaceFinal f g) v = 
       (makeFaceFinalFaceList f (facesAt_v2 g v))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;facesAt_v2;faces_graph];
  BY(REWRITE_TAC[lower_case;makeFaceFinalFaceList;mem_fst_setFinal])
  ]);;
  (* }}} *)

let facesAt_v2_map_final = prove_by_refinement(
  `!f g v. uniq (facesAt_v2 g v) ==>
    facesAt_v2 (makeFaceFinal f g) v = 
    MAP (\p. if p = f then (setFinal f) else p) (facesAt_v2 g v)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[facesAt_v2_makeFaceFinal];
  REWRITE_TAC[makeFaceFinalFaceList];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC uniq_replace_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let facesAt_makeFaceFinal = prove_by_refinement(
  `!f g v. v < sizel (faceListAt g) ==>
      facesAt (makeFaceFinal f g) v = 
       (makeFaceFinalFaceList f (facesAt g v))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;facesAt;faces_graph;Tame_list.FACE_LIST_AT];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC EL_MAP;
  BY(ASM_REWRITE_TAC[lower_case])
  ]);;
  (* }}} *)

let facesAt_map_final = prove_by_refinement(
  `!f g v. uniq (facesAt g v) /\ v < sizel (faceListAt g) ==>
    facesAt (makeFaceFinal f g) v = 
    MAP (\p. if p = f then (setFinal f) else p) (facesAt g v)`,
  (* {{{ proof *)
  [
  SIMP_TAC[facesAt_makeFaceFinal];
  REWRITE_TAC[makeFaceFinalFaceList];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC uniq_replace_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let good_faces_makeFaceFinal = prove_by_refinement(
  `!f g. (!v. v IN vertices_set2 g ==> uniq (facesAt_v2 g v)) /\
    sizel (faceListAt g) = countVertices g /\
    good_faces_v3 g 
  ==>
    good_faces_v3 (makeFaceFinal f g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[good_faces;Tame_list.vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v. v IN vertices_set2 g ==> uniq (facesAt g v)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.perm_eq_uniq]);
  TYPIFY `uniq (facesAt_v2 g v) /\ uniq (facesAt g v) /\ v < sizel(faceListAt g)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.vertices_set2_countVertices]);
  ASM_SIMP_TAC[facesAt_map_final;facesAt_v2_map_final];
  REWRITE_TAC[lower_case];
  MATCH_MP_TAC Seq2.perm_eq_map;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let vs_nonnil = prove_by_refinement(
  `(!L N r x f (v:A) uvns vs.
    //   transform_assumption_v2 L /\
      good_list L /\
      good_list_nodes L /\
      marked_list L N r x /\
      ~final_list L r /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full f v uvns 
  ==> ~(vs = []))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple_full];
  REPEAT WEAKER_STRIP_TAC;
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN REPEAT LET_TAC;
  DISCH_THEN (SUBST1_TAC);
  REWRITE_TAC[Tame_list.concat_flatten;APPEND_NIL;APPEND_EQ_NIL];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ2_TAC;
  DISJ1_TAC;
  MATCH_MP_TAC dest_triple0_nonnil;
  DISJ1_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_SIMP_TAC[core_triple_nonnil])
  ]);;
  (* }}} *)

let reduction_B = prove_by_refinement(
  `assumption_set2 /\ 
    (!L N Nk g p fs f v k r x fx uvns gk fk vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      gk = SND(subdivFace0_alt2 g f (countVertices g) uvns) /\
      fk = FST(subdivFace0_alt2 g f (countVertices g) uvns) /\
      k = transform_count L N r x /\
	Nk = ntrans L N r x k /\ 
	fx = find_face L x
      ==> 
  //    transform_assumption_v2 L /\
      (fgraph gk = quotient_list L Nk) /\
      good_faces_v3 gk /\
      sizel (faceListAt gk) = countVertices gk /\
      (vertices_set2 gk = elements_of_list (fgraph gk)) /\
      gk = (SND(SND (subdivFace0_beta g f NONE 0 vs))) /\
      fk = (FST(SND (subdivFace0_beta g f NONE 0 vs))) /\
      (list_pairs (FST fk) = rtrans L N r x k)
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4
   // generatePolygon_reduction_v7
   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_A;
  ASM_REWRITE_TAC[];
  GEN_TAC;
  TYPIFY `transform_assumption_v2 L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  TYPED_ABBREV_TAC `      gk = SND(subdivFace0_alt2 g f (countVertices g) uvns)`;
  TYPED_ABBREV_TAC `      fk = FST(subdivFace0_alt2 g f (countVertices g) uvns)`;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`fx`;`uvns`;`gk`;`fk`;`vs`;`vs'`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    INTRO_TAC (GSYM Tame_list.fgraph_makeFaceFinal) [`fk`;`gk`];
    DISCH_THEN SUBST1_TAC;
    FULL_EXPAND_TAC "g'";
    REWRITE_TAC[subdivFaceFinal2];
    BY(ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR]);
  DISCH_TAC;
  TYPIFY `makeFaceFinal fk gk = g'` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "g'";
    REWRITE_TAC[subdivFaceFinal2];
    BY(ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR]);
  FIRST_X_ASSUM_ST `subdivFaceFinal2` kill;
  FULL_EXPAND_TAC "g'";
  ASM_REWRITE_TAC[Tame_list.vertices_set2_makeFaceFinal];
  GMATCH_SIMP_TAC subdivFace_subdivFace0_beta;
  ASM_REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  nCONJ_TAC 2;
    MATCH_MP_TAC good_faces_makeFaceFinal;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC Reduction2.facesAt_v2_uniq;
    GEXISTL_TAC [`L`;`N'`];
    ASM_REWRITE_TAC[];
    TYPIFY `marked_list L N' (rtrans L N r x k) x` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[marked_list]);
    FULL_EXPAND_TAC "N'";
    MATCH_MP_TAC Tame_list.AQIUNPP3;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC hd_vs_some_v;
  TYPIFY `v` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Ssrbool.isSome];
  BY(ASM_MESON_TAC[vs_nonnil])
  ]);;
  (* }}} *)

let final_list_pairs = prove_by_refinement(
  `!L r (x:A#A).
    good_list L /\ uniq r /\
    final_list L r /\ MEM x r /\ MEM x (list_of_darts L) ==>
    list_pairs (MAP FST r) = r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_list_rot [`L`;`r`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `list_pairs (MAP FST (find_face L x)) = (find_face L x)` ENOUGH_TO_SHOW_TAC;
    FIRST_ASSUM (SUBST1_TAC o GSYM);
    BY(REWRITE_TAC[lower_case;Seq.map_rot;GSYM List_hypermap.rot_list_pairs;Seq.eqseq_rot]);
  INTRO_TAC face_rep [`L`;`find_face L x`];
  SUBANTS_TAC;
    BY(ASM_SIMP_TAC[List_hypermap.mem_find_face]);
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_list_pairs_core = prove_by_refinement(
  `!L r (x:A#A).
    is_restricted (hypermap_of_list L) /\
    all (\x. MEM x (list_of_darts L)) r /\
    good_list L /\ uniq r /\
    final_list L r /\ MEM x r /\ MEM x (list_of_darts L) ==>
    list_pairs (core L r) = r`,

  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_list_core [`L`;`r`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  SIMP_TAC[];
  BY(ASM_MESON_TAC[final_list_pairs])
  ]);;
  (* }}} *)

let marked_list_mark_rtrans = prove_by_refinement(
  `!i L N r x. good_list L /\ good_list_nodes L /\ marked_list L N r x ==>
    MEM x (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[Reduction2.trans0];
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  INTRO_TAC Tame_list.AQIUNPP3[`L`;`SUC i`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let reduction_C = prove_by_refinement(
   `assumption_set2 /\ 
    (!L N Nk g p fs f v k r x fx uvns gk fk vs vs'.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
      vs' = MAP the (filter isSome vs) /\
      gk = SND(subdivFace0_alt2 g f (countVertices g) uvns) /\
      fk = FST(subdivFace0_alt2 g f (countVertices g) uvns) /\
      k = transform_count L N r x /\
	Nk = ntrans L N r x k /\ 
	fx = find_face L x
      ==> 
      (fgraph gk = quotient_list L Nk) /\
      good_faces_v3 gk /\
      sizel (faceListAt gk) = countVertices gk /\
      (vertices_set2 gk = elements_of_list (fgraph gk)) /\
      gk = (SND(SND (subdivFace0_beta g f NONE 0 vs))) /\
      fk = (FST(SND (subdivFace0_beta g f NONE 0 vs))) /\
	  (core L (rtrans L N r x k) = FST fk)
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_B;
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`Nk`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`fx`;`uvns`;`gk`;`fk`;`vs`;`vs'`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC final_list_pairs_core;
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Kbwpbhq.final_list_transform_count;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  DISCH_TAC;
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[marked_list_mark_rtrans]);
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.AQIUNPP3[`L`;`k`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (rtrans L N r x k) Nk /\ normal_list L Nk` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[marked_list]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`Nk`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let lnrx_induction = prove_by_refinement(
  `!j L N r x.
    core_split_normal_list_assumption L /\
    r_trans_eq_assumption L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    element_pre L N /\
    j < transform_count L N r x ==>
    newvertex_prepped L (ntrans L N r x j) (rtrans L N r x j) x /\
    element_pre L (ntrans L N r x j)
    `,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN SIMP_TAC[Reduction2.trans0];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY ` is_restricted (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `transform_assumption_v2 L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  TYPIFY `marked_list L (ntrans L N r x j) (rtrans L N r x j) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.AQIUNPP3]);
  TYPIFY `j < transform_count L N r x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[arith `SUC j < k ==> j < k`]);
  TYPIFY `~(final_list L (rtrans L N r x j))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `r_rtrans_eq L (ntrans L N r x j) (rtrans L N r x j) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC [r_trans_eq_assumption]);
  SUBCONJ2_TAC;
    INTRO_TAC Reduction2.elements_of_list_ntrans [`L`;`ntrans L N r x j`;`rtrans L N r x j`;`x`];
    ASM_REWRITE_TAC[GSYM element_pre];
    REWRITE_TAC[GSYM trans_add;arith `1 + j = SUC j`];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC Reduction2.newvertex_prepped_transform [`L`;`ntrans L N r x j`;`rtrans L N r x j`;`x`];
  REWRITE_TAC[GSYM trans_add;arith `1 + j = SUC j`];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[GSYM element_pre])
  ]);;
  (* }}} *)

let list_update_nil = prove_by_refinement(
  `!v j. list_update [] j v = []`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[list_update])
  ]);;
  (* }}} *)

let list_update_supsize = prove_by_refinement(
  `!xs v j. sizel xs <= j ==> list_update xs j v = xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[list_update;Seq.size_cons];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[CONS_11];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_list_update = prove_by_refinement(
  `!xs j i v. i < sizel xs /\ j < sizel xs ==>
    EL i (list_update xs j v) = if (i=j) then v else EL i xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[list_update;Seq.size_nil;arith `~(i < 0)`;Seq.size_cons];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC num_CASES [`i`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[EL];
    BY(DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL;arith `~(SUC n = 0)`]);
  DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL];
  TYPIFY `SUC n = j <=> n = j - 1` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let el_mapAt = prove_by_refinement(
  `!ns xs f i. 
    uniq ns /\ i < sizel xs ==>
    EL i (mapAt ns f xs) = if (MEM i ns) then f (EL i xs) else (EL i xs)
    `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[mapAt;MEM];
  REWRITE_TAC[Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[size_list_update];
    ASM_SIMP_TAC[el_list_update];
    REPEAT (COND_CASES_TAC THEN ASM_REWRITE_TAC[]);
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(i=h)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let size_mapAt = prove_by_refinement(
  `!ns xs f.
    sizel (mapAt ns f xs) = sizel xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[mapAt;lower_case];
  BY(REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC[size_list_update])
  ]);;
  (* }}} *)

(* in Tame_list.
let size_replacefacesAt = prove_by_refinement(
  `!ns old news Fs. sizel (replacefacesAt ns old news Fs) = sizel Fs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[replacefacesAt];
  BY(REWRITE_TAC[replacefacesAt;size_mapAt])
  ]);;
  (* }}} *)
*)

let el_replacefacesAt = prove_by_refinement(
  `!ns old news Fs i. uniq ns /\ i < sizel Fs ==>
    EL i (replacefacesAt ns old news Fs) = (if MEM i ns then replace old news (EL i Fs) else EL i Fs)`,
  (* {{{ proof *)
  [
  SIMP_TAC[replacefacesAt;mapAt];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC el_mapAt [`ns`;`Fs`;`(replace old news)`;`i`];
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let replace_uniq = prove_by_refinement(
  `!fs x ys.
    uniq (cat fs ys) ==> uniq (replace x ys fs)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;Seq.uniq;Seq.cat_cons;Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq.uniq_catC]);
  REWRITE_TAC[Seq.cons_uniq];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  POP_ASSUM (MP_TAC o MATCH_MP MEM_replace);
  BY(ASM_MESON_TAC[Seq.mem_cat])
  ]);;
  (* }}} *)

let all_nseq = prove_by_refinement(
  `!n P x. all P (nseq n x) <=> (P x \/ n = 0)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[nseq0;nseq_suc;Seq.all_nil;arith `~(SUC n = 0)`];
  TYPIFY `n=0` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[nseq0;Seq.all_cons;Seq.all_nil]);
  BY(ASM_REWRITE_TAC[Seq.all_cons])
  ]);;
  (* }}} *)

let betwn_disjoint = prove_by_refinement(
  `!x y w f. uniq f /\ MEM x f /\ MEM y f /\ ~(x = y) /\ MEM w (betwn f x y ) ==> ~(MEM w (betwn f y x ))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.indexf_add_betwn [`x`;`w`;`y`;`f`];
  INTRO_TAC Tame_list.indexf_add_betwn [`y`;`w`;`x`;`f`];
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.indexf_antisym [`x`;`w`;`f`];
  INTRO_TAC Tame_list.indexf_antisym [`w`;`y`;`f`];
  INTRO_TAC Tame_list.indexf_antisym [`x`;`y`;`f`];
  ASM_SIMP_TAC[];
  TYPIFY `~(w = y) /\ ~(x = w)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1;not_betwn2]);
  TYPIFY `MEM w f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel f = 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Tame_list.sizel0])
  ]);;
  (* }}} *)

let all_uniq_faceListAt_lemma = prove_by_refinement(
  `!g ram1 ram2 oldF news.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
    ~(MEM f1 (flatten (faceListAt g))) /\
      ~(MEM f2 (flatten (faceListAt g))) /\
      uniq (FST oldF) /\
      MEM ram1 (FST oldF) /\
      ram1 < sizel (faceListAt g) /\
      ram2 < sizel (faceListAt g) /\
      MEM ram2 (FST oldF) /\
      ~(f1 = f2) /\
      ~(ram1 = ram2) /\
    all uniq (faceListAt g) ==>
    all uniq (faceListAt g')) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `heights` MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[Tame_list.FACE_LIST_AT];
  FULL_EXPAND_TAC "Fs'''''";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[lower_case;Seq.all_cat;REPLICATE_nseq];
  ASM_REWRITE_TAC[all_nseq;Seq.cons_uniq;Seq.nil_uniq;MEM];
  FULL_EXPAND_TAC "Fs''''";
  REPLICATE_TAC 5 (POP_ASSUM kill);
  REWRITE_TAC[ (GSYM Seq2.all_EL_P)];
  REWRITE_TAC[size_replacefacesAt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i < sizel Fs /\ i < sizel Fs' /\ i < sizel Fs'' /\ (sizel Fs = sizel Fs') /\ (sizel Fs' = sizel Fs'')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[size_replacefacesAt]);
  TYPIFY `uniq [f1;f2] /\ uniq [f1] /\ uniq [f2] /\ uniq [ram1] /\ uniq [ram2]` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.cons_uniq; Seq.nil_uniq;MEM]);
  TYPIFY `uniq vs1 /\ uniq vs2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Ohcgkfu.uniq_betwn]);
  TYPIFY `~(MEM ram1 vs1) /\ ~(MEM ram1 vs2) /\ ~(MEM ram2 vs1) /\ ~(MEM ram2 vs2)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1;not_betwn2]);
  ASM_SIMP_TAC[el_replacefacesAt;MEM];
  FULL_EXPAND_TAC "Fs'''";
  ASM_SIMP_TAC[el_replacefacesAt;MEM];
  GMATCH_SIMP_TAC el_replacefacesAt;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  FULL_EXPAND_TAC "Fs''";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  REWRITE_TAC[CONJ_ASSOC];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "Fs'";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  ASM_REWRITE_TAC[CONJ_ASSOC];
  TYPIFY `uniq (EL i Fs)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `all uniq` MP_TAC;
    BY(ASM_MESON_TAC[Seq2.all_EL_P]);
  TYPIFY `!s. uniq s /\ (!f. MEM f s ==> MEM f [f1;f2]) ==> uniq (cat (EL i Fs) s)` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[Seq.cat_uniq];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.hasP;NOT_EXISTS_THM];
    GEN_TAC;
    TYPIFY `MEM x s` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `x = f1 \/ x = f2` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN MESON_TAC[MEM]);
    REPEAT (FIRST_X_ASSUM_ST `flatten` MP_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `MEM (EL i Fs) Fs` (C SUBGOAL_THEN MP_TAC);
      MATCH_MP_TAC MEM_EL;
      BY(ASM_REWRITE_TAC[lower_case]);
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    POP_ASSUM (SUBST1_TAC o GSYM);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    POP_ASSUM (SUBST1_TAC o GSYM);
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[MEM;Seq.cons_uniq;Seq.nil_uniq];
    BY(MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    TYPIFY `~(MEM i vs1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[betwn_disjoint]);
    ASM_SIMP_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[MEM];
    BY(MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  MATCH_MP_TAC replace_uniq;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[MEM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let facesAt_graph = prove_by_refinement(
  `!fs n Fs ht i. facesAt (Graph fs n Fs ht) i = EL i Fs `,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[facesAt;Tame_list.FACE_LIST_AT])
  ]);;
  (* }}} *)

let replace_mem_eq = prove_by_refinement(
  `!news' xs h old news.
    (MEM h news <=> MEM h news') ==> (MEM h (replace old news xs) <=> MEM h (replace old news' xs))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[replace;MEM];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[lower_case;Seq.mem_cat];
  BY(ASM_MESON_TAC[MEM])
  ]);;
  (* }}} *)

let replace_perm_eq = prove_by_refinement(
  `!xs xs' (u:A) old news.
    perm_eq xs xs' ==> (MEM u (replace old news xs) <=> MEM u (replace old news xs'))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC size_induct;
  GEN_TAC THEN DISCH_TAC;
  TYPIFY `i = 0` ASM_CASES_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `xs = []` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.size_eq0]);
    BY(ASM_MESON_TAC[replace;Seq2.perm_eq0l;MEM]);
  TYPIFY `!xs xs' (u:A) old news. sizel xs = i /\ perm_eq xs xs' /\ HD xs = HD xs' ==> (MEM u (replace old news xs) <=>                    MEM u (replace old news xs'))` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `~(xs = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.size_eq0]);
    TYPIFY `~(xs' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.perm_eq0r]);
    INTRO_TAC (GSYM list_CASES) [`xs`] THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "xs";
    INTRO_TAC (GSYM list_CASES) [`xs'`] THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "xs'";
    REWRITE_TAC[replace;lower_case];
    RULE_ASSUM_TAC(REWRITE_RULE[HD]);
    FULL_EXPAND_TAC "h'";
    RULE_ASSUM_TAC (REWRITE_RULE[Seq.perm_cons;NOT_CONS_NIL;Seq.size_cons]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      REWRITE_TAC[Seq.mem_cat];
      TYPIFY `MEM u news` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[Seq.perm_eq_mem]);
    REWRITE_TAC[MEM];
    TYPIFY `u =h` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[arith `SUC s = i ==> s  < i`]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(xs = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  TYPIFY `~(xs' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.perm_eq0r]);
  INTRO_TAC (GSYM list_CASES) [`xs`] THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM list_CASES) [`xs'`] THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "xs";
  FULL_EXPAND_TAC "xs'";
  TYPIFY `h = h'` ASM_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[HD;NOT_CONS_NIL]);
  INTRO_TAC Seq2.perm_eq_cons_delete1 [`h`;`h' :: t'`];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[MEM;Seq.perm_eq_mem]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (C INTRO_TAC [`h::t`;`h :: delete1 h (h' :: t')`;`u`;`old`;`news`]);
  SUBANTS_TAC;
    ASM_REWRITE_TAC[HD;NOT_CONS_NIL];
    BY(ASM_MESON_TAC[Seq.perm_eq_sym;Seq.perm_eq_trans]);
  ASM_REWRITE_TAC[HD;NOT_CONS_NIL];
  DISCH_TAC;
  DISCH_THEN SUBST1_TAC;
  TYPIFY `nth h (delete1 h (h' :: t')) 0 = h'` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.nth_delete1];
    BY(ASM_REWRITE_TAC[Seq2.index_cons;arith `0 < SUC i`;Seq.nth]);
  TYPED_ABBREV_TAC `d = delete1 h (h' :: t')`;
  INTRO_TAC list_CASES [`d`];
  DISCH_THEN DISJ_CASES_TAC;
    BY(ASM_MESON_TAC[MEM;Seq.perm_cons;Seq.perm_eq_mem]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (MP_TAC o GSYM) THEN DISCH_TAC;
  FULL_EXPAND_TAC "d";
  TYPIFY `h' = h''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.nth]);
  FULL_EXPAND_TAC "h''";
  TYPIFY `MEM u (replace old news (h :: h' :: t'')) = MEM u (replace old news (h' :: h :: t''))` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[replace;lower_case];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.mem_cat;MEM];
      COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.mem_cat;MEM];
      BY(MESON_TAC[]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.mem_cat;MEM];
      BY(MESON_TAC[]);
    BY(MESON_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  REWRITE_TAC[HD];
  SUBCONJ2_TAC;
    TYPIFY `perm_eq (h' :: h :: t'') (h :: h' :: t'')` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Seq.perm_eq_sym;Seq.perm_eq_trans]);
    TYPIFY_GOAL_THEN `!a b. (a::b::t'') = (cat [a;b] t'')` (unlist REWRITE_TAC);
      BY(REWRITE_TAC[Seq.cat_cons;Seq.cat0s]);
    REWRITE_TAC[Seq.perm_cat2r];
    MATCH_MP_TAC Tame_list.uniq_perm_eq_map;
    ASM_REWRITE_TAC[Seq.cons_uniq;Seq.nil_uniq;MEM;EXTENSION;IN_SET_OF_LIST];
    BY(MESON_TAC[]);
  BY(ASM_MESON_TAC[Seq.perm_eq_size;Seq.perm_eq_sym;Seq.perm_eq_trans])
  ]);;
  (* }}} *)

let replace_filter1 = prove_by_refinement(
  `!xs P u old news.  ~(P old) /\ uniq xs  ==>
    (MEM u (replace old news (filter P xs)) <=> MEM u (filter P xs)) `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;Seq.filter;Seq.cons_uniq];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[replace;MEM;lower_case];
  COND_CASES_TAC THEN ASM_SIMP_TAC[MEM;Seq.mem_cat];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let replace_filter2 = prove_by_refinement(
  `!xs P u old news. P old /\ uniq xs ==>
    ( MEM u (replace old (filter P news) (filter P xs)) <=> MEM u (filter P (replace old news xs)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;Seq.filter;Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[replace;MEM;lower_case;Seq.mem_cat;Seq.filter_cat;Seq.mem_filter];
    COND_CASES_TAC THEN ASM_SIMP_TAC[MEM;Seq.mem_filter;replace;Seq.mem_cat];
      BY(ASM_MESON_TAC[]);
    BY(ASM_MESON_TAC[]);
  COND_CASES_TAC THEN ASM_SIMP_TAC[MEM;Seq.mem_filter;replace;Seq.mem_cat];
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let mem_replace = prove_by_refinement(
  `!xs h old news.
    uniq xs /\ MEM old xs ==>
    (MEM h (replace old news xs) <=> (MEM h (replace old [] xs) \/ MEM h news))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;MEM];
  REWRITE_TAC[Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[Seq.mem_cat;MEM];
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let mem_replace3 = prove_by_refinement(
  `!xs h old news.
    uniq xs /\ (MEM old xs) ==>
    (MEM h (replace old news xs) <=> (MEM h news \/ (MEM h xs /\ ~(h = old))))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;MEM];
  REWRITE_TAC[Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[Seq.mem_cat;MEM];
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let mem_replace2 = prove_by_refinement(
  `!xs h old news.
    uniq xs /\ ~(MEM old xs) ==>
    (MEM h (replace old news xs) <=> (MEM h xs /\ ~(h = old)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;MEM];
  REWRITE_TAC[Seq.cons_uniq;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[Seq.mem_cat;MEM];
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let replace_filter3 = prove_by_refinement(
  `!xs P u old news. P (old:A) /\ uniq xs /\ MEM old xs ==>
    ( (MEM u (replace old [] (filter P xs)) \/ MEM u (filter P news)) <=> MEM u (filter P (replace old news xs)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;Seq.filter;Seq.cons_uniq;lower_case;MEM];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_SIMP_TAC[replace;MEM;lower_case;Seq.mem_cat;Seq.filter_cat;Seq.mem_filter;Seq.cat0s];
    COND_CASES_TAC THEN ASM_SIMP_TAC[MEM;Seq.mem_filter;replace;Seq.mem_cat];
      BY(ASM_MESON_TAC[]);
    TYPIFY `u= h` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC replace_filter2 [`t`;`P`;`u`;`old`;`[]:(A)list`];
    ASM_SIMP_TAC[Seq.mem_filter;Seq.filter_nil];
    BY(ASM_MESON_TAC[mem_replace]);
  COND_CASES_TAC THEN ASM_SIMP_TAC[MEM;Seq.mem_filter;replace;Seq.mem_cat];
    BY(ASM_MESON_TAC[]);
  INTRO_TAC replace_filter2 [`t`;`P`;`u`;`old`;`[]:(A)list`];
  ASM_SIMP_TAC[Seq.mem_filter;Seq.filter_nil];
  BY(ASM_MESON_TAC[mem_replace])
  ]);;
  (* }}} *)

(* 
let mem_faceListAt_lemma = prove_by_refinement(
  `!g ram1 ram2 oldF news vs1 vs2 h i.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
    ~(MEM f1 (flatten (faceListAt g))) /\
      ~(MEM f2 (flatten (faceListAt g))) /\
      uniq (FST oldF) /\
      MEM ram1 (FST oldF) /\
      ram1 < sizel (faceListAt g) /\
      ram2 < sizel (faceListAt g) /\
      MEM ram2 (FST oldF) /\
      ~(f1 = f2) /\
      ~(ram1 = ram2) /\
      betwn (FST oldF) ram1 ram2 = vs1 /\
      betwn (FST oldF) ram2 ram1 = vs2 /\
       (MEM i vs1 ==> i < sizel (faceListAt g)) /\
       (MEM i vs2 ==> i < sizel (faceListAt g)) /\
       i < sizel (faceListAt g')
 ==>
     ( MEM h (facesAt g' i) <=>
	 (i = ram1 /\ (h = f1 \/ h = f2 \/ (MEM h (facesAt g ram1) /\ ~(h = oldF)))) \/
	 (i = ram2 /\ (h = f1 \/ h = f2 \/ (MEM h (facesAt g ram2) /\ ~(h = oldF)))) \/
	 (MEM i vs1 /\ (h = f1 \/ (MEM h (facesAt g i) /\ ~(h = oldF)))) \/
	 (MEM i vs2 /\ (h = f2 \/ (MEM h (facesAt g i) /\ ~(h = oldF)))) \/
	 (sizel (faceListAt g) <= i /\ (h = f1 \/ h = f2)) \/
	 ((~(i=ram1) /\ ~(i=ram2) /\ ~(MEM i vs1) /\ ~(MEM i vs2) /\ ~(sizel (faceListAt g) <= i)) /\ MEM h (facesAt g i))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `heights` MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `i < sizel (faceListAt g')` MP_TAC;
  ASM_REWRITE_TAC[facesAt_graph;Tame_list.FACE_LIST_AT];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  FULL_EXPAND_TAC "Fs'''''";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[lower_case;Seq.all_cat;REPLICATE_nseq;Seq.size_cat;Seq.size_nseq];
  REWRITE_TAC[upper_case;EL_APPEND];
  REWRITE_TAC[lower_case];
  TYPIFY `(sizel Fs' = sizel Fs) /\ (sizel Fs'' = sizel Fs') /\ sizel Fs''' = sizel Fs'' /\ sizel Fs'''' = sizel Fs'''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[size_replacefacesAt]);
  DISCH_TAC;
  TYPIFY `sizel Fs'''' <= i` ASM_CASES_TAC;
    TYPIFY_GOAL_THEN `~(i < sizel Fs'''') /\ sizel Fs <= i` (unlist REWRITE_TAC);
      BY(ASM_MESON_TAC[arith `a <= b ==> ~(b < a:num)`]);
    TYPIFY `i - sizel Fs'''' < sizel news` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    GMATCH_SIMP_TAC el_nseq;
    ASM_REWRITE_TAC[MEM];
    TYPIFY `~(i < sizel Fs)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `i < sizel Fs''''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  FIRST_X_ASSUM_ST `=` MP_TAC;
  (REPLICATE_TAC 6 (POP_ASSUM kill))
  repeat dt
  fexp "Fs''''"
  gm el_replacefacesAt
  pop mp then art[size_replacefacesAt]
  dt
  TYPIFY `uniq [f1;f2] /\ uniq [f1] /\ uniq [f2] /\ uniq [ram1] /\ uniq [ram2]` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.cons_uniq; Seq.nil_uniq;MEM]);
  TYPIFY `uniq vs1 /\ uniq vs2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Ohcgkfu.uniq_betwn]);
  fexp "vs1"
  fexp "vs2"
  rule (rr[])
  TYPIFY `~(MEM ram1 vs1') /\ ~(MEM ram1 vs2') /\ ~(MEM ram2 vs1') /\ ~(MEM ram2 vs2')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1;not_betwn2]);
  asimp[MEM]
  fexp "Fs'''"
  repeat (gm el_replacefacesAt)
  asimp[MEM]
  fexp "Fs''"
  repeat (gm el_replacefacesAt)
  asimp[]
  fexp "Fs'"
  repeat (gm el_replacefacesAt)
  asimp[]
  rule(rr[])
   (fxast `sizel x = sizel y` kill)
  repeat (fxast `T` kill)
  typ `MEM i vs2' ==> ~(MEM i vs1')` smp
  amt[betwn_disjoint]
  simp[]
  dt
... to here.. This might be close enough...
  REWRITE_TAC[ (GSYM Seq2.all_EL_P)];
  REWRITE_TAC[size_replacefacesAt];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[el_replacefacesAt;MEM];
  FULL_EXPAND_TAC "Fs'''";
  ASM_SIMP_TAC[el_replacefacesAt;MEM];
  GMATCH_SIMP_TAC el_replacefacesAt;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  FULL_EXPAND_TAC "Fs''";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  REWRITE_TAC[CONJ_ASSOC];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "Fs'";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  ASM_REWRITE_TAC[CONJ_ASSOC];
  TYPIFY `uniq (EL i Fs)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `all uniq` MP_TAC;
    BY(ASM_MESON_TAC[Seq2.all_EL_P]);
  TYPIFY `!s. uniq s /\ (!f. MEM f s ==> MEM f [f1;f2]) ==> uniq (cat (EL i Fs) s)` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[Seq.cat_uniq];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.hasP;NOT_EXISTS_THM];
    GEN_TAC;
    TYPIFY `MEM x s` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `x = f1 \/ x = f2` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN MESON_TAC[MEM]);
    REPEAT (FIRST_X_ASSUM_ST `flatten` MP_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `MEM (EL i Fs) Fs` (C SUBGOAL_THEN MP_TAC);
      MATCH_MP_TAC MEM_EL;
      BY(ASM_REWRITE_TAC[lower_case]);
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    POP_ASSUM (SUBST1_TAC o GSYM);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    POP_ASSUM (SUBST1_TAC o GSYM);
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[MEM;Seq.cons_uniq;Seq.nil_uniq];
    BY(MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    MATCH_MP_TAC replace_uniq;
    TYPIFY `~(MEM i vs1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[betwn_disjoint]);
    ASM_SIMP_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[MEM];
    BY(MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  MATCH_MP_TAC replace_uniq;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[MEM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)
*)

let mem_faceListAt_lemma = prove_by_refinement(
  `!g ram1 ram2 oldF news vs1 vs2 h i.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
//    ~(MEM f1 (flatten (faceListAt g))) /\
//      ~(MEM f2 (flatten (faceListAt g))) /\
      good_faces_v3 g /\
      countVertices g = sizel (faceListAt g) /\
       (!i. i < sizel (faceListAt g) /\ MEM i (FST f1) ==> MEM i (FST oldF)) /\
       (!i. i < sizel (faceListAt g) /\ MEM i (FST f2) ==> MEM i (FST oldF)) /\
       MEM ram1 (FST f1) /\ MEM ram1 (FST f2) /\ MEM ram2 (FST f1) /\ MEM ram2 (FST f2) /\
       (!i. MEM i vs2 ==> (MEM i (FST f2) /\ ~(MEM i (FST f1)))) /\
       (!i. MEM i vs1 ==> (MEM i (FST f1) /\ ~(MEM i (FST f2)))) /\
       MEM oldF (faces g) /\
      uniq (FST oldF) /\
      uniq (faces g) /\
      MEM ram1 (FST oldF) /\
      ram1 < sizel (faceListAt g) /\
      ram2 < sizel (faceListAt g) /\
      MEM ram2 (FST oldF) /\
      ~(f1 = f2) /\
      ~(ram1 = ram2) /\
      betwn (FST oldF) ram1 ram2 = vs1 /\
      betwn (FST oldF) ram2 ram1 = vs2 /\
       (MEM i vs1 ==> i < sizel (faceListAt g)) /\
       (MEM i vs2 ==> i < sizel (faceListAt g)) /\
       i < sizel (faceListAt g')
 ==>
     ( MEM h (facesAt g' i) <=>
	 	 (sizel (faceListAt g) <= i /\ (h = f1 \/ h = f2)) \/
		 (i < sizel (faceListAt g) /\ MEM h (facesAt_v2 g' i) )))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `heights` MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `i < sizel (faceListAt g')` MP_TAC;
  ASM_REWRITE_TAC[facesAt_graph;Tame_list.FACE_LIST_AT];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  FULL_EXPAND_TAC "Fs'''''";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[lower_case;Seq.all_cat;REPLICATE_nseq;Seq.size_cat;Seq.size_nseq];
  REWRITE_TAC[upper_case;EL_APPEND];
  REWRITE_TAC[lower_case];
  TYPIFY `(sizel Fs' = sizel Fs) /\ (sizel Fs'' = sizel Fs') /\ sizel Fs''' = sizel Fs'' /\ sizel Fs'''' = sizel Fs'''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[size_replacefacesAt]);
  DISCH_TAC;
  TYPIFY `sizel Fs'''' <= i` ASM_CASES_TAC;
    TYPIFY_GOAL_THEN `~(i < sizel Fs'''') /\ sizel Fs <= i` (unlist REWRITE_TAC);
      BY(ASM_MESON_TAC[arith `a <= b ==> ~(b < a:num)`]);
    TYPIFY `i - sizel Fs'''' < sizel news` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    GMATCH_SIMP_TAC el_nseq;
    ASM_REWRITE_TAC[MEM];
    TYPIFY `~(i < sizel Fs)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `i < sizel Fs''''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  FIRST_X_ASSUM_ST `=` MP_TAC;
  (REPLICATE_TAC 6 (POP_ASSUM kill));
  REPEAT DISCH_TAC;
  TYPIFY_GOAL_THEN `~(sizel Fs <= i)` (unlist REWRITE_TAC);
    BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN SIMP_TAC[arith `i < u ==> ~(u <= i:num)`]);
  REWRITE_TAC[facesAt_v2;faces_graph;lower_case];
  FULL_EXPAND_TAC "Fs''''";
  GMATCH_SIMP_TAC el_replacefacesAt;
  POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[size_replacefacesAt];
  DISCH_TAC;
  TYPIFY `uniq [f1;f2] /\ uniq [f1] /\ uniq [f2] /\ uniq [ram1] /\ uniq [ram2]` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.cons_uniq; Seq.nil_uniq;MEM]);
  TYPIFY `uniq vs1 /\ uniq vs2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Ohcgkfu.uniq_betwn]);
  FULL_EXPAND_TAC "vs1";
  FULL_EXPAND_TAC "vs2";
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  TYPIFY `~(MEM ram1 vs1') /\ ~(MEM ram1 vs2') /\ ~(MEM ram2 vs1') /\ ~(MEM ram2 vs2')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1;not_betwn2]);
  ASM_SIMP_TAC[MEM];
  FULL_EXPAND_TAC "Fs'''";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  ASM_SIMP_TAC[MEM];
  FULL_EXPAND_TAC "Fs''";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  ASM_SIMP_TAC[];
  FULL_EXPAND_TAC "Fs'";
  REPEAT (GMATCH_SIMP_TAC el_replacefacesAt);
  ASM_SIMP_TAC[];
  FULL_EXPAND_TAC "n";
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  (FIRST_X_ASSUM_ST `sizel x = sizel y` kill);
  REPEAT (FIRST_X_ASSUM_ST `T` kill);
  TYPIFY `MEM i vs2' ==> ~(MEM i vs1')` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[betwn_disjoint]);
  SIMP_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `good_faces_v3` MP_TAC;
  REWRITE_TAC[good_faces];
  ASM_REWRITE_TAC[GSYM Tame_list.vertices_set2_countVertices];
  ASM_REWRITE_TAC[facesAt];
  ASM_REWRITE_TAC[facesAt_v2;lower_case];
  ONCE_REWRITE_TAC[Seq.perm_eq_sym];
  DISCH_TAC;
  TYPIFY `!i news. i < sizel Fs ==> (MEM h (replace oldF news (EL i Fs)) <=> MEM h (replace oldF news (filter (\f. MEM i (FST f)) fs)))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[replace_perm_eq]);
  ASM_SIMP_TAC[];
  REWRITE_TAC[Seq.filter_cat;Seq.mem_cat];
  COMMENT "first case not in oldF";
  TYPIFY `~(MEM i (FST oldF))` ASM_CASES_TAC;
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
    TYPIFY `MEM h (EL i Fs) <=> MEM h (filter (\f. MEM i (FST f)) fs)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[Seq.perm_eq_mem]);
    REWRITE_TAC[Seq.mem_filter;MEM];
    TYPIFY `~(MEM i (FST h))` ASM_CASES_TAC THEN RULE_ASSUM_TAC(REWRITE_RULE[]) THEN ASM_REWRITE_TAC[];
    TYPIFY `~(h = f1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    TYPIFY `~(h = f2)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC mem_replace3;
    ASM_SIMP_TAC[MEM];
    BY(ASM_MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  COMMENT "second case, in oldF";
  GMATCH_SIMP_TAC (GSYM replace_filter3);
  ASM_SIMP_TAC[];
  INTRO_TAC Tame_list.betwn_cases [`FST oldF`;`ram1`;`i`;`ram2`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC mem_replace [`(filter (\f. MEM i (FST f)) fs)`;`h`;`oldF`];
  REWRITE_TAC[RIGHT_FORALL_IMP_THM];
  ANTS_TAC;
    ASM_REWRITE_TAC[Seq.mem_filter];
    MATCH_MP_TAC Seq.filter_uniq;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  COMMENT "i=ram2";
  POP_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`[f1;f2]`]) THEN ASM_SIMP_TAC[MEM;Seq.mem_filter];
    DISCH_THEN kill;
    BY(REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN MESON_TAC[]);
  COMMENT "i=ram1";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`[f2;f1]`]) THEN ASM_SIMP_TAC[MEM;Seq.mem_filter];
    DISCH_THEN kill;
    BY(REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN MESON_TAC[]);
  COMMENT "vs2'";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`[f2]`]) THEN ASM_SIMP_TAC[MEM;Seq.mem_filter];
    DISCH_THEN kill;
    BY(REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN MESON_TAC[]);
  COMMENT "vs1'";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`[f1]`]) THEN ASM_SIMP_TAC[MEM;Seq.mem_filter];
    DISCH_THEN kill;
    BY(REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN MESON_TAC[]);
  BY(REPLICATE_TAC 5 (POP_ASSUM MP_TAC) THEN MESON_TAC[])
  ]);;
  (* }}} *)

let mem_flatten_facelistat = prove_by_refinement(
  `!g f. countVertices g = sizel (faceListAt g) /\
    good_faces_v3 g /\ (MEM f (flatten (faceListAt g))) ==> MEM f (faces g)`,
  (* {{{ proof *)
  [
  SIMP_TAC[Seq2.mem_flatten;good_faces;GSYM vertices_set2_countVertices];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `faceListAt` (MP_TAC o (REWRITE_RULE[ MEM_EXISTS_EL;lower_case;GSYM facesAt]));
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM f (facesAt_v2 g i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.perm_eq_mem]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[facesAt_v2;lower_case;Seq.mem_filter];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let splitFace_props = prove_by_refinement(
    `!g ram1 ram2 oldF news vs1 vs2 i.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
      good_faces_v3 g /\
      countVertices g = sizel (faceListAt g) /\
       vertices_set2 g = elements_of_list (fgraph g) /\
       MEM oldF (faces g) /\
       ~(MEM f1 (faces g)) /\
       ~(MEM f2 (faces g)) /\
      uniq (FST oldF) /\
      uniq (faces g) /\
      MEM ram1 (FST oldF) /\
      MEM ram2 (FST oldF) /\
      ~(ram1 = ram2) /\
      betwn (FST oldF) ram1 ram2 = vs1 /\
      betwn (FST oldF) ram2 ram1 = vs2 /\
       (!i. MEM i news <=> (sizel (faceListAt g) <= i /\ i < sizel (faceListAt g'))) 
//       (!i. i < sizel (faceListAt g) ==> ~(MEM i news))

       ==>

     (!i. i < sizel (faceListAt g) <=> MEM i (flatten (fgraph g))) /\
    ~(MEM f1 (flatten (faceListAt g))) /\
      ~(MEM f2 (flatten (faceListAt g))) /\
       (!i. i < sizel (faceListAt g) /\ MEM i (FST f1) ==> MEM i (FST oldF)) /\
       (!i. i < sizel (faceListAt g) /\ MEM i (FST f2) ==> MEM i (FST oldF)) /\
       MEM ram1 (FST f1) /\ MEM ram1 (FST f2) /\ MEM ram2 (FST f1) /\ MEM ram2 (FST f2) /\
       (!i. MEM i vs2 ==> (MEM i (FST f2) /\ ~(MEM i (FST f1)))) /\
       (!i. MEM i vs1 ==> (MEM i (FST f1) /\ ~(MEM i (FST f2)))) /\
      ram1 < sizel (faceListAt g) /\
      ram2 < sizel (faceListAt g) /\
      ~(f1 = f2) /\
       (MEM i vs1 ==> i < sizel (faceListAt g)) /\
       (MEM i vs2 ==> i < sizel (faceListAt g)) /\
          (!i. MEM i news ==> MEM i (FST f1) /\ MEM i (FST f2))
  )    
 `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[splitFace];
  LET_TAC;
  POP_ASSUM MP_TAC THEN REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "vs1";
  FULL_EXPAND_TAC "vs2";
  FIRST_X_ASSUM_ST `split_face` MP_TAC THEN REWRITE_TAC[split_face];
  REWRITE_TAC[LET_THM;lower_case;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  TYPIFY `(!i. i < sizel (faceListAt g) ==> ~(MEM i news))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `i < s ==> ~(s <= i:num)`]);
  TYPIFY `~MEM f1' (flatten Fs) /\  ~MEM f2' (flatten Fs) ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ mem_flatten_facelistat]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  TYPIFY `MEM ram1 (FST f1') /\ MEM ram1 (FST f2') /\ MEM ram2 (FST f1') /\ MEM ram2 (FST f2')` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f1'";
    FULL_EXPAND_TAC "f2'";
    BY(REWRITE_TAC[FST;Seq.mem_cat;MEM;FACE]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    TYPIFY_GOAL_THEN `!i. MEM i (flatten (fgraph g)) <=> MEM i (undup (flatten (fgraph g)))` (unlist REWRITE_TAC);
      BY(REWRITE_TAC[Seq.mem_undup]);
    REWRITE_TAC[GSYM List_hypermap.list_of_elements;GSYM IN_SET_OF_LIST;GSYM List_hypermap.elements_of_list];
    BY(ASM_MESON_TAC[vertices_set2_countVertices]);
  DISCH_TAC;
  TYPIFY `!i. MEM i (FST oldF) ==> MEM i (flatten (fgraph g))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[mem_faces_fgraph]);
  TYPIFY `ram1 < sizel Fs /\ ram2 < sizel Fs` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    BY(CONJ_TAC THEN POP_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
  FIRST_ASSUM (unlist REWRITE_TAC);
  TYPIFY `!i. (MEM i vs1' ==> MEM i (FST oldF)) /\  (MEM i vs2' ==> MEM i (FST oldF))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.betwn_mem]);
  TYPIFY `!i. (MEM i vs1' ==> i < sizel Fs) /\ (MEM i vs2' ==> i < sizel Fs)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  SIMP_TAC[];
  DISCH_TAC;
  REPEAT (FIRST_X_ASSUM_ST `flatten` MP_TAC);
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `APPEND` kill);
  REPEAT (FIRST_X_ASSUM_ST `~MEM f (flatten FF)` kill);
  FIRST_X_ASSUM_ST `a /\ b /\ c /\ d` kill;
  REPEAT (FIRST_X_ASSUM_ST `~MEM (f:((A)list # bool)) FF` kill);
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  ASM_REWRITE_TAC[FACE;FST;Seq.mem_cat;Seq.mem_rev;MEM];
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  ASM_SIMP_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[betwn_disjoint;not_betwn1;not_betwn2]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[betwn_disjoint;not_betwn1;not_betwn2]);
  REWRITE_TAC[FACE;PAIR_EQ;DE_MORGAN_THM];
  TYPIFY `news = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq.cat0s;GSYM Seq.catA;rev0;Seq.cat1s];
    BY(ASM_REWRITE_TAC[Seq.cat0s;GSYM Seq.catA;rev0;Seq.cat1s;CONS_11]);
  INTRO_TAC rcons_butlast [`news`];
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  REWRITE_TAC[Seq.rev_rcons;GSYM Seq.catA;Seq.cat1s;CONS_11;DE_MORGAN_THM;Seq.cat_cons];
  DISJ1_TAC;
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let all_uniq_faceListAt = prove_by_refinement(
  `!g ram1 ram2 oldF news.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
//    ~(MEM f1 (flatten (faceListAt g))) /\
//      ~(MEM f2 (flatten (faceListAt g))) /\
      uniq (FST oldF) /\
      MEM ram1 (FST oldF) /\
//      ram1 < sizel (faceListAt g) /\
//      ram2 < sizel (faceListAt g) /\
      MEM ram2 (FST oldF) /\
//      ~(f1 = f2) /\
      ~(ram1 = ram2) /\
    good_faces_v3 g /\
      countVertices g = sizel (faceListAt g) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      MEM oldF (faces g) /\
      ~MEM f1 (faces g) /\
      ~MEM f2 (faces g) /\
      uniq (faces g) /\
      (!i. MEM i news <=>
           sizel (faceListAt g) <= i /\ i < sizel (faceListAt g')) /\
    all uniq (faceListAt g) ==>
    all uniq (faceListAt g')) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `vs1 = betwn (FST oldF) ram1 ram2`;
  TYPED_ABBREV_TAC `vs2 = betwn (FST oldF) ram2 ram1`;
  INTRO_TAC all_uniq_faceListAt_lemma [`g`;`ram1`;`ram2`;`oldF`;`news`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  DISCH_THEN MATCH_MP_TAC;
  INTRO_TAC splitFace_props [`g`;`ram1`;`ram2`;`oldF`;`news`;`vs1`;`vs2`];
  BY((ASM_SIMP_TAC[LET_THM;LAMBDA_TRIPLE]))
  ]);;
  (* }}} *)

let PAIR_EQ3 = prove_by_refinement(
  `!a b. a = b <=> FST a = FST b /\ FST (SND a) = FST (SND b) /\ SND (SND a) = SND (SND b)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[PAIR_EQ2])
  ]);;
  (* }}} *)

let mem_faceListAt = prove_by_refinement(
  `!g ram1 ram2 oldF news h i.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF news in
     good_faces_v3 g /\
       (countVertices g = sizel (faceListAt g)) /\
       vertices_set2 g = elements_of_list (fgraph g) /\
       ~MEM f1 (faces g) /\
       ~MEM f2 (faces g) /\
       (!i. MEM i news <=> (sizel (faceListAt g) <= i /\ i < sizel (faceListAt g'))) /\
       MEM oldF (faces g) /\
       uniq (FST oldF) /\
       uniq (faces g) /\
       MEM ram1 (FST oldF) /\
       MEM ram2 (FST oldF) /\
       ~(ram1 = ram2) /\
       i < sizel (faceListAt g')
     ==>
       ( MEM h (facesAt g' i) <=> MEM h (facesAt_v2 g' i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `vs1 = betwn (FST oldF) ram1 ram2`;
  TYPED_ABBREV_TAC `vs2 = betwn (FST oldF) ram2 ram1`;
  INTRO_TAC mem_faceListAt_lemma [`g`;`ram1`;`ram2`;`oldF`;`news`;`vs1`;`vs2`;`h`;`i`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  MATCH_MP_TAC (MESON [] `!b. ((b /\ a ==> b /\ c) ==> t) ==> ((a ==> c) ==> t)`);
  TYPIFY `(!i. MEM i news ==> MEM i (FST f1) /\ MEM i (FST f2))` EXISTS_TAC;
  ANTS_TAC;
    INTRO_TAC splitFace_props [`g`;`ram1`;`ram2`;`oldF`;`news`;`vs1`;`vs2`;`i`];
    BY(ASM_SIMP_TAC[LET_THM;LAMBDA_TRIPLE]);
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `i < sizel (faceListAt g)` ASM_CASES_TAC THEN ASM_SIMP_TAC[arith `i < j ==> ~(j <= i:num)`];
  RULE_ASSUM_TAC (REWRITE_RULE[arith `~(i < j) <=> (j <= i:num)`]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[facesAt_v2];
  TYPIFY `split_face oldF ram1 ram2 news = f1,f2` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[splitFace_split_face]);
  DISCH_THEN (ASSUME_TAC o ONCE_REWRITE_RULE[PAIR_EQ2]);
  FIRST_X_ASSUM_ST `splitFace` MP_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ3];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `faces g' = (cat (replace oldF [f2] (faces g)) [f1])` (C SUBGOAL_THEN SUBST1_TAC);
    FULL_EXPAND_TAC "g'";
    REWRITE_TAC[splitFace;LET_THM;LAMBDA_PAIR];
    BY(ASM_REWRITE_TAC[faces_graph;lower_case]);
  REWRITE_TAC[lower_case;Seq.mem_filter;Seq.mem_cat;MEM];
  TYPIFY `h = f1` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC mem_replace3;
  ASM_REWRITE_TAC[MEM];
  TYPIFY `h=f2` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM i (list_of_elements (fgraph g))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.list_of_elements;Seq.mem_undup;Seq2.mem_flatten;fgraph];
    TYPIFY `FST h` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[GSYM IN_SET_OF_LIST;GSYM List_hypermap.elements_of_list];
  FIRST_X_ASSUM_ST `elements_of_list` (SUBST1_TAC o GSYM);
  BY(ASM_REWRITE_TAC[GSYM vertices_set2_countVertices;arith `~(i < s) <=> (s <= i:num)`])
  ]);;
  (* }}} *)
splitFace_props;;

(* extends assumption_set2 *)

let assumption_setK6 = new_definition'
  `assumption_setK6 <=> (!L N r x k uvns vs vs' fx v.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      core_triple_v4 L N r x = uvns /\
      dest_triple_full (core L r) v uvns = vs /\
      MAP the (filter isSome vs) = vs' /\
       transform_count L N r x = k /\
        find_face L x = fx /\
      prev_el (core L r) v,v = x 
      ==> 
      //  added for reduction_D: July 10 2014
     uniq (core L (rtrans L N r x k)) /\
     MEM (FST x) (core L (rtrans L N r x k)) /\
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k)) /\
     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\

      // added for induction July 11, 2014
      (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) = MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i))) /\
      (!i. i < k ==> prev_el (core L (rtrans L N r x i)) v,v = x ) /\


      //
      FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0) /\
      set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = set_of_list (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0))) /\
      (!i. MEM i (MAP FST (flatten N)) ==> 
	 ~(MEM i (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0))))) /\
      (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0))) /\
      (let (f1,f2) = split_normal_list L r fx (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N)) /\
               ~(transform_count L N r x = 0) /\
         0 < transform_count L N r x /\
         FST x = prev_el (core L r) v /\
         MEM x fx /\
         uniq fx /\
         1 <= sizel fx /\
         1 < sizel (core L r) /\
         (!i. SUC i < k
              ==> indexf (ytrans L N r x 0) (ztrans L N r x i) fx <=
                  indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx) /\
         (!i. SUC i < k
              ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx <=
                  indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) fx) /\
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx <=
         indexf (next_el fx x) x fx /\
         indexf (next_el fx x) (ytrans L N r x 0) fx <=
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx /\
         MEM (next_el fx x) r /\
         (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\
         (!i. i < k ==> MEM (ztrans L N r x i) r) /\
         (!i. i < k ==> MEM (ytrans L N r x i) r) /\
         MEM (next_el fx x) fx /\
         (!i. i < k ==> MEM (ytrans L N r x i) fx) /\
         (!i. i < k ==> MEM (ztrans L N r x i) fx) /\
         uniq (core L r) /\
         FST (next_el fx x) = v /\
         (!u. MEM u r ==> MEM (FST u) (core L r)) /\
         indexf v (FST (ytrans L N r x 0)) (core L r) =
         indexf (next_el fx x) (ytrans L N r x 0) fx /\
         indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x fx /\
         (!i. SUC i < k
              ==> indexf (FST (ztrans L N r x i))
                  (FST (ytrans L N r x (SUC i)))
                  (core L r) =
                  indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) fx) /\
	   (!i. SUC i < sizel vs'
            ==> indexf v (EL i vs') (core L r) <
           indexf v (EL (SUC i) vs') (core L r)) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (quotient_list L N))
             ==> MEM d (list_pairs (core L r))))
  )`;;

let split_normal_list_split_face = prove_by_refinement(
  `!L N r x v f1 f2 b newVs. 
    assumption_setK6 /\
    core_split_normal_list_assumption L /\
    good_list L /\
        good_list_nodes L /\
      marked_list L N r x /\
     newvertex_prepped L N r x /\
      ~final_list L r /\
      prev_el (core L r) v,v = x /\
    map FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)) = newVs /\
      is_restricted (hypermap_of_list L) /\
    split_normal_list L r (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) = f1,f2 /\
      ~final_list L r ==>
    split_face  (core L r,b) (FST (ytrans L N r x 0)) (FST(ztrans L N r x 0)) newVs = 
	  Face (core L f1) F, Face (core L f2) F
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction2.split_normal_list_split_list [`L`;`N`;`r`;`x`;`b`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM Reduction2.trans0];
  TYPIFY `find_face L (ytrans L N r x 0) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y;Reduction2.trans0]);
  TYPIFY `FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM_ST `assumption_setK6` MP_TAC THEN REWRITE_TAC[assumption_setK6] THEN ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[lower_case;LET_THM];
  DISCH_THEN MATCH_MP_TAC;
  FIRST_X_ASSUM_ST `core_split_normal_list_assumption` MP_TAC;
  REWRITE_TAC[core_split_normal_list_assumption];
  DISCH_THEN (C INTRO_TAC [`N`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[core_split_normal_list];
  ASM_REWRITE_TAC[lower_case;LET_THM;LAMBDA_PAIR];
  BY(ASM_REWRITE_TAC[lower_case;LET_THM;LAMBDA_PAIR;GSYM Reduction2.trans0])
  ]);;
  (* }}} *)

let good_faces_transform_lemma = prove_by_refinement(
  `!L N r x g g' newVs v f.        
    assumption_setK6 /\
    core_split_normal_list_assumption L /\
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    newvertex_prepped L N r x /\
    MEM f (faces g) /\
    marked_list L N r x /\
    ~final_list L r /\
//    match_quotient_list g L N /\    
    countVertices g = sizel (faceListAt g) /\
    countVertices g' = sizel (faceListAt g') /\
    vertices_set2 g = elements_of_list (fgraph g) /\
    vertices_set2 g' = elements_of_list (fgraph g') /\
        fgraph g = quotient_list L N /\
    fgraph g' = quotient_list L (ntrans L N r x 1) /\
    MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)) = newVs /\
    core L r = FST f /\
    prev_el (FST f) v,v = x /\
    SND (SND (splitFace g (FST (ytrans L N r x 0)) (FST (ztrans L N r x 0)) f newVs)) = g' /\
    good_faces_v3 g ==>
    good_faces_v3 g' `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM_ST `good_faces` MP_TAC;
  REWRITE_TAC[good_faces];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.uniq_perm_eq);
  TYPIFY `transform_assumption_v2 L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_defs2.transform_assumption]);
  nCONJ_TAC 0;
    MATCH_MP_TAC Reduction2.facesAt_v2_uniq;
    GEXISTL_TAC [`L`;`ntrans L N r x 1`];
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[marked_list]);
  ASM_REWRITE_TAC[];
  INTRO_TAC all_uniq_faceListAt [`g`;`(FST (ytrans L N r x 0))`;`(FST (ztrans L N r x 0))`;`f`;`newVs`];
  REPEAT LET_TAC;
  TYPIFY `g' = g''` (C SUBGOAL_THEN ASSUME_TAC);
    BY(RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ]) THEN ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "g''";
  ASM_REWRITE_TAC[];
  INTRO_TAC mem_faceListAt [`g`;`FST (ytrans L N r x 0)`;`FST (ztrans L N r x 0)`;`f`;`newVs`];
  REPEAT LET_TAC;
  TYPIFY `g' = g'' /\ f1 = f1' /\ f2 = f2'` (C SUBGOAL_THEN MP_TAC);
    BY(RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ]) THEN ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g''";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  REPEAT (FIRST_X_ASSUM_ST `T` kill);
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC);
  TYPIFY `v' < sizel (faceListAt g')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[vertices_set2_countVertices]);
  ASM_REWRITE_TAC[];
  TYPIFY `~MEM f1 (faces g) /\      ~MEM f2 (faces g) /\      (!i. MEM i newVs <=>           sizel (faceListAt g) <= i /\ i < sizel (faceListAt g')) /\      MEM f (faces g) /\      uniq (FST f) /\      uniq (faces g) /\      MEM (FST (ytrans L N r x 0)) (FST f) /\      MEM (FST (ztrans L N r x 0)) (FST f) /\      ~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0)) /\     all uniq (faceListAt g)` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    SUBCONJ2_TAC;
      GEN_TAC;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `uniq` MP_TAC;
    REWRITE_TAC[facesAt;GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    MATCH_MP_TAC MEM_EL;
    BY(ASM_REWRITE_TAC[lower_case]);
  COMMENT "now prove the assumptions";
  FIRST_ASSUM_ST `assumption_setK6` MP_TAC;
  REWRITE_TAC[assumption_setK6];
  TYPED_ABBREV_TAC `fx = find_face L x`;
  TYPED_ABBREV_TAC `uvns = core_triple_v4 L N r x`;
  TYPED_ABBREV_TAC `vs = dest_triple_full (core L r) v uvns`;
  TYPED_ABBREV_TAC `vs' = MAP the (filter isSome vs)`;
  TYPED_ABBREV_TAC `k = transform_count L N r x`;
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`vs`;`vs'`;`fx`;`v`]);
  ASM_SIMP_TAC[];
  TYPIFY `MEM f (faces g)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.minimalFace_face]);
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (faces g)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `uniq (fgraph g)` ENOUGH_TO_SHOW_TAC;
      REWRITE_TAC[fgraph;lower_case];
      BY(MESON_TAC[Seq.map_uniq]);
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    MATCH_MP_TAC Tame_list.good_list_quotient;
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[is_restricted_all_uniq];
    CONJ_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  ASM_REWRITE_TAC[];
  TYPIFY `all uniq (faceListAt g)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM Seq.allP];
    REWRITE_TAC[MEM_EXISTS_EL;lower_case];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Tame_defs.facesAt];
    FIRST_X_ASSUM_ST `good_faces_v3 g` MP_TAC;
    REWRITE_TAC[good_faces];
    DISCH_THEN (C INTRO_TAC [`i`]);
    ANTS_TAC;
      BY(ASM_MESON_TAC[vertices_set2_countVertices]);
    TYPIFY `uniq (facesAt_v2 g i)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[Seq.perm_eq_uniq]);
    REWRITE_TAC[facesAt_v2;lower_case];
    MATCH_MP_TAC Seq.filter_uniq;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = set_of_list (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `SUC` MP_TAC;
  TYPIFY `(!i. MEM i newVs <=> sizel (faceListAt g) <= i /\ i < sizel (faceListAt g'))` (C SUBGOAL_THEN ASSUME_TAC);
    GEN_TAC;
    POP_ASSUM MP_TAC;
    ASM_REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;IN_DIFF];
    DISCH_THEN (C INTRO_TAC [`i`]);
    DISCH_THEN (SUBST1_TAC o GSYM);
    REWRITE_TAC[arith `s <= i <=> ~( i < s:num)`];
    REWRITE_TAC[GSYM IN_SET_OF_LIST];
    REPEAT (GMATCH_SIMP_TAC Reduction1.oldvertex2);
    TYPIFY `g` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    TYPIFY `g'` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    CONJ_TAC;
      TYPIFY `L` EXISTS_TAC THEN ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_MESON_TAC[Tame_list.vertices_set2_countVertices]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `(let f1,f2 =      split_normal_list L r fx (ytrans L N r x 0)      (prev_el r (ztrans L N r x 0)) in  ~MEM (core L f1) (quotient_list L N) /\  ~MEM (core L f2) (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `SUC` kill;
  INTRO_TAC Tame_list.splitFace_split_face [`g`;`FST (ytrans L N r x 0)`;`FST (ztrans L N r x 0)`;`f`;`newVs`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC split_normal_list_split_face [`L`;`N`;`r`;`x`;`v`];
  FIRST_X_ASSUM_ST `core` MP_TAC THEN LET_TAC;
  POP_ASSUM (ASSUME_TAC o (ONCE_REWRITE_RULE[PAIR_EQ2]));
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  DISCH_TAC;
  DISCH_THEN (C INTRO_TAC [`f1'`;`f2'`;`SND f`;`newVs`]);
  ASM_SIMP_TAC[upper_case;PAIR_EQ];
  ANTS_TAC;
    FIRST_X_ASSUM_ST `prev_el` MP_TAC THEN ONCE_REWRITE_TAC[PAIR_EQ2];
    BY(REWRITE_TAC[]);
  SIMP_TAC[];
  REWRITE_TAC[FACE];
  BY(ASM_MESON_TAC[Tame_list.mem_faces_fgraph;FST])
  ]);;
  (* }}} *)

(* index core *)

let indexl_replace = prove_by_refinement(
  `!s x y.  (MEM y s ==> (y = x)) /\ MEM x s   ==>
    indexl y (replace x [y] s) = indexl x s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[MEM;replace;lower_case];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_cat;Seq.size_cons;Seq.size_nil];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_cat;Seq.size_cons;Seq.size_nil;MEM;Seq2.index_cons];
    BY(ASM_MESON_TAC[MEM]);
  ASM_REWRITE_TAC[Seq.index_cat;Seq.size_cons;Seq.size_nil;MEM;Seq2.index_cons;arith `SUC a = SUC b <=> a = b`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_cat;Seq.size_cons;Seq.size_nil;MEM;Seq2.index_cons];
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[arith `SUC a = SUC b <=> a = b`];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let not_uniq_replace = prove_by_refinement(
  `!s x y . MEM x s /\ MEM y s /\ ~(x = y) ==> ~uniq (replace x [y] s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[replace;MEM;lower_case];
  REPEAT GEN_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat_uniq;MEM;uniq_sing;GSYM Seq.hasP;Seq.cons_uniq];
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Tame_list.MEM2_replace;MEM])
  ]);;
  (* }}} *)

let indexl_uniq_replace = prove_by_refinement(
  `!s x y. uniq (replace x [y] s) /\ MEM x s ==>
    indexl y (replace x [y] s) = indexl x s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexl_replace;
  BY(ASM_MESON_TAC[not_uniq_replace])
  ]);;
  (* }}} *)

let index_rtrans = prove_by_refinement(
  `!L N r x.
    good_list L /\ good_list_nodes L /\ 
    marked_list L N r x  
  ==>
    indexl r N = indexl (rtrans L N r x 1) (ntrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `final_list L r` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[Reduction2.rtrans_id;Reduction2.ntrans_id]);
  INTRO_TAC Reduction2.ntrans1 [`L`;`N`;`r`;`x`];
  REPEAT LET_TAC;
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  TYPIFY `rtrans L N r x 1 = f2` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[rtrans];
    BY(ASM_REWRITE_TAC[Hypermap.POWER_1;transform_list;LET_THM]);
  ASM_REWRITE_TAC[Seq.index_cat];
  TYPIFY `MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM f2 (replace r [f2] N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Tame_list.MEM2_replace;
    BY(ASM_REWRITE_TAC[MEM]);
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC indexl_replace;
  FULL_EXPAND_TAC "f2";
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list;marked_list]);
  DISCH_TAC;
  INTRO_TAC List_hypermap.uniq_sublist_unique [`rtrans L N r x 1`;`r`;`N`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ2_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  MATCH_MP_TAC Aq7.AQ7;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let indexl_map_uniq = prove_by_refinement(
  `!ys d (f:A->B).
    MEM d ys /\ uniq (MAP f ys) ==> indexl (f d) (MAP f ys) = indexl d ys`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexl_map;
  ASM_REWRITE_TAC[];
  CONJ2_TAC;
    MATCH_MP_TAC Aq8.uniq_imp_inj;
    BY(ASM_REWRITE_TAC[]);
  BY(ASM_MESON_TAC[Seq.map_uniq;lower_case])
  ]);;
  (* }}} *)

let indexl_core = prove_by_refinement(
  `!L N r x.  MEM r N /\ uniq (quotient_list L N) ==>
    indexl (core L r) (quotient_list L N) = indexl r N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_list.quotient_list_core];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexl_map_uniq;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let indexl_splitFace = prove_by_refinement(
  `!g ram1 ram2 oldF newVs.
  (let (f1,f2,g') = splitFace g ram1 ram2 oldF newVs in
     uniq (fgraph g) /\ uniq (fgraph g') /\ MEM oldF (faces g) ==>     
    (indexl (FST f2) (fgraph g') = indexl (FST oldF) (fgraph g)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.splitFace_split_face [`g`;`ram1`;`ram2`;`oldF`;`newVs`;`f1`;`f2`;`g'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Reduction2.fgraph_splitFace [`g`;`ram1`;`ram2`;`oldF`;`newVs`];
  ASM_REWRITE_TAC[];
  SIMP_TAC[LET_THM];
  DISCH_TAC;
  REWRITE_TAC[Tame_defs.fgraph];
  REPEAT (GMATCH_SIMP_TAC indexl_map_uniq);
  ASM_REWRITE_TAC[GSYM Tame_defs.fgraph];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `MEM f2 (replace oldF [f2] (faces g))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Tame_list.MEM2_replace;
    BY(ASM_REWRITE_TAC[MEM]);
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[Seq.mem_cat]);
  DISCH_TAC;
  ASM_REWRITE_TAC[Seq.index_cat];
  MATCH_MP_TAC indexl_uniq_replace;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN ASM_REWRITE_TAC[lower_case];
  BY(MESON_TAC[Seq.map_uniq;Seq.cat_uniq])
   ]);;
  (* }}} *)

let AQIUNPP = prove_by_refinement(
  `!L N r x i.   good_list L /\
            good_list_nodes L /\
            marked_list L N r x
            ==> marked_list L (ntrans L N r x i) (rtrans L N r x i) x`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Tame_list.AQIUNPP3;Reduction2.transform_assumption_v2_lemma])
  ]);;
  (* }}} *)

let core_rtrans = prove_by_refinement(
  `!g ram1 ram2 oldF newVs L N r x.
    (let f1,f2,g' = splitFace g ram1 ram2 oldF newVs in
       uniq (quotient_list L N) /\ uniq (quotient_list L (ntrans L N r x 1)) /\
	 good_list L /\
	 good_list_nodes L /\
	 is_restricted (hypermap_of_list L) /\
	 marked_list L N r x /\
	 MEM oldF (faces g) /\ (core L r = FST oldF) /\
	 fgraph g = quotient_list L N /\
	 fgraph g' = quotient_list L (ntrans L N r x 1) 
	  ==> (core L (rtrans L N r x 1) = FST f2))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[AQIUNPP]);
  TYPIFY `MEM (rtrans L N r x 1) (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`rtrans L N r x 1`;`x`];
  ASM_REWRITE_TAC[];
  INTRO_TAC (GSYM index_rtrans) [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  TYPIFY `MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  INTRO_TAC (GSYM indexl_core) [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  TYPIFY `MEM (FST oldF) (fgraph g)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.mem_faces_fgraph]);
  TYPIFY `MEM (core L (rtrans L N r x 1)) (quotient_list L (ntrans L N r x 1))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[quotient_list_core];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (f2) (faces g')` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Tame_list.MEM_splitFace2 [`g`;`ram1`;`ram2`;`oldF`;`newVs`];
    BY(ASM_REWRITE_TAC[LET_THM]);
  TYPIFY `MEM (FST f2) (fgraph g')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.mem_faces_fgraph]);
  TYPIFY `indexl (FST f2) (fgraph g') = indexl (FST oldF) (fgraph g)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  INTRO_TAC indexl_splitFace [`g`;`ram1`;`ram2`;`oldF`;`newVs`];
  BY(ASM_REWRITE_TAC[LET_THM])
  ]);;
  (* }}} *)

let fgraph_quotient_list_transform = prove_by_refinement(
  `!L N r x g oldF g' fx newVs v.
    assumption_setK6 /\
    r_trans_eq_assumption L /\
    core_split_normal_list_assumption L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    vertices_set2 g = elements_of_list (fgraph g) /\
    (fgraph g = quotient_list L N) /\
    ~final_list L r /\
    (find_face L x = fx) /\
    (core L r = FST oldF) /\
    prev_el (core L r) v,v = x /\
    MEM oldF (faces g) /\
    SND (SND (splitFace g (FST (ytrans L N r x 0)) (FST (ztrans L N r x 0)) oldF newVs)) = g' /\
    MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)) = newVs
    ==> fgraph g' = quotient_list L (ntrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x`;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  TYPED_ABBREV_TAC `y = ytrans L N r x 0`;
  TYPED_ABBREV_TAC `z = ztrans L N r x 0`;
  INTRO_TAC Reduction2.fgraph_quotient_list_transform_lemma [`L`;`N`;`r`;`x`;`g`;`ntrans L N r x 1`;`oldF`;`fw`;`g'`;`w`;`y`;`z`;`prev_el r z`;`fx`;`newVs`];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[r_trans_eq_assumption]);
  TYPIFY `FST (prev_el r z) = FST z` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `assumption_setK6` MP_TAC THEN REWRITE_TAC[assumption_setK6];
    TYPED_ABBREV_TAC `uvns = core_triple_v4 L N r x `;
    TYPED_ABBREV_TAC `vs =     dest_triple_full (core L r) v uvns`;
    TYPED_ABBREV_TAC `vs' =    MAP the (filter isSome vs) `;
    TYPED_ABBREV_TAC `k =       transform_count L N r x `;
    DISCH_THEN (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`vs`;`vs'`;`fx`;`v`]);
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  CONJ_TAC;
    FIRST_X_ASSUM_ST `core_split_normal_list_assumption` MP_TAC;
    REWRITE_TAC[core_split_normal_list_assumption];
    DISCH_THEN (C INTRO_TAC [`N`;`r`;`x`]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[core_split_normal_list];
    BY(ASM_REWRITE_TAC[LET_THM]);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    FULL_EXPAND_TAC "newVs";
    BY(REWRITE_TAC[lower_case;Seq.size_map]);
  FULL_EXPAND_TAC "y";
  BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y])
  ]);;
  (* }}} *)

(* nfgtrans *)

(*
let fgtrans0 = prove_by_refinement(
  `!g L N r x.
    fgtrans_v2 g L N r x 0 = (minimalFace (nonFinals g),g)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[fgtrans;Seq.take;subdivFace0_alt2])
  ]);;
  (* }}} *)

let fgtrans1 = prove_by_refinement(
  `!g L N r x.
         good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
     is_restricted (hypermap_of_list L) 
==>
    fgtrans_v2 g L N r x 1 = SND
	 (splitFace g (FST (ytrans L N r x 0)) (FST (ztrans L N r x 0))
	    (minimalFace (nonFinals g))
	    (iota (countVertices g)
 (sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgtrans;arith `SUC 0 = 1`];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC take1;
  TYPIFY `~(transform_count L N r x = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[transform_count_non0]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[core_triple_nonnil]);
  REWRITE_TAC[subdivFace0_alt2];
  REWRITE_TAC[GSYM EL];
  GMATCH_SIMP_TAC el_core_triple;
  ASM_SIMP_TAC[arith `~(n = 0) ==> 0 < n`];
  (REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE;Tame_defs.upt;arith `0 + n = n`]);
  BY(ASM_SIMP_TAC[arith `(a + b) - a = b:num`])
  ]);;
  (* }}} *)

let fgtrans_transform_count = prove_by_refinement(
  `!g L N r x k.
         good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
     is_restricted (hypermap_of_list L) /\
    transform_count L N r x = k 
==>
    fgtrans_v2 g L N r x k = subdivFace0_alt2 g (minimalFace (nonFinals g)) (countVertices g) (core_triple_v4 L N r x) `,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgtrans];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  MATCH_MP_TAC Seq.take_oversize;
  BY(ASM_REWRITE_TAC[size_core_triple;arith `k <= k:num`])
  ]);;
  (* }}} *)

let fgtrans_add = prove_by_refinement(
  `!g L N r x i j.
             good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
     is_restricted (hypermap_of_list L) /\
    i +j <= transform_count L N r x ==>
    fgtrans_v2 g L N r x (i+j) = 
    (let (f',g') = fgtrans_v2 g L N r x i in
       fgtrans_v2 g' L (ntrans L N r x i) (rtrans L N r x i) x j)`,
  (* {{{ proof *)
  [
  rt[fgtrans]  
  st/r
    LET_TAC
  pop mp
 rt[subdivFace0_alt2_foldl_steps_alt]
  typ `take (i + j) (core_triple_v4 L N r x) = cat (take i (core_triple_v4 L N r x)) (take j (dropl i (core_triple_v4 L N r x)))` s1
  rt[take_drop_commute]
  amt[Seq.cat_take_drop;take_take;arith `i + j = j + i:num`;arith `i <= i + j:num`] 
  rt[Seq.foldl_cat]
  asimp[]

...
  gm take_add
  art[size_core_triple]
 intro subdivFace0_alt2_foldl_steps [`(rcons (take i (core_triple_v4 L N r x)) (EL i (core_triple_v4 L N r x)))`;`(0,(minimalFace (nonFinals g)),g)`]
  simp[]
  dthen kill
  rt[foldl_rcons]
 intro subdivFace0_alt2_foldl_steps [`(take i (core_triple_v4 L N r x))`;`(0,(minimalFace (nonFinals g)),g)`]
  rt[]

  ]);;
  (* }}} *)

*)

let foldl_rcons = prove_by_refinement(
  `!f z ss s. foldl f z (rcons ss s) = f (foldl f z ss) s`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Seq.foldl_cat;GSYM Seq.cats1;Seq.foldl])
  ]);;
  (* }}} *)

let nfgtrans0 = prove_by_refinement(
  `!p L N r x. nfgtrans' p L N r x 0 = p`,
  (* {{{ proof *)
  [
      BY(REWRITE_TAC[nfgtrans;Seq.take;Seq.foldl])
  ]);;
  (* }}} *)

let nfgtrans1 = prove_by_refinement(
  `!p L N r x.
         good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
     is_restricted (hypermap_of_list L) 
==>
    nfgtrans' p L N r x 1 = 
    subdiv_triple_step p
      (FST (ytrans L N r x 0),
       FST (ztrans L N r x 0),
       sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nfgtrans;arith `SUC 0 = 1`];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC take1;
  TYPIFY `~(transform_count L N r x = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[transform_count_non0]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[core_triple_nonnil]);
  REWRITE_TAC[Seq.foldl];
  REWRITE_TAC[GSYM EL];
  GMATCH_SIMP_TAC el_core_triple;
  BY(ASM_SIMP_TAC[arith `~(n = 0) ==> 0 < n`])
  ]);;
  (* }}} *)

let nfgtrans_transform_count = prove_by_refinement(
  `!n f g L N r x k.
    is_restricted (hypermap_of_list L) /\
    transform_count L N r x = k 
    ==>
    (SND (nfgtrans' (n,f,g) L N r x k) = subdivFace0_alt2 g f n (core_triple_v4 L N r x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nfgtrans;subdivFace0_alt2_foldl_steps_alt];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  AP_TERM_TAC;
  MATCH_MP_TAC Seq.take_oversize;
  BY(ASM_REWRITE_TAC[size_core_triple;arith `k <= k:num`])
  ]);;
  (* }}} *)

let drop_iota = prove_by_refinement(
  `!i j n. i <= j ==> dropl i (iota n j) = iota (n+i) (j-i)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iota n j = iota n (i + (j - i))` (C SUBGOAL_THEN SUBST1_TAC);
    AP_TERM_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.iota_add];
  MATCH_MP_TAC Seq.drop_size_cat;
  BY(REWRITE_TAC[Seq.size_iota])
  ]);;
  (* }}} *)

let drop_core_triple = prove_by_refinement(
  `!L N r x i.
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    i <= transform_count L N r x ==>
    dropl i (core_triple_v4 L N r x) = 
    core_triple_v4 L (ntrans L N r x i) (rtrans L N r x i) x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core_triple];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.map_drop;lower_case];
  AP_TERM_TAC;
  REWRITE_TAC[triple_data];
  TYPED_ABBREV_TAC `k = transform_count L N r x`;
  ASM_REWRITE_TAC[LET_THM;GSYM trans_add;lower_case;GSYM Seq.map_drop];
  GMATCH_SIMP_TAC drop_iota;
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC transform_count_add;
  REWRITE_TAC[arith `0 + i = i + 0`];
  ASM_REWRITE_TAC[Seq.iota_addl;GSYM Seq.map_comp];
  REWRITE_TAC[upper_case];
  REWRITE_TAC[ map_id_eq;GSYM Seq.allP;o_THM];
  BY(REWRITE_TAC[arith `i + x = x + i:num`])
  ]);;
  (* }}} *)

let nfgtrans_add = prove_by_refinement(
  `!p L N r x i j.
             good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
     is_restricted (hypermap_of_list L) /\
    i  <= transform_count L N r x ==>
    nfgtrans' p L N r x (i+j) = 
    (let p' = nfgtrans' p L N r x i in
       nfgtrans' p' L (ntrans L N r x i) (rtrans L N r x i) x j)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nfgtrans];
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  POP_ASSUM MP_TAC;
  TYPIFY `take (i + j) (core_triple_v4 L N r x) = cat (take i (core_triple_v4 L N r x)) (take j (dropl i (core_triple_v4 L N r x)))` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[take_drop_commute];
    BY(ASM_MESON_TAC[Seq.cat_take_drop;take_take;arith `i + j = j + i:num`;arith `i <= i + j:num`]);
  REWRITE_TAC[Seq.foldl_cat];
  ASM_SIMP_TAC[];
  TYPIFY `dropl i (core_triple_v4 L N r x) = core_triple_v4 L (ntrans L N r x i) (rtrans L N r x i) x` ENOUGH_TO_SHOW_TAC;
    BY(DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[]);
  MATCH_MP_TAC drop_core_triple;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let b_nfgtrans0 = prove_by_refinement(
  `!f0 g L N r x.
    b_nfgtrans0 f0 g L N r x 0 = 
    (let fx = find_face L x in
     let fst_u0 =
       (if FST (next_el fx x) = FST (ytrans L N r x 0)
        then NONE
        else SOME (prev_el (FST f0) (FST (ytrans L N r x 0)))) in
    ((fst_u0,0),f0,g))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[b_nfgtrans;batch;Seq.foldl;Seq.take;Seq.flatten0])
  ]);;
  (* }}} *)

let batch_k = prove_by_refinement(
  `!f L N r x k.
    k = transform_count L N r x 
    ==>
    batch0 f L N r x k = dest_triple0 f [] (core_triple_v4 L N r x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[batch];
  ONCE_REWRITE_TAC[EQ_SYM_EQ;];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM dest_triple0_foldl_steps);
  GMATCH_SIMP_TAC Seq.take_oversize;
  BY(ASM_REWRITE_TAC[size_core_triple;arith `k <= k:num`;Seq.flatten0])
  ]);;
  (* }}} *)

let cond_pair = prove_by_refinement(
  `!a b b' c. (if a then (b,c) else (b',c)) = ((if a then b else b'),c)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let b_nfgtransk = prove_by_refinement(
      `!L N g fs f v k r x fx uvns
	vs . // vs'.
   (?f0 g0.
      (let fst_u0 = if (FST (next_el fx x) = FST (ytrans L N r x 0)) then NONE 
		       else SOME (prev_el (FST f) (FST (ytrans L N r x 0))) in
                     (((SOME (FST (ztrans L N r x (PRE k))),0),f0,g0) =
   foldl subdiv_single_step ((fst_u0,0),f,g)
          (dest_triple0 (FST f) [] (core_triple_v4 L N r x))) /\
          uniq (FST f0) /\
          MEM (FST x) (FST f0) /\
          MEM (FST (ztrans L N r x (PRE k))) (FST f0) /\
         betwn (FST f0) (FST (ztrans L N r x (PRE k))) (FST x) =
          betwn (FST f) (FST (ztrans L N r x (PRE k))) (FST x))) /\
	assumption_setK6 /\
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
 //     planegraphP p g /\
 //     good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
//      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      prev_el (FST f) v,v = x /\
      uvns = core_triple_v4 L N r x /\
      vs = dest_triple_full (FST f) v uvns /\
//      vs' = MAP the (filter isSome vs) /\
 //     gk = SND(subdivFace0_alt2 g f (countVertices g) uvns) /\
  //    fk = FST(subdivFace0_alt2 g f (countVertices g) uvns) /\
      k = transform_count L N r x /\
//	Nk = ntrans L N r x k /\ 
	fx = find_face L x 
    ==>
    SND (b_nfgtrans0 f g L N r x k) = SND (subdivFace0_beta g f NONE 0 vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[b_nfgtrans];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  ASM_SIMP_TAC[batch_k];
  REWRITE_TAC[subdivFace0_beta_foldl_steps_alt];
  FULL_EXPAND_TAC "vs";
  REWRITE_TAC[dest_triple_full];
  REPEAT LET_TAC;
  TYPIFY `fx = fx'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "fx'";
  REWRITE_TAC[Seq.flatten_cons;Seq.flatten0;Seq.cats0];
  REWRITE_TAC[Seq.foldl_cat];
  COMMENT "initial seg";
  INTRO_TAC subdiv_single_step_initial_seg [`f`;`g`;`u`;`v`];
  ASM_REWRITE_TAC[LET_THM];
  INTRO_TAC minimalFace_core [`L`;`N`;`r`;`x`;`g`;`fs`;`f`;`v`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `0 < k` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  COMMENT "compute HD uvns";
  TYPIFY `FST (ytrans L N r x 0) = u` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `HD uvns = t` MP_TAC;
    REWRITE_TAC[GSYM EL];
    FULL_EXPAND_TAC "uvns";
    GMATCH_SIMP_TAC el_core_triple;
    ASM_REWRITE_TAC[PAIR_EQ];
    BY(SIMP_TAC[]);
  TYPIFY ` (!u. MEM u r ==> MEM (FST u) (core L r)) /\  (FST (next_el fx x) = v) /\ uniq (core L r) ` (C SUBGOAL_THEN MP_TAC);
    FIRST_X_ASSUM_ST `assumption_setK6` MP_TAC THEN REWRITE_TAC[assumption_setK6];
    DISCH_THEN (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`dest_triple_full (FST f) v uvns`;`MAP the (filter isSome (dest_triple_full (FST f) v uvns))`;`fx`;`v`]);
    ASM_REWRITE_TAC[];
    BY(SIMP_TAC[]);
  WEAKER_STRIP_TAC;
  SUBANTS_TAC;
    CONJ_TAC;
      BY(REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN MESON_TAC[]);
    SUBCONJ2_TAC;
      FIRST_X_ASSUM_ST `MEM` MP_TAC;
      ASM_REWRITE_TAC[];
      FULL_EXPAND_TAC "u";
      DISCH_THEN MATCH_MP_TAC;
      MATCH_MP_TAC Hojodcm.ytrans_mem_rtrans_v0;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `next_el` kill;
    FULL_EXPAND_TAC "v" THEN MATCH_MP_TAC mem_minimalVertex;
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[Dangeyj.mem_imp_not_nil]);
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(if v = u then (NONE,0),f,g else (SOME (prev_el (FST f) u),0),f,g) = ((fst_u0,0),(f,g))` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[cond_pair];
    REWRITE_TAC[PAIR_EQ];
    FULL_EXPAND_TAC "fst_u0";
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `((foldl subdiv_single_step ((fst_u0,0),f,g) (dest_triple0 (FST f) [] uvns)) = ((SOME v'',0),f0,g0) /\ uniq (FST f0) /\ MEM u0 (FST f0) /\ MEM v'' (FST f0) /\ betwn (FST f0) v'' u0 = betwn (FST f) v'' u0) ` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC subdiv_single_step_final_seg [`f0`;`g0`;`u0`;`v''`];
    BY(ASM_SIMP_TAC[LET_THM]);
  COMMENT "simplify";
  REPEAT ( FIRST_X_ASSUM_ST `dest_triple0` MP_TAC);
  REWRITE_TAC[LET_THM];
  FIRST_X_ASSUM_ST `LAST uvns = t` MP_TAC;
  FULL_EXPAND_TAC "uvns";
  GMATCH_SIMP_TAC last_core_triple;
  TYPIFY `PRE k` EXISTS_TAC;
  ASM_REWRITE_TAC[PAIR_EQ];
  WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `COND` MP_TAC);
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `(if u = v then NONE else SOME (prev_el (FST f) u)) = fst_u0` (C SUBGOAL_THEN SUBST1_TAC);
    BY(POP_ASSUM MP_TAC THEN MESON_TAC[EQ_SYM_EQ]);
  BY(POP_ASSUM MP_TAC THEN SIMP_TAC[])
  ]);;
  (* }}} *)

let assumption_set2_assumption_setK6 = prove_by_refinement(
  `assumption_setK6 ==> assumption_set2`,
  (* {{{ proof *)
  [
  REWRITE_TAC[assumption_setK6;assumption_set2];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`vs`;`vs'`;`fx`;`v`]);
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let reduction_D = prove_by_refinement(
   `assumption_setK6 /\ 
    (!L N Nk g p fs f v k r x fx uvns gk fk.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
      uvns = core_triple_v4 L N r x /\
     gk = SND (SND (nfgtrans' (countVertices g,f,g) L N r x k)) /\
     fk = FST (SND (nfgtrans' (countVertices g,f,g) L N r x k)) /\
      k = transform_count L N r x /\
	Nk = ntrans L N r x k /\ 
	fx = find_face L x
      ==> 
      (fgraph gk = quotient_list L Nk) /\
      good_faces_v3 gk /\
      (sizel (faceListAt gk) = countVertices gk) /\
      (vertices_set2 gk = elements_of_list (fgraph gk)) /\
      (((SOME (FST (ztrans L N r x (PRE k)))),0) = FST (b_nfgtrans0 f g L N r x k)) /\
      ((fk,gk) = SND (b_nfgtrans0 f g L N r x k)) /\
      (core L (rtrans L N r x k) = FST fk)
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_C;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    MATCH_MP_TAC assumption_set2_assumption_setK6;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`Nk`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`fx`;`uvns`;`gk`;`fk`]);
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    ONCE_REWRITE_TAC[CONJ_SYM];
    FULL_EXPAND_TAC "fk";
    FULL_EXPAND_TAC "gk";
    REWRITE_TAC[GSYM PAIR_EQ];
    FULL_EXPAND_TAC "uvns";
    MATCH_MP_TAC nfgtrans_transform_count;
    BY(ASM_REWRITE_TAC[]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[CONJ_SYM];
  FIRST_X_ASSUM_ST `fk,gk` (ASSUME_TAC o (ONCE_REWRITE_RULE[PAIR_EQ2]));
  POP_ASSUM (MP_TAC o (ONCE_REWRITE_RULE[EQ_SYM_EQ]));
  SIMP_TAC[];
  REWRITE_TAC[GSYM PAIR_EQ];
  DISCH_TAC;
  MATCH_MP_TAC b_nfgtransk;
  GEXISTL_TAC [`fs`;`v`;`fx`;`uvns`];
  ASM_SIMP_TAC[];
  SUBCONJ2_TAC;
    INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      CONJ_TAC;
        BY(ASM_MESON_TAC[marked_list]);
      MATCH_MP_TAC Tame_list.quotient_all_uniq;
      BY(ASM_MESON_TAC[]);
    BY(SIMP_TAC[]);
  DISCH_TAC;
  GEXISTL_TAC [`fk`;`gk`];
  ASM_REWRITE_TAC[];
  LET_TAC;
  FIRST_X_ASSUM_ST `ztrans` (SUBST1_TAC o GSYM);
  REWRITE_TAC[GSYM PAIR_EQ2];
  INTRO_TAC b_nfgtrans [`f`;`g`;`L`;`N`;`r`;`x`;`k`];
  ASM_REWRITE_TAC[LET_THM];
  ASM_SIMP_TAC[batch_k];
  DISCH_TAC;
  INTRO_TAC minimalFace_core [`L`;`N`;`r`;`x`;`g`;`fs`;`f`;`v`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_THEN (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `assumption_setK6` MP_TAC THEN REWRITE_TAC[assumption_setK6];
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`;`uvns`;`vs`;`MAP the (filter isSome vs)`;`fx`;`v`]);
  ANTS_TAC;
    POP_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_REWRITE_TAC[]);
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let reduction_E = prove_by_refinement(
   `assumption_setK6 /\ 
    (!i L N g p fs f v r x fx uvns gi fi.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) - 3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice2 g L N /\
		fx = find_face L x /\
      uvns = core_triple_v4 L N r x /\
      gi = SND (SND (nfgtrans' (countVertices g,f,g) L N r x i)) /\
      fi = FST (SND (nfgtrans' (countVertices g,f,g) L N r x i)) /\
      i <= transform_count L N r x 

      ==> 
      (fgraph gi = quotient_list L (ntrans L N r x i)) /\
      good_faces_v3 gi /\
      (sizel (faceListAt gi) = countVertices gi) /\
      (vertices_set2 gi = elements_of_list (fgraph gi)) /\
      (0 < i ==> ((SOME (FST (ztrans L N r x (PRE i)))),0) = FST (b_nfgtrans0 f g L N r x i)) /\
      ((fi,gi) = SND (b_nfgtrans0 f g L N r x i)) /\
      (core L (rtrans L N r x i) = FST fi)
  ) 
  ==> restricted_hypermaps_are_planegraphs_v4   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_D;
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC( ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`k`;`L`;`N`;`g`;`p`;`fs`;`f`;`v`;`r`;`x`;`fx`;`uvns`;`gk`;`fk`]);
  ASM_SIMP_TAC[arith `k <= k:num`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (MATCH_MP_TAC o GSYM);
  REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
  FULL_EXPAND_TAC "k";
  MATCH_MP_TAC transform_count_non0;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nfgtrans_suc = prove_by_refinement(
  `!i n f g L N r x.
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\
     SUC i <= transform_count L N r x 
==>
    (nfgtrans' (n,f,g) L N r x (SUC i) = 
	(let p' = nfgtrans' (n,f,g) L N r x i in
	   subdiv_triple_step p'
     (FST (ytrans L N r x i),
      FST (ztrans L N r x i),
      sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[arith `SUC i =  i + 1`];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC nfgtrans_add [`(n,f,g)`;`L`;`N`;`r`;`x`;`i`;`1`];
  ASM_SIMP_TAC[arith `i + 1 <= k ==> i <= k`];
  DISCH_THEN kill;
  LET_TAC;
  REWRITE_TAC[LET_THM];
  INTRO_TAC nfgtrans1 [`p'`;`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    INTRO_TAC AQIUNPP [`L`;`N`;`r`;`x`;`i`];
    ASM_SIMP_TAC[];
    DISCH_TAC;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_SIMP_TAC[arith `i + 1 <= k ==> i < k`]);
  BY(SIMP_TAC[GSYM trans_add;arith `0 + i = i`])
  ]);;
  (* }}} *)

let nfgtrans_mem = prove_by_refinement(
  `!i n f g L N r x.
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\
      i <= transform_count L N r x /\
    MEM f (faces g) ==>
    (let (n',f',g') = nfgtrans' (n,f,g) L N r x i in 
       MEM f' (faces g'))`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[nfgtrans0];
    BY(SIMP_TAC[LET_THM]);
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  INTRO_TAC nfgtrans_suc [`i`;`n`;`f`;`g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  LET_TAC;
  REWRITE_TAC[subdiv_triple_step_paired];
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  TYPED_ABBREV_TAC `m = (FST p' +  sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`;
  ONCE_REWRITE_TAC[arith `a + b = b + a:num`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (MP_TAC o ONCE_REWRITE_RULE[EQ_SYM_EQ] o ONCE_REWRITE_RULE[PAIR_EQ3]);
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.MEM_splitFace2 [`(SND (SND p'))`;`(FST (ytrans L N r x i))`;`(FST (ztrans L N r x i))`;`(FST (SND p'))`;`(upt (FST p') m)`];
  LET_TAC;
  POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE[PAIR_EQ3]);
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  FULL_EXPAND_TAC "f'";
  FULL_EXPAND_TAC "g'";
  POP_ASSUM MATCH_MP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`n`;`f`;`g`;`L`;`N`;`r`;`x`]);
  ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`];
  BY(REWRITE_TAC[LET_THM;LAMBDA_TRIPLE])
  ]);;
  (* }}} *)

let nfgtrans_fst = prove_by_refinement(
  `!i f g n L N r x. 
    element_pre L N /\
    r_trans_eq_assumption L /\
    core_split_normal_list_assumption L /\
               is_restricted (hypermap_of_list L) /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
            ~final_list L r /\
            newvertex_prepped L N r x /\
         sizel (undup (MAP FST (flatten N))) = n /\
//        sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)) /\
      i <= transform_count L N r x ==> 
    (let (n',f',g') = nfgtrans' (n,f,g) L N r x i in 
       n' = sizel (undup(MAP FST (flatten (ntrans L N r x i)))))
    `,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[trans0;nfgtrans0];
    BY(SIMP_TAC[LET_THM]);
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  INTRO_TAC nfgtrans_suc [`i`;`n`;`f`;`g`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  LET_TAC;
  REWRITE_TAC[subdiv_triple_step_paired];
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  REWRITE_TAC[PAIR_EQ];
  SIMP_TAC[];
  DISCH_THEN kill;
  TYPIFY `?n' f' g'. (n',f',g') = p'` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[EXISTS_PAIR_THM;FST;SND;PAIR]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "p'";
  REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`f`;`g`;`n`;`L`;`N`;`r`;`x`]);
  ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`];
  REWRITE_TAC[LET_THM];
  DISCH_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC newvertex_prepped_transform_lemma [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM trans_add;arith `1 + i = SUC i`];
  DISCH_THEN GMATCH_SIMP_TAC;
  REWRITE_TAC[arith `a + b = b + c <=> a = c:num`];
  INTRO_TAC Reduction2.rtrans_diff_r [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_SIMP_TAC[];
  TYPIFY`l'y L (rtrans L N r x i) x = ytrans L (ntrans L N r x i) (rtrans L N r x i) x 0` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[trans0]);
  REWRITE_TAC[GSYM trans0;GSYM trans_add;arith `1 + i = SUC i`];
  DISCH_THEN GMATCH_SIMP_TAC;
  REWRITE_TAC[lower_case;Seq.size_map;arith `0+i = i`;GSYM trans_add];
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[ AQIUNPP]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[arith `i < k <=> SUC i <= k:num`]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    FIRST_X_ASSUM_ST `r_trans_eq_assumption` MP_TAC THEN REWRITE_TAC[r_trans_eq_assumption];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC lnrx_induction [`i`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[arith `SUC i <= k ==> i < k`];
  BY(SIMP_TAC[element_pre;lower_case])
   ]);;
  (* }}} *)

let marked_list_good_quotient = prove_by_refinement(
  `!L N r x. good_list L /\ good_list_nodes L /\ 
    marked_list L N r x /\ is_restricted (hypermap_of_list L) ==>
    good_list (quotient_list L N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Tame_list.good_list_quotient;
  BY(ASM_MESON_TAC[Hypermap.is_restricted;marked_list;is_restricted_all_uniq])
  ]);;
  (* }}} *)

let marked_list_uniq_quotient = prove_by_refinement(
  `!L N r x. good_list L /\ good_list_nodes L /\ 
    marked_list L N r x /\ is_restricted (hypermap_of_list L) ==>
    uniq (quotient_list L N)`,
  (* {{{ proof *)
  [
    REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC List_hypermap.good_list_uniq;
  BY(ASM_MESON_TAC[marked_list_good_quotient])
  ]);;
  (* }}} *)

let main_induction = prove_by_refinement(
  `assumption_setK6 ==> (!i L N g p fs f v r x fx uvns gi fi.
	  r_trans_eq_assumption L /\
	  core_split_normal_list_assumption L /\
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
          marked_list L N r x /\
          ~final_list L r /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          fx = find_face L x /\
          uvns = core_triple_v4 L N r x /\
          gi = SND (SND (nfgtrans' (countVertices g,f,g) L N r x i)) /\
          fi = FST (SND (nfgtrans' (countVertices g,f,g) L N r x i)) /\
          i <= transform_count L N r x
          ==> fgraph gi = quotient_list L (ntrans L N r x i) /\
              good_faces_v3 gi /\
              sizel (faceListAt gi) = countVertices gi /\
              vertices_set2 gi = elements_of_list (fgraph gi) /\
              (0 < i
               ==> SOME (FST (ztrans L N r x (PRE i))),0 =
                   FST (b_nfgtrans0 f g L N r x i)) /\
              fi,gi = SND (b_nfgtrans0 f g L N r x i) /\
              core L (rtrans L N r x i) = FST fi)`,
  (* {{{ proof *)
  [

  DISCH_TAC;
  INDUCT_TAC;
    COMMENT "0 case";
    REWRITE_TAC[arith `~(0 < 0)`;nfgtrans0;trans0];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 2;
      REWRITE_TAC[b_nfgtrans0];
      BY(REWRITE_TAC[LET_THM]);
    ASM_REWRITE_TAC[];
    nCONJ_TAC 2;
      MATCH_MP_TAC minimalFace_core;
      GEXISTL_TAC [`N`;`x`;`g`;`fs`;`v`];
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC;
      BY(MESON_TAC[match_quotient_list]);
    DISCH_TAC;
    MATCH_MP_TAC Reduction1.sizel_faceListAt;
    REWRITE_TAC[Tame_list.planegraph_P];
    TYPIFY `p` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "induction step";
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`g`;`p`;`fs`;`f`;`v`;`r`;`x`;`fx`;`uvns`]);
  ASM_REWRITE_TAC[arith `0 < SUC i`];
  TYPED_ABBREV_TAC `g' = SND (SND (nfgtrans' (countVertices g,f,g) L N r x i))`;
  TYPED_ABBREV_TAC `f' = FST (SND (nfgtrans' (countVertices g,f,g) L N r x i))`;
  DISCH_THEN (C INTRO_TAC [`g'`;`f'`]);
  ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `newVs = MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i))`;
  COMMENT "general hypotheses";
  TYPIFY `i < transform_count L N r x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i < k`]);
  INTRO_TAC AQIUNPP [`L`;`N`;`r`;`x`;`i`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction2.elements_of_list_vertices_set2_converse [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `element_pre L (ntrans L N r x i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[element_pre]);
  INTRO_TAC Reduction2.elements_of_list_vertices_set2_converse [`L`;`N`;`r`;`x`;`g`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[match_quotient_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `element_pre L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[element_pre]);
  INTRO_TAC lnrx_induction [`i`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `~final_list L (rtrans L N r x i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  INTRO_TAC nfgtrans_mem [`i`;`countVertices g`;`f`;`g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    ASM_SIMP_TAC[arith `i < k ==> i <= k:num`];
    FULL_EXPAND_TAC "f";
    FULL_EXPAND_TAC "fs";
    BY(ASM_SIMP_TAC[ Tame_list.minimalFace_face]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  FIRST_X_ASSUM_ST `countVertices` (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  DISCH_TAC;
  TYPIFY `(SND (nfgtrans' (countVertices g,f,g) L N r x (SUC i))) = (fi,gi)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "fi";
    FULL_EXPAND_TAC "gi";
    BY(REWRITE_TAC[GSYM PAIR_EQ]);
  TYPIFY `(SND (nfgtrans' (countVertices g,f,g) L N r x i)) = (f',g')` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f'";
    FULL_EXPAND_TAC "g'";
    BY(REWRITE_TAC[GSYM PAIR_EQ]);
  COMMENT "fst nfgtrans";
  INTRO_TAC nfgtrans_fst [`i`;`f`;`g`;`countVertices g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  (DISCH_TAC)

    INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      CONJ_TAC;
        BY(ASM_MESON_TAC[marked_list]);
      MATCH_MP_TAC Tame_list.quotient_all_uniq;
      BY(ASM_MESON_TAC[]);
  st/r

    typ `core L r = FST f` sat
          MATCH_MP_TAC minimalFace_core;
      GEXISTL_TAC [`N`;`x`;`g`;`fs`;`v`];
      BY(ASM_REWRITE_TAC[]);

  comment "setK6"
  typ `iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) = newVs /\ prev_el (core L (rtrans L N r x i)) v,v = x ` sat
  fxast `assumption_setK6` mp then rt[assumption_setK6]
  abbrev `vs  = dest_triple_full (core L r) v uvns` 
  dthen (C intro [`L`;`N`;`r`;`x`;`transform_count L N r x`;`uvns`;`vs`;`MAP the (filter isSome vs)`;`fx`;`v`])
  art[]
  asimp[]


  comment "splitFace formula"
  typ `SND (splitFace g' (FST (ytrans L N r x i)) (FST (ztrans L N r x i)) f' newVs) = (fi,gi)` sat
  intro nfgtrans_suc [`i`;`countVertices g`;`f`;`g`;`L`;`N`;`r`;`x`]
  art[]
  LET_TAC
  art[subdiv_triple_step_paired;LET_THM;LAMBDA_TRIPLE]
  dthen (mp o orr[PAIR_EQ2])
  art[]
  art[Tame_defs.upt;arith `(i + j) - i = j:num`]
  simp[]  

  comment "QUOT"
  intro fgraph_quotient_list_transform [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`;`f'`;`gi`;`fx`;`newVs`;`v`]
  art[sym trans_add;arith `0 + i = i /\ 1 + i = SUC i`]
  simp[]
  dt

  comment "CORE"
  intro core_rtrans [`g'`;`(FST (ytrans L N r x i))`;`(FST (ztrans L N r x i))`;`f'`;`newVs`;`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`]
  art[sym trans_add]
  art[LET_THM;LAMBDA_TRIPLE]
  art[arith `1 + i = SUC i`]
    INTRO_TAC AQIUNPP [`L`;`N`;`r`;`x`;`SUC i`];
  art[]
  dt
  subants
    amt[marked_list_uniq_quotient]
  simp[]
  st/r

  comment "COUNT"
  intro Reduction2.sizel_faceListAt_splitFace [`g'`;`gi`;`f'`;`newVs`;`(ytrans L N r x i)`;`(ztrans L N r x i)`]
  asimp[]
  dt

  comment "VSET"
  intro Reduction2.splitFace_good_vertices_set2 [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`ntrans L N r x (SUC i)`;`gi`;`g'`;`(FST (ytrans L N r x i))`;`(FST (ztrans L N r x i))`;`f'`;`newVs`]
  asimp[sym trans_add]
    TYPIFY`l'y L (rtrans L N r x i) x = ytrans L (ntrans L N r x i) (rtrans L N r x i) x 0` sat
    BY(REWRITE_TAC[trans0]);
  art[arith `1 + i = SUC i`;sym trans0;sym trans_add;arith `0 + i = i`]
  typ `r_rtrans_eq L (ntrans L N r x i) (rtrans L N r x i) x` sat
        BY(ASM_MESON_TAC [r_trans_eq_assumption]);
  art[]
  subants
  fexp "newVs"
  rt[lower_case;Seq.size_map]
  simp[]
  st/r

  comment "GOOD"
    intro good_faces_transform_lemma [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`;`gi`;`newVs`;`v`;`f'`]
  art[sym trans_add;arith `1 + i = SUC i`;arith `0+i = i`]
  simp[]
  dt

    comment "B_NFGTRANS"
    typ `b_nfgtrans0 f g L N r x (SUC i) = ((SOME (FST (ztrans L N r x (PRE (SUC i)))),0),(fi,gi))` ets
  dthen (mp o orr[PAIR_EQ2])
  simp[]
  (* now just the b_nfgtrans0 conclusions *)

xxd
  ]);;
  (* }}} *)

Reduction2.splitFace_good_vertices_set2;;
trans_add;;

b_nfgtrans_suc:

iota (sizel (undup (MAP FST (flatten (ntrans L N r x i)))))
      (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) =
      newVs /\
MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i)) = newVs /\
i < transform_count L N r x /\
0 < i
      ==> FST (b_nfgtrans0 f g L N r x i) =
          SOME (FST (ztrans L N r x (PRE i))),0 /\
SND (b_nfgtrans0 f g L N r x i) = f',g' /\
SND
      (splitFace g' (FST (ytrans L N r x i)) (FST (ztrans L N r x i)) f'
      newVs) =
      fi,gi /\

SND (nfgtrans' (countVertices g,f,g) L N r x i) = f',g' 

SND (nfgtrans' (countVertices g,f,g) L N r x (SUC i)) = fi,gi /\

==> b_nfgtrans0 f g L N r x (SUC i) =
 (SOME (FST (ztrans L N r x (PRE (SUC i)))),0),fi,gi



(* MORE DEFS *)

let prebatch = new_definition' 
  `!f0 L N r (x:A#A) i.
         prebatch f0 L N r x i =
         (foldl (dest_triple0_step f0) [] (take i (core_triple_v4 L N r x)))`;;

let dest_triple0_rcons = new_definition'
  `dest_triple0_rcons f s ((u:A),v,n) =
    (let ns = nseq n NONE in
       if (flatten s = []) then (flatten[[SOME u];ns;[SOME v]])
       else 
	 (let u0 = the (LAST (LAST s)) in
	  let b = MAP SOME (betwn f u0 u) in
	    if (u0 = u) then (flatten[ns;[SOME v]])
	    else if (next_el f u0 = u) then (flatten[[SOME u];ns;[SOME v]])
	    else (flatten[b;[SOME u];ns;[SOME v]])))`;;


(* END DEFS *)

let prebatch_batch = prove_by_refinement(
  `!f0 L N r x i. flatten (prebatch f0 L N r x i) = batch0 f0 L N r x i`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[prebatch;batch])
  ]);;
  (* }}} *)

let prebatch0 = prove_by_refinement(
  `!f0 L N r x.
    prebatch f0 L N r x 0 = []`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[prebatch;Seq.foldl;dest_triple0_step;Seq.take])
  ]);;
  (* }}} *)

let prebatch_suc = prove_by_refinement(
  `!f L N r x i.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    ~final_list L r /\
     i < transform_count L N r x 
    ==>
    prebatch f L N r x (SUC i) = dest_triple0_step f (prebatch f L N r x i)
	(FST (ytrans L N r x i),
	 FST (ztrans L N r x i),
	 sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[prebatch];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC take_el;
  ASM_SIMP_TAC[size_core_triple];
  REWRITE_TAC[foldl_rcons];
  REWRITE_TAC[GSYM prebatch];
  GMATCH_SIMP_TAC el_core_triple;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let dest_triple0_rcons_paired = prove_by_refinement(
  `!f s p. dest_triple0_rcons f s p = 
    (let ns = nseq (SND(SND p)) NONE in
       if (flatten s = []) then (flatten[[SOME (FST p)];ns;[SOME (FST (SND p))]])
       else 
	 (let u0 = the (LAST (LAST s)) in
	  let b = MAP SOME (betwn f u0 (FST p)) in
	    if (u0 = (FST p)) then (flatten[ns;[SOME (FST (SND p))]])
	    else if (next_el f u0 = (FST p)) then (flatten[[SOME (FST p)];ns;[SOME (FST (SND p))]])
	    else (flatten[b;[SOME (FST p)];ns;[SOME (FST (SND p))]])))`,
  (* {{{ proof *)
  [
  GEN_TAC THEN GEN_TAC;
  BY(REWRITE_TAC[FORALL_PAIR_THM;dest_triple0_rcons])
  ]);;
  (* }}} *)

let dest_triple0_step_rcons = prove_by_refinement(
  `!f s (u:A) v n. (flatten s = [] ==> s = []) ==>
    dest_triple0_step f s (u,v,n) = rcons s (dest_triple0_rcons f s (u,v,n))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[dest_triple0_step];
  REPEAT LET_TAC;
  REWRITE_TAC[dest_triple0_rcons;LET_THM];
  COND_CASES_TAC THEN ASM_SIMP_TAC[Seq.rcons];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple0_step_rcons_paired = prove_by_refinement(
  `!f s p. (flatten s = [] ==> s = []) ==>
    dest_triple0_step f s p = rcons s (dest_triple0_rcons f s p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[dest_triple0_step_paired];
  REPEAT LET_TAC;
  REWRITE_TAC[dest_triple0_rcons_paired;LET_THM];
  COND_CASES_TAC THEN ASM_SIMP_TAC[Seq.rcons];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let b_nfgtrans_suc = prove_by_refinement(
  `!i f g L N r x.
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
     i < transform_count L N r x /\
   (batch0 (FST f) L N r x i = [] ==> prebatch (FST f) L N r x i = [])
==>
    (b_nfgtrans0 f g L N r x (SUC i) = foldl subdiv_single_step (b_nfgtrans0 f g L N r x i)
 (dest_triple0_rcons (FST f) (prebatch (FST f) L N r x i)
 (FST (ytrans L N r x i),
  FST (ztrans L N r x i),
  sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `bb = b_nfgtrans0 f g L N r x i`;
  ASM_REWRITE_TAC[b_nfgtrans;GSYM prebatch_batch];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  GMATCH_SIMP_TAC prebatch_suc;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC dest_triple0_step_rcons_paired;
  REWRITE_TAC[GSYM Seq.cats1;Seq.flatten_cat];
  ASM_REWRITE_TAC[Seq.foldl_cat;prebatch_batch];
  TYPIFY `(foldl subdiv_single_step ((fst_u0,0),f,g) (batch0 (FST f) L N r x i)) = b_nfgtrans0 f g L N r x i` (C SUBGOAL_THEN SUBST1_TAC);
    ASM_REWRITE_TAC[b_nfgtrans;LET_THM];
    ASM_REWRITE_TAC[Aq1.flatten_sing];
    FULL_EXPAND_TAC "bb";
    REWRITE_TAC[b_nfgtrans];
    BY(ASM_REWRITE_TAC[LET_THM]);
  BY(ASM_REWRITE_TAC[Aq1.flatten_sing])
  ]);;
  (* }}} *)

let prebatch1 = prove_by_refinement(
  `!f L N r x.
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
     0 < transform_count L N r x ==>
   (prebatch (FST f) L N r x 1 = [cat [SOME (FST (ytrans L N r x 0))]
  (cat
   (nseq
    (sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))
   NONE)
  [SOME (FST (ztrans L N r x 0))])])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[prebatch];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC take1;
  ASM_SIMP_TAC[core_triple_nonnil];
  REWRITE_TAC[Seq.foldl;GSYM EL];
  GMATCH_SIMP_TAC el_core_triple;
  ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[dest_triple0_step;Seq.flatten0;LET_THM;Aq1.flatten_sing;Seq.flatten_cons])
  ]);;
  (* }}} *)

let prebatch_suc_explicit = prove_by_refinement(
  `!i f L N r x.
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
   uniq (FST f) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f)) /\
    0 < i /\
     i < transform_count L N r x ==>
   (prebatch (FST f) L N r x (SUC i) = 
       cat (prebatch (FST f) L N r x i) [(
      cat (if FST (ztrans L N r x (PRE i)) = FST (ytrans L N r x i) then []
	   else (cat (MAP SOME (betwn (FST f) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i))))
	([SOME (FST (ytrans L N r x i))])))
  (cat
   (nseq
    (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))
   NONE)
  [SOME (FST (ztrans L N r x i))]))])`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[arith `~(0 < 0)`;arith `0 < SUC i`];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `j = SUC i`;
  GMATCH_SIMP_TAC prebatch_suc;
  ASM_REWRITE_TAC[];
  TYPIFY `i=0` ASM_CASES_TAC;
    FULL_EXPAND_TAC "j";
    ASM_SIMP_TAC[arith `SUC 0 = 1`];
    INTRO_TAC prebatch1 [`f`;`L`;`N`;`r`;`x`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      BY(REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    SIMP_TAC[];
    DISCH_THEN kill;
    GMATCH_SIMP_TAC dest_triple0_step_rcons;
    CONJ_TAC;
      BY(REWRITE_TAC[Seq.flatten_cons;cat_eq_nil;NOT_CONS_NIL]);
    REWRITE_TAC[dest_triple0_rcons;LAST;arith `PRE 1 = 0`;Seq.flatten_cons;cat_eq_nil;NOT_CONS_NIL];
    REWRITE_TAC[Seq.flatten0;Seq.cats0;Seq.catA;Seq.cats1;LAST_rcons;the_some];
    REWRITE_TAC[LET_THM];
    AP_TERM_TAC;
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat0s];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC Tame_list.betwn_nil [`FST f`;`(FST (ztrans L N r x 0))`;`FST (ytrans L N r x 1)`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[arith `1 < k ==> 0  < k`; arith `SUC 0 = 1`]);
    BY(SIMP_TAC[MAP;Seq.rcons]);
  COMMENT "i pos";
  GMATCH_SIMP_TAC dest_triple0_step_rcons;
  FIRST_X_ASSUM_ST `SOME` (C INTRO_TAC [`f`;`L`;`N`;`r`;`x`]);
  ANTS_TAC;
    ASM_SIMP_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[Seq.flatten_cons;cat_eq_nil;NOT_CONS_NIL;Seq.flatten_cat]);
  REWRITE_TAC[Seq.cats1];
  AP_TERM_TAC;
  TYPIFY `~(flatten (prebatch (FST f) L N r x j) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.flatten_cons;cat_eq_nil;NOT_CONS_NIL;Seq.flatten_cat]);
  TYPIFY `the (LAST (LAST (prebatch (FST f) L N r x j))) = FST (ztrans L N r x i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.flatten_cons;cat_eq_nil;Seq.catA;Seq.cats1;LAST_rcons;the_some]);
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN POP_ASSUM kill;
  ASM_SIMP_TAC[dest_triple0_rcons_paired];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[arith `SUC i = j /\ ~(i=0) ==> PRE j = i`];
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat0s;Seq.flatten_cons;Seq.cats1;Seq.flatten0;Seq.cats0];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC Tame_list.betwn_nil [`FST f`;`(FST (ztrans L N r x i))`;`FST (ytrans L N r x j)`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[arith `SUC i = j /\ j < k ==> i < k`]);
    BY(ASM_SIMP_TAC[MAP;Seq.rcons]);
  BY(ASM_REWRITE_TAC[Seq.cat0s;Seq.flatten_cons;Seq.catA;GSYM Seq.cats1;Seq.flatten0;Seq.cats0])
  ]);;
  (* }}} *)

let batch_nonnil = prove_by_refinement(
  `!i f L N r x.
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
   uniq (FST f) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f)) /\
    0 < i /\
     i < transform_count L N r x 
 ==>    ~(batch0 (FST f) L N r x i = [])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = 0` ASM_CASES_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `i=1` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `batch0` MP_TAC THEN ASM_REWRITE_TAC[GSYM prebatch_batch];
    REPEAT ( GMATCH_SIMP_TAC prebatch1);
    ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;cat_eq_nil];
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `batch0` MP_TAC THEN ASM_REWRITE_TAC[GSYM prebatch_batch];
  INTRO_TAC num_CASES [`i`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  REPEAT ( GMATCH_SIMP_TAC prebatch_suc_explicit);
  ASM_REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;cat_eq_nil;Seq.flatten_cat];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let batch_nil_prebatch_nil = prove_by_refinement(
  `!i f L N r x.
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
   uniq (FST f) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f)) /\
     i < transform_count L N r x 
 ==>    (batch0 (FST f) L N r x i = [] ==> prebatch (FST f) L N r x i = [])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = 0` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[prebatch0]);
  INTRO_TAC batch_nonnil [`i`;`f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let the_last_last_prebatch = prove_by_refinement(
  `!i f L N r x.
         good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
    uniq (FST f) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f)) /\
    0 < i /\
    i < transform_count L N r x ==>
    the (LAST (LAST (prebatch (FST f) L N r x i))) = FST (ztrans L N r x (PRE i))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i=1` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC prebatch1;
    ASM_REWRITE_TAC[LAST_CLAUSES;Seq.catA;LAST_rcons;Seq.cats1;the_some;arith `PRE 1 = 0`];
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC num_CASES [`i`];
  ASM_SIMP_TAC[arith `0 < i ==> ~(i=0)`];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC prebatch_suc_explicit;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[LAST_CLAUSES;Seq.catA;LAST_rcons;Seq.cats1;the_some;arith `PRE (SUC n) = n`];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let upt_iota_simple = prove_by_refinement(
  `!a b. upt a (a + b) = iota a b`,
  (* {{{ proof *)
  [
BY(REWRITE_TAC[Tame_defs.upt;arith `(a + b) - a = b:num`])
  ]);;
  (* }}} *)


let b_nfgtrans_induction = prove_by_refinement(
  `!i L N r x f g newVs f' g'. 
     good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_restricted (hypermap_of_list L) /\
    uniq (FST f) /\
    uniq (FST f') /\
    ~(next_el (FST f') (FST (ytrans L N r x i)) = FST (ztrans L N r x i) /\
     sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)) = 0) /\
    ((betwn (FST f) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i))) = 
    (betwn (FST f') (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)))) /\
    (next_el (FST f') (FST (ztrans L N r x (PRE i))) =
      FST (ytrans L N r x i) <=>
	next_el (FST f) (FST (ztrans L N r x (PRE i))) =
      FST (ytrans L N r x i)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f)) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (FST f')) /\
    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (FST f')) /\
    0 < i /\
//    MEM (FST (ytrans L N r x i)) (FST f') /\
//    MEM (FST (ztrans L N r x (PRE i))) (FST f') /\
    i < transform_count L N r x /\
    iota (countVertices g')
      (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) = newVs /\
    b_nfgtrans0 f g L N r x i = ((SOME (FST (ztrans L N r x (PRE i))),0),f',g') ==>
    b_nfgtrans0 f g L N r x (SUC i) = 
	((SOME (FST (ztrans L N r x (PRE (SUC i)))),0),
	 SND(splitFace g' (FST (ytrans L N r x i)) (FST (ztrans L N r x i)) f'
      newVs))
	 `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC b_nfgtrans_suc;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    MATCH_MP_TAC batch_nil_prebatch_nil;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[dest_triple0_rcons_paired];
  REWRITE_TAC[LET_THM;prebatch_batch];
  INTRO_TAC batch_nonnil [`i`;`f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  INTRO_TAC the_last_last_prebatch [`i`;`f`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[arith `PRE (SUC i) = i`];
  TYPED_ABBREV_TAC `n = (sizel             (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`;
  COMMENT "first case";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.flatten_cons;Seq.catA;Seq.flatten0;Seq.cats0;];
    REWRITE_TAC[Seq.foldl_cat];
    REWRITE_TAC[subdiv_single_step_nseg;Seq.foldl;arith `n+0=n`];
    ASM_REWRITE_TAC[subdiv_single_step;not_some_none;the_some];
    REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
    BY(ASM_SIMP_TAC[Tame_list.nextVertex_next_el;upt_iota_simple]);
  REWRITE_TAC[PAIR_EQ];
  COMMENT "second case";
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.flatten_cons;Seq.catA;Seq.flatten0;Seq.cats0;];
    REWRITE_TAC[Seq.foldl_cat;Seq.foldl];
    ASM_REWRITE_TAC[subdiv_single_step;not_some_none;the_some;];
    REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
    GMATCH_SIMP_TAC nextVertex_next_el;
    ASM_SIMP_TAC[arith `i < k ==> PRE i < k`];
    ASM_REWRITE_TAC[subdiv_single_step_nseg;not_some_none;the_some;arith `n+0=n`];
    ASM_REWRITE_TAC[subdiv_single_step;not_some_none;the_some];
    REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
    BY(ASM_SIMP_TAC[Tame_list.nextVertex_next_el;upt_iota_simple]);
  COMMENT "final case";
  REWRITE_TAC[Seq.flatten_cons;Seq.catA;Seq.flatten0;Seq.cats0;];
  ASM_REWRITE_TAC[Seq.foldl_cat;Seq.foldl];
  GMATCH_SIMP_TAC subdiv_single_step_betwn;
  CONJ_TAC;
    GEXISTL_TAC [`betwn (FST f') (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i))`];
    BY(ASM_SIMP_TAC[arith `i < k ==> PRE i < k`]);
  ASM_REWRITE_TAC[subdiv_single_step;not_some_none;the_some;];
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  GMATCH_SIMP_TAC nextVertex_next_el;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_prev_el;
    BY(ASM_SIMP_TAC[]);
  DISCH_TAC;
  TYPIFY `next_el (FST f') (prev_el (FST f') (FST (ytrans L N r x i))) =      FST (ytrans L N r x i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_SIMP_TAC[Seq2.next_prev_id]);
  REWRITE_TAC[];
  ASM_REWRITE_TAC[subdiv_single_step_nseg;not_some_none;the_some;arith `n+0=n`];
  ASM_REWRITE_TAC[subdiv_single_step;not_some_none;the_some];
  REWRITE_TAC[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE];
  BY(ASM_SIMP_TAC[Tame_list.nextVertex_next_el;upt_iota_simple])
  ]);;
  (* }}} *)

