needs "Multivariate/convex.ml";;
flyspeck_needs "local/polar_fan.hl";;
flyspeck_needs "local/local_lemmas1.hl";;
flyspeck_needs "general/flyspeck_lib.hl";;
flyspeck_needs "nonlinear/ineq.hl";;
flyspeck_needs "nonlinear/calc_derivative.hl";;
flyspeck_needs "nonlinear/merge_ineq.hl";;
flyspeck_needs "general/flyspeck_lib.hl";;
flyspeck_needs "../glpk/glpk_link.ml";;
flyspeck_needs "../glpk/minorlp/OXLZLEZ.ml";;
flyspeck_needs "local/VPWSHTO.hl";;
flyspeck_needs "local/LFJCIXP.hl";;
flyspeck_needs "local/PCRTTID.hl";;
flyspeck_needs "local/deformation.hl";;
flyspeck_needs "local/NKEZBFC.hl";;
flyspeck_needs "fan/GMLWKPK.hl";;
flyspeck_needs "nonlinear/post.hl";;
flyspeck_needs "jordan/flyspeck_constants.hl";;

flyspeck_needs "usr/thales/hales_tactic.hl";;
flyspeck_needs "packing/counting_spheres.hl";;
Counting_spheres.GOTCJAH;;
flyspeck_needs "../jHOLLight/caml/sections.hl";;
flyspeck_needs "../jHOLLight/caml/ssreflect.hl";;
flyspeck_needs "tame/ssreflect/seq2-compiled.hl";;
rflyspeck_needs "tame/ssreflect/sort-compiled.hl";;
flyspeck_needs "tame/ssreflect/FNJLBXS-compiled.hl";;
flyspeck_needs "nonlinear/merge_ineq.hl";;
hollight_dir;;
load_path;;

Merge_ineq.TSKAJXY_DERIVED4;;


   load_path:= 
     let dir = (Sys.getenv "FLYSPECK_DIR") in
     let jdir = Filename.concat dir "../jHOLLight" in
      jdir::dir::(!load_path);;
!load_path;;

type_of `x:A+B`;;
searcht 5 [`x:A+B`];;
Pcrttid.PCRTTID;;
type_of `1`;;
Local_lemmas1.EJRCFJD;;
`1`;;


flyspeck_needs "nonlinear/functional_equation.hl";;
type_of `transitive`;;
searcht 5 [def "transitive"];;
open Hales_tactic;;
open Merge_ineq;;
let CALC_ID_TAC = Calc_derivative.CALC_ID_TAC;;
let positive = new_definition `positive y = (y > &0)`;;
module Test = struct
  open Sphere;;
  open Ineq;;
end;;

let ztg23_concl = 
  all_forall `ineq
    [(&2 * hminus,y1,&2 * hplus);
     (&2,y2,sqrt8);
     (&2,y3,sqrt8);
     (&0,az4,&2 * pi);
     (&2,y5,sqrt8);
     (&2,y6,sqrt8)]
    ((dih_y y1 y2 sqrt2 sqrt2 sqrt2 y6 +
       dih_y y1 sqrt2 y3 sqrt2 y5 sqrt2 <= az4 /\
       dih_y y1 y2 y3 (&2) y5 y6 <= az4 /\
    &0 <  delta_y y1 y2 sqrt2 sqrt2 sqrt2 y6 /\
    &0 <  delta_y y1 sqrt2 y3 sqrt2 y5 sqrt2) ==>
    (truncate_gamma23a_x (&(wtcount3_y y1 y2 y6)) (&(wtcount3_y y1 y3 y5))
       (h0cut y1) (h0cut y2) (h0cut y3) (h0cut y5) (h0cut y6)
       (y1*y1) (y2*y2) (y3*y3) az4 (y5*y5) (y6*y6)
     >
    a_spine5 + b_spine5 * az4))`;;

let ztg23_hyp = 
  let ztgs = 
    ["ZTGIJCF23v2 0 0 0 7907792228 b";
   "ZTGIJCF23v2 0 0 0 7907792228 b2";
   "ZTGIJCF23v2 0 0 0 7907792228 c2"; 
   "ZTGIJCF23v2 0 0 0 7907792228 c3"; 
   "ZTGIJCF23v2 0 0 0 7907792228 d";
   "ZTGIJCF23v2 0 0 1 7907792228 b"; "ZTGIJCF23v2 0 0 1 7907792228 b2";
   "ZTGIJCF23v2 0 0 1 7907792228 c"; "ZTGIJCF23v2 0 0 1 7907792228 d";
   "ZTGIJCF23v2 0 1 0 7907792228 c2"; 
   "ZTGIJCF23v2 0 1 0 7907792228 c3"; 
   "ZTGIJCF23v2 0 1 1 7907792228 b";
   "ZTGIJCF23v2 0 1 1 7907792228 b2"; "ZTGIJCF23v2 0 1 1 7907792228 c";
   "ZTGIJCF23v2 0 1 1 7907792228 d"; "ZTGIJCF23v2 1 0 1 7907792228 b";
   "ZTGIJCF23v2 1 0 1 7907792228 b2"; "ZTGIJCF23v2 1 0 1 7907792228 c";
   "ZTGIJCF23v2 1 0 1 7907792228 d"] in
  let ztg_nonlinear = map (fun t -> (hd(Ineq.getexact t)).ineq) ztgs in
    end_itlist (curry mk_conj) ztg_nonlinear;;

let ztg23_concl' = 
    mk_imp(ztg23_hyp,ztg23_concl);;





(* minor lp. Major work in development lemmas *)

Oxlzlez_informal.execute();;
Oxlzlez_informal.backup;;
let bak = !Oxlzlez_informal.backup;;
let valuex i = (fun bf -> bf.Oxlzlez_informal.lpvalue) (List.nth bak i);;
map valuex (50--70);;							  
map (fun bf -> bf.Oxlzlez_informal.lpvalue) (!Oxlzlez_informal.backup);;
List.length (snd chop_list 30 !Oxlzlez_informal.backup;; (* 85 cases *)

let strip_id s =
  let ss = Str.split (Str.regexp "[],[]") s in
    (hd ss,map int_of_string (tl ss));;

strip_id "abc[0,1,2,3]";;

0.0659/. 0.042;;

let ox_model = 
  `
    // ampl model sets
    (2 <= n /\ n <= 4 /\ (f = (0..(n-1))) /\ 
   (bl = IMAGE (\i. (i,((i+1) MOD n))) f) /\ 
   (sblade SUBSET bl) /\ (nonsblade SUBSET bl) /\ 
   (sblade INTER nonsblade= {}) /\
   (f = qu UNION qx UNION qy) /\
   (qu INTER qx = {}) /\ (qu INTER qy = {}) /\ (qx INTER qy = {}) /\
   (qx = qxd UNION nonqxd /\ qxd INTER nonqxd = {}) /\
   (qu = negqu UNION posqu /\ negqu INTER posqu = {}) /\
   (shorty4 UNION longy4 = qy /\ shorty4 INTER longy4 = {})
   (halfwt INTER fullwt = {}) /\ .... /\  `;;
   (* ampl model variables. *)

let oxlzlez_model = 
`{ (n,(face,eface,blade,sblade,nonsblade,qu,qx,qy,qxd,nonqxd,negqu,posqu,
    halfwt,fullwt,shorty4,longy4),
    (az,gammasum,gamma,gamma3a,gamma3b,gamma2,y1,y2,y3,y4,y5,y6)) |
       (n=0 \/ n IN negqu) /\
       qu SUBSET hassmall /\
	 face = qu UNION qx UNION qy /\
    qu INTER qx = {} /\
    qu INTER qy = {} /\
    qx INTER qy = {} /\
    ...
   (!i. (i IN face) ==> (&0 <= azim i /\ azim i <= &2 * pi)) /\
     (!i. (i IN face) ==> (lb <= gamma i /\ gamma i <= #0.1)) /\
     (!i. (i IN etc.)`;;
(*

let gammaX4 = prove_by_refinement(
  `!V X v0 v1 v2 v3 v4.
  let y01 = dist(v0,v1) in
  let y02 = dist(v0,v2) in
  let y03 = dist(v0,v3) in
  let y12 = dist(v1,v2) in
  let y13 = dist(v1 v3) in
  let y23 = dist(v2,v3) in
    (
   packing V /\ ({v1,v2,v3,v4} SUBSET V) /\ 
    ==>
    gammaX V X = gamma4f y01 y02 y03 y23 y13 y12)`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)
*)

let dihX2 = prove_by_refinement(
  `!V X v0 v1.
  let y = dist(v0,v1) in
    (packing V /\ saturated V /\ mcell_set V X /\ 
       ((2,[v0;v1])= cell_params_d V X [v0;v1]) ==>
     dihX V X (v0,v1) =   `,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)

let domain6 soh h f g = 
  let (v,body) = strip_abs h in
  let vs = map (fst o dest_var) v in
  let vars = Flyspeck_lib.join_space vs in
  let bodys = soh body in
  let fs = fst(dest_const f) in
  let gs = soh g in
    (Printf.sprintf 
    "let %s %s = \n  let _ = ( %s ) or failwith \"domain6:%s\" in \n
      ( %s ) %s;;" fs vars bodys fs gs vars);;

module Temp =  struct
  open Sphere;;
  open Ineq;;
add
{
  idv="2485876245b";
  doc="Used in some quad calculations to show that a node
   is not straight (both halves are acute)";
  tags=[Flypaper[];Main_estimate;Cfsqp;Xconvert;Tex];
  ineq = all_forall `ineq [
    (&2,y1,#2.52);
    (&2,y2,#2.52);
    (&2,y3,#2.52);
    (&2,y4,#2.52);
    (#3.01,y5, &2 * #2.52);
      (&2,y6,#3.01)
  ]
((delta4_y y1 y2 y3 y4 y5 y6 > &0) \/ (delta_y y1 y2 y3 y4 y5 y6 < &0))`;
};;
end;;

let ztg4s = map (fun t -> t.idv) (Ineq.getprefix "ZTGIJCF4");;
cfsqp ztg4s;;

module Test = struct
  open Ineq;;
  open Sphere;;
add
{
  idv = "test QITNPEA 3848804089";
  ineq = all_forall `ineq
   [(&2 * hminus,y1, &2 * hplus);
    (&2,y2, &2 * hminus);
    (&2,y3, &2 * hminus);
    (#2 ,y4, &2 * hminus);
    (&2,y5, &2 * hminus);
    (&2,y6, &2 * hminus)
   ]
    ((gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun - #0.164017 + #0.119482* dih_y y1 y2 y3 y4 y5 y6 > #0.0) \/  (eta_y y1 y2 y6 pow 2 < #1.34 pow 2 )) `;
  doc =   "
     This is an inequality for quarters used to prove the cluster inequality.";
  tags=[Marchal;Cfsqp;Clusterlp;Flypaper["OXLZLEZ"];Tex;Xconvert;Branching;Split[0]];
};;
add
{
  idv = "MMGKNVE";
  ineq = all_forall `ineq
   [(&2 * hminus,y1, &2 * hplus);
    (&2,y2, &2 * hminus);
    (&2,y3, &2 * hminus);
    (&2,y4, &2 * hminus);
    (&2,y5, &2 * hminus);
    (&2,y6, &2 * hminus)
   ]
    ((gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun + #0.0539 
      - #0.042*dih_y y1 y2 y3 y4 y5 y6 > #0.0) \/
    (eta_y y1 y2 y6 pow 2 < #1.34 pow 2 ))`;
  doc =   "
     This is an inequality for quarters used to prove the cluster inequality.";
  tags=[Marchal;Cfsqp;Flypaper["OXLZLEZ"];Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;
add
{
  idv = "test BIXPCGW 9455898160";
  ineq = all_forall `ineq
   [(&2 * hminus, y1, #2.6);
    (&2,y2, &2 * hminus);
    (&2,y3, &2 * hminus);
    (&2,y4, &2 * hminus);
    (&2,y5, &2 * hminus);
    (&2,y6, &2 * hminus)
   ]
   (
    gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun > &0) `;
  doc =   "
     If $X$ is a quarter, then $\\gamma(X,L)\\ge -0.00569$.";
  tags=[Marchal;Flypaper["OXLZLEZ";];Cfsqp;Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;
add
{
  idv = "test ratio2";
  ineq = all_forall `ineq
   [(&2 * hminus, y4, &2 * hplus);
    (&2  ,y5, sqrt8);
    (&2 ,y6, sqrt8)
   ]
   ( truncate_gamma3f_x (#0.001) (h0cut y4) (h0cut y5) (h0cut y6) (&2) (&2) (&2) (y4*y4) (y5*y5) (y6*y6) /
       (&1* dih_y y4 y5 sqrt2 sqrt2 sqrt2 y6) > &0 \/
       eta_y y4 y5 y6 > sqrt2 - #0.001 
     \/
     eta_y y4 y5 y6 < #1.34 
   )`;
  doc =   "test";
  tags=[Marchal;Flypaper["OXLZLEZ";];Cfsqp;Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;
add
{
  idv = "test gamma23";
  ineq = all_forall `ineq
   [(&2 * hminus, y1, &2 * hplus);
    (&2,y2, &2 * hminus);
    (&2,y3, &2 * hminus);
    (&2,y4, sqrt8);
    (&2,y5, &2 * hminus);
    (&2,y6, &2 * hminus)
   ]
   (
y_of_x (truncate_gamma3f_x #0.0 (h0cut y1) (&1) (&1)) (&0) (&0) (&0) y1 y2 y6  +
y_of_x (truncate_gamma3f_x #0.0 (h0cut y1) (&1) (&1)) (&0) (&0) (&0) y1 y3 y5  +
     (dih_y y1 y2 y3 y4 y5 y6 - 
      (dih_y y1 y2 sqrt2 sqrt2 sqrt2 y6 +
       dih_y y1 sqrt2 y3 sqrt2 y5 sqrt2)) * #0.008  > &0 \/
     rad2_y y1 y2 y3 y4 y5 y6 < &2 \/
     eta_y y1 y2 y6 > #1.34 \/
     eta_y y1 y3 y5 > #1.34 \/
    dih_y y1 y2 y3 y4 y5 y6 < #1.946 \/
    dih_y y1 y2 y3 y4 y5 y6 > #2.089)`;
  doc =   "test";
  tags=[Marchal;Flypaper["OXLZLEZ";];Cfsqp;Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;
add
{
  idv = "test gamma23bis";
  ineq = all_forall `ineq
   [(&2 * hminus, y1, &2 * hplus);
    (&2,y2, sqrt8);
    (&2,y3, &2 * hminus);
    (&2,y4, sqrt8);
    (&2,y5, &2 * hminus);
    (&2,y6, sqrt8)
   ]
   (
y_of_x (truncate_gamma3f_x #0.0 (h0cut y1) (&1) (&1)) (&0) (&0) (&0) y1 y3 y5  +
     (dih_y y1 y2 y3 y4 y5 y6 - 
       dih_y y1 sqrt2 y3 sqrt2 y5 sqrt2) * #0.008  > a_spine5 +
     b_spine5 * dih_y y1 y2 y3 y4 y5 y6 \/
     rad2_y y1 y2 y3 y4 y5 y6 < &2 \/
     eta_y y1 y2 y6 < #1.34 \/
     eta_y y1 y2 y6 > sqrt2 \/
     eta_y y1 y3 y5 > #1.34 \/
    dih_y y1 y2 y3 y4 y5 y6 > #1.074)`;
  doc =   "test";
  tags=[Marchal;Flypaper["OXLZLEZ";];Cfsqp;Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;
end;;

add
{
  idv = "test";
  ineq = all_forall `ineq
   [(&2 * hminus, y1, &2 * hplus);
    (&2,y2, sqrt8);
    (&2,y3, sqrt8);
    (&2,y4, sqrt8);
    (&2,y5, sqrt8);
    (&2,y6, sqrt8)
   ]
   (
    dih_y y1 y2 y3 y4 y5 y6  > &0 \/
     rad2_y y1 y2 y3 y4 y5 y6 < &2 \/
     eta_y y1 y2 y6 > sqrt2 \/
     eta_y y1 y3 y5 > sqrt2 )`;
  doc =   "test";
  tags=[Marchal;Flypaper["OXLZLEZ";];Cfsqp;Clusterlp;Tex;Xconvert;Branching;Split[0]];
};;


type_of theorems;;
follow;;
textchar;;
augment_search_results ["hi"];;
really_expand "?-0";;
help_grep "";;
help_flag "";;
help "apropos_short_order_script";;
suggest();;
String.sub "abcde" 1 (String.length "abcde" - 1);;
expand_suggest "0";;
hd it;;
List.nth !loaded_files 69;; Reload 1--69 
mk_thm;;
flyspeck_needs "general/lib.hl";;
flyspeck_needs "nonlin/kelvin_lattice.hl";;
flyspeck_needs "usr/thales/init_search.hl";;
reneeds "packing/counting_spheres.hl";;
flyspeck_needs "packing/QZKSYKG.hl";;
flyspeck_needs "packing/DDZUPHJ.hl";;
flyspeck_needs "packing/AJRIPQN.hl";;
flyspeck_needs "packing/QZYZMJC.hl";;
flyspeck_needs "packing/marchal_cells_3.hl";;
flyspeck_needs "packing/GRUTOTI.hl";;
Grutoti.GRUTOTI;;
flyspeck_needs "fan/CFYXFTY.hl";;
flyspeck_needs "packing/counting_spheres.hl";;
open Counting_spheres;;
flyspeck_needs "nonlinear/cleanDeriv.hl";;
flyspeck_needs "nonlinear/cleanDeriv_examples.hl";;
flyspeck_needs "../development/thales/chaff/tmp/vectors_patch.ml";;
flyspeck_needs "../development/thales/chaff/tmp/determinants_patch.ml";;
flyspeck_needs "../development/thales/chaff/tmp/wlog_patch.hl";;
reneeds "trigonometry/trig2.hl";;
update_database();;
augment_search_results;;
!search_results;;
Counting_spheres.ORDER_AZIM_SUM2PI;;

let u11111 = ((GOAL_TERM (fun w -> ALL_TAC)):tactic);;
RDISK_R;;

GOAL_TERM (fun w -> (MP_TAC (ISPECL ( envl w [`p`;`v`;`u0`;`b`]) RCONE_PREP)));;

INST [(`u:bool`,`A:bool`)] (TAUT ` ((A ==> B) /\ A) ==> B`);;

let thh = Collect_geom.EQ_POW2_COND;;
let ta1 = TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`;;
let th2 = REWRITE_RULE[ta1] ( thh);;
let tm1 = snd (strip_forall (concl th2));;
let tm2 = snd (dest_imp tm1);;
let tm3 = fst (dest_eq tm2);;
let force_rewrite th;;



let goalx = `&0 <= sqrt x /\ &0 <= sqrt t ==> &0 <= sqrt u`;;
GMATCH_SIMP_TAC SQRT_POS_LE;;

let (asl,w) = (top_realgoal());;
let thm = SQRT_POS_LE;;
  let thm' = hd (mk_rewrites true thm []);;
  let t1 = fst (dest_eq(snd (dest_imp(concl(thm'))))) ;;
  let matcher u t = 
    let m = term_match [] t1 t in
    let _ = subset (frees t) (frees u) or failwith "" in
      m ;;
  let wsub u = find_term (can (matcher u)) u ;;
  let w' = wsub w ;;
  let vv = 
    let var1 = mk_var("v",type_of w') in
      variant (frees w) var1 ;;
  let athm = REWRITE_CONV[ ASSUME (mk_eq (w',vv))] w ;;
  let arhs = rhs (concl athm) ;;
  let bthm = (ISPECL [mk_abs(vv,arhs);w'] BETA_THM) ;;
  let betx = SYM(TRANS bthm (BETA_CONV (rhs (concl bthm)))) ;;
   ONCE_REWRITE_TAC[betx]
  MATCH_MP_TAC (lift_eq thm')
     BETA_TAC
 THEN BETA_TAC);;
rt[]


let lift_SQRT_POS_LE = GEN_ALL (MATCH_MP lift_imp (SPEC_ALL SQRT_POS_LE));;

add_rewrite_tag("mycase ",th);;
let xxx n = add_rewrite_stag (List.nth search_result_dump_march7_8am n);;
xxx 0;;
assoc (List.nth search_result_dump_march7_8am 0) !theorems;;

!rewrite_tags;;
let th = ASSUME (`!p q r. p ==> q ==> (cos r = s) /\ (u ==> sin y > &1)`);;

let gexp = `!t. (cos x + sqrt (t pow 2) > &0)`;;
let hexp = `!x. (cos x + sqrt (t pow 2) > &0)`;;


mk_rewrites;;


let matcherx u t = 
  let m = term_match [] t1 t in
  let _ = subset (frees t) (frees u) or failwith "" in
    m;;
let mmat u = find_term (can (matcherx u)) u;;
let mx = mmat hexp;;
let mma1 = term_match [] `sqrt x` (mmat hexp);;
let vv = 
  let var1 = mk_var("v",type_of mx) in
    variant (frees hexp) var1;;
let rrx = REWRITE_CONV[ ASSUME (mk_eq (mx,vv))] hexp;;
let rhsx = rhs (concl rrx);;
let bthx = (ISPECL [mk_abs(vv,rhsx);mx] BETA_THM);;
let betx = SYM(TRANS bthx (BETA_CONV (rhs (concl bthx))));;

term_match [] `sqrt x` mmat;;

st_of  `sin x + cos (asn t)`;;
mk_prover;;
net_of_thm;;
help "term_match";;
help "find_term";;
help "GEN_PART_MATCH";;
help "PART_MATCH";;
help "MATCH_MP";;
`(&0 <= sqrt (t pow 2)) \/ b ==> ~(&0 <= sqrt u)`
mmp lift_SQRT_POS_LE
rt[]
SPEC_ALL (ASSUME `!x. x = x`);;
let lift_SQRT_POS_LE = GEN_ALL (MATCH_MP lift_imp (SPEC_ALL SQRT_POS_LE));;
searcht 5 [`&0 <= sqrt x`];;

eval_command ~silent:true "let x111 = 1+1+4";;
x111;;
eval_command ~silent:false "mark 4";;
mark 4;;
snd it;;
help_grep "match";;
help "term_match";;  
help "PART_MATCH";;
find_term;;
help "find_term";;
List.map hd (split_proof_record [] [] (!proof_record));;
term_match;;
help "term_match";;
searchl;;

retrieve_search;;
thm_counts;;


eval_tactic_lines "st/r\nfxa mpt";;
text_char;;


process_to_string "date";;
gax();;


last (show_gax());;
List.nth (show_gax()) 2;;

Clean_deriv.x1_eta2;;
axioms();;
type_of `( %% )`;;
Qzyzmjc.QZYZMJC;;
search [name "FMSWMVO"];;
search [name "IVFICRK"];;
search [name "volume_props"];;
stm_depth "T";;
(* PROJECT BUILD *)
Hashtbl.hash;;

  (*
  let (d,hd) = data (get_tm_depth w) in
    filter (fun ((d',hd'),_,_) -> (((abs (d-d')< 1+k)  && sorted_meet 0 hd hd' ))) thml;; 
  *)

List.length (ballpark_theorems   (top_realgoal()));;
 (ballpark_theorems   (top_realgoal()));;
abs_of_float;;
int_abs;;
last [0;1;2;3];;
strip_imp `a`;;
strip_imp `a ==> b==> c`;;
help_grep "dest_";;
type_of `==>`;;
strip_comb;;
help_grep "strip";;
is_comb;;
help "strip_exists";;
strip_comb `a ==> b==> c`;;
help_grep "comb";;
help "strip_ncomb";;
help_grep "strip";;


let nearest_thm_to_goal thml (asl,w) = 
  let tt tl = List.flatten (map (tm_depth o concl) tl) in
  let common = tt (map snd asl) in
  let thl = map (fun (s,t) -> ((tm_depth o snd o strip_forall o concl )t,s,t) ) thml in
  let r = map (fun (tl,s,t) -> (tl,s,t,msd 0.0 common (tm_depth w) tl)) thl in
    (sort (fun (_,_,_,a) (_,_,_,b) -> a < b) r);;

let thml_depth_of_goalmatch thml (asl,w) = 
  let tt tl = List.flatten (map (tm_depth o concl) tl) in
  let w'::rest = List.rev strip_imp o  snd o strip_forall w in
  let common = tt ((map snd asl) @ rest) in
  let thl = map (fun (s,t) -> ((tm_depth o snd o strip_forall o concl )t,s,t) ) thml in
  let 
;;



nearest_thm_to_goal (ballpark_theorems (top_realgoal())) (top_realgoal());;
let guess = nearest_thm_to_goal (top_realgoal());;
List.length !theorems;;

top_realgoal;;
help_grep "goal";;
(* *)

tt;;
hd (!theorems);;
tt;;
strip_forall;;
help_grep "strip";;

(* jan 3, 2012 chaff *)



(* USEFUL CONSTRUCTS *)

let report s =
  Format.print_string s; Format.print_newline();;

g `?(x:A) . f A`

(* generalize *)

let ( TYPE_VAR :string -> (term -> tactic) -> tactic) = 
    fun s tm_tactic (asl,g) ->
      let (_,r) = dest_comb g in
      let (v,_) = dest_abs r in
      let (_,ty) = dest_var v in
	tm_tactic (mk_var(s,ty)) (asl,g);;

TYPE_VAR "x" EXISTS_TAC;
;;
Format.print_flush();;
FINITE_EMPTY;;

searcht 10 [`eulerA_hexall_x`];;

Sphere.num_combo1;;

(*
process_to_string "cat qed_log.txt | sed  's/^.*ineq./\"/' | sed 's/., secs.*$/\";/'  "

cat qed_log.txt | sed  's/^.*ineq./"/' | sed 's/., secs.*$/";/' | sort -u | wc  

(*
let _ = Sys.command("cat "^flyspeck_dir^"/../interval_code/qed_log.txt");;
*)
*)


let ee () = 
  let b = (false or (let _ = Sys.command("date") in failwith "h")) in b;;


suggest();;

EXISTSv_TAC "y";

dest_binder "?" (`?(x:A). f A`);;

(*

let searchl = sortlength_thml o search;;
let take = Lib_ext.take;;
let searcht r = take 0 5 (searchl r);;
let searchtake i j r = take i j (searchl r);;

*)
term_match;;
INSTANTIATE;;
  open Searching;;

definitions();;
State_manager.neutralize_state();;
let vv = (eval("1+1")) + 3;;
let vv = (eval("REFL `T`"));;
concl vv;;

prefixes();;
rev(infixes());;
binders();;
unparse_as_infix;;
map (List.nth (infixes())) (95--131);;
unparse_as_binder "!";;
binders();;


find_path ((=) `4`) `(sum (3..4) f)`;;  (* lrr *)

let kill_process n = Sys.command (Printf.sprintf "sudo kill -9 %d" n);;

help_grep "conj";;
help "list_mk_conj";;
 end_itlist;;

FROZEN_REWRITE_TAC [REAL_ARITH `b + d = d - (--b)`];;

let goal_types = Print_types.print_goal_types;;
Print_types.goal_types();;
Print_types.print_term_types `#2`;;
Print_types.print_thm_types (REFL `1`);;



(*
(* parsing printing *)
let pterm = Print_types.print_term_types;;
let tterm = Print_types.print_thm_types;;

#install_printer print_qterm;;


#install_printer Goal_printer.print_goal_hashed;;
#install_printer Goal_printer.print_goalstack_hashed;;

#remove_printer Goal_printer.print_goal_hashed;;
#remove_printer Goal_printer.print_goalstack_hashed;;

#print_length 1000;;
*)

search[`f (x:A) (g (y:A) z) = f (g x y) z`];; (* min, max, + /\, \/ *, compose, monoidal ops,
   APPEND, a - (b + c) = a - b - c /\ a - (b - c) = a - b + c),
    p ==> q ==> r <=> p /\ q ==> r);; *)

find_term  ( can (term_match[ `r a (r y z) = r (r x y) z`])) (concl IMP_IMP);;

filter_pred;;
can (term_match[]);;
type_of;;

constant_of_regexp "at.*[gn]$";;

constant_of_regexp "FILTER";;
searcht 15 [`cos`];;
def_of_string "FILTER";;

def_of_string "fan";;
conjuncts `!a b c. (u /\ v /\ (!c. w /\ r) /\ (!x y. r2 /\ r3))`;;


help "dest_forall";;
List.nth !theorems 0;;

help_grep ".*TAC$";;

INFINITE_DIFF_FINITE;;
search[`INFINITE`;`DIFF`];;


Format.set_max_boxes 100;;
let tt = hol_of_smalllist (1--300);;
string_of_my_term tt;;



let hel i = help (List.nth  tacsss i );;

hel 1;;

constant_of_regexp "sol";;

apropos;;
suggest;;


(* get all word counts in HOL LIGHT and FLYSPECK *)

let match_mp_strip =
  fun th ->
          let tm = concl th in
          let avs,bod = strip_forall tm in
          let ant,con = dest_imp bod in
          let th1 = SPECL avs (ASSUME tm) in
          let th2 = UNDISCH th1 in
          let evs = filter (fun v -> vfree_in v ant & not (vfree_in v con))
                           avs in
          let th3 = itlist SIMPLE_CHOOSE evs (DISCH tm th2) in
          let tm3 = hd(hyp th3) in
            MP (DISCH tm (GEN_ALL (DISCH tm3 (UNDISCH th3)))) th;;

let mp_short_list = 
  let u = fst(chop_list 50 (trigger_counts "MATCH_MP_TAC")) in
  let sl = map fst !theorems in
  let f1 = filter (fun (t,_) -> mem t sl ) u in
  let f2 = map (fun (s,n) -> (s,n,assoc s !theorems)) f1 in
    filter (fun (_,_,t) -> can  match_mp_strip t) f2;;


let relevant_match_mp r = 
  filter (fun (_,_,t) -> can (MATCH_MP_TAC t) r) mp_short_list;;

let suggest_match_mp () = relevant_match_mp (top_realgoal());;

mp_short_list;;

tachy"rep";;

tcs;;

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/ .*$//g'


let recent_search = ref [""];;

let refcount = ref [("",0)];;

trigger_counts "MATCH_MP_TAC";;

EQ_EXT;;
FINITE_SUBSET;;
search[regexp "EQ_SYM"];;
tachy "amt";;
tachy "asmcase";;

(* to get tacticals as well *)
(* grep "TYPE.*tactic" -i *.doc -l | sed 's/.doc//g' *)

List.length tactic_list;;
List.length(tachy "");;
subtract tactic_list (tachy "");;
tachy "bool";;

help "SUBST1_TAC";;

let typesss ss = 
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; grep TYPE "^ss^".doc | sed 's/TYPE[^{]*//g' )") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

typesss "ALL_TAC";;
help "SUBST1_TAC";;

(*
let MP_TAC_BAK = MP_TAC;;
let MATCH_MP_TAC_BAK = MATCH_MP_TAC;;
*)


let mp_theorems = ref[];;
let incr1 thm = (mp_theorems:= thm::!mp_theorems);;

let MP_TAC_COUNT t  = 
  let _ = incr1 t in MP_TAC_BAK t;;

let MP_TAC = MP_TAC_COUNT ;;

let MATCH_MP_TAC_COUNT t  = 
  let _ = incr1 t in MATCH_MP_TAC_BAK t;;

let MATCH_MP_TAC = MATCH_MP_TAC_COUNT ;;
let MATCH_MP_TAC = MATCH_MP_TAC_BAK ;;


reneeds "trigonometry/trig2.hl";;

let thm_hash = Hashtbl.create 1000;;
map (fun (x,y) -> Hashtbl.add thm_hash y x) (!theorems);;

let find_name th = 
  try (Hashtbl.find thm_hash th) with Not_found -> "ANONYMOUS";;

List.length (search[`x:A`]);;

List.length (search[`x > (y:real)`]);; (* 111 *)

List.length (search[`x > &0`]);; (* 67 *)
 (search[`x > y`; omit `x > &0`]);; (* complicated thing > simple thing. *)
List.length (search[`x < y`]);; (* 1438 *)

List.length (search[`x >= &0`]);; (* 11 *)
List.length (search[`x <= (y:real)`]);; (* 1830 *)
List.length (search[`x >= y`; omit `x >= &0`]);; (* 85, complicated thing > simple thing. *)


(* IN -- no rhyme or reason. *)
List.length(search[`(IN)`])  (* 3455 *);;
List.length(search[`SETSPEC`]);;  (* 1071 *);;
List.length(search[`SETSPEC`;`(IN)`]);;  (* 568 *)
dest_comb `{x | T} y`;;
List.length (search[`y IN (GSPEC f)`]);; (* 23 *)
 (search[`y IN {u | f}`]);; (* 14 *)
(search[`{u | f} y`]);; (* 3 *)
(searcht 40 [`(IN)`;omit `SETSPEC`]);;  

dest_comb `{x | x > 0}`;;

List.length (search[`x < y`]);; (* 1438 *)

(* search, what is the arc cosine called?  acs *)

search[rewrite `inv`;`( / )`];;
searcht 5 [rewrite `inv`;`a*b`];;
search [regexp "[dD]iff"];;
is_rewrite "inv" ("",REAL_INV_MUL);;
heads (snd(dest_thm(REAL_INV_MUL)));;

Toploop.execute_phrase;;


types();;

constants();;
heads(concl(hd(definitions())));;




(* experiments *)

let _ = 
  let dds = map fst def_assoc in
    sort (fun (_,a) (_,b) -> a > b) (map (fun t-> (t,stm_depth t)) dds);;




let thm_depthnth n =
  let (s,th) = List.nth !theorems n in
  let d = thm_depth th in (s,d,th);;


tm_depth `!a b.  (&2 <= a /\ a <= #2.52) /\ &2 <= b /\ b <= #2.52
         ==>( ((\x. -- (&4 + a pow 2 - x pow 2)/(a * sqrt(ups_x (a pow 2) (b pow 2) (&4)))) has_real_derivative
              (&32 * a * b /( (sqrt (ups_x (a pow 2) (b pow 2) (&4))) pow 3)))
             (atreal b within real_interval [&2,#2.52]))`;;

let depth_filter n = filter (fun (_,t)-> 
	  let (_,c) = hd (thm_depth t) in (c <= n));;

searcht 10 [`has_real_derivative`;`real_div`];;
(* now distance between constants *)

help_grep_flags "rat" "i";;

help "REAL_RAT_REDUCE_CONV";;
stm_depth "pi";;
stm_depth "cos";;
stm_depth "sin";;
assoc "pi" def_assoc;;

thm_depthnth 1000;;

stm_depth "?";;
stm_depth "!";;
stm_depth "hull";;
stm_depth "uniformly_continuous_on";;
stm_depth "real_add";;
stm_depth "treal_add";;
stm_depth "hreal_add";;
stm_depth "nadd_eq";;
stm_depth "dist";;
stm_depth "-";;
stm_depth "PRE";;
stm_depth "_0";;
assoc "_0" def_assoc;;

dest_const `(+)`;;
s_depth "arclength";;

c_depth `acs`;;
c_depth `(@)`;;
assoc `T` def_assoc;;

rho_node;;

c_of [] `sin(cos (x + y))`;;

searcht 5 [`a/b + c/d`];;


searcht 5 [`x pow n = &0`];;

help_grep "REAL_RAT";;
    
pre_rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;

strip_comb `&1 + &2`;;
dest_comb;;




REAL_INV_DIV;;

searcht 5 [`inv`;`a/b`];;
searcht 5 [`a/b + c/d`];;
let (rr,_)=hd[(`(+)`,ratform_add);
		       (`( * )`,ratform_mul);(`( - )`,ratform_sub);
		       (`( / )`,ratform_div)];;
type_of rr;;
rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;
Calc_derivative.derivative_form `\q. sin(q pow 5)` `t:real` `{}:real->bool`;;
pre_rationalize `inv (w)`;;

Calc_derivative.derivative_form `(\x. --(&4 + a pow 2 - x pow 2) /       (a * sqrt (ups_x (a pow 2) (x pow 2) (&4))))` `b:real` `real_interval [&2,#2.52]`;;

searcht 5[`x pow 1`];;

search [name "HAS_REAL";name "COS"];;

search [`(within)`;`(:real)`];;

open Calc_derivative;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `\x. x pow 3 + x * x - x * -- x + x/(x + &1)`in 
      differentiate tm x s;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `(\q:real. (q  - sin(q pow 3) + q pow 7 + y)/(q pow 2  + q pow 4 *(&33 + &43 * q)) +  (q pow 3) *  ((q pow 2) / (-- (q pow 3))))` in
      differentiate tm x s;;

  let th2 = 
    let x = `x:real` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;
  
  let th3 = 
    let x = `&5` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;


(* prove rational identity modulo accumulating assumptions *)

  let   equ = `(&1 / u  - &1/v) pow 2  = inv u pow 2 - &2 * inv (u * v) + inv v pow 2`;;
  let eq0 = MATCH_MP (REAL_ARITH `u - v = &0 ==> (u=v)`);;

CONV_RULE rc (pre_rationalize `&1 / (x + y) - &1 / (x - y) - (-- &2 * y / (x pow 2 - y pow 2))`);;
  let lite_imp = MESON[] `ratform p a ;;

REAL_FIELD ` ((x - y - (x + y)) * (x pow 2 * &1 pow 2 - &1 pow 2 * y pow 2) -
      ((x + y) * (x - y)) * -- &2 * y * &1 pow 2 * &1 pow 2) = &0`;;
  
mk_neg;;
mk_binop;;

searcht 5 [`(a1 pow n / b1 pow n)`];;

let ratform_tac =   
    REWRITE_TAC [ratform] THEN
    REPEAT STRIP_TAC THENL
    [ASM_MESON_TAC[REAL_ENTIRE] ;
    REPEAT (FIRST_X_ASSUM (fun t -> MP_TAC t THEN ANTS_TAC THEN 
			     ASM_REWRITE_TAC[])) THEN 
    REPEAT STRIP_TAC THEN 
    ASM_REWRITE_TAC[] THEN 
    REPEAT (POP_ASSUM MP_TAC) THEN 
    CONV_TAC REAL_FIELD];;



let ratform_pow = prove_by_refinement(
  `ratform p1 r1 a1 b1 ==> ratform p1 (r1 pow n) (a1 pow n) (b1 pow n)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[ratform;GSYM REAL_POW_DIV];
  ratform_tac;
  ]);;
  (* }}} *)

rational_identity `&1 / (x + y) - &1 / (x - y) = -- &2 * y / (x pow 2 - y pow 2)`;;


REAL_FIELD `&2 * x * y - &2 * y * x`;;


   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) in

   let hooked_deriv hook =
     let assumed_rules = map mk_derived hook in
     let d_hyp tm  = 
       let r =        assoc tm assumed_rules in
       let _ = print_thm r in
	 r in

    let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` ) in 

differentiate_hook [`(f has_real_derivative (&17)) (atreal x within (:real))`] `\x. ((f:real->real) x) pow 2` `x:real` `(:real)`;;

  differentiate_hook [`(f has_real_derivative f') (atreal x within (:real))`] `f:real->real` `x:real` `(:real)`;;

let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` );;


mk_derived `(f has_real_derivative (&17)) (atreal x within (:real))`;;
assoc `f:real->real` [it];;
differentiate_hook;;

`(f has_real_derivative f') (atreal x within (:univ))`;;

  let d_hyp assumed_rules tm =
    snd(find (fun (r,s) -> aconv tm r) assumed_rules);;


let triv2 = prove_by_refinement(
  `f f' x s. derived_form ((f has_real_derivative f') (atreal x)) f f' x (:real)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[derived_form;WITHINREAL_UNIV];
  ]);;
  (* }}} *)


(* acceptable forms
   `!x s. p ==> (f has_real_derivative f') (atreal x within s)`
   `!x s. p ==> (f has_real_derivative f') (atreal x)`
   `!x s. derived_form f f' x s`;;
*)

let thm5 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x s.  (derived_form (p x) f (f' x) x s))) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;


let thm4 = prove_by_refinement(
  `!x s. derived_form (!x s.  (f has_real_derivative f' x) (atreal x within s)) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let thm3 = prove_by_refinement(
  `!x s. derived_form (!x.  (f has_real_derivative f' x) (atreal x)) f (f' x) x s`,
  (* {{{ proof *)
  [
   REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm2 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x. p x ==> (f has_real_derivative f' x) (atreal x) )) f (f' x) x s`,
  (* {{{ proof *)
  [
     REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm1 = prove_by_refinement(
  `! x s. derived_form (p x /\ (!x s. p x==> (f has_real_derivative f' x) (atreal x within s)))
    f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let mk_derived  = 
  let     form1 =    `!x s. p x==> (f has_real_derivative f' x) (atreal x within s)`in
  let     form2 =    `!x. p x ==> (f has_real_derivative f' x) (atreal x)` in
  let     form3 =    `!x.  (f has_real_derivative f' x) (atreal x)` in
  let     form4 =    `!x s.  (f has_real_derivative f' x) (atreal x within s)` in
  let     form5 =    `!x s.  derived_form p f f' x s` in
  let fls =  [
    (form1,thm1);(form2,thm2);(form3,thm3);(form4,thm4);(form5,thm5)] in
  let mm tm (r,s) = 
    let ins = term_match [] r tm in
      INST ((fun (_,a,_) -> a) ins) s in
    fun tm -> 
      tryfind (mm tm) fls;;




df tm4;;
search [`within`;`atreal`;`has_real_derivative`;name "HAS_REAL"];;
let tm5 = `!x u. derived_form q g g' x u`;;
let tm4 = `!x u. (x > &0) ==> (g has_real_derivative (x pow 2)) (atreal x within u)`;;
if (can (term_match [] form5) tm) then tm else ( failwith "form5");;
MATCH_MP th4 tm4;;
MATCH_MP;;
let ins =  (term_match [] form4) tm4 ;;
INST ((fun (_,a,_) -> a) ins)  thm4;;

mk_derived tm5;;

   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) ;;

 


MATCH_MP;;


  

type_of `has_real_derivative`;;
types_of `derived_form ((f has_real_deriv f') (atreal x within s))`;;



snd(top_realgoal());;
let (h1,[f;f';r]) = strip_comb (snd(top_realgoal()));;
let _ = (h1 = `(has_real_derivative)`) or 
  failwith "form 'f has_real_derivative f' atreal b within s' expected." ;;
let (h2,[atb;s1]) = strip_comb r;;
let (h3,b) = dest_comb atb;;
1;;
1;;

BETA_CONV;;



search[`A INTER B = B INTER A`];;

search[`&0 <= x * x`];;
REAL_ENTIRE;;

time REAL_RING `a' = &2 * a /\ b' = a*a - &4 * b /\ x2 * y1 = x1 /\ y2 * y1 pow 2 = &1 - b * x1 pow 4 /\ y1 pow 2 = &1 + a * x1 pow 2 + b * x1 pow 4 /\ ~(y1 = &0) ==> y2 pow 2 = &1 - a' * x2 pow 2 + b' * x2 pow 4`;;

Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `(:real)`;;

time Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `{x | x > &0}`;;




searcht 5 [`(a,b) = (c,d)`];;
``,
    if (NULLSET X) then {} else
        (let (k,ul) = cell_params V X in set_of_list (truncate_simplex (k-1) ul))`;;

LET_TAC;;

g `!(x). (x = x) \/ (!(x:num). x = x) \/ (!(y:bool). y = y)`;;

Print_types.print_goal_var_overload();;

hash_of_term `p /\ q ==> r`;;

tachy "rt";;


eval_goal `a /\ b /\ c /\ d ==> r /\ s`;;
eval_tactic_abbrev "rt/a,[TRUTH]";;

st/r,
rt/a,[];;

(!Toploop.parse_toplevel_phrase (Lexing.from_string ("let xx = `&1`;;")));;

eval_command "let xx = `(x:real) + 2`;;";;

eval_command "failwith \"hi\" ;;";;
eval_command "assocrx";;

thm_depth FACET_OF_POLYHEDRON;;
searcht 15 [`norm x = &1`];;


 let tachit s = 
   let alpha_num = Str.regexp "[a-z_A-Z]+" in
    let _ = Str.string_match alpha_num s 0 or failwith "tachit" in
    let m = Str.matched_string s in
    let ns = (break_init m s) in
    let n = if (String.length n > 0)
      el n (tachy m)   ;;
tachit "sgth";;
tachy "sgth";;

Str.regexp;;
String.escaped "/\\ ";;

Sys.command;;
Sys.command "date";;



(*
let lemma = prove_by_refinement(
  `!a b . (!t. a < t ==> b <= t) ==> (!t. a <= t ==> b <= t)`,
  (* {{{ proof *)
[
REPEAT STRIP_TAC ;
DISJ_CASES_TAC (REAL_ARITH `a< t \/ a = t \/ t < a`);
ASM_MESON_TAC [];
HASH_UNDISCH_TAC 1429 ;
DISCH_THEN DISJ_CASES_TAC;
ASM_REWRITE_TAC [REAL_ARITH `b<=t <=> (t < b ==> F)`];
DISCH_TAC ;
HASH_RULE_TAC 6466 (SPEC `(a + b)/ (&2)`);
ASM_REAL_ARITH_TAC ;
ASM_REAL_ARITH_TAC 
]
);;
  (* }}} *)
*)
*)
]
);;
  (* }}} *)


List.length tactic_counts;;
  end_itlist (fun (_,t) (_,u) -> ("",t + u)) tactic_counts20;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE];
REPEAT STRIP_TAC;
ASM_MESON_TAC[FINITE_EMPTY;Misc_defs_and_lemmas.EMPTY_EXISTS;];
]);;
FINITE_EMPTY;;
INFINITE;;
FINITE_EMPTY;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE;GSYM Misc_defs_and_lemmas.EMPTY_EXISTS];
CONV_TAC (CONTRAPOS_CONV);
 THEN MESON_TAC[FINITE_EMPTY];

]);;


(* save. find strange constants *)

let symbolic_of cnames = 
  let symbolchar = explode "=-~.,@#$%^&*|\\/?><" in
    filter (fun t -> not (intersect (explode t) symbolchar=[])) cnames;;

let symbolic_constants = symbolic_of (map fst (constants()));;
let symbolic_infixes = symbolic_of (map fst (infixes()));;


searcht 5 [name "CHAIN";`has_derivative`];;
apropos();;
help "apropos_derivative";;
Calc_derivative.differentiate;;
Calc_derivative.derived_form;;
Calc_derivative.differentiate `cos` `x:real` `(:real)`;;

help;;
help "help";;

type_of `vector`;;

type_of;;
let types_of = Print_types.print_term_types;;
let type_of_thm = Print_types.print_thm_types;;
let type_of_goal = Print_types.print_goal_types;;
help_grep "type";;

help "apropos_types";;
types_of `($)`;;
has_derivative;;

map (fun t -> (t,type_of t)) (frees ` (!(y:real^6). p y ==> (continuous) (lift o f'') (at y within s))`);;

let arclength2 = prove_by_refinement(
  `!h.  (&1 <= h /\ h <= h0) ==> arclength (&2) (&2 * h) (&2) = acs(h / &2)`,
  (* {{{ proof *)
  [
  REPEAT STRIP_TAC;
  MP_TAC (SPECL [`&2`;`&2 * h`;`&2`] Trigonometry1.ACS_ARCLENGTH);
  BRANCH_A [
    ANTS_TAC ;
    MP_TAC Sphere.h0;
    ASM_REAL_ARITH_TAC;
  ];
  DISCH_THEN SUBST1_TAC;
  AP_TERM_TAC;
  UNDISCH_TAC `&1 <= h`;
  BY (CONV_TAC REAL_FIELD);
  ]);;
  (* }}} *)

let usage_count x = List.length (search [x]);;

(* marking *)
reset();;
show_marked();;

let marked = ref [];;
let show_marked() = map (fun t-> (t,assoc t !theorems)) (!marked);;
let mark s = 
  let th = assoc s (!theorems) in
  let _ = marked := s::!marked in
  th;;
let resetm() = marked:=[];;


term_match [] `s:C` `s:E->G`;;
frees_of_goal();;
`(r:B -> D) ((f:A->B) x) =  ((g:C->D) y)`;;
map types_of (gtypl [`f x`;`y`;`f`;`z:D`]);;
filter has_stv (setify (frees `f x`));;
apropos();;
help "apropos_types";;

 
let EZ_SOS_TAC equ =
  let lh = lhs equ in
  (REWRITE_TAC[REAL_ARITH `(x > y <=> y < x) /\ (x >= y <=> y <= x)`] THEN
    ONCE_REWRITE_TAC[REAL_ARITH `(x < y <=> &0 < y - x) /\ (x <= y <=> (&0 <= y - x))`]) THEN
let 
    fun (asl,w) -> 
      let eqthm = try    (REAL_FIELD eqn ) with _ -> failwith "sos_tac, REAL_FIELD failed" in
      let binop = 

rhs;;

searcht 5 [`x > y <=> x < y`];;

let equ = `(&1 - t) * (&1 pow 2) + t * (&1 - t) * (&1 pow 2) = (&1 - t pow 2)`;;
let lh = lhs equ;;
let (plus,adden) = strip_comb  lh;;
let _ = (plus = `(+)`) or failwith "sum expected";;
help_grep "strip";;
help "strip_comb";;

g `&1 + &1 = &2`;;
r,[];;

Str.split (Str.regexp "`") "`how `1` is it`";;
Str.split (Str.regexp "ab") "That is a better choice ab t";;
Str.split (Str.regexp "(\*") "^(* Start comment (* ( *) $";;

help_grep "dest";;
dest_pair `(a,b)`;;

map type_of [disjunct (`CARD`,`HAS_SIZE`)];;
search [disjunct (`HAS_SIZE`,`CARD`)];;
type_of `HAS_SIZE`;;
search [disjunct (`&0 < inv x`,`&0 < sqrt u`)];;
search [disjunct (`&0 < sqrt u`,`&0 < inv x`)];;
search [`&0 < sqrt u`];;

search[disjunct (`INJ`,`(f x = f y) ==> (x = y)`);disjunct(`CARD`,`HAS_SIZE`)];;

INJ_CARD;;

mk_rewrites false (ASSUME `!s. s = t`) [];;

net_of_thm false (ASSUME `s = t`) empty_net;;

empty_net;;

p();;
!invariant_under_linear;;


let pollack_inconsistency = 
  let thm1 = prove(  `?(n:num). (t < n)`,EXISTS_TAC`t + 1` THEN ARITH_TAC) in
  let t = mk_var("n < 0 /\\ 0",`:num`) in
    INST [(t,`t:num`)] thm1;;

(* *)

    let curryl = [Calc_derivative.atn2curry] ;;
    let curry = REWRITE_CONV curryl;;
    let uncurry = REWRITE_CONV (map GSYM curryl) ;;

uncurry `\x. atn2 (x,x + &1)`;;

curry `f`;;
(* 
Counting_spheres....
*)

!invariant_under_translation;;
searcht 10 [`dihV`;`arcV`];;
searcht 10 [`r f x y = f y x`;omit `#x`];;
VECTOR_ANGLE_ANGLE;;
search[name "ARCV_ANGLE"];;
search[`Arg`;`vector_angle`];;
searcht 10 [`azim`;`Arg`];;
(* from wlog_examples.ml *)

let TRUONG_1 = prove
 (`!u1:real^3 u2 p a b.
     ~(u1 = u2) /\
     plane p /\
     {u1,u2} SUBSET p /\
     dist(u1,u2) <= a + b /\
     abs(a - b) < dist(u1,u2) /\
     &0 <= a /\
     &0 <= b
     ==> (?d1 d2.
              {d1, d2} SUBSET p /\
              &1 / &2 % (d1 + d2) IN affine hull {u1, u2} /\
              dist(d1,u1) = a /\
              dist(d1,u2) = b /\
              dist(d2,u1) = a /\
              dist(d2,u2) = b)`,
  (*** First, rotate the plane p to the special case z$3 = &0 ***)

  GEOM_HORIZONTAL_PLANE_TAC `p:real^3->bool` 


(* bug on loading misc.ml. (next is used as a variable, but later it becomes a constant  *)
Debug.Term_of_preterm_error
 [("function head", `next`, `:(?2712096)loop->?2712096->?2712096`);
  ("function arg", `0`, `:num`)].
Error in included file /Users/thomashales/Desktop/googlecode/hol_light/Multivariate/misc.ml
- : unit = ()

File "/Users/thomashales/Desktop/googlecode/hol_light/calc_rat.ml", line 515, characters 4-160:
Error: This expression has type
         (num -> term) * conv * conv * conv * (term -> thm) * (term -> thm) *
         (term -> thm) * (term -> thm) * 'a
       but an expression was expected of type
         (thm list * thm list * thm list -> positivstellensatz -> thm) ->
         thm list * thm list * thm list -> thm

(*
let backup_proof_record = !proof_record;;
List.length backup_proof_record;;
*)

(*
let rec clean_proof_record g skip tbs  = 
   function
       [] -> (g, EVERY (List.rev tbs))
     | Gax u :: xs -> clean_proof_record [u] skip tbs xs
     | Bax::xs -> clean_proof_record g (skip+1) tbs
     | Tax (_,_,t)::xs -> if (skip<=0) then clean_proof_record g 0 (t::tbs) xs else
	 clean_proof_record g (skip-1) tbs xs;;
      
let replay (g,t) = 
  

let replay_proof gax_no count = 
  let p1 = List.nth (gax()) gax_no in
  let p2 = fst(chop_list count p1) in
  let _ = proof_record:= p2 @ !proof_record in
    replay();;

let rotate_proof n =
  let (a,b) = chop_list n (gax()) in
    List.flatten (b,a);;
*)

  let _ = reneeds "usr/thales/init_search.hl" in ();;



let REAL_LEMMA = prove_by_refinement(
  `!t s. (&0 < t ) ==> (?x. &0 < x /\ (&0 < s + t * x))`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  ASM_CASES_TAC (`&0 < s + t `);
    EXISTS_TAC `&1`;
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN REAL_ARITH_TAC);
  EXISTS_TAC `&1 - s/t`;
  CONJ_TAC;
    MATCH_MP_TAC (arith `&0 < (-- a)/b ==> &0 < &1 - a/b`);
    MATCH_MP_TAC REAL_LT_DIV;
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN REAL_ARITH_TAC);
  SUBGOAL_THEN `s + t * (&1 - s/t) = t` SUBST1_TAC;
    Calc_derivative.CALC_ID_TAC;
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN REAL_ARITH_TAC);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

Topology.th1;;

let AZIM_ARG4 = prove_by_refinement(
  `!x v u w t1 t2 t3.  &0 < t3 /\ ~collinear {x , v , u} /\ ~collinear {x,v,w} ==>
    azim x v u w  = azim x v u (t1 % x + t2 % v + t3 % w)`,
  (* {{{ proof *)
  [
  st/r
  sgth `(?x. &0 < x /\ (&0 < (t1 + t2 + t3 * x)))` mptac
    rt[arith `t1 + t2 + t3*x = (t1 + t2) + t3*x`]
    mmp REAL_LEMMA
    art[]
    st
    sgth `(t3 % w = (t3 * x') % (&1/x' % (w:real^3)))` subst1
    rt[VECTOR_MUL_ASSOC]
    repeat (apthmtac ORELSE aptermtac)
    calc
    repeat (fxa mptac) then rat
      abbrev `s = t1 + t2 + t3 * x'`
      sgth `t1 % x + t2 % v + (t3 * x') % (&1/x' % w) = 
  ]);;
  (* }}} *)

searcht 5 [`a % (b % c)`;`(a * b) % c`];;





Auto_lib.testsplit true "QZECFIC wt0 sqrt8";;
  map (fun t -> try (Auto_lib.testsplit bool t) with Failure _ -> [()]) cases;;
open Functional_equation;;
string_of_num (num_of `5`;;
dest_numeral `55555555555555`;;
i_mk2 `0`;;

	       module More = struct
		 open Sphere;;
		 open Ineq;;

	       end;;

Auto_lib.testsplit true "CJFZZDW test";;


let idq_of_string s = hd(Ineq.getexact s);;
idq_of_string "GRKIBMP test";;
Auto_lib.testsplit true "GRKIBMP B";;

<<<<<<< .mine
  EXTREME_POINT_OF_FACE;;

FACE_OF_EQ;;  (* relative interiors of faces are disjoint *)

QOEPBJD;;
 FACE_OF_POLYHEDRON_POLYHEDRON;;

NEHRQPR;;
  POLYHEDRON_COLLINEAR_FACES;;



Graph_control.run(Graph_control.bezdek_reid_properties);;
flyspeck_needs "../glpk/fejesToth_contact/bezdek_reid_problem.ml";;
List.length Bezdek_reid_problem.archive;;
let brp = Bezdek_reid_problem.exec();;
let zbrp = zip Bezdek_reid_problem.archive brp;;
let feas = filter (fun (_,(a,_)) -> not(a = ["PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION"]) && not (a = ["PROBLEM HAS NO FEASIBLE SOLUTION"])) zbrp;;
List.length feas;;
let mk_bb = Bezdek_reid_problem.mk_bb;;
let feas_bb = map (fun (t,_) -> mk_bb t) feas;;

open Bezdek_reid_problem;;
open Glpk_link;;
let out_bb = map (fun bb -> solve_branch_f model dumpfile "optival" ampl_of_bb bb) feas_bb;;
feas_bb;;

let bb = "154372608266 14 7 0 1 2 3 4 5 6 3 0 6 5 3 0 5 7 3 7 5 4 3 1 0 8 3 8 0 7 3 7 4 9 3 9 4 3 3 9 3 10 3 10 3 2 3 10 2 11 3 11 2 8 3 2 1 8 5 8 7 9 10 11 ";;
solve_branch_f model dumpfile "optival" ampl_of_bb (mk_bb bb);;

  let svar = mk_var (s,snd(dest_var t));;



