(* GETTING STARTED *)

let idq_of_string s = hd(Ineq.getexact s);;
cfsqp !testids;;

Optimize.preprocess (hd !testids);;

idq_of_string "OXLZLEZ 6346351218 1 18";;




let ox n i = (idq_of_string (Printf.sprintf "OXLZLEZ 6346351218 %d %d" i n)).ineq;;

let tm0 n = ox n 0;;
let tm1 n = ox n 1;;
let tm2 n = ox n 2;;
let tm3 n = ox n 3;;
let tm4 n = ox n 4;;

let ox_conj n = end_itlist (curry mk_conj) [tm0 n;tm1 n;tm2 n;tm3 n;tm4 n];;
let ox3q1h_term() =  end_itlist (curry mk_conj) (map ox_conj (0--45));;
let ox3q1h() =  new_definition (mk_eq (`ox3q1h:bool`,ox3q1h_term()));;
let ox3q1h_mp = MP_TAC(ox3q1h());;

let [yv;a12;a23;a34;a14;b12;b23;b34;b14;c1;c2;c3;c4] = 
  map (fun t -> mk_var(t,`:real`))
    (Str.split (Str.regexp " ")
       "y a12 a23 a34 a14 b12 b23 b34 b14 c1 c2 c3 c4");;

let y12 = `(a12 + b12)/ &2`;;
let y23 = `(a23 + b23)/ &2`;;
let y34 = `(a34 + b34)/ &2`;;
let y41 = `(a14 + b14)/ &2`;;

let specl x = concl o (SPECL x) o ASSUME;;
let spec1 = specl[yv;a12;a14;c1;b14;b12];;
let spec2 = specl[yv;a23;a12;c2;b12;b23];;
let spec3 = specl[yv;a34;a23;c3;b23;b34];;
let spec4 = specl[yv;a14;a34;c4;b14;b34];;
let spec0 = specl[yv;y12;y23;y34;y41];;
let in1 n  = spec1 (tm1 n);;
let in2 n = spec2 (tm2 n);;
let in3 n = spec3 (tm3 n);;
let in4 n = spec4  (tm4 n);;
let in0 n = spec0  (tm0 n);;

(* labels: y=spine, aij lower edge shared between i & j. bij = top edge.
   ci = edge opp spine on simplex i *)
prioritize_real();;

(*
let getinstantiation = 
  let concl1 = ` (gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun / w +
		    cb * beta_bump_force_y y1 y2 y3 y4 y5 y6 +
        cd * dih_y y1 y2 y3 y4 y5 y6 +
        cy * y1 +
        cab * (y2 + y3 + y5 + y6) +
        cc >
        &0)` in
  fun in2 -> 
    let u =  hd(tl(snd (strip_comb in2))) in
      (term_match [] (concl1)) u;;
*)

let combinator_lemma = 
  prove_by_refinement(`!cd cy1 cy2 cy3 cy4 cab1 cab2 cab3 cab4 cc1 cc2 cc3 cc4.
   ((dih_y y a12 a14 c1 b14 b12 +
      dih_y y a23 a12 c2 b12 b23 +
      dih_y y a34 a23 c3 b23 b34 +
      dih_y y a14 a34 c4 b14 b34 =
      &2 * pi) /\ (&2 * pi * cd +
 (cy1 + cy2 + cy3 + cy4) * y +
 &2 * (cab1 + cab2) * (a12 + b12) / &2 +
 &2 * (cab2 + cab3) * (a23 + b23) / &2 +
 &2 * (cab3 + cab4) * (a34 + b34) / &2 +
 &2 * (cab4 + cab1) * (a14 + b14) / &2 +
 cc1 +
 cc2 +
 cc3 +
 cc4 <
 &0) /\ ( gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 +
     &1 * beta_bump_force_y y a12 a14 c1 b14 b12 +
     cd * dih_y y a12 a14 c1 b14 b12 +
     cy1 * y +
     cab1 * (a12 + a14 + b14 + b12) +
     cc1 >
     &0) /\ 
   (gamma4fgcy y a23 a12 c2 b12 b23 lmfun / &1 +
     &0 * beta_bump_force_y y a23 a12 c2 b12 b23 +
     cd * dih_y y a23 a12 c2 b12 b23 +
     cy2 * y +
     cab2 * (a23 + a12 + b12 + b23) +
     cc2 > &0) /\
   (gamma4fgcy y a34 a23 c3 b23 b34 lmfun / &1 +
     &0 * beta_bump_force_y y a34 a23 c3 b23 b34 +
     cd * dih_y y a34 a23 c3 b23 b34 +
     cy3 * y +
     cab3 * (a34 + a23 + b23 + b34) +
     cc3 >
     &0) /\
    (gamma4fgcy y a14 a34 c4 b14 b34 lmfun / &1 +
     &0 * beta_bump_force_y y a14 a34 c4 b14 b34 +
     cd * dih_y y a14 a34 c4 b14 b34 +
     cy4 * y +
     cab4 * (a14 + a34 + b14 + b34) +
     cc4 >
     &0) ==> 
    (  gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 +
     beta_bump_force_y y a12 a14 c1 b14 b12 +
     gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
     gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
     gamma4fgcy y a14 a34 c4 b14 b34 lmfun >
     &0 
     ))`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  REPEAT(FIRST_X_ASSUM_ST `gamma4fgcy` MP_TAC);
  MATCH_MP_TAC (arith `(a + b+c+d - e < &0)   ==> ((a > &0) ==> (b > &0) ==> (c > &0) ==> (d > &0) ==> (e> &0))`);
  FIRST_X_ASSUM MP_TAC;
  MATCH_MP_TAC (arith `(t = e) ==> ((t< &0) ==> (e < &0))`);
  REWRITE_TAC[arith `&2 * pi * cd = (&2 * pi) * cd`];
  FIRST_X_ASSUM (fun t -> SUBST1_TAC (SYM t));
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)


let template_OX = `!in0 in1 in2 in3 in4
  y' y''
  c1' c1'' c2' c2'' c3' c3'' c4' c4''
  a12' a12'' a23' a23'' a34' a34'' a14' a14''
  b12' b12'' b23' b23'' b34' b34'' b14' b14''.
  (in0 /\ in1 /\ in2 /\ in3 /\ in4) ==>
  ineq [(y',y,y'');
   (c1',c1,c1'');
   (c2',c2,c2'');
   (c3',c3,c3'');
   (c4',c4,c4'');
   (a12',a12,a12'');
   (a23',a23,a23'');
   (a34',a34,a34'');
   (a14',a14,a14'');
   (b12',b12,b12'');
   (b23',b23,b23'');
   (b34',b34,b34'');
   (b14',b14,b14'')
   ]
  ((dih_y y a12 a14 c1 b14 b12  + 
  dih_y y a23 a12 c2 b12 b23  +
  dih_y y a34 a23 c3 b23 b34  +
  dih_y y a14 a34 c4 b14 b34 = &2 * pi) ==>
  (gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 + 
  beta_bump_force_y y a12 a14 c1 b14 b12 +
  gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
  gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
  gamma4fgcy y a14 a34 c4 b14 b34 lmfun > &0))`;;

let template_OX2 = `!
  y' y''
  c1' c1'' c2' c2'' c3' c3'' c4' c4''
  a12' a12'' a23' a23'' a34' a34'' a14' a14''
  b12' b12'' b23' b23'' b34' b34'' b14' b14''.
  ox3q1h ==>
  ineq [(y',y,y'');
   (c1',c1,c1'');
   (c2',c2,c2'');
   (c3',c3,c3'');
   (c4',c4,c4'');
   (a12',a12,a12'');
   (a23',a23,a23'');
   (a34',a34,a34'');
   (a14',a14,a14'');
   (b12',b12,b12'');
   (b23',b23,b23'');
   (b34',b34,b34'');
   (b14',b14,b14'')
   ]
  ((dih_y y a12 a14 c1 b14 b12  + 
  dih_y y a23 a12 c2 b12 b23  +
  dih_y y a34 a23 c3 b23 b34  +
  dih_y y a14 a34 c4 b14 b34 = &2 * pi) ==>
  (gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 + 
  beta_bump_force_y y a12 a14 c1 b14 b12 +
  gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
  gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
  gamma4fgcy y a14 a34 c4 b14 b34 lmfun > &0))`;;


let dest_triple x = 
  let (a,b) = dest_pair x in
  let (b,c) = dest_pair b in (b,(a,c));;

let getbounds tm =
  let xx1 = hd(snd(strip_comb tm)) in
  let xx2 = dest_list xx1 in
    map dest_triple xx2;;

let allbounds n = setify(List.flatten (map getbounds [in1 n;in2 n;in3 n;in4 n]));;

let goal_OX n = 
  let g1 = specl [in0 n;in1 n;in2 n;in3 n;in4 n] template_OX in
  let a = C assoc (allbounds n) in
  let s1 v g = 
    let (v',v'')  = a v in
      specl [v';v''] g in
    itlist s1 (List.rev [yv;c1;c2;c3;c4;a12;a23;a34;a14;b12;b23;b34;b14]) g1;;

let goal_OX2 n = 
  let g1 = template_OX2 in
  let a = C assoc (allbounds n) in
  let s1 v g = 
    let (v',v'')  = a v in
      specl [v';v''] g in
    itlist s1 (List.rev [yv;c1;c2;c3;c4;a12;a23;a34;a14;b12;b23;b34;b14]) g1;;


let mk13ner n = prove_by_refinement(
  goal_OX n,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.ineq];
  REPEAT STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `/\` MP_TAC);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[arith `a <= b /\ a <= c ==> a <= (b + c)/ &2`; arith `b <= a /\ c <= a ==> (b + c)/ &2 <= a` ];
  FIRST_X_ASSUM_ST `dih_y` MP_TAC;
  REWRITE_TAC[TAUT `(a ==> b==>c ==>d==>e==>f==>g)<=>(a /\ b /\ c /\ d/\ e /\ f ==>g)`];
  DISCH_THEN (fun t -> ASSUME_TAC (MATCH_MP combinator_lemma t));
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mk_ox3q1h n = prove_by_refinement(
  goal_OX2 n,
  (* {{{ proof *)
  [
 REPEAT WEAK_STRIP_TAC;
  MATCH_MP_TAC (mk13ner n);
  BY(BY(ox3q1h_mp THEN ASM_REWRITE_TAC[] THEN REPEAT WEAK_STRIP_TAC THEN ASM_REWRITE_TAC[]))
  ]);;
  (* }}} *)


(* 0--45 *)
mk_ox3q1h 5;;
let ox3q1h_46 = map mk_ox3q1h (0--45);;

List.length Ineqdata3q1h.records;;
List.nth Ineqdata3q1h.records 17;;

curry mk_conj;;

ox3q1h = 

(*

let gammaX4 = prove_by_refinement(
  `!V X v0 v1 v2 v3 v4.
  let y01 = dist(v0,v1) in
  let y02 = dist(v0,v2) in
  let y03 = dist(v0,v3) in
  let y12 = dist(v1,v2) in
  let y13 = dist(v1 v3) in
  let y23 = dist(v2,v3) in
    (
   packing V /\ ({v1,v2,v3,v4} SUBSET V) /\ 
    ==>
    gammaX V X = gamma4f y01 y02 y03 y23 y13 y12)`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)
*)

let dihX2 = prove_by_refinement(
  `!V X v0 v1.
  let y = dist(v0,v1) in
    (packing V /\ saturated V /\ mcell_set V X /\ 
       ((2,[v0;v1])= cell_params_d V X [v0;v1]) ==>
     dihX V X (v0,v1) =   `,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)

searcht 5 [`dihu2`];;
search [`mcell_set`];;
searcht 5 [`cell_params`];;
searcht 5 [`cell_params_d`];;
let gammaX2 = prove_by_refinement(
  `!V X v0 v1.
  let y = dist(v0,v1) in
    (packing V /\ mcell_set V X .... ==>
       gammaX V X = gamma2f_divdih * dihX V X`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)

searcht 19 [`total_solid`];;
searcht 19 [`gammaX`];;

searcht 45 [def "gamma";def "4"];;
Sphere.gamma4f;;
search [`gammaX`];;
search [`total_solid`];;
search [`dihX`];;
search [`dihu2`];;
let thm  =Functional_equation.functional_taum_x1;;
let thm = snd(strip_forall (concl (Nonlinear_lemma.strip_let thm)));;

Optimize.preprocess_split_idq (hd (Ineq.getexact "QITNPEA 4003532128 d"));;

Sphere.gamma3f_x_v_lfun;;
Nonlinear_lemma.gamma3f_x_v0;;
searcht 5 [`gamma3f_v0`];;
let functional1_ = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)

Sphere.flat_term_x;;
Sphere2.matan 3.;;
Pervasives.atan (Pervasives.sqrt(3.)) /. (Pervasives.sqrt 3.);;
Sphere2.ldih6_x_126_n 4. 4. 4. 4. 4. 4.;;
Sphere2.dih_x 4. 4. 4. 4. 4. 4.;;
Sphere.sqn;;
searcht 5 [`rho`];;
searcht 5 [`ly`];;
searcht 5 [`const1`;`sol0`];;
Sphere.const1;;
Sphere.rho;;
quadratic_root_plus_curry;;
Sphere.quadratic_root_plus;;
searcht 25 [`quadratic_root_plus_curry`];;
Sphere.abc_of_quadratic;;
Sphere.edge_flat2_x;;
Sphere.edge_flat;;
Sphere.lfun;;
Sphere.matan;;
Sphere.sqrt3;;
Sphere.eta_x;;
Sphere2.taum_x 4. 4. 4. 4. 4. 4.;;




Functional_equation.rotate126;;
Functional_equation.mk_126;;
Sphere.eta_y;;
Sphere.eta2_126;;
Sphere.tau0;;
Sphere.sol0;;
Sphere.gchi;;

let soh = Parse_ineq.ocaml_string_of_term;;

strip_abs `\x1 x2 x3 x4 x5 x6. f x1 x2 x3 x4 x5 x6`;;


let test = map 
  (fun x->
    try
      ocam x; true
    with Match_failure _ -> false);;


let domain6 soh h f g = 
  let (v,body) = strip_abs h in
  let vs = map (fst o dest_var) v in
  let vars = Flyspeck_lib.join_space vs in
  let bodys = soh body in
  let fs = fst(dest_const f) in
  let gs = soh g in
    (Printf.sprintf 
    "let %s %s = \n  let _ = ( %s ) or failwith \"domain6:%s\" in \n
      ( %s ) %s;;" fs vars bodys fs gs vars);;

let _  = 
  let r1 = (strip_all Functional_equation.functional_dih4_x) in
  let (_,[h;f;g]) = strip_comb r1 in
    domain6 soh h f g;;

soh bb1;;

dest_const `(>=)`;;
type_of `(/\ )`;;

dest_const `(/\ )`;;
strip_comb (strip_all Functional_equation.functional_dih4_x);;

Parse_ineq.ocaml_function `proj_x1 x1 x2 x3 x4 x5 x6 = let z = 1 in (&3)`;;

strip_comb `let t = 1 in (x + u)`;;
strip_comb `(x,y)`;;
	    type_of `(,)`;;
dest_const `(,)`;;
warn;;
warn false "hello";;
let ocaml_test = map 
  (function b -> 
  [functonal_equation.]
  [sqrt2;sqrt8;delta_x;delta_y;delta_x4;delta_x6;ups_x;eta_x;
  eta_y;dih_x;dih_y;dih2_y;dih3_y;sol_x;sol_y;interp;ly;const1;
  rho;rhazim;lnazim;taum;arclength];;

let ocaml_code = 
  "(* code automatically generated from Parse_ineq.ocaml_code *)\n\n"^
   "module Sphere_math = struct\n\n"^
   "let sqrt = Pervasives.sqrt\n\n" ^
   "let pi = 4.0 *. atan(1.0);;\n" ^
   (join_lines (map ocaml_function ocaml_autogen)) ^
   "end;;\n";;

  (function b -> snd(strip_forall (concl (strip_let b))));;

flyspeck_needs "local/polar_fan.hl";;
flyspeck_needs "general/flyspeck_lib.hl";;
flyspeck_needs "nonlinear/optimize.hl";;
flyspeck_needs "../development/thales/nonlinear/functional_equation.hl";;
Polar_fan.BGMIFTE;;
searcht 5 [`sqrt (x1 * x2) = sqrt x1 * sqrt x2`];;
searcht 5 [`&0 <= x * y`];;
List.nth !Parse_ineq.autogen 9;;
let RNONLIN = ;;
Sphere.rho_x;;
Nonlinear_lemma.rho_x;;
g `x:bool`;;

module Temp =  struct
  open Sphere;;
  open Ineq;;
add
{
  idv="2485876245b";
  doc="Used in some quad calculations to show that a node
   is not straight (both halves are acute)";
  tags=[Flypaper[];Main_estimate;Cfsqp;Xconvert;Tex];
  ineq = all_forall `ineq [
    (&2,y1,#2.52);
    (&2,y2,#2.52);
    (&2,y3,#2.52);
    (&2,y4,#2.52);
    (#3.01,y5, &2 * #2.52);
      (&2,y6,#3.01)
  ]
((delta4_y y1 y2 y3 y4 y5 y6 > &0) \/ (delta_y y1 y2 y3 y4 y5 y6 < &0))`;
};;
end;;

one_cfsqp (hd all_cases);;
execute_cfsqp();;
Ineq.make_F23 0 0;;

map (Optimize.testsplit false) all_cases;;

loadt (flyspeck_dir^"/nonlinear/check_completeness.hl");;
Check_completeness.execute();;

one_cfsqp "2485876245-test";;

Sphere_math.taum 2. twoh0 2. cstab cstab 2.;;

arc 2. 2. sqrt1553;;
arc1553;;
arc 2. 2. 2. +. arc 2. 2. cstab;;
0.1 *. (cstab -. sqrt8) +. 0.11;;
arc 2. 2. (3.15/. 1.26);;
arc 2.52 2. 3.01;;

1;;
end;;
tame_table_d 1 2;;
map (Optimize.testsplit true) ["2485876245b"];;
!testids;;
flyspeck_needs;;

let rr y = Sphere_math.delta_y 2. sqrt8 y 3.01 2. y;;
rr 3.41;;

Sphere_math.taum 2. 2. 2. (sqrt(8.0)) 2. 2.;;
1;;
arc 2. 2. (sqrt(15.53));;
arc 2. 2. 2. +. arc 2. 2. sqrt8;;
Sphere_math.dih_y 2. 2. 2. 3.01 3.04 2.0 +.
Sphere_math.dih_y 2. 2. 2. sqrt8 3.04 2.0;;
tame_table_d 2 1;;
2.0 *. arc 2. 2. 2.52;;
3.0 *. arc 2.52 2.52 2.;;
cos ((arc 2.52 2.52 2.) *. 3.);;
cos(arc 2. 2. 2.52);;
arc 2. 2. 2.52;;
cos(arc 2. 2. 2.);;

type_of `d3`;;
search [name "d3"];;
flyspeck_needs "leg/collect_geom2.hl";;
flyspeck_needs "local/MTUWLUN.hl";;
Upfzbzm.UPFZBZM;;
Rdwkarc.RDWKARC;;
Mtuwlun.MTUWLUN4;;

8 + 1+7+30+30+14+15+46+17+36+25+35+10+21;;
`a cross b`;;
type_of `cross`;;
AFFINE;;
search [`normball`;`ball`];;
search [name "triple_of_real3"];;
search [name "CARD4"];;
search[name "NORM_TOWARD"];;
CONVEX_FINITE;;
search [name "REAL_POSSQ"];;
search [name "bis"];;
search [`!x. &0 < (x * x) <=> ~(x = &0)`];;
search [name "REAL_RDISTRIB"];;
search [name "kepler_conjecture"];;
search [name "lmfun_ineq_center"];;
search [name "TSKAJXY_statement"];;
search [name "cell_cluster_estimate"];;
search [name "cluster_gammaX"];;
let ff (u) (v) = u+ v;;
atan2;;
tame_table_d 2 1;;
tame_table_d 1 2;;

uniq [3;3;4;4;5;5];;
Lib.uniq;;
Kizhltl.KIZHLTL4;;

open Glpk_link;;
open Lpproc;;
open Hard_lp;;

161847242261: 12.066
39599353438: 12.037
65974205892: 12.399
88089363170: 12.306
154005963125: 12.460
50803004532: 12.541
223336279535: 12.315
242652038506: 12.406
86506100695: 12.109
179189825656: 12.110
164470574315: 12.186
215863975889: 12.159
34970074286: 12.437
100126458338: 12.301
75641658977: 12.412;;

Lpproc.make_model();;
hard_bb();;
execute();;

let output = it;;
let (nu,un) = output;;
nu;; (* 64240 *)
let ((an,bn,cn,dn,en),fn,gn) = un;;
en;;
an=1;;
bn=1;;
cn=1;;
dn=1;;
en;;

!load_path;;
flyspeck_needs;;
Sys.file_exists(fullpath "build.hl");;

Ineq.getprefix "ZTGIJCF23 0 0 0 7907792228 b";;
flyspeck_needs  "general/flyspeck_lib.hl";;
flyspeck_needs  "nonlinear/parse_ineq.hl";;
let one_cfsqp t = 
  Parse_ineq.execute_cfsqp (hd(Ineq.getexact t));;
one_cfsqp "4322269127";; 

let cfsqp ts = 
  let us = map (hd o Ineq.getexact) ts in
  !(Parse_ineq.execute_cfsqp_list us);;

cfsqp newcases;;

one_cfsqp "test";;

module Test = struct
  open Ineq;;
  open Sphere;;
add
{
  idv="test";
  doc="   ";
  tags=[Flypaper[];Main_estimate;Tex];
  ineq = all_forall `ineq [
    (&2,y1,#2.52);
    (#2.0,y2,#2.52);
    (&2,y3,#2.52);
    (#3.01,y4,#3.915);
    (&2,y5,&2);
      (&2,y6,&2)
  ]
(
  (ups_x (y1*y1) (y2* y2) (y3*y3) * ups_x (y1*y1) (y2*y2) (y6*y6) * 
     ups_x (y2*y2) (y3*y3) (y4*y4) > &0) \/
  (delta_y y1 y2 y3 y4 y5 y6 < &15)
 )`;
};;
end;;

add_hints_force_include_flat t;; (* fail *)
ignore;;
type_of `upsilon_x`;;
Pervasives.ignore;;
Parse_ineq.autogen;;
hollight_dir;;
  let _ = Lpproc.make_model();;
  let _ = resetc();;
flyspeck_dir;;
  let hr = hard_bb();;
let exec i = 
   (fun t-> allpass_hint_include_flat 20000 [t]) (List.nth hr i);;

exec 12;;

Sys.command("head "^ flyspeck_dir^"/../kepler_tex/x.txt");;

Glpk_link.solve_branch_f;;

type_of theorems;;
follow;;
textchar;;
augment_search_results ["hi"];;
really_expand "?-0";;
help_grep "";;
help_flag "";;
help "apropos_short_order_script";;
suggest();;
String.sub "abcde" 1 (String.length "abcde" - 1);;
expand_suggest "0";;
hd it;;
List.nth !loaded_files 69;; Reload 1--69 
mk_thm;;
flyspeck_needs "general/lib.hl";;
flyspeck_needs "nonlin/kelvin_lattice.hl";;
flyspeck_needs "usr/thales/init_search.hl";;
reneeds "packing/counting_spheres.hl";;
flyspeck_needs "packing/QZKSYKG.hl";;
flyspeck_needs "packing/DDZUPHJ.hl";;
flyspeck_needs "packing/AJRIPQN.hl";;
flyspeck_needs "packing/QZYZMJC.hl";;
flyspeck_needs "packing/marchal_cells_3.hl";;
flyspeck_needs "packing/GRUTOTI.hl";;
Grutoti.GRUTOTI;;
flyspeck_needs "fan/CFYXFTY.hl";;
flyspeck_needs "packing/counting_spheres.hl";;
open Counting_spheres;;
flyspeck_needs "nonlinear/cleanDeriv.hl";;
flyspeck_needs "nonlinear/cleanDeriv_examples.hl";;
flyspeck_needs "../development/thales/chaff/tmp/vectors_patch.ml";;
flyspeck_needs "../development/thales/chaff/tmp/determinants_patch.ml";;
flyspeck_needs "../development/thales/chaff/tmp/wlog_patch.hl";;
reneeds "trigonometry/trig2.hl";;
update_database();;
augment_search_results;;
!search_results;;
Counting_spheres.ORDER_AZIM_SUM2PI;;
search [name "GSYM_EXISTS"];;
!search_results;;
searcht 15 [`delta`;`&0`];;
searcht 15 [def "delta"];;
flyspeck_needs   "local/dih2k.hl";;
flyspeck_needs   "local/WJSCPRO.hl";;

flyspeck_needs "local/TECOXBM.hl";;

let u11111 = ((GOAL_TERM (fun w -> ALL_TAC)):tactic);;
RDISK_R;;

GOAL_TERM (fun w -> (MP_TAC (ISPECL ( envl w [`p`;`v`;`u0`;`b`]) RCONE_PREP)));;

INST [(`u:bool`,`A:bool`)] (TAUT ` ((A ==> B) /\ A) ==> B`);;

let thh = Collect_geom.EQ_POW2_COND;;
let ta1 = TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`;;
let th2 = REWRITE_RULE[ta1] ( thh);;
let tm1 = snd (strip_forall (concl th2));;
let tm2 = snd (dest_imp tm1);;
let tm3 = fst (dest_eq tm2);;
let force_rewrite th;;

1;;
Sphere.dih_x;;





searcht 5 [`&0 <= sqrt x`];;
SQRT_POS_LE;;

let goalx = `&0 <= sqrt x /\ &0 <= sqrt t ==> &0 <= sqrt u`;;
GMATCH_SIMP_TAC SQRT_POS_LE;;

let (asl,w) = (top_realgoal());;
let thm = SQRT_POS_LE;;
  let thm' = hd (mk_rewrites true thm []);;
  let t1 = fst (dest_eq(snd (dest_imp(concl(thm'))))) ;;
  let matcher u t = 
    let m = term_match [] t1 t in
    let _ = subset (frees t) (frees u) or failwith "" in
      m ;;
  let wsub u = find_term (can (matcher u)) u ;;
  let w' = wsub w ;;
  let vv = 
    let var1 = mk_var("v",type_of w') in
      variant (frees w) var1 ;;
  let athm = REWRITE_CONV[ ASSUME (mk_eq (w',vv))] w ;;
  let arhs = rhs (concl athm) ;;
  let bthm = (ISPECL [mk_abs(vv,arhs);w'] BETA_THM) ;;
  let betx = SYM(TRANS bthm (BETA_CONV (rhs (concl bthm)))) ;;
   ONCE_REWRITE_TAC[betx]
  MATCH_MP_TAC (lift_eq thm')
     BETA_TAC
 THEN BETA_TAC);;
rt[]

 (asl,w);;
thm;;
lift_eq thm;;

  let thm' = hd (mk_rewrites true thm []);;
  let t1 = snd (dest_imp(concl(thm')));;
  let matcher u t = 
    let m = term_match [] t1 t in
    let _ = subset (frees t) (frees u) or failwith "" in
      m in
  let wsub u = find_term (can (matcher u)) u in
  let w' = wsub w in
  let vv = 
    let var1 = mk_var("v",type_of w') in
      variant (frees w) var1 in
  let athm = REWRITE_CONV[ ASSUME (mk_eq (w',vv))] w in
  let arhs = rhs (concl athm) in
  let bthm = (ISPECL [mk_abs(vv,arhs);w'] BETA_THM) in
  let betx = SYM(TRANS bthm (BETA_CONV (rhs (concl bthm)))) in
   (ONCE_REWRITE_TAC[betx] THEN MATCH_MP_TAC (lift_bool thm) THEN BETA_TAC) (asl,w);;


let lift_SQRT_POS_LE = GEN_ALL (MATCH_MP lift_imp (SPEC_ALL SQRT_POS_LE));;




OR_ELSE;;
searcht 5 [`sqrt (t pow 2)`];;

add_rewrite_tag("mycase ",th);;
let xxx n = add_rewrite_stag (List.nth search_result_dump_march7_8am n);;
xxx 0;;
assoc (List.nth search_result_dump_march7_8am 0) !theorems;;

!rewrite_tags;;
let th = ASSUME (`!p q r. p ==> q ==> (cos r = s) /\ (u ==> sin y > &1)`);;

let gexp = `!t. (cos x + sqrt (t pow 2) > &0)`;;
let hexp = `!x. (cos x + sqrt (t pow 2) > &0)`;;


mk_rewrites;;
let thm = POW_2_SQRT;;



let matcherx u t = 
  let m = term_match [] t1 t in
  let _ = subset (frees t) (frees u) or failwith "" in
    m;;
let mmat u = find_term (can (matcherx u)) u;;
let mx = mmat hexp;;
let mma1 = term_match [] `sqrt x` (mmat hexp);;
let vv = 
  let var1 = mk_var("v",type_of mx) in
    variant (frees hexp) var1;;
let rrx = REWRITE_CONV[ ASSUME (mk_eq (mx,vv))] hexp;;
let rhsx = rhs (concl rrx);;
let bthx = (ISPECL [mk_abs(vv,rhsx);mx] BETA_THM);;
let betx = SYM(TRANS bthx (BETA_CONV (rhs (concl bthx))));;

ort[betx];;
mmp (lift_eq POW_2_SQRT);;
BETA_TAC;;



1;;
GMATCH_SIMP_TAC POW_2_SQRT

  


help "BETA";;
rhsx;;
;;
mx;;
mk_eq;;
mk_var;;

frees mmat;;
frees gexp;;
term_match [] `sqrt x` mmat;;

st_of  `sin x + cos (asn t)`;;
mk_prover;;
net_of_thm;;
help "term_match";;
help "find_term";;
help "GEN_PART_MATCH";;
help "PART_MATCH";;
help "MATCH_MP";;
`(&0 <= sqrt (t pow 2)) \/ b ==> ~(&0 <= sqrt u)`
mmp lift_SQRT_POS_LE
rt[]
SPEC_ALL (ASSUME `!x. x = x`);;
let lift_SQRT_POS_LE = GEN_ALL (MATCH_MP lift_imp (SPEC_ALL SQRT_POS_LE));;
searcht 5 [`&0 <= sqrt x`];;

eval_command ~silent:true "let x111 = 1+1+4";;
x111;;
eval_command ~silent:false "mark 4";;
mark 4;;
snd it;;
help_grep "match";;
help "term_match";;  
help "PART_MATCH";;
find_term;;
help "find_term";;
List.map hd (split_proof_record [] [] (!proof_record));;
term_match;;
help "term_match";;
searchl;;

vol_solid_triangle_ortho;;
searcht 5 [`measure  A <= measure ( B)`];;

searcht 5 [`(b /\ c ) /\ a = b /\ c /\ a`];;

retrieve_search;;
thm_counts;;


eval_tactic_lines "st/r\nfxa mpt";;
text_char;;


process_to_string "date";;
gax();;


last (show_gax());;
List.nth (show_gax()) 2;;

Clean_deriv.x1_eta2;;
axioms();;
type_of `( %% )`;;
Qzyzmjc.QZYZMJC;;
search [name "FMSWMVO"];;
search [name "IVFICRK"];;
search [name "volume_props"];;
stm_depth "T";;
(* PROJECT BUILD *)
Hashtbl.hash;;

  (*
  let (d,hd) = data (get_tm_depth w) in
    filter (fun ((d',hd'),_,_) -> (((abs (d-d')< 1+k)  && sorted_meet 0 hd hd' ))) thml;; 
  *)

List.length (ballpark_theorems   (top_realgoal()));;
 (ballpark_theorems   (top_realgoal()));;
abs_of_float;;
int_abs;;
last [0;1;2;3];;
strip_imp `a`;;
strip_imp `a ==> b==> c`;;
help_grep "dest_";;
type_of `==>`;;
strip_comb;;
help_grep "strip";;
is_comb;;
help "strip_exists";;
strip_comb `a ==> b==> c`;;
help_grep "comb";;
help "strip_ncomb";;
help_grep "strip";;


let nearest_thm_to_goal thml (asl,w) = 
  let tt tl = List.flatten (map (tm_depth o concl) tl) in
  let common = tt (map snd asl) in
  let thl = map (fun (s,t) -> ((tm_depth o snd o strip_forall o concl )t,s,t) ) thml in
  let r = map (fun (tl,s,t) -> (tl,s,t,msd 0.0 common (tm_depth w) tl)) thl in
    (sort (fun (_,_,_,a) (_,_,_,b) -> a < b) r);;

let thml_depth_of_goalmatch thml (asl,w) = 
  let tt tl = List.flatten (map (tm_depth o concl) tl) in
  let w'::rest = List.rev strip_imp o  snd o strip_forall w in
  let common = tt ((map snd asl) @ rest) in
  let thl = map (fun (s,t) -> ((tm_depth o snd o strip_forall o concl )t,s,t) ) thml in
  let 
;;



nearest_thm_to_goal (ballpark_theorems (top_realgoal())) (top_realgoal());;
let guess = nearest_thm_to_goal (top_realgoal());;
List.length !theorems;;

top_realgoal;;
help_grep "goal";;
(* *)

tt;;
hd (!theorems);;
tt;;
strip_forall;;
help_grep "strip";;

(* jan 3, 2012 chaff *)



(* USEFUL CONSTRUCTS *)

let report s =
  Format.print_string s; Format.print_newline();;

g `?(x:A) . f A`

(* generalize *)

let ( TYPE_VAR :string -> (term -> tactic) -> tactic) = 
    fun s tm_tactic (asl,g) ->
      let (_,r) = dest_comb g in
      let (v,_) = dest_abs r in
      let (_,ty) = dest_var v in
	tm_tactic (mk_var(s,ty)) (asl,g);;

TYPE_VAR "x" EXISTS_TAC;
;;
Format.print_flush();;
FINITE_EMPTY;;

searcht 10 [`eulerA_hexall_x`];;

Sphere.num_combo1;;

(*
process_to_string "cat qed_log.txt | sed  's/^.*ineq./\"/' | sed 's/., secs.*$/\";/'  "

cat qed_log.txt | sed  's/^.*ineq./"/' | sed 's/., secs.*$/";/' | sort -u | wc  

(*
let _ = Sys.command("cat "^flyspeck_dir^"/../interval_code/qed_log.txt");;
*)
*)


let ee () = 
  let b = (false or (let _ = Sys.command("date") in failwith "h")) in b;;


suggest();;

EXISTSv_TAC "y";

dest_binder "?" (`?(x:A). f A`);;

(*

let searchl = sortlength_thml o search;;
let take = Lib_ext.take;;
let searcht r = take 0 5 (searchl r);;
let searchtake i j r = take i j (searchl r);;

*)
term_match;;
INSTANTIATE;;
  open Searching;;

definitions();;
State_manager.neutralize_state();;
let vv = (eval("1+1")) + 3;;
let vv = (eval("REFL `T`"));;
concl vv;;

prefixes();;
rev(infixes());;
binders();;
unparse_as_infix;;
map (List.nth (infixes())) (95--131);;
unparse_as_binder "!";;
binders();;

sort (<) [`y3:real`;`y2:real`];;

Sphere.all_forall `(y1 + y3 + y2  = y0 + y7)`;;

REAL_FIELD `x > &0 /\ y > &0 ==> x * y > &0`;;

find_path ((=) `4`) `(sum (3..4) f)`;;  (* lrr *)

help "MK_CONJ";;
Temp_in.generate_ineq_datum_p;;
List.length !theorems;;

let kill_process n = Sys.command (Printf.sprintf "sudo kill -9 %d" n);;

search [`min`];;
type_of `max`;;

help_grep "conj";;
help "list_mk_conj";;
 end_itlist;;

FROZEN_REWRITE_TAC [REAL_ARITH `b + d = d - (--b)`];;

let goal_types = Print_types.print_goal_types;;
Print_types.goal_types();;
Print_types.print_term_types `#2`;;
Print_types.print_thm_types (REFL `1`);;


edge_flat_x;;
Print_types.print_term_types 
`dih_hexall_x x14 x12 x23 x1 x2 x3 x4 x5 (x6:real) = 
   dih_x x1 x2 x4 ((&2 * h0) pow 2) x14 x12 - dih_x x1 x3 x4 x5 x14 (edge_flat2_x x2 x1 x3 (&0)    x23 x12)`;;


(*
(* parsing printing *)
let pterm = Print_types.print_term_types;;
let tterm = Print_types.print_thm_types;;

#install_printer print_qterm;;


#install_printer Goal_printer.print_goal_hashed;;
#install_printer Goal_printer.print_goalstack_hashed;;

#remove_printer Goal_printer.print_goal_hashed;;
#remove_printer Goal_printer.print_goalstack_hashed;;

#print_length 1000;;
*)

search[`f (x:A) (g (y:A) z) = f (g x y) z`];; (* min, max, + /\, \/ *, compose, monoidal ops,
   APPEND, a - (b + c) = a - b - c /\ a - (b - c) = a - b + c),
    p ==> q ==> r <=> p /\ q ==> r);; *)

find_term  ( can (term_match[ `r a (r y z) = r (r x y) z`])) (concl IMP_IMP);;

filter_pred;;
can (term_match[]);;
type_of;;

constant_of_regexp "at.*[gn]$";;

constant_of_regexp "FILTER";;
searcht 15 [`cos`];;
def_of_string "FILTER";;

def_of_string "fan";;
conjuncts `!a b c. (u /\ v /\ (!c. w /\ r) /\ (!x y. r2 /\ r3))`;;


help "dest_forall";;
List.nth !theorems 0;;

help_grep ".*TAC$";;

INFINITE_DIFF_FINITE;;
search[`INFINITE`;`DIFF`];;

Tame_general.sol0_over_pi_EQ_const1;;
Tame_general.sol0_POS;;
def_of_string "dih_x";;
search[name "SQRT_MUL_POW_2"];;

search[`sqrt x = sqrt y`];;
search[`sqrt x = y`;`x = y pow 2`];;
search[`sqrt (x * y) = sqrt x * sqrt y`];;
search[`&0 <= a*a `];;
searcht 5 [`x <= y`;`y >= x`];;
search[`sqrt x * sqrt x`];;
search [`&0 pow 2`];;

type_of `bn_facesAt`;;


flyspeck_needs "hypermap/bauer_nipkow.hl";;
search[name "ACS_2"];;


Format.set_max_boxes 100;;
let tt = hol_of_smalllist (1--300);;
string_of_my_term tt;;



let hel i = help (List.nth  tacsss i );;

hel 1;;

constant_of_regexp "sol";;

apropos;;
suggest;;


(* get all word counts in HOL LIGHT and FLYSPECK *)

let match_mp_strip =
  fun th ->
          let tm = concl th in
          let avs,bod = strip_forall tm in
          let ant,con = dest_imp bod in
          let th1 = SPECL avs (ASSUME tm) in
          let th2 = UNDISCH th1 in
          let evs = filter (fun v -> vfree_in v ant & not (vfree_in v con))
                           avs in
          let th3 = itlist SIMPLE_CHOOSE evs (DISCH tm th2) in
          let tm3 = hd(hyp th3) in
            MP (DISCH tm (GEN_ALL (DISCH tm3 (UNDISCH th3)))) th;;

let mp_short_list = 
  let u = fst(chop_list 50 (trigger_counts "MATCH_MP_TAC")) in
  let sl = map fst !theorems in
  let f1 = filter (fun (t,_) -> mem t sl ) u in
  let f2 = map (fun (s,n) -> (s,n,assoc s !theorems)) f1 in
    filter (fun (_,_,t) -> can  match_mp_strip t) f2;;


let relevant_match_mp r = 
  filter (fun (_,_,t) -> can (MATCH_MP_TAC t) r) mp_short_list;;

let suggest_match_mp () = relevant_match_mp (top_realgoal());;

mp_short_list;;

tachy"rep";;

tcs;;

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/ .*$//g'


let recent_search = ref [""];;

let refcount = ref [("",0)];;

trigger_counts "MATCH_MP_TAC";;

EQ_EXT;;
FINITE_SUBSET;;
search[regexp "EQ_SYM"];;
tachy "amt";;
tachy "asmcase";;

(* to get tacticals as well *)
(* grep "TYPE.*tactic" -i *.doc -l | sed 's/.doc//g' *)

List.length tactic_list;;
List.length(tachy "");;
subtract tactic_list (tachy "");;
tachy "bool";;

help "SUBST1_TAC";;

let typesss ss = 
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; grep TYPE "^ss^".doc | sed 's/TYPE[^{]*//g' )") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

typesss "ALL_TAC";;
help "SUBST1_TAC";;

(*
let MP_TAC_BAK = MP_TAC;;
let MATCH_MP_TAC_BAK = MATCH_MP_TAC;;
*)


let mp_theorems = ref[];;
let incr1 thm = (mp_theorems:= thm::!mp_theorems);;

let MP_TAC_COUNT t  = 
  let _ = incr1 t in MP_TAC_BAK t;;

let MP_TAC = MP_TAC_COUNT ;;

let MATCH_MP_TAC_COUNT t  = 
  let _ = incr1 t in MATCH_MP_TAC_BAK t;;

let MATCH_MP_TAC = MATCH_MP_TAC_COUNT ;;
let MATCH_MP_TAC = MATCH_MP_TAC_BAK ;;


reneeds "trigonometry/trig2.hl";;

let thm_hash = Hashtbl.create 1000;;
map (fun (x,y) -> Hashtbl.add thm_hash y x) (!theorems);;

let find_name th = 
  try (Hashtbl.find thm_hash th) with Not_found -> "ANONYMOUS";;

List.length (search[`x:A`]);;

List.length (search[`x > (y:real)`]);; (* 111 *)

List.length (search[`x > &0`]);; (* 67 *)
 (search[`x > y`; omit `x > &0`]);; (* complicated thing > simple thing. *)
List.length (search[`x < y`]);; (* 1438 *)

List.length (search[`x >= &0`]);; (* 11 *)
List.length (search[`x <= (y:real)`]);; (* 1830 *)
List.length (search[`x >= y`; omit `x >= &0`]);; (* 85, complicated thing > simple thing. *)


(* IN -- no rhyme or reason. *)
List.length(search[`(IN)`])  (* 3455 *);;
List.length(search[`SETSPEC`]);;  (* 1071 *);;
List.length(search[`SETSPEC`;`(IN)`]);;  (* 568 *)
dest_comb `{x | T} y`;;
List.length (search[`y IN (GSPEC f)`]);; (* 23 *)
 (search[`y IN {u | f}`]);; (* 14 *)
(search[`{u | f} y`]);; (* 3 *)
(searcht 40 [`(IN)`;omit `SETSPEC`]);;  

dest_comb `{x | x > 0}`;;

List.length (search[`x < y`]);; (* 1438 *)

search[`cross`;`collinear`];;
search[`(a cross b) cross c`];;
search[`c cross (a cross b) `];;

search[`sqrt(x) = y`];;

(* search, what is the arc cosine called?  acs *)

`(?x. a) /\ b ==> c`;;
STRIP_TAC;;

search[];;
searcht 15 [`inv`];;
search[rewrite `inv`;`( / )`];;
searcht 5 [rewrite `inv`;`a*b`];;
search [regexp "[dD]iff"];;
is_rewrite "inv" ("",REAL_INV_MUL);;
heads (snd(dest_thm(REAL_INV_MUL)));;

288. /. 32.;;
Toploop.execute_phrase;;


types();;

constants();;
heads(concl(hd(definitions())));;




(* experiments *)

let _ = 
  let dds = map fst def_assoc in
    sort (fun (_,a) (_,b) -> a > b) (map (fun t-> (t,stm_depth t)) dds);;




let thm_depthnth n =
  let (s,th) = List.nth !theorems n in
  let d = thm_depth th in (s,d,th);;


tm_depth `!a b.  (&2 <= a /\ a <= #2.52) /\ &2 <= b /\ b <= #2.52
         ==>( ((\x. -- (&4 + a pow 2 - x pow 2)/(a * sqrt(ups_x (a pow 2) (b pow 2) (&4)))) has_real_derivative
              (&32 * a * b /( (sqrt (ups_x (a pow 2) (b pow 2) (&4))) pow 3)))
             (atreal b within real_interval [&2,#2.52]))`;;

let depth_filter n = filter (fun (_,t)-> 
	  let (_,c) = hd (thm_depth t) in (c <= n));;

searcht 10 [`has_real_derivative`;`real_div`];;
(* now distance between constants *)

help_grep_flags "rat" "i";;

help "REAL_RAT_REDUCE_CONV";;
stm_depth "pi";;
stm_depth "cos";;
stm_depth "sin";;
assoc "pi" def_assoc;;

thm_depthnth 1000;;

stm_depth "?";;
stm_depth "!";;
stm_depth "hull";;
stm_depth "uniformly_continuous_on";;
stm_depth "real_add";;
stm_depth "treal_add";;
stm_depth "hreal_add";;
stm_depth "nadd_eq";;
stm_depth "dist";;
stm_depth "-";;
stm_depth "PRE";;
stm_depth "_0";;
assoc "_0" def_assoc;;

dest_const `(+)`;;
s_depth "arclength";;

c_depth `acs`;;
c_depth `(@)`;;
assoc `T` def_assoc;;

rho_node;;

c_of [] `sin(cos (x + y))`;;

searcht 5 [`a/b + c/d`];;


searcht 5 [`x pow n = &0`];;

help_grep "REAL_RAT";;
    
pre_rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;

strip_comb `&1 + &2`;;
dest_comb;;




REAL_INV_DIV;;

searcht 5 [`inv`;`a/b`];;
searcht 5 [`a/b + c/d`];;
let (rr,_)=hd[(`(+)`,ratform_add);
		       (`( * )`,ratform_mul);(`( - )`,ratform_sub);
		       (`( / )`,ratform_div)];;
type_of rr;;
rationalize `-- (v/ u pow 3)/(&1/x  + &3 * (-- (u /( v * inv (w)))))`;;
Calc_derivative.derivative_form `\q. sin(q pow 5)` `t:real` `{}:real->bool`;;
pre_rationalize `inv (w)`;;

Calc_derivative.derivative_form `(\x. --(&4 + a pow 2 - x pow 2) /       (a * sqrt (ups_x (a pow 2) (x pow 2) (&4))))` `b:real` `real_interval [&2,#2.52]`;;

searcht 5[`x pow 1`];;

search [name "HAS_REAL";name "COS"];;

search [`(within)`;`(:real)`];;

open Calc_derivative;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `\x. x pow 3 + x * x - x * -- x + x/(x + &1)`in 
      differentiate tm x s;;

  let th1 = 
    let x = `x:real` in
    let s = `{t | t > &0}` in
    let tm = `(\q:real. (q  - sin(q pow 3) + q pow 7 + y)/(q pow 2  + q pow 4 *(&33 + &43 * q)) +  (q pow 3) *  ((q pow 2) / (-- (q pow 3))))` in
      differentiate tm x s;;

  let th2 = 
    let x = `x:real` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;
  
  let th3 = 
    let x = `&5` in
    let s = `(:real)` in
    let tm = `\q.  cos(&1 + q pow 2) * acs (q pow 4) + atn(cos q) + inv (q + &1)` in
      differentiate tm x s;;


(* prove rational identity modulo accumulating assumptions *)

  let   equ = `(&1 / u  - &1/v) pow 2  = inv u pow 2 - &2 * inv (u * v) + inv v pow 2`;;
  let eq0 = MATCH_MP (REAL_ARITH `u - v = &0 ==> (u=v)`);;

CONV_RULE rc (pre_rationalize `&1 / (x + y) - &1 / (x - y) - (-- &2 * y / (x pow 2 - y pow 2))`);;
  let lite_imp = MESON[] `ratform p a ;;

REAL_FIELD ` ((x - y - (x + y)) * (x pow 2 * &1 pow 2 - &1 pow 2 * y pow 2) -
      ((x + y) * (x - y)) * -- &2 * y * &1 pow 2 * &1 pow 2) = &0`;;
  
mk_neg;;
mk_binop;;

searcht 5 [`(a1 pow n / b1 pow n)`];;

let ratform_tac =   
    REWRITE_TAC [ratform] THEN
    REPEAT STRIP_TAC THENL
    [ASM_MESON_TAC[REAL_ENTIRE] ;
    REPEAT (FIRST_X_ASSUM (fun t -> MP_TAC t THEN ANTS_TAC THEN 
			     ASM_REWRITE_TAC[])) THEN 
    REPEAT STRIP_TAC THEN 
    ASM_REWRITE_TAC[] THEN 
    REPEAT (POP_ASSUM MP_TAC) THEN 
    CONV_TAC REAL_FIELD];;



let ratform_pow = prove_by_refinement(
  `ratform p1 r1 a1 b1 ==> ratform p1 (r1 pow n) (a1 pow n) (b1 pow n)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[ratform;GSYM REAL_POW_DIV];
  ratform_tac;
  ]);;
  (* }}} *)

rational_identity `&1 / (x + y) - &1 / (x - y) = -- &2 * y / (x pow 2 - y pow 2)`;;


REAL_FIELD `&2 * x * y - &2 * y * x`;;


   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) in

   let hooked_deriv hook =
     let assumed_rules = map mk_derived hook in
     let d_hyp tm  = 
       let r =        assoc tm assumed_rules in
       let _ = print_thm r in
	 r in

    let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` ) in 

differentiate_hook [`(f has_real_derivative (&17)) (atreal x within (:real))`] `\x. ((f:real->real) x) pow 2` `x:real` `(:real)`;;

  differentiate_hook [`(f has_real_derivative f') (atreal x within (:real))`] `f:real->real` `x:real` `(:real)`;;

let  triv = REWRITE_RULE[](REWRITE_CONV[derived_form] 
     `!f f' x s. derived_form ((f has_real_derivative f') (atreal x within s)) f f' x s` );;


mk_derived `(f has_real_derivative (&17)) (atreal x within (:real))`;;
assoc `f:real->real` [it];;
differentiate_hook;;

`(f has_real_derivative f') (atreal x within (:univ))`;;

  let d_hyp assumed_rules tm =
    snd(find (fun (r,s) -> aconv tm r) assumed_rules);;


let triv2 = prove_by_refinement(
  `f f' x s. derived_form ((f has_real_derivative f') (atreal x)) f f' x (:real)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[derived_form;WITHINREAL_UNIV];
  ]);;
  (* }}} *)


(* acceptable forms
   `!x s. p ==> (f has_real_derivative f') (atreal x within s)`
   `!x s. p ==> (f has_real_derivative f') (atreal x)`
   `!x s. derived_form f f' x s`;;
*)

let thm5 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x s.  (derived_form (p x) f (f' x) x s))) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;


let thm4 = prove_by_refinement(
  `!x s. derived_form (!x s.  (f has_real_derivative f' x) (atreal x within s)) f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let thm3 = prove_by_refinement(
  `!x s. derived_form (!x.  (f has_real_derivative f' x) (atreal x)) f (f' x) x s`,
  (* {{{ proof *)
  [
   REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm2 = prove_by_refinement(
  `!x s. derived_form (p x /\ (!x. p x ==> (f has_real_derivative f' x) (atreal x) )) f (f' x) x s`,
  (* {{{ proof *)
  [
     REWRITE_TAC[derived_form];
    MESON_TAC[HAS_REAL_DERIVATIVE_ATREAL_WITHIN];
  ]);;
  (* }}} *)

let thm1 = prove_by_refinement(
  `! x s. derived_form (p x /\ (!x s. p x==> (f has_real_derivative f' x) (atreal x within s)))
    f (f' x) x s`,
  (* {{{ proof *)
  [
    REWRITE_TAC[derived_form];
    MESON_TAC[];
  ]);;
  (* }}} *)

let mk_derived  = 
  let     form1 =    `!x s. p x==> (f has_real_derivative f' x) (atreal x within s)`in
  let     form2 =    `!x. p x ==> (f has_real_derivative f' x) (atreal x)` in
  let     form3 =    `!x.  (f has_real_derivative f' x) (atreal x)` in
  let     form4 =    `!x s.  (f has_real_derivative f' x) (atreal x within s)` in
  let     form5 =    `!x s.  derived_form p f f' x s` in
  let fls =  [
    (form1,thm1);(form2,thm2);(form3,thm3);(form4,thm4);(form5,thm5)] in
  let mm tm (r,s) = 
    let ins = term_match [] r tm in
      INST ((fun (_,a,_) -> a) ins) s in
    fun tm -> 
      tryfind (mm tm) fls;;




df tm4;;
search [`within`;`atreal`;`has_real_derivative`;name "HAS_REAL"];;
let tm5 = `!x u. derived_form q g g' x u`;;
let tm4 = `!x u. (x > &0) ==> (g has_real_derivative (x pow 2)) (atreal x within u)`;;
if (can (term_match [] form5) tm) then tm else ( failwith "form5");;
MATCH_MP th4 tm4;;
MATCH_MP;;
let ins =  (term_match [] form4) tm4 ;;
INST ((fun (_,a,_) -> a) ins)  thm4;;

mk_derived tm5;;

   let mk_derived tm =
     let (h1,[f1;f1';r1]) = strip_comb tm in
     let (h2,[b2;s1]) = strip_comb r1 in
     let (h3,b) = dest_comb b2 in
       (f1,SPECL [f1;f1';b;s1] triv) ;;

 


MATCH_MP;;


  

type_of `has_real_derivative`;;
types_of `derived_form ((f has_real_deriv f') (atreal x within s))`;;



snd(top_realgoal());;
let (h1,[f;f';r]) = strip_comb (snd(top_realgoal()));;
let _ = (h1 = `(has_real_derivative)`) or 
  failwith "form 'f has_real_derivative f' atreal b within s' expected." ;;
let (h2,[atb;s1]) = strip_comb r;;
let (h3,b) = dest_comb atb;;
1;;
1;;

BETA_CONV;;

let data = 
[("    * JLIGZGS ",14);
("    * AMHFNXP ",26);
("    * WBLARHH ",3);
("    * BSXAQBQ ",16);];;

let data=[
("packing ",0);
( "   * SLTSTLO ",12);
( "   * RVFXZBU ",14);
( "   * URRPHBZ ",2);
( "   * QZYZMJC ",1);
( "   * GRUTOTI ",10);
( "   * KIZHLTL ",26);
( "   * TSKAJXY ",1);
( "   * OXLZLEZ ",7);
( "   * UPFZBZM ",16);
( "   * RDWKARC ",5);
( "   * EUSOTYP ",23);
( "   * GOTCJAH ",30);
( "   * DLWCHEM ",30);
( "   * XULJEPR ",14);];;

let data=[
(" local ",0);
( "   * EGHNAVX ",26);
( "   * XRECQNS ",15);
( "   * MHAEYJN ",46);
( "   * ZLZTHIC ",0);
( "   * EJRCFJD ",17);
( "   * NKEZBFC ",7);
( "   * BGMIFTE ",36);
( "   * WSEWPCH ",25);
];;

let data=[
("tame ",0);
( "   * FNJLBXS ",35);
( "   * FCDJDOT ",10);
( "   * KCBLRQC ",21);];;

List.fold_left (+) 0 (map snd data);;



search[`A INTER B = B INTER A`];;

search[`&0 <= x * x`];;
REAL_ENTIRE;;

time REAL_RING `a' = &2 * a /\ b' = a*a - &4 * b /\ x2 * y1 = x1 /\ y2 * y1 pow 2 = &1 - b * x1 pow 4 /\ y1 pow 2 = &1 + a * x1 pow 2 + b * x1 pow 4 /\ ~(y1 = &0) ==> y2 pow 2 = &1 - a' * x2 pow 2 + b' * x2 pow 4`;;

Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `(:real)`;;

time Calc_derivative.differentiate `\t. &1/(cos (a * t pow 2))` `b+ &1` `{x | x > &0}`;;




searcht 5 [`(a,b) = (c,d)`];;
``,
    if (NULLSET X) then {} else
        (let (k,ul) = cell_params V X in set_of_list (truncate_simplex (k-1) ul))`;;

LET_TAC;;

g `!(x). (x = x) \/ (!(x:num). x = x) \/ (!(y:bool). y = y)`;;

Print_types.print_goal_var_overload();;



  let tm1 = `p /\ (q ==> r)`
  and tm2 = `p ==> q` in
  let th1,th2 = CONJ_PAIR(ASSUME tm1) in
  let th = itlist DISCH [tm1;tm2] (MP th2 (MP(ASSUME tm2) th1)) in
    th;;

help "ASM_REAL_ARITH_TAC";;

hash_of_term `p /\ q ==> r`;;

`(x:real):real`;;

`(&1):real`;;

tachy "rt";;


eval_goal `a /\ b /\ c /\ d ==> r /\ s`;;
eval_tactic_abbrev "rt/a,[TRUTH]";;

st/r,
rt/a,[];;

(!Toploop.parse_toplevel_phrase (Lexing.from_string ("let xx = `&1`;;")));;

eval_command "let xx = `(x:real) + 2`;;";;

eval_command "failwith \"hi\" ;;";;
eval_command "assocrx";;

thm_depth FACET_OF_POLYHEDRON;;
searcht 15 [`norm x = &1`];;


 let tachit s = 
   let alpha_num = Str.regexp "[a-z_A-Z]+" in
    let _ = Str.string_match alpha_num s 0 or failwith "tachit" in
    let m = Str.matched_string s in
    let ns = (break_init m s) in
    let n = if (String.length n > 0)
      el n (tachy m)   ;;
tachit "sgth";;
tachy "sgth";;

Str.regexp;;
String.escaped "/\\ ";;

Sys.command;;
Sys.command "date";;



(*
let lemma = prove_by_refinement(
  `!a b . (!t. a < t ==> b <= t) ==> (!t. a <= t ==> b <= t)`,
  (* {{{ proof *)
[
REPEAT STRIP_TAC ;
DISJ_CASES_TAC (REAL_ARITH `a< t \/ a = t \/ t < a`);
ASM_MESON_TAC [];
HASH_UNDISCH_TAC 1429 ;
DISCH_THEN DISJ_CASES_TAC;
ASM_REWRITE_TAC [REAL_ARITH `b<=t <=> (t < b ==> F)`];
DISCH_TAC ;
HASH_RULE_TAC 6466 (SPEC `(a + b)/ (&2)`);
ASM_REAL_ARITH_TAC ;
ASM_REAL_ARITH_TAC 
]
);;
  (* }}} *)
*)
*)
]
);;
  (* }}} *)


search [`polar_cycle_on`];;


  [



searcht 15 [`FINITE (x:real->bool)`;`(<)`];;
searcht 15 [`(polar_cycle_on x V = r)`];;
Trigonometry2.polar_cycle_on;;
searcht 15 [`(polar_lt x y = z)`];;
searcht 15 [`tri_itv`];;

searcht 20 [name "INDUC";];;

FINITE_INDUCT_STRONG;;


searcht 5 [`sup s IN r`];;
searcht 5 [`s DELETE r HAS_SIZE n`];;
searcht 5 [`s HAS_SIZE 0`];;
searcht 15 [`CARD (x INSERT s)`];;
searcht 5 [`{} SUBSET x`];;
searcht 5 [`x < 0`];;
searcht 5 [`{x | F}`];;
searcht 5 [`IMAGE f {}`];;


searcht 5 [`arg_diff`];;

searcht  5 [`x:complex`];;

searcht 15 [`~(x = {})`];;

search [`Arg`];;
search [`directed_angle`];;
searcht 50 [`f:num->num->num`;omit `nsum`;omit `monoidal`;omit `SUC`;omit `EVEN`;omit `((+):num->num->num)`];;
searcht 5 [`(MOD)`];;

net_of_cong (ASSUME `p ==> (r = s)`) (basic_congs());;

basic_congs();;
mk_prover;;
rand;;
rand `x = y`;;
enter;;
help "IMP_RES_THEN";;

List.length tactic_counts;;
  end_itlist (fun (_,t) (_,u) -> ("",t + u)) tactic_counts20;;

tactic_counts;;
    let total = 516794.0;;
(177618.0 +. 14899.0) /. total;;
(11965.0 +. 22441.0 +. 4993.0) /. total;;
(3591.0) /. total;;
779.0 /. total;;
assoc "INDUCT_TAC" tactic_counts;;
    let tactic_counts20 = map (fun i -> el i tactic_counts) (0--9);;

498727.0 /. total;;


37.25 +. 14.5 +. 4.0 +. 3.0 +. 2.9 +. 2.5 +. 2.3 +. 2.3 +. 3.1 +. 1.6 +. 2.6 +. 1.4;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE];
REPEAT STRIP_TAC;
ASM_MESON_TAC[FINITE_EMPTY;Misc_defs_and_lemmas.EMPTY_EXISTS;];
]);;
FINITE_EMPTY;;
INFINITE;;
FINITE_EMPTY;;

let INFINITE_EXISTS = prove_by_refinement (
`!S. INFINITE S ==> (?(x:A). x IN S)`,
[
REWRITE_TAC[INFINITE;GSYM Misc_defs_and_lemmas.EMPTY_EXISTS];
CONV_TAC (CONTRAPOS_CONV);
 THEN MESON_TAC[FINITE_EMPTY];

]);;

help "CONTRAPOS_CONV";;
FINITE_EMPTY;;
INFINITE;;
FINITE_EMPTY;;

search[`x IN {}`];;
Misc_defs_and_lemmas.EMPTY_EXISTS;;

FINITE_EMPTY;;
searcht 15 [`x IN S`;`{}`];;


(* save. find strange constants *)

let symbolic_of cnames = 
  let symbolchar = explode "=-~.,@#$%^&*|\\/?><" in
    filter (fun t -> not (intersect (explode t) symbolchar=[])) cnames;;

let symbolic_constants = symbolic_of (map fst (constants()));;
let symbolic_infixes = symbolic_of (map fst (infixes()));;


searcht 5 [name "CHAIN";`has_derivative`];;
apropos();;
help "apropos_derivative";;
Calc_derivative.differentiate;;
Calc_derivative.derived_form;;
Calc_derivative.differentiate `cos` `x:real` `(:real)`;;

help;;
help "help";;

type_of `vector`;;

type_of;;
let types_of = Print_types.print_term_types;;
let type_of_thm = Print_types.print_thm_types;;
let type_of_goal = Print_types.print_goal_types;;
help_grep "type";;

searcht 5 [`has_real_derivative`;`lift`];;
searcht 50 [`has_vector_derivative`;];;
searcht 50 [`has_derivative`;`has_real_derivative`];;
searcht 50 [`has_derivative`;`within`];;
searcht 15 [`($)`];;
help "search";;

help "apropos_types";;
types_of `($)`;;
has_derivative;;

type_of_thm HAS_DERIVATIVE_IMP_DIFFERENTIABLE;;
type_of_thm has_derivative;;
type_of_thm HAS_REAL_FRECHET_DERIVATIVE_AT;;

type_of `:1`;;
search [`x:1`];;



search [`func`];;
searcht 15 [`continuous`];;

map (fun t -> (t,type_of t)) (frees ` (!(y:real^6). p y ==> (continuous) (lift o f'') (at y within s))`);;


searcht 5 [`has_derivative`;name "CHAIN"];;
type_of_thm DIFF_CHAIN_AT;;
search[`has_derivative`];;





searcht 50 [`hypermap1_of_fanx`];;
hypermap1_of_fanx;;

Polyhedron.POLYHEDRON_FAN;;


Polyhedron.AMHFNXP;;

suggest();;
searcht 5 [`arclength`;`acs`];;
Trigonometry1.ACS_ARCLENGTH;;

let new_thm_name = prove_by_refinement(
  `3 + 4 = 7`,
  (* {{{ proof *)
  [
  ARITH_TAC
  ]);;
  (* }}} *)

help "ANTS_TAC";;

let arclength2 = prove_by_refinement(
  `!h.  (&1 <= h /\ h <= h0) ==> arclength (&2) (&2 * h) (&2) = acs(h / &2)`,
  (* {{{ proof *)
  [
  REPEAT STRIP_TAC;
  MP_TAC (SPECL [`&2`;`&2 * h`;`&2`] Trigonometry1.ACS_ARCLENGTH);
  BRANCH_A [
    ANTS_TAC ;
    MP_TAC Sphere.h0;
    ASM_REAL_ARITH_TAC;
  ];
  DISCH_THEN SUBST1_TAC;
  AP_TERM_TAC;
  UNDISCH_TAC `&1 <= h`;
  BY (CONV_TAC REAL_FIELD);
  ]);;
  (* }}} *)

Polyhedron.FLVNSME;;

Polyhedron.WBLARHH;;

Polyhedron.fchanged;;

searcht 25 [`cell_params`];;
FAN;;
search[name "JACO";name "WORK"];;
search[`jacobian`];;
matrix;;
search[`fchanged`];;
fan80;;
List.length (search[`fan80`]);;
constant_of_regexp "TET";;
apropos();;
help "apropos_searching";;
searcht 5 [`delta_x`;`vol`];;
conv0;;
def_assoc;;
def_of_regexp "critical";;
def_of_regexp "edgeX";;
def_of_regexp "VX";;
def_of_regexp "cell_params";;
def_of_regexp "barV";;
def_of_regexp "cycle";;
def_of_regexp "tri_itv";;
def;;
searcht 15 [`cw_dart_fan`];;
searcht 15 [`directed_angle`];;
searcht 15 [`cyclic_order`];;
searcht 15 [`pl_angle`];;
searcht 15 [`arg_diff`];;
searcht 15 [`tri_itv`];;
search [`Arg`];;
type_of_thm Trigonometry2.pl_angle;;
help "MESON_TAC";;
search [`FAN`;`&2 * pi`];;
usage_count `FAN`;;
1+1;;
usage_count `fan`;;
search [name "ULEK"];;
search [name "VBT"];;
search [name "W_SUBSET_SINGLETON"];;
search [`fan`];;
search [`polar_le`];;
List.length (search [`azim_cycle`;omit `local_fan`;omit `FAN`;omit `convex_local_fan`;omit `darts_of_hyp`;omit `EE`]);;
search [`wedge_ge`];;
usage_count `arg_diff`;;
usage_count `pl_angle`;;

let usage_count x = List.length (search [x]);;

(* marking *)
reset();;
show_marked();;

let marked = ref [];;
let show_marked() = map (fun t-> (t,assoc t !theorems)) (!marked);;
let mark s = 
  let th = assoc s (!theorems) in
  let _ = marked := s::!marked in
  th;;
let resetm() = marked:=[];;


term_match [] `s:C` `s:E->G`;;
frees_of_goal();;
`(r:B -> D) ((f:A->B) x) =  ((g:C->D) y)`;;
map types_of (gtypl [`f x`;`y`;`f`;`z:D`]);;
filter has_stv (setify (frees `f x`));;
apropos();;
help "apropos_types";;

 
let EZ_SOS_TAC equ =
  let lh = lhs equ in
  (REWRITE_TAC[REAL_ARITH `(x > y <=> y < x) /\ (x >= y <=> y <= x)`] THEN
    ONCE_REWRITE_TAC[REAL_ARITH `(x < y <=> &0 < y - x) /\ (x <= y <=> (&0 <= y - x))`]) THEN
let 
    fun (asl,w) -> 
      let eqthm = try    (REAL_FIELD eqn ) with _ -> failwith "sos_tac, REAL_FIELD failed" in
      let binop = 

rhs;;

searcht 5 [`x > y <=> x < y`];;

let equ = `(&1 - t) * (&1 pow 2) + t * (&1 - t) * (&1 pow 2) = (&1 - t pow 2)`;;
let lh = lhs equ;;
let (plus,adden) = strip_comb  lh;;
let _ = (plus = `(+)`) or failwith "sum expected";;
help_grep "strip";;
help "strip_comb";;

g `&1 + &1 = &2`;;
r,[];;

Str.split (Str.regexp "`") "`how `1` is it`";;
Str.split (Str.regexp "ab") "That is a better choice ab t";;
Str.split (Str.regexp "(\*") "^(* Start comment (* ( *) $";;

help_grep "dest";;
dest_pair `(a,b)`;;

map type_of [disjunct (`CARD`,`HAS_SIZE`)];;
search [disjunct (`HAS_SIZE`,`CARD`)];;
type_of `HAS_SIZE`;;
search [disjunct (`&0 < inv x`,`&0 < sqrt u`)];;
search [disjunct (`&0 < sqrt u`,`&0 < inv x`)];;
search [`&0 < sqrt u`];;

search[disjunct (`INJ`,`(f x = f y) ==> (x = y)`);disjunct(`CARD`,`HAS_SIZE`)];;

INJ_CARD;;

INJ_SURJ;;
suggest();;
searcht 5 [`x HAS_SIZE 0`];;
searcht 5 [`SUBSET`;`FINITE`];;
searcht 5 [`a IN {}`];;
type_of_thm
CARD_UNION_EQ;;
search[`INJ`;`IMAGE`];;
Misc_defs_and_lemmas.IMAGE_SURJ;;
Misc_defs_and_lemmas.BIJ_CARD;;
search [`SURJ`;`IMAGE`];;
search [disjunct (`INJ`,`(f x = f y) ==> (x = y)`);`FINITE`];;
search [`BIJ`;`INJ`];;
search [`INJ`;`SURJ`];;
search [`INJ`;`BIJ`];;
search [`BIJ`;`CARD`];;
search [`CARD a + CARD b`];;  


srch [`a IN {}`];;
r [ ?d0 ];;

mk_rewrites false (ASSUME `!s. s = t`) [];;

net_of_thm false (ASSUME `s = t`) empty_net;;

empty_net;;

p();;
!invariant_under_linear;;

type_of `rcone_gt`;;
type_of_thm PRESERVES_NORM_PRESERVES_DOT;;
srch [`linear`;`vec 0`];;
srch [`f x dot f y = x dot y`];;
srch [`di(x,vec 0)`];;
srch [`norm (f x) = norm x`;`dist`];;
;;

searcht 5 [`rcone_gt`];;
help_grep "GEOM";;
LINEAR_INVARIANTS;;
ROTATION_RIGHTWARD_LINE;;

srch [`IMAGE f (ball(x,r)) = ball(x,r)`];;
def_of_regexp "has_integral";;
def_of_regexp "measure";;
def_of_regexp "fchanged";;
searcht 15 [`fchanged`];;
search_thml (term_match []) [`ball`] (map (fun s -> ("",s)) (!invariant_under_linear));;
searcht 5 [`polyhedron (IMAGE f s)`];;
constant_of_regexp "rcone";;
type_of_thm(  end_itlist CONJ (!invariant_under_linear));;
FINITE_EMPTY;;
search[name "EMPTY_EXISTS"];;


let pollack_inconsistency = 
  let thm1 = prove(  `?(n:num). (t < n)`,EXISTS_TAC`t + 1` THEN ARITH_TAC) in
  let t = mk_var("n < 0 /\\ 0",`:num`) in
    INST [(t,`t:num`)] thm1;;

search[name "DOT_RE"];;
!theorems;;


let v1 = mk_var ("!m. SUC m", `:nat`) in
let th1 = REFL v1 in
let v2 = mk_var ("n", `:nat`) in
let tm1 = mk_exists (v2, mk_eq (v1,v2)) in
EXISTS (tm1,v1) th1;;

let v = mk_var ("0 < 0",`:bool`);;

Tactics.SELECT_TAC;;

Sphere.adodec;;

(* *)

search [name "TAYLOR"];;

`\x2. dih_x x1 x2 x3 x4 x5 x6`;;
type_of `dih_x`;;
mk_abs;;
mk_abs (`x2:real`,`dih_x x1 x2 x3 x4 x5 x6`);;
let xlist = [`x1:real`;`x2:real`;`x3:real`];;
let ftest i = mk_abs (i,`dih_x x1 x2 x3 x4 x5 x6`);;
map ftest xlist;;

Calc_derivative.differentiate `\x. x * atn2 (x, x + &1) ` `x:real` `(:real)`;;

REWRITE_CONV;;

    let curryl = [Calc_derivative.atn2curry] ;;
    let curry = REWRITE_CONV curryl;;
    let uncurry = REWRITE_CONV (map GSYM curryl) ;;

uncurry `\x. atn2 (x,x + &1)`;;

curry `f`;;

Rvfxzbu.RVFXZBU;;

let XX = prove_by_refinement(
  `derived_form (&0 < x1 /\ &0 < x2 /\ &0 < x6) (\x1. eta x1 x2 x6) (blah) x1 (:real)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Calc_derivative.derived_form];
  ]);;
  (* }}} *)

HAS_REAL_DERIVATIVE_TRANSFORM_WITHIN;;


(* 
Counting_spheres....
*)

!invariant_under_translation;;
searcht 10 [`dihV`;`arcV`];;
searcht 10 [`r f x y = f y x`;omit `#x`];;
VECTOR_ANGLE_ANGLE;;
search[name "ARCV_ANGLE"];;
search[`Arg`;`vector_angle`];;
searcht 10 [`azim`;`Arg`];;
(* from wlog_examples.ml *)

let TRUONG_1 = prove
 (`!u1:real^3 u2 p a b.
     ~(u1 = u2) /\
     plane p /\
     {u1,u2} SUBSET p /\
     dist(u1,u2) <= a + b /\
     abs(a - b) < dist(u1,u2) /\
     &0 <= a /\
     &0 <= b
     ==> (?d1 d2.
              {d1, d2} SUBSET p /\
              &1 / &2 % (d1 + d2) IN affine hull {u1, u2} /\
              dist(d1,u1) = a /\
              dist(d1,u2) = b /\
              dist(d2,u1) = a /\
              dist(d2,u2) = b)`,
  (*** First, rotate the plane p to the special case z$3 = &0 ***)

  GEOM_HORIZONTAL_PLANE_TAC `p:real^3->bool` 


(* bug on loading misc.ml. (next is used as a variable, but later it becomes a constant  *)
Debug.Term_of_preterm_error
 [("function head", `next`, `:(?2712096)loop->?2712096->?2712096`);
  ("function arg", `0`, `:num`)].
Error in included file /Users/thomashales/Desktop/googlecode/hol_light/Multivariate/misc.ml
- : unit = ()

File "/Users/thomashales/Desktop/googlecode/hol_light/calc_rat.ml", line 515, characters 4-160:
Error: This expression has type
         (num -> term) * conv * conv * conv * (term -> thm) * (term -> thm) *
         (term -> thm) * (term -> thm) * 'a
       but an expression was expected of type
         (thm list * thm list * thm list -> positivstellensatz -> thm) ->
         thm list * thm list * thm list -> thm

(*
let backup_proof_record = !proof_record;;
List.length backup_proof_record;;
*)

(*
let rec clean_proof_record g skip tbs  = 
   function
       [] -> (g, EVERY (List.rev tbs))
     | Gax u :: xs -> clean_proof_record [u] skip tbs xs
     | Bax::xs -> clean_proof_record g (skip+1) tbs
     | Tax (_,_,t)::xs -> if (skip<=0) then clean_proof_record g 0 (t::tbs) xs else
	 clean_proof_record g (skip-1) tbs xs;;
      
let replay (g,t) = 
  

let replay_proof gax_no count = 
  let p1 = List.nth (gax()) gax_no in
  let p2 = fst(chop_list count p1) in
  let _ = proof_record:= p2 @ !proof_record in
    replay();;

let rotate_proof n =
  let (a,b) = chop_list n (gax()) in
    List.flatten (b,a);;
*)

