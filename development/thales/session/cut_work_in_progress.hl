



(* hyp't. *)

(*
let hyp_t_exists = 
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked H NF L x /\ ~(L IN final_loops H NF) ==>
  (?t. (!NF' L'.  (transform H x) POWER t (NF,L) = (NF',L') ==>
      L' IN final_loops H NF') /\
  (!i NF' L'. i < t /\ (transform H x) POWER i (NF,L) = (NF',L') ==>
      ~(L' IN final_loops H NF')))`;;
*)

(* hyp't = new_specification... *)

(*
let transform_H_concl = 
  `transform (H,NF,L,x) = (N',NF',L',x') ==> H' = H`;;

let transform_x_concl = 
  `transform (H,NF,L,x) = (H',NF',L',x') ==> x' = x`;;
*)
let transform_z_index = new_definition
  `transform_z_index (H,NF,L,x) i = 
     (let (NF',L') = (transform H x POWER i) (NF,L) in
        (index L x (hyp'z H NF' L' x)))`;;

let transform_p_index = new_definition
  `transform_p_index (H,NF,L,x) i = 
     (let (NF',L') = (transform H x POWER i) (NF,L) in
	hyp'p H NF' L' x)`;;

(* 
let good_iso_fgraph = prove_by_refinement(
  `!x y. good_list x /\ iso_fgraph x y /\ uniq(list_of_darts y) ==> good_list y`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list;iso_fgraph;is_iso;is_Iso;is_pr_Iso;is_pr_Hom;EQ_CLASS;IMAGE_INFIX;GSYM Seq2.ALL_all;GSYM ALL_MEM]
 ...
  ]);;
  (* }}} *)
*)

(*
let list_pairs_rotate = prove_by_refinement(
  `!n x. rotate n (list_pairs x) = list_pairs (rotate n x)`,
  (* {{{ proof *)
  [
  rt[List_hypermap.list_pairs]
  ]);;
  (* }}} *)

let list_of_darts_cong = prove_by_refinement(
  `!x y. set_of_list (MAP (__cong) x) = set_of_list (MAP (__cong) y) ==>
    set_of_list (list_of_darts x) = set_of_list (list_of_darts y)`,
  (* {{{ proof *)
  [
  rt[EXTENSION;IN_SET_OF_LIST]
    st/r
  rt[List_hypermap.list_of_darts]

  ]);;
  (* }}} *)

let good_cong_eq = prove_by_refinement(
  `!x y. good_list x /\ good_list y /\ 
   IMAGE (__cong) (set_of_list x) = IMAGE (__cong) (set_of_list y) ==>
    hypermap_of_list x = hypermap_of_list y`,
  (* {{{ proof *)
  [
rt[GSYM SET_OF_LIST_MAP]
  st/r
  rt[List_hypermap.hypermap_of_list]
apterm
    rt[PAIR_EQ]
rt[List_hypermap.darts_of_list;List_hypermap.e_list_ext]


rt[List_hypermap.f_list_ext;List_hypermap.n_list_ext;List_hypermap.n_list;List_hypermap.f_list]
typ `darts_of_list x = darts_of_list y /\ list_of_darts x = list_of_darts y` ets
mt[]
  ]);;
  (* }}} *)
*)

(*
let good_iso = prove_by_refinement(
  `!x y. good_list x /\ good_list y /\ iso_fgraph x y ==>
  (iso (hypermap_of_list (x)) (hypermap_of_list (y)) \/
     iso (opposite_hypermap (hypermap_of_list (x))) (hypermap_of_list (y)))`,
  (* {{{ proof *)
  [
rt[List_hypermap.good_list;iso_fgraph;is_iso;is_Iso;is_pr_Iso;is_pr_Hom;EQ_CLASS;IMAGE_INFIX;GSYM Seq2.ALL_all;GSYM ALL_MEM]
st/r
fxa disjcase thenl [disj1;disj2]
mmp Hypermap_iso.hyp_iso_imp_iso
  ]);;
  (* }}} *)
*)


let plane_step = `!g p fs f v n e vl. 
  (Seed p, g) IN RTranCl (next_plane p) /\
  fs = nonFinals g /\
  ~(fs = []) /\
  f = minimalFace fs /\
  v = minimalVertex g f /\
  3 <= n /\ n <= maxGon p /\
  MEM e (enumerator n (LENGTH (vertices f))) /\
  ~(containsDuplicateEdge g f v e) /\
  vl = indexToVertexList f v e 
 ==>
  (Seed p, subdivFace g f vl) IN RTranCl (next_plane p)`;;  

let plane_correspondence_seed = `!H p. dih2k H p ==>
  iso H (hypermap_of_list (fgraph (Seed p)))`;;

let iso_correspondence_finals = new_definition
  `iso_corresponding_finals phi H NF g <=>
    (hyp_iso phi ((quotient H NF) ,(hypermap_of_list (fgraph g))) /\
       IMAGE (IMAGE phi) (final_quotient_faces H NF) = 
	map (darts_of_list o vertices ) (filter SND (faces g)))`;;




let subdivFace_step = new_recursive_definition list_RECURSION
  `(subdivFace_step g f u n [] = (g,f,u,[])) /\
    (subdivFace_step g f u n (vo :: vos) = 
      if (vo = NONE) then subdivFace_step g f u (SUC n) vos else
	(let v = the vo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace_step g f v 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		(g',f2,v,vos))))`;;

let subdivFace_instep = 
  `subdivFace0 g f u 0 [] = makeFaceFinal f g /\
   subdivFace0 g f u 0 vos = 
    (let (g',f',v',vos') = subdivFace_step g f u 0 vos in subdivFace0 g' f' u' 0 vos')`;;

let subdivFace_shorten = 
  `~(vos = []) /\ (g',f',v',vos') = subdivFace_step g f u n vos ==>
  LENGTH vos' < LENGTH vos`;;

let face_index_on_loop = new_definition `face_index_on_loop L f x' d i = 
  (let y = (f POWER i ) x' in
     (if y in_dart_of_loop L 
     then index L x' y
     else d))`;;

let hyp_enumeration = new_definition `hyp_enumeration L f x' n = 
  REVERSE (foldr (\i bs. CONS (face_index_on_loop L f x' (HD bs) i) bs) [0] (iota 0 n))`;;

let hyp't = new_definition `hyp't L f x' n = 
  (let rs = hyp_enumeration L f x' n in
     CARD { i | 0 < i /\ i < n /\ SUC (EL (i-1) rs) < EL i rs })`;;


(* fix *)
(*
let hyp_enumeration_enumerates = 
 `MEM (hyp_enumeration L f x' n) 
   (FILTER (\is. ~(containsDuplicateEdge g f v is)) (enumerator n (LENGTH (vertices f))))`;;


let plane_correspondence_step = `!H NF phi g p.
  (Seed p, g) IN RTranCl (next_plane p) /\
  iso_correspondence_finals phi H NF g /\
  fs = nonFinals g /\
  ~(fs = []) /\
  f = minimalFace fs /\
  v = minimalVertex g f /\
  3 <= n /\ n <= maxGon p /\
  MEM e (enumerator n (LENGTH (vertices f))) /\
  IMAGE phi qf = map (darts_of_list o vertices ) f /\
  ~(containsDuplicateEdge g f v e) /\
  vl = indexToVertexList f v e  /\
  IMAGE phi (dart_of_loop L) =  list_pairs f /\
  x in_dart_of_loop L /\
  FST (phi x) = v /\ 
  // add matching p-q data with e.
  (NF',L') = (transform H x) POWER (hyp't H NF L X)  (NF,L) 
 ==>
  (?phi'. iso_correspondence_finals phi' H NF' (subdivFace g f vl))`;;
  
let flag_correspondece = `! `;;
*)


(*
let AQIUNPP2 = prove_by_refinement(
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked (H ,NF, L, x) /\ ~(L IN final_loops H NF) 
   ==> (let (NF',L') =  (transform H x (NF,L)) in is_marked (H,NF',L',x))`,
  (* {{{ proof *)
  [
g/r
st
intro Hypermap.lemma_normal_family_transform [`H`;`NF`;`L`;`x`]
art[]
repeat (pop mp)
rt[LET_THM;transform;is_marked]
st/r
art[]
comment "1st"
conj
rt[family_transform]
set[]

"redo here "
comment "2nd"
conj
rt[in_dart_of_loop;loop1_transform]
gm lemma_generate_loop
rt[path1_transform;glue]
  ]);;
  (* }}} *)
*)


(* Added Jan 2014. *)





(*
let exists_atomize = prove_by_refinement(
  `!ni (s:(A)list). (all (\d. ~(ni d = d)) s) /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
fxast `LAST` mp
rt[GSYM Seq.all_cons]
amt[Seq.all_cons]
  ]);;
  (* }}} *)
*)

let exists_atomize = prove_by_refinement(
  `!ni f (s:(A)list).  (all (\d. ~(ni d = d)) s) /\ 
    (all (\d. ~(ni d = f d)) s) /\ 
    next_el s (LAST s) = f (LAST s) /\
    all (\d. next_el s d = f d \/ next_el s d = ni d) s /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC then g
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    nconj 2
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
    
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
  ]);;
  (* }}} *)


(* Cut May 5, 2014 *)


(* not used.
let next_g_exists = prove_by_refinement(
  `!L N g. ?next_g next_gon. 
    (let rx = loop_choice g L N in
     let           p = foldr maxn 0 (MAP sizel L) -3 in
     let  fs = nonFinals g in
     let f = minimalFace fs in
     let  v = minimalVertex g f in
     let  r = FST rx in
     let x = SND rx in
     let  k = transform_count L N r x in
     let  N' = ntrans L N r x k in
      (generatePolygon_reduction_v3 /\
	 good_list L /\
	 good_list_nodes L /\
	 is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
	  marked_list L N r x /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
          (!v. v IN vertices_set2 g
               ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
          vertices_set2 g = elements_of_list (fgraph g) ==>
      (match_quotient_list next_g L N' /\
                  // planegraphP p next_g /\
                   3 <= next_gon /\
                   next_gon <= maxGon p /\
                   (!v. v IN vertices_set2 next_g
                        ==> facesAt next_g v =
                            FILTER (\f. MEM v (FST f)) (faces next_g)) /\
                   vertices_set2 next_g = elements_of_list (fgraph next_g) /\
                   MEM next_g (generatePolygon next_gon v f g))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[RIGHT_EXISTS_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon_reduction_v3` MP_TAC THEN REWRITE_TAC[generatePolygon_reduction];
  DISCH_THEN (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    REWRITE_TAC[PAIR_EQ2];
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`g'`;`i`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

new_specification ["next_g_v3";"next_gon_v3"]
  (REWRITE_RULE[SKOLEM_THM] next_g_exists);;
*)


(* ............... END NEW DEFS *)



marked_list;;
generatePolygon_reduction;; (* L' N' (ntrans L' N' r' x' k) g p=fold' *)
transform_assumption;;
mem_makeFaceFinal_generatePolygon;;
transform_assumption;;
iso_list_newvertex_lemma;;
finalGraph;;
good_graph;;
normal_list_size_bound;;

(* SET ASIDE A BIT:::: *)


let match_quotient_list_size = prove_by_refinement(
  `!g L N. match_quotient_list g L N ==> 
    sizel (filter SND (faces g)) <= sizel N`,
  (* {{{ proof *)
  [
  rt[match_quotient_list]
  ]);;
  (* }}} *)

match_quotient_list;;

1;;

(* then XZAJELF *)
(* come back *)




1;;




(* add a better induction principle, f'' face, u in f''.
   increasing sequence of vs in f. *)

(*
let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
//     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
//     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  conj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  conj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)
*)


let split_face_all_mem = prove_by_refinement(
  `!ts f u v ws f1 f2.
   all (\t. MEM t (FST f)) ts /\ 
   ~(u = v) /\ 
   uniq (FST f) /\
   pairwisel (\i j. indexf u (i) (FST f) < indexf u (j) (FST f)) ts /\
    indexf u v (FST f) < indexf u (HD ts) (FST f) /\
    split_face f u v ws = f1,f2 
    ==>
    all (\t. MEM t (FST f2)) ts
`,
  (* {{{ proof *)
  [
  listinduct
  art[GSYM Seq.allP;MEM]
  rt[pairwisel;HD;Seq.all_cons]
  g/r
  condcase then art[]
  rt[GSYM Seq.allP;MEM]
  rt[split_face]
  repeat LET_TAC
  rt[PAIR_EQ] then st/r
  fexp "f2"
  fexp "f2'"
  rt[vertices_face_FST]
  rt[MEM_APPEND;MEM]
  typ `MEM h (betwn vs v u)` ets
  mt[]
  fexp "vs"
  typ `indexf u h (FST f) <= sizel (FST f)` sat
  rt[indexf_le_sizel]
  TYPIFY `MEM v (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM u (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`v`]) THEN ASM_TAC THEN ARITH_TAC);
  intro betwn_cases [`FST f`;`v`;`h`;`u`]
  art[]
  strip/r then art[]
  repeat (fxast `indexf` mp) then art[] then ARITH_TAC
  repeat (fxast `indexf` mp) then asimp[indexf_refl;arith `~(x < 0)`]
  fxa mp
  repeat (gm indexf_betwn_eq)
  art[]
  asm then ARITH_TAC
  st/r then art[]
  fxa (C intro [`f`;`u`;`v`;`ws`;`f1`;`f2`])
  art[]
  typ `indexf u v (FST f) < indexf u (HD t) (FST f) /\ MEM h (FST f2)` ets
  mt[]


xxd  

  ]);;
  (* }}} *)



let subdivFace0_induct2 = prove_by_refinement(
  `!B vs g f u n.
     (!f' g. B g ==> B (makeFaceFinal f' g)) /\
     B g /\
     MEM f (faces g) /\
     MEM u (FST f) /\
     all (\t. MEM (the t) (FST f)) (filter isSome vs) /\
     pairwisel (\i j. indexf u (the i) (FST f) < indexf u (the j) (FST f)) 
     (filter isSome vs) /\
     (!g u v f'' n.
          B g /\
          MEM f'' (faces g) /\
          MEM u (FST f'') /\
          MEM v (FST f'') /\
          (~(n = 0) \/ ~(nextVertex f'' u = v))
          ==> (let ws = upt (countVertices g) (countVertices g + n) in
               let f1,f2,g' = splitFace g u v f'' ws in B g'))
     ==> B (subdivFace0 g f u n vs)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[HD;NOT_CONS_NIL;Seq.filter;GSYM Seq.allP;MEM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    subconj
    REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome;MEM]);
    dt
    fxast `pairwisel` mp then art[Ssrbool.isSome;MEM]
  COMMENT "second case";
  REPEAT LET_TAC;
    TYPIFY `isSome h` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
  typ `MEM v (FST f)` sat
      FULL_EXPAND_TAC "v";
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_REWRITE_TAC[MEM]);
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP];
    subconj
    BY(REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[MEM]);
    dt
    fxast `pairwisel` mp
    art[pairwisel]
    condcase then art[pairwisel]
   gtyp `!w ts. pairwisel (\i j. indexf w (the i) (FST f) < indexf w (the j) (FST f)) ts = pairwisel (\i j. indexf w i (FST f) < indexf w j (FST f)) (MAP the ts)` (unlist rt)
   rt[GSYM pairwise_o]
 dt
    mmp pairwise_lt_shift
  typ `u` ex
  art[]
  gm HD_MAP
  asimp[arith `x < y:num ==> x <= y`]

  COMMENT "third case";
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  (ASM_REWRITE_TAC[GSYM DE_MORGAN_THM])
  ants
  fxa mp then mt[]
  repeat LET_TAC
  rule(rr[PAIR_EQ])
  asm then st/r
  fexp "f1"
  fexp "f2"
  fexp "g'"
  art[]
  subconj
  intro MEM_splitFace2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  subconj
  intro splitFace2_vertex2 [`g`;`u`;`v`;`f`;`ws`]
  repeat LET_TAC
  amt[PAIR_EQ]
  dt
  repeat (fxast `CONS` mp) then art[MEM;pairwisel] then st/r
  typ `filter isSome t = []` asmcase
  art[pairwisel;MEM;GSYM Seq.allP]
  fxast `T` mp then art[] then st/r

  rt[GSYM Seq.allP]
  ... problem here.
  ]);;
  (* }}} *)


let ETDLJXT = prove_by_refinement(
  `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`,
  (* {{{ proof *)
  [
  ...

  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;good_vertices_set2_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  TYPED_ABBREV_TAC `mf = minimalFace (nonFinals g)`;
  MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] subdivFace0_induct);
  DISCH_THEN (C INTRO_TAC [`\r. vertices_set2 r = elements_of_list (fgraph r)`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[fgraph_makeFaceFinal;vertices_set2_makeFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g''";
  REWRITE_TAC[fgraph;vertices_set2;faces_graph;vertices_graph];
  REWRITE_TAC[countVertices];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  FIRST_X_ASSUM kill;
  REPEAT (FIRST_X_ASSUM_ST `replacefacesAt` kill);
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN REWRITE_TAC[PAIR_EQ] THEN REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[face_def];
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f2";
  REPLICATE_TAC 4 (FIRST_X_ASSUM kill);
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[MAP];
  FULL_EXPAND_TAC "vs'";
  REPLICATE_TAC 5 (FIRST_X_ASSUM kill);
  FIRST_X_ASSUM_ST `vertices_set2` MP_TAC THEN ASM_REWRITE_TAC[vertices_set2;vertices_graph];
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  REPEAT (FIRST_X_ASSUM_ST `x = x` kill);
  REWRITE_TAC[upt0];
  REWRITE_TAC[Import_tame_classification.upt;GSYM Seq.size;Seq.size_iota];
  REWRITE_TAC[arith `n' + (n' + n:num) - n' = n' + n`;arith `(n'+n:num) - n' = n`];
  REWRITE_TAC[set_of_list_flatten_APPEND];
  REWRITE_TAC[concat_flatten];
  REWRITE_TAC[APPEND_NIL];
  REWRITE_TAC[SET_OF_LIST_APPEND];
  (REWRITE_TAC[set_of_list])

...


  ]);;
  (* }}} *)


subdivFace0_induct;;



1;;
(* *************************************************************************** *)
(* DEAD WORK *)
(* *************************************************************************** *)


(* plane graphs good *)


(* replaced with planegraph_induct
let PlaneGraphs_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. PlaneGraphs g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[PlaneGraphs];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  TYPIFY_GOAL_THEN `!g. ((?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?m. g IN planeGraphsP m))` (unlist REWRITE_TAC);
    BY(MESON_TAC[]);
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`m`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane m x))`;`\ x y. (x = Seed m) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed m`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)
*)

let planeGraphs_transpose = prove_by_refinement(
   `!g. PlaneGraphs g ==> (!d. MEM d (list_of_darts (fgraph g))
                 ==> MEM (SND d,FST d) (list_of_darts (fgraph g)))`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC PlaneGraphs_induct;
  REWRITE_TAC[mem_transpose_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  fxa mp
  ort[EQ_SYM_EQ]
  dt
  fxast `list_of_darts` mp
  INTRO_TAC nonFinals_subdivFace0_induct [`(\g. MEM d (list_of_darts(fgraph g)) ==> MEM (SND d, FST d) (list_of_darts(fgraph g)))`]
rt[]
fexp "g'"
dt
rule (  orr[taut `((a ==> a' ==> b ==> c) <=> ((a /\ a') ==> (b ==> c)))`])
fxa mmp
  REWRITE_TAC[fgraph_makeFaceFinal];
art[]
gm mem_minimalFace_nonFinals
art[]
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
dt
comment "next"
fxast `splitFace` mp
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
fxast `Face` mp
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  fexp "g'";
fxast `list_of_darts` mp
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
fexp "fs"
repeat (fxast `replacefacesAt` kill)
fxast `REPLICATE` kill
repeat (fxast `betwn vs u v = vs'` kill)
fexp "f2"
fexp "f1"
fxast `faceListAt` kill
fxast `heights` kill
repeat (fxast `x = x` kill)
rt[MAP_APPEND]
fexp "f1'"
rt[MAP]
rt[vertices_face_FST]
rt[APPEND_cat]
rt[List_hypermap.list_of_darts_cat]
...
  #
  ]);;
  (* }}} *)


let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

(* XX Added Jan 2014. *)


(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)



let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]
  ...
  ]);;
  (* }}} *)


(* CUT JULY 3, 2014 *)

(* ------------------------------------------------------------ *)
(*  UNFINISHED STUFF *)
(* ------------------------------------------------------------ *)

let subdivFace_reduction = new_definition'
  `subdivFace_reduction_v3 <=> 
  (!L N N' g g' p fs f v k r x uvns.
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          newvertex_prepped L N r x /\
          marked_list L N r x /\
          ~final_list L r /\
          match_quotient_list g L N /\
          ~finalGraph g /\
          planegraphP p g /\
	  good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          uvns = core_triple g L N /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          g' = subdivFaceFinal2 g f uvns
      ==>
      fgraph g' = quotient_list L N' /\ 
      vertices_set2 g' = elements_of_list (fgraph g') /\
      good_faces_v3 g')
   `;;


let facesAt_uniq = prove_by_refinement(
  `!g g' y z' h newVs.
     sizel (faceListAt g) = countVertices g /\
        SND (SND (splitFace g (FST y) (FST z') h newVs)) = g' /\
    (!v. v IN vertices_set2 g ==> uniq (facesAt g v)) ==>
    (!v. v IN vertices_set2 g' ==> uniq (facesAt g' v))`,
  (* {{{ proof *)
  [
    st/r
      intro sizel_faceListAt_splitFace [`g`;`g'`;`h`;`newVs`;`y`;`z'`]
  art[]
  dt
  rt[facesAt]
  typ `all (uniq) (faceListAt g')` ets
  rt[sym Seq.allP] then st/r
  pop mmp
  mmp mem_el_index
  art[]
  fxast `vertices_set2` mp
  rt[vertices_set2_countVertices]
  comment "down to 1"

   ...
   fexp "g'"
   rt[facesAt;faceListAt;splitFace] then st/r
  repeat LET_TAC
  rt[GRAPH]
  typ `all (uniq) Fs'''''` ets
  rt[sym Seq.allP] then st/r
  pop mmp
  mmp mem_el_index
  abbrev `g' = SND (SND (splitFace g (FST y) (FST z') h newVs))`

  ...
  ... need size of Fs'''''
  ]);;
  (* }}} *)

let good_faces_criteria = prove_by_refinement(
  `!L N r x N' g g'.
    fgraph g = quotient_list L N /\
    r_rtrans_eq L N r x /\
    transform_assumption_v2 L /\
    is_restricted (hypermap_of_list L) /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    newvertex_prepped L N r x /\
    ~final_list L r /\
    ntrans L N r x 1 = N'  /\
    good_faces_v3 g /\
    vertices_set2 g = elements_of_list (fgraph g) /\
    fgraph g' = quotient_list L N' /\
    T // ...criteria here...
    ==> (good_faces_v3 g')
    `,
  (* {{{ proof *)
  [
  rt[good_faces]
  st/r
    ...
  ]);;
  (* }}} *)

good_faces;;


let subdivFace0_alt_next_el_k = prove_by_refinement(
  `!g f u  v w vos vos'.
    all (isSome) vos /\
    nextVertex f u = the (HD vos) /\
    (!i. i < ...
    all (nextVertex (
    nextVertex f u = (the v) ==>
    subdivFace0_alt g f u 0 (cat vos vos') = 
    subdivFace0_alt g f (the v) 0 vos`,
  (* {{{ proof *)
  [
  REWRITE_TAC[subdivFace0_alt];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!v:(num)option. isSome v ==> ~(v = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GSYM not_isSome_NONE]);
  BY(ASM_SIMP_TAC[LET_THM])
  ]);;
  (* }}} *)

subdivFace0_alt;;

let subdivFace0_alt_none_segment = prove_by_refinement(
  `!g f u n vs.
    vs = cat vs' vs'' /\
    isSome v /\ isSome v3 /\
    vs' = v :: (rcons v2 v3) /\
    ~(v2 = []) /\
    all (\t. t = NONE) v2 ==>
    sbudivFace0_alt g f u 0 vs = 
	(let ws = iota (countVertices g) (n) in 
	 let f1,f2,g' = splitFace g u (the v3) f ws in
	   subdivFace0_alt g' f2 (the v3) 0 vs''`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let core_triple = prove_by_refinement(
  `#`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)


let subdivFaceFinal2_subdivFace = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  subdivFaceFinal2 g f uvns = subdivFaceFinal
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)

triple_data;;
subdivFace0_alt2;;
subdivFaceFinal2;;
subdivFace;;

let match_quotient_list_reduction = prove_by_refinement(
  `!L N N' g g' p fs f v k r x uvns.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\
      ~finalGraph g /\
      planegraphP p g /\
      (!v. v IN vertices_set2 g
           ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      uvns = core_triple g L N /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      r,x = loop_choice g L N /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k /\
      g' = subdivFaceFinal2 g f uvns ==>
  set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET
         set_of_list (filter (final_list L) N')
    `,
  (* {{{ proof *)
  [
  ...
  ]);;
  (* }}} *)



let subdivFace_generatePolygon_reduction = prove_by_refinement(
  `subdivFace_reduction_v3 /\    
    (!(L:((num)list)list). good_list L /\ good_list_nodes L ==>
  	   transform_assumption_v2 L) // AQ
  ==>
    generatePolygon_reduction_v4`,
  (* {{{ proof *)
  [
  rt[generatePolygon_reduction;subdivFace_reduction]
  st/r
  rep 7 (pop (mp o sym))
  st/r
  abbrev `uvns = core_triple g L N`
  abbrev `g' = subdivFaceFinal2 g f uvns`
  typ `g'` ex
  fxa (C intro [`L`;`N`;`N'`;`g`;`g'`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`])
  art[]
  simp[]
  st/r
  rt[generatePolygon]
  art[match_quotient_list]
  ]);;
  (* }}} *)

subdivFace_reduction;;
match_quotient_list;;


(* Cut July 4, 2014 *)

(* doesn't work without conditions.
let dest_triple0_alt = prove_by_refinement(
  `!f sofar uvn uvns. dest_triple0 f sofar [] = sofar /\
     dest_triple0 f sofar (uvn :: uvns) =
     (let u,v,n = uvn in
      let ns = nseq n NONE in
      let u0 = the (LAST sofar) in
      let b = MAP SOME (betwn f u0 u) in
      if sofar = []
      then dest_triple0 f (flatten [sofar; [SOME u]; ns; [SOME v]]) uvns
      else if u0 = u
      then dest_triple0 f (flatten [sofar; ns; [SOME v]]) uvns
      else  dest_triple0 f (flatten [sofar; b; [SOME u]; ns; [SOME v]])
                     uvns)`,
  (* {{{ proof *)
  [
  st/r
  repeat (LET_TAC)
  art[dest_triple0;LET_THM]
  condcase then art[]
  condcase then art[]
  condcase then art[]
  fexp "b"
  typ `betwn 
  ]);;
  (* }}} *)
*)

(* first failed attempt.

let subdivFace0A = new_recursive_definition list_RECURSION
  `subdivFace0A g f uo n [] = (f,g) /\
    subdivFace0A g f uo n (vo :: vos) = 
      if (uo = NONE) then subdivFace0A g f vo 0 vos else
      if (vo = NONE) then subdivFace0A g f uo (SUC n) vos else
	(let v = the vo in
	 let u = the uo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace0A g f vo 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		subdivFace0A g' f2 vo 0 vos))`;;

let subdivFace0_alt_subdivFace0A = prove_by_refinement(
  `!vos g f u n.  
      (~(vos = []) /\ SOME u = (HD vos) 
       ==>   subdivFace0A g f NONE 0 vos = subdivFace0_alt g f (u) 0 (TL vos) ) /\
    (subdivFace0A g f (SOME u) n vos = subdivFace0_alt g f u n vos)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL;HD;TL;subdivFace0A;subdivFace0_alt;Tame_list.not_some_none];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT LET_TAC;
  TYPIFY `u' = u` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[the_some]);
  TYPIFY `f1 = f1' /\ f2 = f2' /\ g' = g''` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "u";
    BY(REPLICATE_TAC 2 ( POP_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[PAIR_EQ]);
  ASM_REWRITE_TAC[];
  TYPIFY `h = SOME v` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Tame_list.some_the])
  ]);;
  (* }}} *)

let subdivFace_subdivFace0A = prove_by_refinement(
  `!vos g f.  ~(vos = []) /\ isSome (HD vos) ==>
    subdivFace g f vos = 
    (let (f',g') = subdivFace0A g f NONE 0 vos in makeFaceFinal f' g') `,
  (* {{{ proof *)
  [
  SIMP_TAC[Reduction1.subdivFaceFinal_eq];
  REWRITE_TAC[subdivFaceFinal];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM;LAMBDA_PAIR];
  TYPIFY `subdivFace0A g f NONE 0 vos = subdivFace0_alt g f (the (HD vos)) 0 (TL vos)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INTRO_TAC subdivFace0_alt_subdivFace0A [`vos`;`g`;`f`;`the (HD vos)`;`0`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Tame_list.some_the;
  BY(ASM_MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

*)


(* 0D 
let subdivFace0D = new_definition'
  `subdivFace0D ((uo,n),f,g) voss = 
  if voss = [] then ((uo,n),f,g) else
    (let vo,vos = HD voss, TL voss in
       if (uo = NONE) then ((vo,0),(f,g)) else
	 if (vo = NONE) then ((uo,SUC n),f,g) else
	   (let v = the vo in
	    let u = the uo in
	      if (nextVertex f u = v /\ n = 0) then ((vo,0),f,g) else
		(let ws = upt (countVertices g) (countVertices g + n) in
		 let (f1,f2,g') = splitFace g u v f ws in
		   ((vo,0),f2,g'))))`;;
*)

let foldl_subdivFac0D = 0;;
let foldl_subdivFace0D = 0;; (* now 0C *)

(*
let triple_data_nonnil_deprecated = prove_by_refinement(
  `!g L N r x. 
    transform_assumption_v2 L /\
            good_list L /\
            good_list_nodes L /\
            marked_list L N r x /\
       loop_choice2 g L N = r,x /\
       ~(final_list L r) 
  ==> ~(triple_data2 g L N = [])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[triple_data2];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[MAP_EQ_NIL];
  FULL_EXPAND_TAC "zp";
  MATCH_MP_TAC zip_eq_nil;
  FULL_EXPAND_TAC "ys";
  FULL_EXPAND_TAC "zs";
  REWRITE_TAC[Tame_list.filter_nil;GSYM Seq.hasP];
  FIRST_X_ASSUM_ST `r',x' = r,x` (MP_TAC o GSYM);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "r'";
  FULL_EXPAND_TAC "x'";
  TYPIFY `w = f_list L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC List_hypermap.uniq_find_face;
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `!u. MEM u (find_face L x) ==> MEM u f` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "f";
    GMATCH_SIMP_TAC (GSYM Reduction1.mem_rotate_to2);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC List_hypermap.mem_f_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `0 < k` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "k";
    REWRITE_TAC[arith `0 < t <=> ~(t = 0)`];
    DISCH_TAC;
    INTRO_TAC (GEN_ALL Kbwpbhq.final_list_transform_count) [`0`;`L`;`N`;`r`;`x`];
    BY(ASM_REWRITE_TAC[trans0]);
  TYPIFY `!u. MEM u r ==> find_list N u  = r` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC Tame_list.find_list_uniq;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[marked_list;normal_list]);
  CONJ_TAC;
    TYPED_ABBREV_TAC `y = ytrans L N r x 0`;
    TYPIFY `y` EXISTS_TAC;
    INTRO_TAC Kbwpbhq.KBWPBHQ1 [`L`;`N`;`r`;`x`;`y`];
    ASM_REWRITE_TAC[];
    SUBANTS_TAC;
      SUBCONJ_TAC;
        BY(ASM_MESON_TAC[Hojodcm.ytrans_mem_rtrans_v0]);
      DISCH_TAC;
      BY(ASM_MESON_TAC[Pplhulj.ytran_me_f]);
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    TYPIFY `next_el f y = f_list L y` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[List_hypermap.f_list];
    FULL_EXPAND_TAC "f";
    GMATCH_SIMP_TAC (GSYM Pwssrat.next_el_rotate);
    REWRITE_TAC[];
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC List_hypermap.mem_f_list;
    ASM_REWRITE_TAC[];
    INTRO_TAC List_hypermap.mem_find_face_imp_faces_eq [`y`;`x`;`L`];
    ASM_REWRITE_TAC[];
    SUBANTS_TAC;
      BY(ASM_MESON_TAC[List_hypermap.good_list]);
    BY(SIMP_TAC[]);
  TYPED_ABBREV_TAC `z = ztrans L N r x 0`;
  TYPIFY `z` EXISTS_TAC;
  SUBCONJ_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[Hojodcm.ztran_me_f_v0]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Hojodcm.mem_ztrans_rtrans_v0]);
  DISCH_TAC;
  INTRO_TAC Kbwpbhq.KBWPBHQ2 [`L`;`N`;`r`;`x`;`ztrans L N r x 0`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[ Hojodcm.ztran_me_f_v0]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `?` MP_TAC;
  ASM_SIMP_TAC[];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  TYPIFY_GOAL_THEN `(?i. ztrans L N r x i = z /\ i < k)` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `prev_el f z = prev_el (find_face L z) z` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    GMATCH_SIMP_TAC List_hypermap.f_list_inverse;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.good_list]);
    BY(ASM_MESON_TAC[Hojodcm.ztran_me_f_v0;List_hypermap.mem_find_face_imp_mem_darts]);
  (FULL_EXPAND_TAC "f");
  GMATCH_SIMP_TAC (GSYM prev_el_rotate_to);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC List_hypermap.mem_f_list;
  ASM_REWRITE_TAC[];
  AP_THM_TAC;
  AP_TERM_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC List_hypermap.mem_find_face_imp_faces_eq;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.good_list])
  ]);;
  (* }}} *)
*)

(* cut July 5, 2014 *)

(*
let generatePolygon_explicit = new_definition'
  `generatePolygon_explicit_v4 <=> (!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v4 L N r x /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
	 match_quotient_list g' L N' /\
	 good_faces_v3 g' /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  ))`;;
*)

(*
let generateNonfinalPolygon_explicit = new_definition'
  `generateNonfinalPolygon_explicit_v6 <=> (!L:((num)list)list N N' g p fs f v k r x uvns g' i.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
          planegraphP p g /\
          good_faces_v3 g /\
          vertices_set2 g = elements_of_list (fgraph g) /\
          p = foldr maxn 0 (MAP sizel L) - 3 /\
          uvns = core_triple_v4 L N r x /\
          g' = subdivFaceFinal2 g f uvns /\
          fs = nonFinals g /\
          f = minimalFace fs /\
          v = minimalVertex g f /\
          r,x = loop_choice2 g L N /\
          k = transform_count L N r x /\
          N' = ntrans L N r x k /\
          i = sizel (find_face L x)
    ==>
      (
	transform_assumption_v2 L /\					   
	  list_pairs (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) = rtrans L N r x k /\ 
	  fgraph g' = quotient_list L N' /\
	  good_faces_v3 g' /\
          vertices_set2 g' = elements_of_list (fgraph g') /\
	  MEM g' (generatePolygon i v f g)
  ))`;;
*)

(*
let generatePolygon_explicit_reduction = prove_by_refinement(
  `generatePolygon_explicit_v4 ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  REWRITE_TAC[generatePolygon_reduction;generatePolygon_explicit];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `uvns = core_triple_v4 L N r x`;
  TYPED_ABBREV_TAC `g' = subdivFaceFinal2 g f uvns`;
  TYPED_ABBREV_TAC `i = sizel (find_face L x)`;
  GEXISTL_TAC [`g'`;`i`];
  TYPIFY `3 <= i /\ i <= maxGon p` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    DISCH_THEN kill;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`N`;`p`;`fs`;`k`;`r`;`x`;`uvns`];
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "i";
  TYPIFY `MEM (find_face L x) (list_of_faces L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.mem_find_face;
    MATCH_MP_TAC Pplhulj.marked_list_of_dart;
    BY(GEXISTL_TAC [`N`;`r`] THEN ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    MATCH_MP_TAC Tame_list.is_restricted_size_face;
    TYPIFY `L` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  ASM_REWRITE_TAC[maxGon];
  ONCE_REWRITE_TAC[GSYM Tame_list.map_size_list_of_faces];
  INTRO_TAC Tame_list.foldr_size_max [`list_of_faces L`;`find_face L x`];
  ASM_REWRITE_TAC[];
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)
*)

(*
let generateNonfinalPolygon_reduction = prove_by_refinement(
  `generateNonfinalPolygon_explicit_v6 ==> generatePolygon_reduction_v7`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC generatePolygon_explicit_reduction;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[generateNonfinalPolygon_explicit;generatePolygon_explicit;match_quotient_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(transform_assumption_v2 L /\ list_pairs               (FST (FST (subdivFace0_alt2 g f (countVertices g) uvns))) =              rtrans L N r x k /\ fgraph g' = quotient_list L N') ==> set_of_list (MAP (list_pairs o FST) (filter SND (faces g'))) SUBSET   set_of_list (filter (final_list L) N')` ENOUGH_TO_SHOW_TAC;
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
    DISCH_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`N'`;`g`;`p`;`fs`;`f`;`v`;`k`;`r`;`x`;`uvns`;`g'`;`i`]);
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `generatePolygon` kill;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "g'";
  REWRITE_TAC[REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  MATCH_MP_TAC SUBSET_TRANS;
  TYPIFY `set_of_list (MAP (list_pairs o FST) (setFinal(FST (subdivFace0_alt2 g f (countVertices g) uvns)) :: (finals g)))` EXISTS_TAC;
  CONJ_TAC;
    REWRITE_TAC[SET_OF_LIST_MAP];
    MATCH_MP_TAC IMAGE_SUBSET;
    INTRO_TAC subdivFaceFinal2_finals [`uvns`;`g`;`f`;`(countVertices g)`];
    ANTS_TAC;
      CONJ_TAC;
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.minimalFace_face;
        BY(ASM_REWRITE_TAC[]);
      DISCH_TAC;
      TYPIFY `MEM f (nonFinals g)` (C SUBGOAL_THEN MP_TAC);
        FULL_EXPAND_TAC "f";
        FULL_EXPAND_TAC "fs";
        MATCH_MP_TAC Tame_list.mem_minimalFace_nonFinals;
        BY(ASM_MESON_TAC[Tame_defs.finalGraph]);
      REWRITE_TAC[nonFinals;MEM_FILTER];
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[set_of_list];
    BY(SET_TAC[]);
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;MEM;o_THM;Tame_list.fst_setFinal;MAP];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[];
    POP_ASSUM kill;
    FIRST_X_ASSUM_ST `rtrans` (SUBST1_TAC o GSYM);
    REWRITE_TAC[upper_case;MEM_FILTER];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Kbwpbhq.final_list_transform_count]);
    FULL_EXPAND_TAC "N'";
    MATCH_MP_TAC AQ6_INDUCT;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `SUBSET` MP_TAC;
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;REWRITE_RULE[lower_case] (GSYM Tame_defs.finals)];
  DISCH_THEN (C INTRO_TAC [`x'`]);
  ASM_REWRITE_TAC[];
  INTRO_TAC ntrans_final_list [`k`;`L`;`N`;`r`;`x`;`x'`];
  FIRST_X_ASSUM_ST `rtrans` (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[arith `k <= k:num`];
  REWRITE_TAC[Seq.mem_filter];
  SIMP_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

(*
let triple_data = new_definition'
  `!g L N. triple_data_v3 g L N = 
    (
      let (r,x) = loop_choice2 g L N in
      let k = transform_count L N r x in
	MAP (\i. (ytrans L N r x i,ztrans L N r x i, 
		  betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) 
	  (iota 0 k))`;;

let core_triple = new_definition'
  `core_triple_v3 g L N = 
  MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) (triple_data_v3 g L N)`;;
*)




let dest_triple_rcons = prove_by_refinement(
  `!uvns f  (u:A) v w n.
    ~(uvns = []) ==>
    (let v' = FST(SND (LAST uvns)) in
       (dest_triple0 f [] (rcons uvns (u,v,n)) = 
	 cat (butlast (dest_triple0 f [] (uvns))) (dest_triple0 f [SOME v'] [(u,v,n)]) /\ 
       (~(w = FST (HD uvns)) /\ next_el f w = FST (HD uvns) ==>
       dest_triple0 f [SOME w] (rcons uvns (u,v,n)) = 
	 cat (butlast (dest_triple0 f [SOME w] (uvns))) (dest_triple0 f [SOME v'] [(u,v,n)]))))
    `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC then rt[NOT_CONS_NIL;LAST;dest_triple0;Seq.rcons_cons]
  g/r
  typ `h` spec1
  rt[FORALL_PAIR_THM]
  rt[LET_THM;LAMBDA_PAIR;LAMBDA_TRIPLE]  
  gv "u1"
  gv "v1"
  gv "n1"
  asimp[HD;the_some;FST;Seq.rcons]
  rt[Seq.flatten_cons;Seq.cat0s;Seq.catA;Seq.flatten0;Seq.cats0]
  repeat (gm dest_triple0_cat)  
  rt[NOT_CONS_NIL;Seq.cats0]
  comment "t nil"
  typ `t = []` asmcase then art[the_some;Seq.rcons]
  rt[dest_triple0;NOT_CONS_NIL]
  rt[LET_THM;LAST;the_some]
  rt[Seq.flatten_cons;Seq.cat0s;Seq.catA;Seq.flatten0;Seq.cats0]
  rt[Seq.cats1;butlast_rcons]
  mt[]
...
  conj
  repeat (apthm orelse apterm)
...
  rt[Seq.flatten_cons;Seq.cat0s;Seq.catA;Seq.flatten0;Seq.cats0]
  repeat (gm dest_triple0_cat)  
  rt[NOT_CONS_NIL;Seq.cats0]



  typ `
  st/r
  intro dest_triple0_foldl_steps  [`rcons uvns (u,v,n)`;`f`;`[]:(((A)option)list)list`]
  simp[Seq.flatten0;sym Seq.cats1]
  rt[Seq.foldl_cat]
  intro dest_triple0_foldl_steps  [`uvns`;`f`;`[]:(((A)option)list)list`]
  simp[Seq.flatten0;sym Seq.cats1]

  ]);;
  (* }}} *)

dest_triple0_step;;

(* CUT JULY 11 2014 *)

(*
  DISCH_TAC;
  INDUCT_TAC;
    COMMENT "0 case";
    REWRITE_TAC[arith `~(0 < 0)`;nfgtrans0;Reduction2.trans0];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 2;
      REWRITE_TAC[b_nfgtrans0];
      BY(REWRITE_TAC[LET_THM]);
    ASM_REWRITE_TAC[];
    nCONJ_TAC 2;
      MATCH_MP_TAC minimalFace_core;
      GEXISTL_TAC [`N`;`x`;`g`;`fs`;`v`];
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      FIRST_X_ASSUM_ST `match_quotient_list` MP_TAC;
      BY(MESON_TAC[match_quotient_list]);
    DISCH_TAC;
    MATCH_MP_TAC Reduction1.sizel_faceListAt;
    REWRITE_TAC[Tame_list.planegraph_P];
    TYPIFY `p` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "induction step";
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`g`;`p`;`fs`;`f`;`v`;`r`;`x`;`fx`;`uvns`]);
  ASM_REWRITE_TAC[arith `0 < SUC i`];
  TYPED_ABBREV_TAC `g' = SND (SND (nfgtrans' (countVertices g,f,g) L N r x i))`;
  TYPED_ABBREV_TAC `f' = FST (SND (nfgtrans' (countVertices g,f,g) L N r x i))`;
  DISCH_THEN (C INTRO_TAC [`g'`;`f'`]);
  ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `newVs = MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i))`;
  COMMENT "general hypotheses";
  TYPIFY `i < transform_count L N r x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i < k`]);
  INTRO_TAC AQIUNPP [`L`;`N`;`r`;`x`;`i`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Reduction2.elements_of_list_vertices_set2_converse [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `element_pre L (ntrans L N r x i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[element_pre]);
  INTRO_TAC Reduction2.elements_of_list_vertices_set2_converse [`L`;`N`;`r`;`x`;`g`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[match_quotient_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `element_pre L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[element_pre]);
  INTRO_TAC lnrx_induction [`i`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `~final_list L (rtrans L N r x i)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  INTRO_TAC nfgtrans_mem [`i`;`countVertices g`;`f`;`g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    ASM_SIMP_TAC[arith `i < k ==> i <= k:num`];
    FULL_EXPAND_TAC "f";
    FULL_EXPAND_TAC "fs";
    BY(ASM_SIMP_TAC[ Tame_list.minimalFace_face]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  FIRST_X_ASSUM_ST `countVertices` (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  DISCH_TAC;
  TYPIFY `(SND (nfgtrans' (countVertices g,f,g) L N r x (SUC i))) = (fi,gi)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "fi";
    FULL_EXPAND_TAC "gi";
    BY(REWRITE_TAC[GSYM PAIR_EQ]);
  TYPIFY `(SND (nfgtrans' (countVertices g,f,g) L N r x i)) = (f',g')` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f'";
    FULL_EXPAND_TAC "g'";
    BY(REWRITE_TAC[GSYM PAIR_EQ]);
  COMMENT "fst nfgtrans";
  INTRO_TAC nfgtrans_fst [`i`;`f`;`g`;`countVertices g`;`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM;LAMBDA_TRIPLE];
  (DISCH_TAC)
    INTRO_TAC Reduction1.loop_choice_props [`L`;`N`;`r`;`x`;`g`;`f`;`v`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      CONJ_TAC;
        BY(ASM_MESON_TAC[marked_list]);
      MATCH_MP_TAC Tame_list.quotient_all_uniq;
      BY(ASM_MESON_TAC[]);
  st/r
    typ `core L r = FST f` sat
          MATCH_MP_TAC minimalFace_core;
      GEXISTL_TAC [`N`;`x`;`g`;`fs`;`v`];
      BY(ASM_REWRITE_TAC[]);

  comment "setK7"
  typ `iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) = newVs /\ prev_el (core L (rtrans L N r x i)) v,v = x ` sat
  fxast `assumption_setK7` mp then rt[assumption_setK7]
  abbrev `vs  = dest_triple_full (core L r) v uvns` 
  dthen (C intro [`L`;`N`;`r`;`x`;`transform_count L N r x`;`uvns`;`vs`;`MAP the (filter isSome vs)`;`fx`;`v`])
  art[]
  asimp[]


  comment "splitFace formula"
  typ `SND (splitFace g' (FST (ytrans L N r x i)) (FST (ztrans L N r x i)) f' newVs) = (fi,gi)` sat
  intro nfgtrans_suc [`i`;`countVertices g`;`f`;`g`;`L`;`N`;`r`;`x`]
  art[]
  LET_TAC
  art[subdiv_triple_step_paired;LET_THM;LAMBDA_TRIPLE]
  dthen (mp o orr[PAIR_EQ2])
  art[]
  art[Tame_defs.upt;arith `(i + j) - i = j:num`]
  simp[]  
  comment "QUOT"
  intro fgraph_quotient_list_transform [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`;`f'`;`gi`;`fx`;`newVs`;`v`]
  art[sym trans_add;arith `0 + i = i /\ 1 + i = SUC i`]
  simp[]
  dt
  comment "CORE"
  intro core_rtrans [`g'`;`(FST (ytrans L N r x i))`;`(FST (ztrans L N r x i))`;`f'`;`newVs`;`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`]
  art[sym trans_add]
  art[LET_THM;LAMBDA_TRIPLE]
  art[arith `1 + i = SUC i`]
    INTRO_TAC AQIUNPP [`L`;`N`;`r`;`x`;`SUC i`];
  art[]
  dt
  subants
    amt[marked_list_uniq_quotient]
  simp[]
  st/r
  comment "COUNT"
  intro Reduction2.sizel_faceListAt_splitFace [`g'`;`gi`;`f'`;`newVs`;`(ytrans L N r x i)`;`(ztrans L N r x i)`]
  asimp[]
  dt
  comment "VSET"
  intro Reduction2.splitFace_good_vertices_set2 [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`ntrans L N r x (SUC i)`;`gi`;`g'`;`(FST (ytrans L N r x i))`;`(FST (ztrans L N r x i))`;`f'`;`newVs`]
  asimp[sym trans_add]
    TYPIFY`l'y L (rtrans L N r x i) x = ytrans L (ntrans L N r x i) (rtrans L N r x i) x 0` sat
    BY(REWRITE_TAC[Reduction2.trans0]);
  art[arith `1 + i = SUC i`;sym Reduction2.trans0;sym trans_add;arith `0 + i = i`]
  typ `r_rtrans_eq L (ntrans L N r x i) (rtrans L N r x i) x` sat
        BY(ASM_MESON_TAC [r_trans_eq_assumption]);
  art[]
  subants
  fexp "newVs"
  rt[lower_case;Seq.size_map]
  simp[]
  st/r
  comment "GOOD"
    intro good_faces_transform_lemma [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`g'`;`gi`;`newVs`;`v`;`f'`]
  art[sym trans_add;arith `1 + i = SUC i`;arith `0+i = i`]
  simp[]
  dt
    comment "B_NFGTRANS"
    typ `b_nfgtrans0 f g L N r x (SUC i) = ((SOME (FST (ztrans L N r x (PRE (SUC i)))),0),(fi,gi))` ets
  dthen (mp o orr[PAIR_EQ2])
  simp[]

    comment "CASE0"
  typ `i=0` asmcase
  art[arith `SUC 0 = 1`]
  intro b_nfgtrans1 [`f`;`g`;`L`;`N`;`r`;`x`;`newVs`]
  asimp[arith `PRE 1 = 0`]
  repeat (fxast `nfgtrans'` kill)
  dthen gm
  fxast `b_nfgtrans0` mp
  art[b_nfgtrans0;LET_THM;PAIR_EQ]
  st/r
  fexp "f'"
  fexp "g'"
  fxast `i=0` (assume o sym)
  fexp "i"
  asimp[]
  fxast `assumption_setK7` mp then rt[assumption_setK7]
  abbrev `vs  = dest_triple_full (core L r) v uvns` 
  dthen (C intro [`L`;`N`;`r`;`x`;`transform_count L N r x`;`uvns`;`vs`;`MAP the (filter isSome vs)`;`fx`;`v`])
  art[]
  asimp[]

   comment "CASEPOS"
  typ `0 < i` sat
  pop mp then ARITH_TAC
  intro b_nfgtrans_induction [`i`;`L`;`N`;`r`;`x`;`f`;`g`;`newVs`;`f'`;`g'`]
  asimp[]
  dthen mmp
  rt[CONJ_ASSOC]
  conj2
  ort[PAIR_EQ2]
  art[]
  fxa mmp
  pop mp then simp[]
  rt[sym CONJ_ASSOC]

  fxast `assumption_setK7` mp then rt[assumption_setK7]
  abbrev `vs  = dest_triple_full (core L r) v uvns` 
  dthen (C intro [`L`;`N`;`r`;`x`;`transform_count L N r x`;`uvns`;`vs`;`MAP the (filter isSome vs)`;`fx`;`v`])
  art[]
  (* repeat (fxast `core L r = FST f` (sub1 o sym)) *)

  asimp[]

  (* now just the b_nfgtrans0 conclusions *)
*)
