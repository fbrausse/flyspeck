let float_cache = ref (fun() -> 0.0);;

let eval_float s = 
    let (b,r) = eval_command ~silent:false 
      ("float_cache := (fun () -> ("^s^"));;") in
    let _ = b or (print_string (r^"\n"^s^"\n"); failwith "bad input string") in
    let t= (!float_cache)() in
      t;;



(* This version omits the given bounds. Added 2013/7/30 for nonrigorous partitioning experiments. *)

let cpp_template_arg = Printf.sprintf "
 const char svn[] = %s;
 const char ineq_id[] = %s;

 int testRun(double x1[6],double z1[6]) // autogenerated code
	{
        // Warning: not rigorous. The rounding is off by epsilon. Use this only for experiments.
	interval tx[6]={interval(x1[0],x1[0]),interval(x1[1],x1[1]),interval(x1[2],x1[2]),
                        interval(x1[3],x1[3]),interval(x1[4],x1[4]),interval(x1[5],x1[5])   };
	interval tz[6]={interval(z1[0],z1[0]),interval(z1[1],z1[1]),interval(z1[2],z1[2]),
                        interval(z1[3],z1[3]),interval(z1[4],z1[4]),interval(z1[5],z1[5])}; 
	domain x = domain::lowerD(tx);
	domain z = domain::upperD(tz);
        domain x0=x;
        domain z0=z;
        %s
        const Function* I[%d] = {%s}; // len ...
        cellOption opt;
        opt.allowSharp = %d; // sharp
        opt.onlyCheckDeriv1Negative = %d; // checkderiv
        %s // other options.
	return  prove::recursiveVerifier(0,x,z,x0,z0,I,%d,opt); // len
	}";;


let mk_cpp_arg_proc t s tags = 
  let sharp = if  mem Sharp tags then 1 else 0 in
  let checkderiv = if  mem Onlycheckderiv1negative tags then 1 else 0 in
  let ifd b s = if b then s else "" in
  let (b,f) = widthCut tags in
  let sWidth = ifd b (Printf.sprintf "\topt.widthCutoff = %8.16f;\n" f) in 
  let c = map cpp_string_of_term in
  let f (x,y,z) = (c x,c y,c z) in
  let (aas,bbs,iis) = f (dest_nonlin t) in
  let len = length iis in
  let sq = quoted s in
  let svn = (quoted(svn_version())) in
    cpp_template_arg svn sq (cpp_template_t "" iis) 
      len (cpp_template_Fc "" len) sharp  checkderiv sWidth len;;

let arg_tail() = join_lines (load_file  (flyspeck_dir^"/../interval_code/arg_tail.txt"));;

let mkfile_arg  t s tags  = 
  output_filestring tmpfile 
   (join_lines [cpp_header(); (mk_cpp_arg_proc t s tags);arg_tail()]);;

let mkfile_arg t s tags  = 
  let cpp_header = Optimize.cpp_header() in
  let cpp_tail = arg_tail() in
  Flyspeck_lib.output_filestring tmpfile
   (join_lines [cpp_header;Auto_lib.interval_code;(mk_cpp_arg_proc t s tags);cpp_tail]);;

let execute_args ex tags s testineq xlist zlist =  (* xxd add args *)
   let x = List.nth xlist in
   let z = List.nth zlist in
   let args = Printf.sprintf " %f %f %f %f %f %f   %f %f %f %f %f %f"
      (x 0) (x 1) (x 2) (x 3) (x 4) (x 5)     (z 0) (z 1) (z 2) (z 3) (z 4) (z 5) in
  let interval_dir = flyspeck_dir^"/../interval_code" in
  let _ = mkfile_arg testineq s tags in
  let _ = Optimize.compile_cpp() in 
  let _ = (not ex) or (0=  Sys.command(interval_dir^"/test_auto"^args)) or failwith "interval execution error" in
    ();;

let rerun xlist zlist = 
   let x = List.nth xlist in
   let z = List.nth zlist in
   let args = Printf.sprintf " %f %f %f %f %f %f   %f %f %f %f %f %f"
      (x 0) (x 1) (x 2) (x 3) (x 4) (x 5)     (z 0) (z 1) (z 2) (z 3) (z 4) (z 5) in
  let interval_dir = flyspeck_dir^"/../interval_code" in
  let _ = (0=  Sys.command(interval_dir^"/test_auto"^args)) or failwith "interval execution error" in
    ();;

let process_and_prep_args ex (s,tags,case) = 
  let _ = report ("process and prep args: "^s) in
  let (s,tags,testineq) = preprocess (s,tags,case) in
  let (x,y,_) = dest_nonlin testineq in
    (execute_args ex tags s testineq , x, y);;

let testsplit_idq ex idq = 
  let splits = Optimize.preprocess_split_idq idq in
    map (fun (s,tags,testineq) -> execute_args ex tags s testineq) splits;;

let getprep s = hd(filter (fun t -> t.idv = s) (!Prep.prep_ineqs));;

Ineq.getexact "6601228004";;
let stc = Optimize.idq_fields (hd(Ineq.getexact "6601228004"));;

let (exec1,f1,f2) = process_and_prep_args true stc;;
let c1 = map (eval_float o Parse_ineq.ocaml_string_of_term) f1;;
let c2 = map (eval_float o Parse_ineq.ocaml_string_of_term) f2;;
let c1 = map (fun x -> x -. 1.0e-12) c1;;
let c2 = map (fun x -> x +. 1.0e-12) c2;;
let nth = List.nth;;
exec1 c1 c2;;
rerun c1 c2;;
let c1' = [3.999999999998; 3.999999999998; 4.3; 9.06009999999799831;
   3.999999999998; 3.999999999998];;
let c2' = [6.350400000003; 6.350400000003; 4.3; 10.4781690000030014;
   4.000000000003; 4.000000000003];;
rerun c1 c2';;
rerun c1' c2;;
1.0e-11;;

c1;;
c2;;
c12;;

eval_command "3 * 4";;

(* eval constants *)




(* test constants *)

let idvlist = map (fun t -> t.idv) (!Prep.prep_ineqs);;

let scrub_c t = 
  let th = REWRITE_CONV [Sphere.h0;
        GSYM Nonlinear_lemma.sol0_over_pi_EQ_const1;
	ASSUME `hminus = #1.2317544220903216`;
        ASSUME `pi = #3.1415926535897932385`;
        ASSUME `sol0 = #0.55128559843253080794`] t in
    rhs(concl th);;

let get_constants s = 
  let (s,tags,case) = Optimize.idq_fields (getprep s) in
  let (x,y,_) = dest_nonlin case in
  let z = x @ y in
    map scrub_c z;;

let check_constants s = map (eval_float o Parse_ineq.ocaml_string_of_term) (get_constants s);;

let s1 = List.nth idvlist 0;;

(* they all check out on 2013/7/31
find (fun s -> not(can check_constants s)) (snd (chop_list 650 idvlist));;
*)

let seconds_target = 3;;

assoc "6601228004" Scripts.times;;
let (s,tags,case) = Optimize.idq_fields (getprep "6601228004");;
let (xx,zz,iis) = dest_nonlin case;;
map Parse_ineq.ocaml_string_of_term iis;;

let iis_eval iisk xlist = 
  let x = List.nth xlist in
  let iis = Parse_ineq.ocaml_string_of_term iisk in
  eval_float (Printf.sprintf 
"let x1 = %f in
 let x2 = %f in
 let x3 = %f in
 let x4 = %f in
 let x5 = %f in
 let x6 = %f in
 let e =     ( -. ( %s ) ) in
   if (compare e nan = 0) then - 1.0 else e" 
(x 0) (x 1) (x 2) (x 3) (x 4) (x 5) iis);;

open Sphere2;;

iis;;
iis_eval (List.nth iis 0) c1;;
iis_eval (`delta_x x1 x2 x3 x4 x5 x6`) c1;;

let vv = map (eval_float o Parse_ineq.ocaml_string_of_term)  (get_constants s);;


Auto_lib.sphere2_ml;;
Sphere2.ups_x 2.;;

(fun () -> (let x1 = 4.000000 in
   let x2 = 4.000000 in
   let x3 = 4.000000 in
   let x4 = 9.060100 in
   let x5 = 4.000000 in
   let x6 = 4.000000 in
      ( -- (  taud_D2_num_x (x1) (x2) (x3) (x4) (x5) (x6)  ) )));;;;
