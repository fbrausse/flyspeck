open Hol_core
open Floor
open Products
open Vectors
open Determinants
open Topology
open Convex
open Paths
open Dimension
open Derivatives
open Complexes
open Canal
include Transcendentals2

(* ------------------------------------------------------------------------- *)
(* More delicate continuity results for arcsin and arccos.                   *)
(* ------------------------------------------------------------------------- *)

let CONTINUOUS_ON_CASN_REAL = prove
 (`casn continuous_on {w | real w /\ abs(Re w) <= &1}`,
  MATCH_MP_TAC CONTINUOUS_ON_SUBSET THEN
  EXISTS_TAC `IMAGE csin {z | real z /\ abs(Re z) <= pi / &2}` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_ON_INVERSE THEN
    REWRITE_TAC[CONTINUOUS_ON_CSIN] THEN CONJ_TAC THENL
     [REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN CONJ_TAC THENL
       [MATCH_MP_TAC BOUNDED_SUBSET THEN
        EXISTS_TAC `cball(Cx(&0),pi / &2)` THEN
        REWRITE_TAC[BOUNDED_CBALL; SUBSET; IN_ELIM_THM; IN_CBALL] THEN
        REWRITE_TAC[dist; COMPLEX_SUB_LZERO; NORM_NEG; real] THEN
        X_GEN_TAC `z:complex` THEN
        MP_TAC(SPEC `z:complex` COMPLEX_NORM_LE_RE_IM) THEN REAL_ARITH_TAC;
        SIMP_TAC[SET_RULE `{x | P x /\ Q x} = {x | P x} INTER {x | Q x}`;
                  GSYM REAL_BOUNDS_LE] THEN
        SIMP_TAC[CLOSED_INTER; CLOSED_REAL_SET; CLOSED_HALFSPACE_RE_LE;
                 REWRITE_RULE[real_ge] CLOSED_HALFSPACE_RE_GE]];
      SIMP_TAC[SUBSET; IMP_CONJ; FORALL_REAL; IN_ELIM_THM; RE_CX] THEN
      REPEAT STRIP_TAC THEN MATCH_MP_TAC CASN_CSIN THEN
      REWRITE_TAC[RE_CX; IM_CX] THEN ASM_REAL_ARITH_TAC];
    SIMP_TAC[SUBSET; IMP_CONJ; FORALL_REAL; IN_ELIM_THM; RE_CX; IN_IMAGE] THEN
    X_GEN_TAC `x:real` THEN DISCH_TAC THEN
    EXISTS_TAC `Cx(asn x)` THEN
    ASM_SIMP_TAC[RE_CX; ASN_BOUNDS; REAL_BOUNDS_LE; REAL_CX; SIN_ASN;
                 GSYM CX_SIN] THEN
    ASM_MESON_TAC[REAL_BOUNDS_LE; ASN_BOUNDS]]);;

let CONTINUOUS_WITHIN_CASN_REAL = prove
 (`!z. casn continuous (at z within {w | real w /\ abs(Re w) <= &1})`,
  GEN_TAC THEN ASM_CASES_TAC `z IN {w | real w /\ abs(Re w) <= &1}` THENL
   [ASM_SIMP_TAC[REWRITE_RULE[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN]
      CONTINUOUS_ON_CASN_REAL];
    MATCH_MP_TAC CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL THEN
    ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_BOUNDS_LE] THEN
    ASM_SIMP_TAC[SET_RULE `{x | P x /\ Q x} = {x | P x} INTER {x | Q x}`] THEN
    SIMP_TAC[CLOSED_INTER; CLOSED_REAL_SET; CLOSED_HALFSPACE_RE_LE;
             REWRITE_RULE[real_ge] CLOSED_HALFSPACE_RE_GE]]);;

let CONTINUOUS_ON_CACS_REAL = prove
 (`cacs continuous_on {w | real w /\ abs(Re w) <= &1}`,
  MATCH_MP_TAC CONTINUOUS_ON_SUBSET THEN
  EXISTS_TAC `IMAGE ccos {z | real z /\ &0 <= Re z /\ Re z <= pi}` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_ON_INVERSE THEN
    REWRITE_TAC[CONTINUOUS_ON_CCOS] THEN CONJ_TAC THENL
     [REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN CONJ_TAC THENL
       [MATCH_MP_TAC BOUNDED_SUBSET THEN
        EXISTS_TAC `cball(Cx(&0),&2 * pi)` THEN
        REWRITE_TAC[BOUNDED_CBALL; SUBSET; IN_ELIM_THM; IN_CBALL] THEN
        REWRITE_TAC[dist; COMPLEX_SUB_LZERO; NORM_NEG; real] THEN
        X_GEN_TAC `z:complex` THEN
        MP_TAC(SPEC `z:complex` COMPLEX_NORM_LE_RE_IM) THEN REAL_ARITH_TAC;
        SIMP_TAC[SET_RULE `{x | P x /\ Q x} = {x | P x} INTER {x | Q x}`] THEN
        SIMP_TAC[CLOSED_INTER; CLOSED_REAL_SET; CLOSED_HALFSPACE_RE_LE;
                 REWRITE_RULE[real_ge] CLOSED_HALFSPACE_RE_GE]];
      SIMP_TAC[SUBSET; IMP_CONJ; FORALL_REAL; IN_ELIM_THM; RE_CX] THEN
      REPEAT STRIP_TAC THEN MATCH_MP_TAC CACS_CCOS THEN
      REWRITE_TAC[RE_CX; IM_CX] THEN ASM_REAL_ARITH_TAC];
    SIMP_TAC[SUBSET; IMP_CONJ; FORALL_REAL; IN_ELIM_THM; RE_CX; IN_IMAGE] THEN
    X_GEN_TAC `x:real` THEN DISCH_TAC THEN
    EXISTS_TAC `Cx(acs x)` THEN
    ASM_SIMP_TAC[RE_CX; ACS_BOUNDS; REAL_BOUNDS_LE; REAL_CX; COS_ACS;
                 GSYM CX_COS]]);;

let CONTINUOUS_WITHIN_CACS_REAL = prove
 (`!z. cacs continuous (at z within {w | real w /\ abs(Re w) <= &1})`,
  GEN_TAC THEN ASM_CASES_TAC `z IN {w | real w /\ abs(Re w) <= &1}` THENL
   [ASM_SIMP_TAC[REWRITE_RULE[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN]
      CONTINUOUS_ON_CACS_REAL];
    MATCH_MP_TAC CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL THEN
    ASM_REWRITE_TAC[] THEN REWRITE_TAC[GSYM REAL_BOUNDS_LE] THEN
    ASM_SIMP_TAC[SET_RULE `{x | P x /\ Q x} = {x | P x} INTER {x | Q x}`] THEN
    SIMP_TAC[CLOSED_INTER; CLOSED_REAL_SET; CLOSED_HALFSPACE_RE_LE;
             REWRITE_RULE[real_ge] CLOSED_HALFSPACE_RE_GE]]);;

(* ------------------------------------------------------------------------- *)
(* Some limits, most involving sequences of transcendentals.                 *)
(* ------------------------------------------------------------------------- *)

let LIM_CX_OVER_CEXP = prove
 (`((\x. Cx x / cexp(Cx x)) --> Cx(&0)) at_posinfinity`,
  ONCE_REWRITE_TAC[LIM_NULL_COMPLEX_NORM] THEN
  REWRITE_TAC[LIM_AT_POSINFINITY; real_ge] THEN
  X_GEN_TAC `e:real` THEN DISCH_TAC THEN
  EXISTS_TAC `max (&1) (&1 + &2 * log (&2 / e))` THEN
  X_GEN_TAC `x:real` THEN REWRITE_TAC[REAL_MAX_LE] THEN STRIP_TAC THEN
  REWRITE_TAC[dist; COMPLEX_SUB_RZERO; COMPLEX_NORM_CX; REAL_ABS_NORM] THEN
  ASM_SIMP_TAC[COMPLEX_NORM_DIV; NORM_CEXP; COMPLEX_NORM_CX; RE_CX] THEN
  SIMP_TAC[REAL_LT_LDIV_EQ; REAL_EXP_POS_LT] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  ASM_SIMP_TAC[GSYM REAL_LT_LDIV_EQ] THEN GEN_REWRITE_TAC
   (RAND_CONV o RAND_CONV) [REAL_ARITH `x = x / &2 + x / &2`] THEN
  REWRITE_TAC[REAL_EXP_ADD; REAL_ARITH
   `x / e < y * y <=> x / &2 * &2 / e < y * y`] THEN
  MATCH_MP_TAC REAL_LT_MUL2 THEN REPEAT CONJ_TAC THENL
   [REAL_ARITH_TAC;
    MATCH_MP_TAC(REAL_ARITH
     `&1 <= x /\ &1 + x / &2 <= y ==> abs x / &2 < y`) THEN
    ASM_REWRITE_TAC[REAL_EXP_LE_X];
    ASM_SIMP_TAC[REAL_LE_DIV; REAL_POS; REAL_LT_IMP_LE];
    MATCH_MP_TAC LOG_MONO_LT_REV THEN
    ASM_SIMP_TAC[REAL_LT_DIV; REAL_OF_NUM_LT; ARITH; LOG_EXP;
                 REAL_ARITH `&1 <= x ==> &0 < x`; REAL_EXP_POS_LT] THEN
    ASM_REAL_ARITH_TAC]);;

let LIM_Z_TIMES_CLOG = prove
 (`((\z. z * clog z) --> Cx(&0)) (at (Cx(&0)))`,
  ONCE_REWRITE_TAC[SPEC `clog z` COMPLEX_EXPAND] THEN
  REWRITE_TAC[COMPLEX_ADD_LDISTRIB] THEN
  MATCH_MP_TAC LIM_NULL_COMPLEX_ADD THEN CONJ_TAC THENL
   [SIMP_TAC[RE_CLOG] THEN MP_TAC LIM_CX_OVER_CEXP THEN
    REWRITE_TAC[LIM_AT_POSINFINITY; LIM_AT; dist; COMPLEX_SUB_RZERO] THEN
    MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `e:real` THEN
    ASM_CASES_TAC `&0 < e` THEN ASM_REWRITE_TAC[real_ge] THEN
    REWRITE_TAC[COMPLEX_NORM_DIV; COMPLEX_NORM_CX; NORM_CEXP; RE_CX] THEN
    DISCH_THEN(X_CHOOSE_TAC `b:real`) THEN
    REWRITE_TAC[COMPLEX_NORM_MUL; COMPLEX_NORM_CX] THEN
    EXISTS_TAC `inv(exp b)` THEN SIMP_TAC[REAL_LT_INV_EQ; REAL_EXP_POS_LT] THEN
    X_GEN_TAC `z:complex` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC `log(inv(norm(z:complex)))`) THEN
    ASM_SIMP_TAC[LOG_INV; EXP_LOG; REAL_LT_INV_EQ] THEN
    ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
    REWRITE_TAC[real_div; REAL_INV_INV; REAL_ABS_NEG] THEN
    DISCH_THEN MATCH_MP_TAC THEN
    GEN_REWRITE_TAC I [GSYM REAL_EXP_MONO_LE] THEN
    ASM_SIMP_TAC[EXP_LOG; REAL_EXP_NEG] THEN
    GEN_REWRITE_TAC LAND_CONV [GSYM REAL_INV_INV] THEN
    MATCH_MP_TAC REAL_LE_INV2 THEN ASM_REAL_ARITH_TAC;
    MATCH_MP_TAC LIM_NULL_COMPLEX_RMUL_BOUNDED THEN
    REWRITE_TAC[LIM_AT_ID] THEN EXISTS_TAC `pi` THEN
    REWRITE_TAC[COMPLEX_NORM_MUL; COMPLEX_NORM_II; COMPLEX_NORM_CX] THEN
    REWRITE_TAC[EVENTUALLY_AT; dist; COMPLEX_SUB_0; COMPLEX_NORM_NZ] THEN
    SIMP_TAC[CLOG_WORKS; REAL_MUL_LID; REAL_ABS_BOUNDS; REAL_LT_IMP_LE] THEN
    MESON_TAC[REAL_LT_01]]);;

let LIM_LOG_OVER_Z = prove
 (`((\z. clog z / z) --> Cx(&0)) at_infinity`,
  SIMP_TAC[LIM_AT_INFINITY_COMPLEX_0; o_DEF; complex_div; COMPLEX_INV_INV;
           CLOG_INV] THEN
  ONCE_REWRITE_TAC[COMPLEX_RING
   `clog(inv z) * z = z * (clog z + clog(inv z)) - z * clog z`] THEN
  MATCH_MP_TAC LIM_NULL_COMPLEX_SUB THEN
  REWRITE_TAC[LIM_Z_TIMES_CLOG] THEN
  MATCH_MP_TAC LIM_NULL_COMPLEX_RMUL_BOUNDED THEN
  REWRITE_TAC[LIM_AT_ID] THEN EXISTS_TAC `&2 * pi` THEN
  REWRITE_TAC[EVENTUALLY_AT; dist; COMPLEX_SUB_RZERO; COMPLEX_NORM_NZ] THEN
  EXISTS_TAC `&1` THEN SIMP_TAC[REAL_LT_01] THEN
  X_GEN_TAC `z:complex` THEN STRIP_TAC THEN
  GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [COMPLEX_EXPAND] THEN
  ASM_SIMP_TAC[RE_ADD; RE_CLOG; REAL_LT_INV_EQ; COMPLEX_INV_EQ_0;
               COMPLEX_NORM_INV; LOG_INV; COMPLEX_NORM_NZ] THEN
  REWRITE_TAC[REAL_ADD_RINV; COMPLEX_ADD_LID; COMPLEX_NORM_MUL] THEN
  REWRITE_TAC[COMPLEX_NORM_II; COMPLEX_NORM_CX; IM_ADD] THEN
  MATCH_MP_TAC(REAL_ARITH
   `--pi < x /\ x <= pi /\ --pi < y /\ y <= pi
    ==> &1 * abs(x + y) <= &2 * pi`) THEN
  ASM_SIMP_TAC[CLOG_WORKS; COMPLEX_INV_EQ_0]);;

let LIM_LOG_OVER_POWER = prove
 (`!s. &0 < Re s
       ==> ((\x. clog(Cx x) / (Cx x) cpow s) --> Cx(&0)) at_posinfinity`,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIM_AT_POSINFINITY] THEN
  X_GEN_TAC `e:real` THEN DISCH_TAC THEN REWRITE_TAC[real_ge] THEN
  MP_TAC(REWRITE_RULE[LIM_AT_POSINFINITY] LIM_CX_OVER_CEXP) THEN
  DISCH_THEN(MP_TAC o SPEC `Re s * e`) THEN
  ASM_SIMP_TAC[REAL_LT_MUL; real_ge; dist; COMPLEX_SUB_RZERO] THEN
  REWRITE_TAC[COMPLEX_NORM_DIV; COMPLEX_NORM_CX; NORM_CEXP; RE_CX] THEN
  DISCH_THEN(X_CHOOSE_TAC `B:real`) THEN
  EXISTS_TAC `max (&1) (exp((abs B + &1) / Re s))` THEN X_GEN_TAC `x:real` THEN
  REWRITE_TAC[REAL_MAX_LE] THEN STRIP_TAC THEN
  SUBGOAL_THEN `&0 < x` ASSUME_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
  ASM_SIMP_TAC[NORM_CPOW_REAL; COMPLEX_NORM_DIV; REAL_CX; RE_CX;
               GSYM CX_LOG; COMPLEX_NORM_CX; real_abs; LOG_POS] THEN
  MATCH_MP_TAC REAL_LT_LCANCEL_IMP THEN EXISTS_TAC `Re s` THEN
  ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC `Re s * log x`) THEN
  ASM_SIMP_TAC[real_abs; REAL_LE_MUL; LOG_POS; REAL_LT_IMP_LE] THEN
  REWRITE_TAC[real_div; GSYM REAL_MUL_ASSOC] THEN DISCH_THEN MATCH_MP_TAC THEN
  MATCH_MP_TAC(REAL_ARITH `abs b + &1 <= x * y ==> b <= y * x`) THEN
  ASM_SIMP_TAC[GSYM REAL_LE_LDIV_EQ] THEN
  ONCE_REWRITE_TAC[GSYM REAL_EXP_MONO_LE] THEN
  ASM_SIMP_TAC[EXP_LOG]);;

let LIM_LOG_OVER_X = prove
 (`((\x. clog(Cx x) / Cx x) --> Cx(&0)) at_posinfinity`,
  MP_TAC(SPEC `Cx(&1)` LIM_LOG_OVER_POWER) THEN
  REWRITE_TAC[CPOW_N; RE_CX; REAL_LT_01; COMPLEX_POW_1] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] LIM_TRANSFORM_EVENTUALLY) THEN
  REWRITE_TAC[EVENTUALLY_AT_POSINFINITY; CX_INJ] THEN
  EXISTS_TAC `&1` THEN REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  REWRITE_TAC[] THEN ASM_REAL_ARITH_TAC);;

let LIM_LOG_OVER_POWER_N = prove
 (`!s. &0 < Re s
       ==> ((\n. clog(Cx(&n)) / Cx(&n) cpow s) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_POSINFINITY_SEQUENTIALLY THEN
  ASM_SIMP_TAC[LIM_LOG_OVER_POWER]);;

let LIM_LOG_OVER_N = prove
 (`((\n. clog(Cx(&n)) / Cx(&n)) --> Cx(&0)) sequentially`,
  MP_TAC(SPEC `Cx(&1)` LIM_LOG_OVER_POWER_N) THEN
  SIMP_TAC[RE_CX; REAL_LT_01] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] LIM_TRANSFORM_EVENTUALLY) THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY; CPOW_N; CX_INJ] THEN EXISTS_TAC `1` THEN
  SIMP_TAC[COMPLEX_POW_1; REAL_OF_NUM_EQ; ARITH_RULE `1 <= n <=> ~(n = 0)`]);;

let LIM_1_OVER_POWER = prove
 (`!s. &0 < Re s
       ==> ((\n. Cx(&1) / Cx(&n) cpow s) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_NULL_COMPLEX_BOUND THEN
  EXISTS_TAC `\n. clog(Cx(&n)) / Cx(&n) cpow s` THEN
  ASM_SIMP_TAC[LIM_LOG_OVER_POWER_N] THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
  MP_TAC(ISPEC `exp(&1)` REAL_ARCH_SIMPLE) THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `N:num` THEN
  ASM_CASES_TAC `N = 0` THENL
   [ASM_SIMP_TAC[GSYM REAL_NOT_LT; REAL_EXP_POS_LT]; ALL_TAC] THEN
  DISCH_TAC THEN X_GEN_TAC `n:num` THEN DISCH_TAC THEN
  REWRITE_TAC[complex_div; COMPLEX_NORM_MUL] THEN
  MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[NORM_POS_LE] THEN
  SUBGOAL_THEN `~(n = 0)` ASSUME_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
  ASM_SIMP_TAC[GSYM CX_LOG; REAL_OF_NUM_LT; LT_NZ;
               COMPLEX_NORM_CX; REAL_ABS_NUM] THEN
  MATCH_MP_TAC(REAL_ARITH `x <= y ==> x <= abs y`) THEN
  ONCE_REWRITE_TAC[GSYM REAL_EXP_MONO_LE] THEN
  ASM_SIMP_TAC[EXP_LOG; REAL_OF_NUM_LT; LT_NZ] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM REAL_OF_NUM_LE]) THEN ASM_REAL_ARITH_TAC);;

let LIM_INV_Z_OFFSET = prove
 (`!z. ((\w. inv(w + z)) --> Cx(&0)) at_infinity`,
  GEN_TAC THEN REWRITE_TAC[LIM_AT_INFINITY_COMPLEX_0; o_DEF] THEN
  SIMP_TAC[COMPLEX_INV_DIV; COMPLEX_FIELD
   `~(w = Cx(&0)) ==> inv w + z = (Cx(&1) + w * z) / w`] THEN
  GEN_REWRITE_TAC LAND_CONV
   [COMPLEX_FIELD `Cx(&0) = Cx(&0) / (Cx(&1) + Cx(&0) * z)`] THEN
  MATCH_MP_TAC LIM_COMPLEX_DIV THEN
  REWRITE_TAC[COMPLEX_RING `~(Cx(&1) + Cx(&0) * z = Cx(&0))`] THEN
  CONJ_TAC THEN LIM_TAC);;

let LIM_INV_Z = prove
 (`((\z. inv(z)) --> Cx(&0)) at_infinity`,
  ONCE_REWRITE_TAC[MESON[COMPLEX_ADD_RID] `inv z = inv(z + Cx(&0))`] THEN
  REWRITE_TAC[LIM_INV_Z_OFFSET]);;

let LIM_INV_X_OFFSET = prove
 (`!z. ((\x. inv(Cx x + z)) --> Cx(&0)) at_posinfinity`,
  GEN_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] LIM_INFINITY_POSINFINITY_CX) THEN
  REWRITE_TAC[LIM_INV_Z_OFFSET]);;

let LIM_INV_X = prove
 (`((\x. inv(Cx x)) --> Cx(&0)) at_posinfinity`,
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] LIM_INFINITY_POSINFINITY_CX) THEN
  REWRITE_TAC[REWRITE_RULE[ETA_AX] LIM_INV_Z]);;

let LIM_INV_N_OFFSET = prove
 (`!z. ((\n. inv(Cx(&n) + z)) --> Cx(&0)) sequentially`,
  GEN_TAC THEN MATCH_MP_TAC LIM_POSINFINITY_SEQUENTIALLY THEN
  REWRITE_TAC[LIM_INV_X_OFFSET]);;

let LIM_1_OVER_N = prove
 (`((\n. Cx(&1) / Cx(&n)) --> Cx(&0)) sequentially`,
  MP_TAC(SPEC `Cx(&1)` LIM_1_OVER_POWER) THEN SIMP_TAC[RE_CX; REAL_LT_01] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] LIM_TRANSFORM_EVENTUALLY) THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY; CPOW_N; CX_INJ] THEN EXISTS_TAC `1` THEN
  SIMP_TAC[COMPLEX_POW_1; REAL_OF_NUM_EQ; ARITH_RULE `1 <= n <=> ~(n = 0)`]);;

let LIM_INV_N = prove
 (`((\n. inv(Cx(&n))) --> Cx(&0)) sequentially`,
  MP_TAC LIM_1_OVER_N THEN REWRITE_TAC[complex_div; COMPLEX_MUL_LID]);;

let LIM_INV_Z_POW_OFFSET = prove
 (`!z n. 1 <= n ==> ((\w. inv(w + z) pow n) --> Cx(&0)) at_infinity`,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `Cx(&0) = Cx(&0) pow n` SUBST1_TAC THENL
   [ASM_SIMP_TAC[COMPLEX_POW_ZERO; LE_1];
    MATCH_MP_TAC LIM_COMPLEX_POW THEN REWRITE_TAC[LIM_INV_Z_OFFSET]]);;

let LIM_INV_Z_POW = prove
 (`!n. 1 <= n ==> ((\z. inv(z) pow n) --> Cx(&0)) at_infinity`,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `Cx(&0) = Cx(&0) pow n` SUBST1_TAC THENL
   [ASM_SIMP_TAC[COMPLEX_POW_ZERO; LE_1];
    MATCH_MP_TAC LIM_COMPLEX_POW THEN
    REWRITE_TAC[REWRITE_RULE[ETA_AX] LIM_INV_Z]]);;

let LIM_INV_X_POW_OFFSET = prove
 (`!z n. 1 <= n ==> ((\x. inv(Cx x + z) pow n) --> Cx(&0)) at_posinfinity`,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] LIM_INFINITY_POSINFINITY_CX) THEN
  ASM_SIMP_TAC[LIM_INV_Z_POW_OFFSET]);;

let LIM_INV_X_POW = prove
 (`!n. 1 <= n ==> ((\x. inv(Cx x) pow n) --> Cx(&0)) at_posinfinity`,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] LIM_INFINITY_POSINFINITY_CX) THEN
  ASM_SIMP_TAC[LIM_INV_Z_POW]);;

let LIM_INV_N_POW_OFFSET = prove
 (`!z m. 1 <= m ==> ((\n. inv(Cx(&n) + z) pow m) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_POSINFINITY_SEQUENTIALLY THEN
  ASM_SIMP_TAC[LIM_INV_X_POW_OFFSET]);;

let LIM_INV_N_POW = prove
 (`!m. 1 <= m ==> ((\n. inv(Cx(&n)) pow m) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_POSINFINITY_SEQUENTIALLY THEN
  ASM_SIMP_TAC[LIM_INV_X_POW]);;

let LIM_1_OVER_LOG = prove
 (`((\n. Cx(&1) / clog(Cx(&n))) --> Cx(&0)) sequentially`,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN X_GEN_TAC `e:real` THEN
  DISCH_TAC THEN X_CHOOSE_TAC `N:num` (SPEC `exp(inv e)` REAL_ARCH_SIMPLE) THEN
  EXISTS_TAC `N + 1` THEN X_GEN_TAC `n:num` THEN DISCH_TAC THEN
  REWRITE_TAC[dist; COMPLEX_SUB_RZERO; COMPLEX_MUL_LID; complex_div] THEN
  SUBGOAL_THEN `0 < n` ASSUME_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE
   [GSYM REAL_OF_NUM_LT; GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_ADD]) THEN
  ASM_SIMP_TAC[GSYM CX_LOG; COMPLEX_NORM_CX; COMPLEX_NORM_INV] THEN
  GEN_REWRITE_TAC RAND_CONV [GSYM REAL_INV_INV] THEN
  MATCH_MP_TAC REAL_LT_INV2 THEN ASM_REWRITE_TAC[REAL_LT_INV_EQ] THEN
  MATCH_MP_TAC(REAL_ARITH `a < x ==> a < abs x`) THEN
  ONCE_REWRITE_TAC[GSYM REAL_EXP_MONO_LT] THEN
  ASM_SIMP_TAC[EXP_LOG] THEN ASM_REAL_ARITH_TAC);;

let LIM_N_TIMES_POWN = prove
 (`!z. norm(z) < &1 ==> ((\n. Cx(&n) * z pow n) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC `z = Cx(&0)` THEN
  ASM_SIMP_TAC[COMPLEX_POW_ZERO; LIM_CASES_FINITE_SEQUENTIALLY; LIM_CONST;
               COND_RAND; FINITE_SING; SING_GSPEC; COMPLEX_MUL_RZERO] THEN
  MP_TAC LIM_LOG_OVER_N THEN
  REWRITE_TAC[LIM_SEQUENTIALLY; dist; COMPLEX_SUB_RZERO] THEN
  DISCH_THEN(MP_TAC o SPEC `log(inv(norm(z:complex))) / &2`) THEN
  ASM_SIMP_TAC[LOG_POS_LT; REAL_INV_1_LT; COMPLEX_NORM_NZ; REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN `N1:num` (LABEL_TAC "+")) THEN
  X_GEN_TAC `e:real` THEN DISCH_TAC THEN
  FIRST_ASSUM(X_CHOOSE_THEN `N2:num` STRIP_ASSUME_TAC o
              GEN_REWRITE_RULE I [REAL_ARCH_INV]) THEN
  EXISTS_TAC `MAX 1 (MAX N1 N2)` THEN
  REWRITE_TAC[ARITH_RULE `MAX a b <= c <=> a <= c /\ b <= c`] THEN
  X_GEN_TAC `n:num` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC `n:num`) THEN
  ASM_SIMP_TAC[GSYM CX_LOG; REAL_OF_NUM_LT; LE_1; GSYM CX_DIV;
               COMPLEX_NORM_CX; REAL_ABS_DIV; REAL_ABS_NUM] THEN
  ASM_SIMP_TAC[REAL_LT_RDIV_EQ; REAL_OF_NUM_LT; ARITH; real_abs;
               LOG_POS; REAL_OF_NUM_LE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH `a / b * &2 = (&2 * a) / b`] THEN
  ASM_SIMP_TAC[REAL_LT_LDIV_EQ; REAL_OF_NUM_LT; LE_1] THEN
  GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [REAL_MUL_SYM] THEN
  GEN_REWRITE_TAC LAND_CONV [GSYM REAL_EXP_MONO_LT] THEN
  ASM_SIMP_TAC[REAL_EXP_N; EXP_LOG; REAL_OF_NUM_LT; LE_1;
               REAL_LT_INV_EQ; COMPLEX_NORM_NZ] THEN
  REWRITE_TAC[REAL_POW_INV] THEN
  GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [GSYM REAL_MUL_LID] THEN
  ASM_SIMP_TAC[GSYM real_div; REAL_LT_RDIV_EQ; REAL_POW_LT; COMPLEX_NORM_NZ;
               COMPLEX_NORM_MUL; COMPLEX_NORM_NUM; COMPLEX_NORM_POW] THEN
  DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC `inv(&N2)` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC `inv(&n)` THEN
  ASM_SIMP_TAC[REAL_LE_INV2; REAL_OF_NUM_LE; REAL_OF_NUM_LT; LE_1] THEN
  MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `&n` THEN
  ASM_SIMP_TAC[REAL_MUL_RINV; REAL_LT_IMP_NZ; REAL_OF_NUM_LT; LE_1] THEN
  ASM_REAL_ARITH_TAC);;

let LIM_N_OVER_POWN = prove
 (`!z. &1 < norm(z) ==> ((\n. Cx(&n) / z pow n) --> Cx(&0)) sequentially`,
  ASM_SIMP_TAC[complex_div; GSYM COMPLEX_POW_INV; COMPLEX_NORM_INV;
               REAL_INV_LT_1; LIM_N_TIMES_POWN]);;

let LIM_POWN = prove
 (`!z. norm(z) < &1 ==> ((\n. z pow n) --> Cx(&0)) sequentially`,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_NULL_COMPARISON_COMPLEX THEN
  EXISTS_TAC `\n. Cx(&n) * z pow n` THEN ASM_SIMP_TAC[LIM_N_TIMES_POWN] THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC `1` THEN
  REWRITE_TAC[COMPLEX_NORM_MUL; COMPLEX_NORM_CX; REAL_ABS_NUM] THEN
  REWRITE_TAC[REAL_ARITH `a <= n * a <=> &0 <= (n - &1) * a`] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_MUL THEN
  ASM_REWRITE_TAC[NORM_POS_LE; REAL_SUB_LE; REAL_OF_NUM_LE]);;

let LIM_CSIN_OVER_X = prove
 (`((\z. csin z / z) --> Cx(&1)) (at (Cx(&0)))`,
  ONCE_REWRITE_TAC[LIM_NULL_COMPLEX] THEN
  MATCH_MP_TAC LIM_NULL_COMPARISON_COMPLEX THEN
  EXISTS_TAC `\z. cexp(Cx(abs(Im z))) * z pow 2 / Cx(&2)` THEN
  REWRITE_TAC[EVENTUALLY_AT] THEN CONJ_TAC THENL
   [EXISTS_TAC `&1` THEN REWRITE_TAC[REAL_LT_01; dist; COMPLEX_SUB_RZERO] THEN
    X_GEN_TAC `z:complex` THEN SIMP_TAC[COMPLEX_NORM_NZ] THEN STRIP_TAC THEN
    MATCH_MP_TAC REAL_LE_LCANCEL_IMP THEN EXISTS_TAC `norm(z:complex)` THEN
    ASM_REWRITE_TAC[COMPLEX_NORM_NZ; GSYM COMPLEX_NORM_MUL] THEN
    ASM_SIMP_TAC[COMPLEX_FIELD
     `~(z = Cx(&0)) ==> z * (s / z - Cx(&1)) = s - z`] THEN
    REWRITE_TAC[GSYM CX_EXP; COMPLEX_NORM_MUL; COMPLEX_NORM_CX] THEN
    REWRITE_TAC[real_abs; REAL_EXP_POS_LE] THEN REWRITE_TAC[GSYM real_abs] THEN
    MP_TAC(ISPECL [`0`; `z:complex`] TAYLOR_CSIN) THEN
    REWRITE_TAC[VSUM_SING_NUMSEG] THEN CONV_TAC NUM_REDUCE_CONV THEN
    REWRITE_TAC[complex_pow; COMPLEX_POW_1; COMPLEX_DIV_1] THEN
    REWRITE_TAC[COMPLEX_MUL_LID] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LE_TRANS) THEN
    MATCH_MP_TAC REAL_EQ_IMP_LE THEN
    REWRITE_TAC[COMPLEX_NORM_DIV; COMPLEX_NORM_CX; REAL_ABS_NUM] THEN
    REWRITE_TAC[COMPLEX_NORM_POW] THEN REAL_ARITH_TAC;
    LIM_TAC THEN TRY(CONV_TAC COMPLEX_RING) THEN
    GEN_REWRITE_TAC LAND_CONV [GSYM o_DEF] THEN
    MATCH_MP_TAC CONTINUOUS_AT_COMPOSE THEN
    REWRITE_TAC[CONTINUOUS_AT_CEXP] THEN
    REWRITE_TAC[CONTINUOUS_AT; LIM_AT; dist; COMPLEX_SUB_RZERO;
                IM_CX; REAL_ABS_NUM; COMPLEX_NORM_CX; REAL_ABS_ABS] THEN
    MESON_TAC[REAL_LET_TRANS; COMPLEX_NORM_GE_RE_IM]]);;

(* ------------------------------------------------------------------------- *)
(* Roots of unity.                                                           *)
(* ------------------------------------------------------------------------- *)

let COMPLEX_ROOT_POLYFUN = prove
 (`!n z a.
        1 <= n
        ==> (z pow n = a <=>
             vsum(0..n) (\i. (if i = 0 then --a else if i = n then Cx(&1)
                              else Cx(&0)) * z pow i) = Cx(&0))`,
  ASM_SIMP_TAC[VSUM_CLAUSES_RIGHT; LE_1; LE_0] THEN
  SIMP_TAC[VSUM_CLAUSES_LEFT; LE_0; ADD_CLAUSES] THEN
  ASM_SIMP_TAC[LE_1; ARITH_RULE `1 <= n /\ 1 <= i /\ i <= n - 1
                           ==> ~(i = n)`] THEN
  REWRITE_TAC[COMPLEX_MUL_LZERO; complex_pow; COMPLEX_MUL_RID] THEN
  REWRITE_TAC[GSYM COMPLEX_VEC_0; VSUM_0; VECTOR_ADD_RID] THEN
  REWRITE_TAC[COMPLEX_VEC_0] THEN CONV_TAC COMPLEX_RING);;

let COMPLEX_ROOT_UNITY = prove
 (`!n j. ~(n = 0)
         ==> cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) pow n = Cx(&1)`,
  REWRITE_TAC[GSYM CEXP_N; CX_DIV] THEN
  ASM_SIMP_TAC[CX_INJ; complex_div; REAL_OF_NUM_EQ; COMPLEX_FIELD
    `~(n = Cx(&0)) ==> n * t * p * ii * j * inv(n) = j * (ii * t * p)`] THEN
  REWRITE_TAC[CEXP_N; GSYM CX_MUL] THEN
  REWRITE_TAC[CEXP_EULER; GSYM CX_MUL; GSYM CX_SIN; GSYM CX_COS] THEN
  REWRITE_TAC[COS_NPI; SIN_NPI; REAL_POW_NEG; COMPLEX_MUL_RZERO;
              REAL_POW_ONE; ARITH_EVEN; COMPLEX_ADD_RID; COMPLEX_POW_ONE]);;

let COMPLEX_ROOT_UNITY_EQ = prove
 (`!n j k. ~(n = 0)
           ==> (cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) =
                cexp(Cx(&2) * Cx pi * ii * Cx(&k / &n)) <=> (j == k) (mod n))`,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CEXP_EQ; num_congruent; CX_MUL] THEN
  REWRITE_TAC[COMPLEX_RING
   `t * p * ii * j = t * p * ii * k + (t * n * p) * ii <=>
        (t * p * ii = Cx(&0)) \/ j - k = n`] THEN
  SIMP_TAC[COMPLEX_ENTIRE; II_NZ; CX_INJ; PI_NZ; REAL_OF_NUM_EQ; ARITH] THEN
  REWRITE_TAC[GSYM CX_SUB; CX_INJ] THEN
  ASM_SIMP_TAC[REAL_OF_NUM_EQ; REAL_FIELD
   `~(n = &0) ==> (j / n - k / n = m <=> j - k = n * m)`] THEN
  REWRITE_TAC[int_congruent] THEN
  REWRITE_TAC[int_eq; int_sub_th; int_mul_th; int_of_num_th] THEN
  MESON_TAC[int_abstr; int_rep]);;

let COMPLEX_ROOT_UNITY_EQ_1 = prove
 (`!n j. ~(n = 0)
         ==> (cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) = Cx(&1) <=>
              n divides j)`,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `Cx(&1) = cexp(Cx(&2) * Cx pi * ii * Cx(&n / &n))`
  SUBST1_TAC THENL
   [ASM_SIMP_TAC[REAL_DIV_REFL; REAL_OF_NUM_EQ; COMPLEX_MUL_RID] THEN
    ONCE_REWRITE_TAC[COMPLEX_RING `t * p * ii = ii * t * p`] THEN
    REWRITE_TAC[CEXP_EULER; GSYM CX_MUL; GSYM CX_SIN; GSYM CX_COS] THEN
    REWRITE_TAC[COS_NPI; SIN_NPI] THEN SIMPLE_COMPLEX_ARITH_TAC;
    ASM_SIMP_TAC[COMPLEX_ROOT_UNITY_EQ] THEN CONV_TAC NUMBER_RULE]);;

let FINITE_CARD_COMPLEX_ROOTS_UNITY = prove
 (`!n. 1 <= n
       ==> FINITE {z | z pow n = Cx(&1)} /\ CARD {z | z pow n = Cx(&1)} <= n`,
  REPEAT GEN_TAC THEN DISCH_TAC THEN ASM_SIMP_TAC[COMPLEX_ROOT_POLYFUN] THEN
  MATCH_MP_TAC COMPLEX_POLYFUN_ROOTBOUND THEN
  DISCH_THEN(MP_TAC o SPEC `n:num`) THEN
  ASM_SIMP_TAC[IN_NUMSEG; LE_1; LE_0; LE_REFL] THEN CONV_TAC COMPLEX_RING);;

let FINITE_COMPLEX_ROOTS_UNITY = prove
 (`!n. ~(n = 0) ==> FINITE {z | z pow n = Cx(&1)}`,
  SIMP_TAC[FINITE_CARD_COMPLEX_ROOTS_UNITY; LE_1]);;

let FINITE_CARD_COMPLEX_ROOTS_UNITY_EXPLICIT = prove
 (`!n. 1 <= n
       ==> FINITE {cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) | j | j < n} /\
           CARD {cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) | j | j < n} = n`,
  let lemma = prove (* So we don't need to load number theories yet *)
   (`!x y n:num. (x == y) (mod n) /\ x < y + n /\ y < x + n ==> x = y`,
    REWRITE_TAC[num_congruent; GSYM INT_OF_NUM_EQ; GSYM INT_OF_NUM_LT] THEN
    REWRITE_TAC[GSYM INT_OF_NUM_ADD] THEN
    REWRITE_TAC[INT_ARITH `x < y + n /\ y < x + n <=> abs(x - y:int) < n`] THEN
    REPEAT GEN_TAC THEN REWRITE_TAC[int_congruent] THEN
    DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC `d:int`) MP_TAC) THEN
    ONCE_REWRITE_TAC[GSYM INT_SUB_0] THEN
    ASM_SIMP_TAC[INT_ABS_MUL; INT_ENTIRE; INT_ABS_NUM;
                 INT_ARITH `n * x:int < n <=> n * x < n * &1`] THEN
    DISJ_CASES_TAC(INT_ARITH `&n:int = &0 \/ &0:int < &n`) THEN
    ASM_SIMP_TAC[INT_LT_LMUL_EQ] THEN INT_ARITH_TAC) in
  REWRITE_TAC[GSYM HAS_SIZE] THEN
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [SIMPLE_IMAGE_GEN] THEN
  MATCH_MP_TAC HAS_SIZE_IMAGE_INJ THEN REWRITE_TAC[IN_ELIM_THM] THEN
  ASM_SIMP_TAC[HAS_SIZE_NUMSEG_LT; COMPLEX_ROOT_UNITY_EQ; LE_1] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC lemma THEN EXISTS_TAC `n:num` THEN
  ASM_REWRITE_TAC[] THEN ASM_ARITH_TAC);;

let COMPLEX_ROOTS_UNITY = prove
 (`!n. 1 <= n
       ==> {z | z pow n = Cx(&1)} =
           {cexp(Cx(&2) * Cx pi * ii * Cx(&j / &n)) | j | j < n}`,
  REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN MATCH_MP_TAC CARD_SUBSET_LE THEN
  ASM_SIMP_TAC[FINITE_CARD_COMPLEX_ROOTS_UNITY;
               FINITE_CARD_COMPLEX_ROOTS_UNITY_EXPLICIT] THEN
  GEN_REWRITE_TAC LAND_CONV [SIMPLE_IMAGE_GEN] THEN
  REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; IN_ELIM_THM] THEN
  ASM_SIMP_TAC[COMPLEX_ROOT_UNITY; LE_1]);;

let CARD_COMPLEX_ROOTS_UNITY = prove
 (`!n. 1 <= n ==> CARD {z | z pow n = Cx(&1)} = n`,
  SIMP_TAC[COMPLEX_ROOTS_UNITY; FINITE_CARD_COMPLEX_ROOTS_UNITY_EXPLICIT]);;

let HAS_SIZE_COMPLEX_ROOTS_UNITY = prove
 (`!n. 1 <= n ==> {z | z pow n = Cx(&1)} HAS_SIZE n`,
  SIMP_TAC[HAS_SIZE; CARD_COMPLEX_ROOTS_UNITY; FINITE_COMPLEX_ROOTS_UNITY;
           LE_1]);;

let COMPLEX_NOT_ROOT_UNITY = prove
 (`!n. 1 <= n ==> ?u. norm u = &1 /\ ~(u pow n = Cx(&1))`,
  GEN_TAC THEN DISCH_TAC THEN
  ABBREV_TAC `u = cexp (Cx pi * ii * Cx (&1 / &n))` THEN
  EXISTS_TAC `u : complex` THEN CONJ_TAC THEN EXPAND_TAC "u" THEN
  REWRITE_TAC [NORM_CEXP; RE_MUL_CX; RE_II; REAL_MUL_LZERO;
               REAL_MUL_RZERO; REAL_EXP_0] THEN
  EXPAND_TAC "u" THEN REWRITE_TAC[GSYM CEXP_N] THEN
  ASM_SIMP_TAC[CX_DIV; LE_1; CX_INJ; REAL_OF_NUM_EQ; COMPLEX_FIELD
       `~(n = Cx(&0)) ==> n * p * i * Cx(&1) / n = i * p`] THEN
  REWRITE_TAC[CEXP_EULER; RE_CX; IM_CX; GSYM CX_COS; GSYM CX_SIN] THEN
  REWRITE_TAC[COS_PI; SIN_PI] THEN CONV_TAC COMPLEX_RING);;

(* ------------------------------------------------------------------------- *)
(* Relation between clog and Arg, and hence continuity of Arg.               *)
(* ------------------------------------------------------------------------- *)

let ARG_CLOG = prove
 (`!z. &0 < Arg z ==> Arg z = Im(clog(--z)) + pi`,
  GEN_TAC THEN ASM_CASES_TAC `z = Cx(&0)` THENL
   [ASM_REWRITE_TAC[Arg_DEF; REAL_LT_REFL]; ALL_TAC] THEN
  DISCH_TAC THEN MP_TAC(last(CONJUNCTS(SPEC `z:complex` ARG))) THEN
  ASM_SIMP_TAC[CX_INJ; COMPLEX_NORM_ZERO; COMPLEX_FIELD
   `~(z = Cx(&0)) ==> (w = z * a <=> a = w / z)`] THEN
  DISCH_THEN(MP_TAC o AP_TERM `( * ) (cexp(--(ii * Cx pi)))`) THEN
  REWRITE_TAC[GSYM CEXP_ADD] THEN DISCH_THEN(MP_TAC o AP_TERM `clog`) THEN
  W(MP_TAC o PART_MATCH (lhs o rand) CLOG_CEXP o lhand o lhand o snd) THEN
  REWRITE_TAC[IM_ADD; IM_MUL_II; RE_CX; IM_NEG] THEN
  ASM_SIMP_TAC[REAL_LT_ADDR; ARG; REAL_ARITH
    `z < &2 * pi ==> --pi + z <= pi`] THEN
  DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[CEXP_NEG; CEXP_EULER] THEN
  REWRITE_TAC[GSYM CX_SIN; GSYM CX_COS; SIN_PI; COS_PI] THEN
  REWRITE_TAC[CX_NEG; COMPLEX_MUL_RZERO; COMPLEX_ADD_RID;
              SIMPLE_COMPLEX_ARITH `inv(--Cx(&1)) * z / w = --z / w`] THEN
  DISCH_THEN(MP_TAC o AP_TERM `Im`) THEN
  REWRITE_TAC[IM_ADD; IM_NEG; IM_MUL_II; RE_CX] THEN
  MATCH_MP_TAC(REAL_RING `w = z ==> --pi + x = w ==> x = z + pi`) THEN
  REWRITE_TAC[complex_div] THEN
  W(MP_TAC o PART_MATCH (lhs o rand) CLOG_MUL_SIMPLE o rand o lhand o snd) THEN
  ASM_SIMP_TAC[CX_INJ; REAL_INV_EQ_0; COMPLEX_NORM_ZERO; COMPLEX_NEG_EQ_0;
    GSYM CX_INV; GSYM CX_LOG; REAL_LT_INV_EQ; COMPLEX_NORM_NZ; IM_CX] THEN
  ASM_SIMP_TAC[REAL_ADD_RID; CLOG_WORKS; COMPLEX_NEG_EQ_0] THEN
  DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[IM_ADD; IM_CX; REAL_ADD_RID]);;

let CONTINUOUS_AT_ARG = prove
 (`!z. ~(real z /\ &0 <= Re z) ==> (Cx o Arg) continuous (at z)`,
  let lemma = prove
   (`(\z. Cx(Im(f z) + pi)) = (Cx o Im) o (\z. f z + ii * Cx pi)`,
    REWRITE_TAC[FUN_EQ_THM; o_DEF; IM_ADD; IM_CX; IM_MUL_II; RE_CX]) in
  REPEAT STRIP_TAC THEN REWRITE_TAC[CONTINUOUS_AT] THEN
  MATCH_MP_TAC LIM_TRANSFORM_WITHIN_OPEN THEN
  EXISTS_TAC `\z. Cx(Im(clog(--z)) + pi)` THEN
  EXISTS_TAC `(:complex) DIFF {z | real z /\ &0 <= Re z}` THEN
  ASM_REWRITE_TAC[IN_DIFF; IN_UNIV; IN_ELIM_THM; GSYM closed] THEN
  ASM_SIMP_TAC[o_THM; ARG_CLOG; ARG_LT_NZ; ARG_EQ_0] THEN CONJ_TAC THENL
   [REWRITE_TAC[SET_RULE `{z | P z /\ Q z} = P INTER {z | Q z}`] THEN
    MATCH_MP_TAC CLOSED_INTER THEN
    REWRITE_TAC[CLOSED_REAL; GSYM real_ge; CLOSED_HALFSPACE_RE_GE];
    REWRITE_TAC[GSYM CONTINUOUS_AT; lemma] THEN
    MATCH_MP_TAC CONTINUOUS_AT_COMPOSE THEN
    REWRITE_TAC[CONTINUOUS_AT_CX_IM] THEN
    MATCH_MP_TAC CONTINUOUS_ADD THEN REWRITE_TAC[CONTINUOUS_CONST] THEN
    MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_AT_COMPOSE) THEN
    GEN_REWRITE_TAC (LAND_CONV o LAND_CONV) [GSYM ETA_AX] THEN
    SIMP_TAC[CONTINUOUS_NEG; CONTINUOUS_AT_ID] THEN
    MATCH_MP_TAC CONTINUOUS_AT_CLOG THEN POP_ASSUM MP_TAC THEN
    REWRITE_TAC[real; IM_NEG; RE_NEG] THEN REAL_ARITH_TAC]);;

let CONTINUOUS_WITHIN_UPPERHALF_ARG = prove
 (`!z. ~(z = Cx(&0))
       ==> (Cx o Arg) continuous (at z) within {z | &0 <= Im z}`,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC `real z /\ &0 <= Re z` THEN
  ASM_SIMP_TAC[CONTINUOUS_AT_ARG; CONTINUOUS_AT_WITHIN] THEN
  FIRST_X_ASSUM(CONJUNCTS_THEN2
   (ASSUME_TAC o GEN_REWRITE_RULE I [real]) MP_TAC) THEN
  SUBGOAL_THEN `~(Re z = &0)` ASSUME_TAC THENL
   [DISCH_TAC THEN UNDISCH_TAC `~(z = Cx(&0))` THEN
    ASM_REWRITE_TAC[COMPLEX_EQ; RE_CX; IM_CX];
    GEN_REWRITE_TAC LAND_CONV [REAL_LE_LT]] THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  MP_TAC(ISPEC `rotate2d (pi / &2) z` CONTINUOUS_AT_ARG) THEN ANTS_TAC THENL
   [ASM_REWRITE_TAC[ROTATE2D_PI2; real; IM_MUL_II]; ALL_TAC] THEN
  REWRITE_TAC[continuous_at; continuous_within] THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `e:real` THEN
  ASM_CASES_TAC `&0 < e` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `d:real` THEN
  REWRITE_TAC[o_THM; dist; GSYM CX_SUB; COMPLEX_NORM_CX] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[IN_ELIM_THM] THEN
  X_GEN_TAC `w:complex` THEN STRIP_TAC THEN
  SUBGOAL_THEN `Arg z = &0` ASSUME_TAC THENL
   [ASM_SIMP_TAC[ARG_EQ_0; real; REAL_LT_IMP_LE]; ALL_TAC] THEN
  ASM_CASES_TAC `Arg w = &0` THEN
  ASM_REWRITE_TAC[REAL_SUB_REFL; REAL_ABS_NUM] THEN
  SUBGOAL_THEN `&0 < Arg w` ASSUME_TAC THENL
   [ASM_REWRITE_TAC[ARG; REAL_LT_LE]; ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC `rotate2d (pi / &2) w`) THEN
  ASM_REWRITE_TAC[GSYM ROTATE2D_SUB; NORM_ROTATE2D] THEN
  MP_TAC(ISPECL [`pi / &2`; `z:complex`] ARG_ROTATE2D) THEN ANTS_TAC THENL
   [ASM_REWRITE_TAC[] THEN MP_TAC PI_POS THEN ASM_REAL_ARITH_TAC; ALL_TAC] THEN
  DISCH_THEN SUBST1_TAC THEN ASM_REWRITE_TAC[REAL_ADD_RID] THEN
  MATCH_MP_TAC(REAL_ARITH
   `w' = p + w ==> abs(w' - p) < e ==> abs(w - &0) < e`) THEN
  MATCH_MP_TAC ARG_ROTATE2D THEN CONJ_TAC THENL
   [DISCH_TAC THEN UNDISCH_TAC `&0 < Arg w` THEN
    ASM_REWRITE_TAC[Arg_DEF; REAL_LT_REFL];
    FIRST_X_ASSUM(MP_TAC o GEN_REWRITE_RULE I [GSYM ARG_LE_PI]) THEN
    MP_TAC(SPEC `w:complex` ARG) THEN REAL_ARITH_TAC]);;

let CONTINUOUS_ON_UPPERHALF_ARG = prove
 (`(Cx o Arg) continuous_on ({z | &0 <= Im z} DIFF {Cx(&0)})`,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  X_GEN_TAC `z:complex` THEN REWRITE_TAC[IN_DIFF; IN_SING; IN_ELIM_THM] THEN
  STRIP_TAC THEN FIRST_ASSUM(MP_TAC o
    MATCH_MP CONTINUOUS_WITHIN_UPPERHALF_ARG) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_WITHIN_SUBSET) THEN
  SET_TAC[]);;

let CONTINUOUS_ON_COMPOSE_ARG = prove
 (`!s p:real->real^N.
        (p o drop) continuous_on interval[vec 0,lift(&2 * pi)] /\
        p(&2 * pi) = p(&0) /\ ~(Cx(&0) IN s)
        ==> (\z. p(Arg z)) continuous_on s`,
  let ulemma = prove
   (`!s. s INTER {z | &0 <= Im z} UNION s INTER {z | Im z <= &0} = s`,
    SET_TAC[REAL_LE_TOTAL]) in
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THEN
  EXISTS_TAC
   `\z. if &0 <= Im z then p(Arg z)
        else p(&2 * pi - Arg(cnj z)):real^N` THEN
  REWRITE_TAC[IN_UNIV; IN_SING; IN_DIFF] THEN CONJ_TAC THENL
   [X_GEN_TAC `z:complex` THEN DISCH_TAC THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[ARG_CNJ] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_SUB_SUB2] THEN
    SUBGOAL_THEN `Arg z = &0`
     (fun th -> ASM_REWRITE_TAC[REAL_SUB_RZERO; th]) THEN
    ASM_REWRITE_TAC[ARG_EQ_0];
    GEN_REWRITE_TAC RAND_CONV [GSYM ulemma] THEN
    MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN REWRITE_TAC[ulemma] THEN
    SIMP_TAC[CLOSED_IN_CLOSED_INTER; CLOSED_HALFSPACE_IM_LE;
             REWRITE_RULE[real_ge] CLOSED_HALFSPACE_IM_GE] THEN
    REWRITE_TAC[IN_INTER; IN_DIFF; IN_UNIV; IN_SING; IN_ELIM_THM] THEN
    SIMP_TAC[GSYM CONJ_ASSOC; REAL_LE_ANTISYM; TAUT `~(p /\ ~p)`] THEN
    REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
     [GEN_REWRITE_TAC (BINOP_CONV o LAND_CONV) [GSYM o_DEF] THEN
      SUBGOAL_THEN `(p:real->real^N) = (p o drop) o lift` SUBST1_TAC THENL
       [REWRITE_TAC[o_DEF; LIFT_DROP; ETA_AX]; ALL_TAC] THEN
      ONCE_REWRITE_TAC[GSYM o_ASSOC] THEN
      CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN CONJ_TAC THENL
       [REWRITE_TAC[o_DEF; GSYM CONTINUOUS_ON_CX_LIFT] THEN
        MP_TAC CONTINUOUS_ON_UPPERHALF_ARG THEN REWRITE_TAC[o_DEF] THEN
        MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
        ASM SET_TAC[];
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ]
          CONTINUOUS_ON_SUBSET)) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; IN_INTER; IN_ELIM_THM] THEN
        REWRITE_TAC[IN_INTERVAL_1; LIFT_DROP; o_THM; DROP_VEC] THEN
        SIMP_TAC[ARG; REAL_LT_IMP_LE];
        REWRITE_TAC[o_DEF; LIFT_SUB] THEN MATCH_MP_TAC CONTINUOUS_ON_SUB THEN
        REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
        GEN_REWRITE_TAC (LAND_CONV o TOP_DEPTH_CONV) [GSYM o_DEF] THEN
        REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
        REWRITE_TAC[CONTINUOUS_ON_CNJ; o_DEF; GSYM CONTINUOUS_ON_CX_LIFT] THEN
        MP_TAC CONTINUOUS_ON_UPPERHALF_ARG THEN REWRITE_TAC[o_DEF] THEN
        MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
        SIMP_TAC[SUBSET; FORALL_IN_IMAGE; IN_INTER; IN_ELIM_THM; IN_DIFF] THEN
        SIMP_TAC[IN_SING; CNJ_EQ_0; IM_CNJ; REAL_NEG_GE0] THEN ASM SET_TAC[];
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ]
          CONTINUOUS_ON_SUBSET)) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; IN_INTER; IN_ELIM_THM] THEN
        REWRITE_TAC[IN_INTERVAL_1; LIFT_DROP; o_THM; DROP_VEC] THEN
        X_GEN_TAC `z:complex` THEN STRIP_TAC THEN
        MP_TAC(SPEC `cnj z` ARG) THEN REAL_ARITH_TAC];
      REWRITE_TAC[GSYM ARG_EQ_0_PI; GSYM real; ARG_CNJ] THEN
      REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
      COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_SUB_SUB2; REAL_SUB_RZERO] THEN
      ASM_REWRITE_TAC[REAL_ARITH `&2 * x - x = x`]]]);;

let OPEN_ARG_LTT = prove
 (`!s t. &0 <= s /\ t <= &2 * pi ==> open {z | s < Arg z /\ Arg z < t}`,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`Cx o Arg`; `(:complex) DIFF {z | real z /\ &0 <= Re z}`;
                   `{z | Re(z) > s} INTER {z | Re(z) < t}`]
           CONTINUOUS_OPEN_PREIMAGE) THEN
  ASM_SIMP_TAC[OPEN_INTER; OPEN_HALFSPACE_RE_GT; OPEN_HALFSPACE_RE_LT] THEN
  ANTS_TAC THENL
   [CONJ_TAC THENL
     [MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
      REWRITE_TAC[IN_DIFF; IN_UNIV; IN_ELIM_THM; CONTINUOUS_AT_ARG];
      REWRITE_TAC[GSYM closed] THEN
      REWRITE_TAC[SET_RULE `{z | P z /\ Q z} = P INTER {z | Q z}`] THEN
      MATCH_MP_TAC CLOSED_INTER THEN
      REWRITE_TAC[CLOSED_REAL; GSYM real_ge; CLOSED_HALFSPACE_RE_GE]];
    MATCH_MP_TAC EQ_IMP THEN AP_TERM_TAC THEN REWRITE_TAC[EXTENSION] THEN
    ASM_SIMP_TAC[IN_DIFF; IN_INTER; IN_UNIV; IN_ELIM_THM; o_THM; RE_CX;
                 GSYM ARG_EQ_0] THEN
    ASM_REAL_ARITH_TAC]);;

let OPEN_ARG_GT = prove
 (`!t. open {z | t < Arg z}`,
  GEN_TAC THEN DISJ_CASES_TAC(REAL_ARITH `t < &0 \/ &0 <= t`) THENL
   [SUBGOAL_THEN `{z | t < Arg z} = (:complex)`
     (fun th -> SIMP_TAC[th; OPEN_UNIV]) THEN
    REWRITE_TAC[EXTENSION; IN_UNIV; IN_ELIM_THM] THEN
    MP_TAC ARG THEN MATCH_MP_TAC MONO_FORALL THEN ASM_REAL_ARITH_TAC;
    MP_TAC(ISPECL [`t:real`; `&2 * pi`] OPEN_ARG_LTT) THEN
    ASM_REWRITE_TAC[ARG; REAL_LE_REFL]]);;

let CLOSED_ARG_LE = prove
 (`!t. closed {z | Arg z <= t}`,
  REWRITE_TAC[closed; DIFF; IN_UNIV; IN_ELIM_THM] THEN
  REWRITE_TAC[REAL_NOT_LE; OPEN_ARG_GT]);;

(* ------------------------------------------------------------------------- *)
(* Relation between Arg and arctangent in upper halfplane.                   *)
(* ------------------------------------------------------------------------- *)

let ARG_ATAN_UPPERHALF = prove
 (`!z. &0 < Im z ==> Arg(z) = pi / &2 - atn(Re z / Im z)`,
  GEN_TAC THEN ASM_CASES_TAC `z = Cx(&0)` THEN
  ASM_REWRITE_TAC[IM_CX; REAL_LT_REFL] THEN DISCH_TAC THEN
  MATCH_MP_TAC ARG_UNIQUE THEN EXISTS_TAC `norm(z:complex)` THEN
  ASM_REWRITE_TAC[COMPLEX_NORM_NZ] THEN CONJ_TAC THENL
   [ALL_TAC; MP_TAC(ISPEC `Re z / Im z` ATN_BOUNDS) THEN REAL_ARITH_TAC] THEN
  REWRITE_TAC[CEXP_EULER; GSYM CX_SIN; GSYM CX_COS] THEN
  REWRITE_TAC[SIN_SUB; COS_SUB; SIN_PI2; COS_PI2] THEN
  REWRITE_TAC[REAL_MUL_LZERO; REAL_MUL_LID; SIN_ATN; COS_ATN] THEN
  SUBGOAL_THEN `sqrt(&1 + (Re z / Im z) pow 2) = norm(z) / Im z`
  SUBST1_TAC THENL
   [MATCH_MP_TAC SQRT_UNIQUE THEN
    ASM_SIMP_TAC[REAL_LE_DIV; NORM_POS_LE; REAL_LT_IMP_LE] THEN
    REWRITE_TAC[REAL_POW_DIV; COMPLEX_SQNORM] THEN
    UNDISCH_TAC `&0 < Im z` THEN CONV_TAC REAL_FIELD;
    REWRITE_TAC[REAL_ADD_LID; REAL_SUB_RZERO; real_div] THEN
    REWRITE_TAC[COMPLEX_EQ; RE_MUL_CX; IM_MUL_CX; RE_MUL_II; IM_MUL_II;
                RE_ADD; IM_ADD; RE_CX; IM_CX] THEN
    FIRST_X_ASSUM(MP_TAC o GEN_REWRITE_RULE I [GSYM COMPLEX_NORM_NZ]) THEN
    POP_ASSUM MP_TAC THEN CONV_TAC REAL_FIELD]);;

(* ------------------------------------------------------------------------- *)
(* Real n'th roots. Regardless of whether n is odd or even, we totalize by   *)
(* setting root_n(-x) = -root_n(x), which makes some convenient facts hold.  *)
(* ------------------------------------------------------------------------- *)

let root = new_definition
 `root(n) x = real_sgn(x) * exp(log(abs x) / &n)`;;

let ROOT_0 = prove
 (`!n. root n (&0) = &0`,
  REWRITE_TAC[root; REAL_SGN_0; REAL_MUL_LZERO]);;

let ROOT_1 = prove
 (`!n. root n (&1) = &1`,
  REWRITE_TAC[root; REAL_ABS_NUM; LOG_1; real_div; REAL_MUL_LZERO] THEN
  REWRITE_TAC[real_sgn; REAL_EXP_0] THEN REAL_ARITH_TAC);;

let ROOT_2 = prove
 (`!x. root 2 x = sqrt x`,
  GEN_TAC THEN CONV_TAC SYM_CONV THEN MATCH_MP_TAC SQRT_UNIQUE_GEN THEN
  REWRITE_TAC[root; REAL_SGN_MUL; REAL_POW_MUL; REAL_SGN_REAL_SGN] THEN
  REWRITE_TAC[REAL_SGN_POW_2; GSYM REAL_SGN_POW] THEN
  SIMP_TAC[real_sgn; REAL_EXP_POS_LT; REAL_MUL_RID] THEN
  REWRITE_TAC[REAL_ARITH `(&0 < abs x <=> ~(x = &0)) /\ ~(abs x < &0)`] THEN
  ASM_CASES_TAC `x = &0` THEN
  ASM_REWRITE_TAC[REAL_MUL_LZERO; REAL_ABS_NUM; REAL_MUL_LID] THEN
  REWRITE_TAC[GSYM REAL_EXP_N; REAL_ARITH `&2 * x / &2 = x`] THEN
  ASM_SIMP_TAC[EXP_LOG; REAL_ARITH `&0 < abs x <=> ~(x = &0)`]);;

let ROOT_NEG = prove
 (`!n x. root n (--x) = --(root n x)`,
  REWRITE_TAC[root; REAL_SGN_NEG; REAL_ABS_NEG; REAL_MUL_LNEG]);;

let ROOT_WORKS = prove
 (`!n x. real_sgn(root n x) = real_sgn x /\
         (root n x) pow n = if n = 0 then &1
                            else real_sgn(x) pow n * abs x`,
  REWRITE_TAC[root; REAL_SGN_MUL; REAL_POW_MUL; GSYM REAL_EXP_N] THEN
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[real_div; REAL_MUL_LZERO; REAL_MUL_RZERO; REAL_INV_0;
                  REAL_EXP_0; REAL_MUL_RID; real_pow; REAL_SGN_REAL_SGN] THEN
  REWRITE_TAC[real_sgn; REAL_LT_01; REAL_MUL_RID] THEN
  ASM_SIMP_TAC[REAL_EXP_POS_LT; REAL_MUL_RID; GSYM REAL_ABS_NZ;
               GSYM real_div; REAL_DIV_LMUL; REAL_OF_NUM_EQ] THEN
  ASM_CASES_TAC `x = &0` THEN
  ASM_REWRITE_TAC[REAL_LT_REFL; REAL_POW_ZERO; REAL_MUL_LZERO] THEN
  ASM_SIMP_TAC[EXP_LOG; GSYM REAL_ABS_NZ]);;

let REAL_POW_ROOT = prove
 (`!n x. ODD n \/ ~(n = 0) /\ &0 <= x ==> (root n x) pow n = x`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `n = 0` THEN
  ASM_REWRITE_TAC[ARITH] THEN STRIP_TAC THEN ASM_REWRITE_TAC[ROOT_WORKS] THENL
   [FIRST_ASSUM(CHOOSE_THEN SUBST1_TAC o GEN_REWRITE_RULE I [ODD_EXISTS]) THEN
    REWRITE_TAC[ONCE_REWRITE_RULE[REAL_MUL_SYM] real_pow] THEN
    REWRITE_TAC[GSYM REAL_MUL_ASSOC; REAL_SGN_ABS] THEN
    REWRITE_TAC[GSYM REAL_POW_POW] THEN
    REWRITE_TAC[REWRITE_RULE[REAL_SGN_POW] REAL_SGN_POW_2] THEN
    REWRITE_TAC[real_sgn; GSYM REAL_ABS_NZ] THEN
    ASM_CASES_TAC `x = &0` THEN
    ASM_REWRITE_TAC[REAL_LT_REFL; REAL_POW_ONE] THEN ASM_REAL_ARITH_TAC;
    ASM_REWRITE_TAC[real_sgn; REAL_LT_LE] THEN
    ASM_CASES_TAC `x = &0` THEN
    ASM_REWRITE_TAC[REAL_POW_ZERO; REAL_POW_ONE] THEN
    ASM_REAL_ARITH_TAC]);;

let ROOT_POS_LT = prove
 (`!n x. &0 < x ==> &0 < root n x`,
  REPEAT STRIP_TAC THEN REWRITE_TAC[root] THEN
  MATCH_MP_TAC REAL_LT_MUL THEN
  ASM_REWRITE_TAC[REAL_EXP_POS_LT; REAL_SGN_INEQS]);;

let ROOT_POS_LE = prove
 (`!n x. &0 <= x ==> &0 <= root n x`,
  MESON_TAC[REAL_LE_LT; ROOT_POS_LT; ROOT_0; REAL_LT_REFL]);;

let ROOT_LT_0 = prove
 (`!n x. &0 < root n x <=> &0 < x`,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[ROOT_POS_LT] THEN
  REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
  REWRITE_TAC[REAL_ARITH `x <= &0 <=> &0 <= --x`; GSYM ROOT_NEG] THEN
  REWRITE_TAC[ROOT_POS_LE]);;

let ROOT_LE_0 = prove
 (`!n x. &0 <= root n x <=> &0 <= x`,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[ROOT_POS_LE] THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN
  ONCE_REWRITE_TAC[GSYM CONTRAPOS_THM] THEN
  REWRITE_TAC[REAL_ARITH `x < &0 <=> &0 < --x`; GSYM ROOT_NEG] THEN
  REWRITE_TAC[ROOT_POS_LT]);;

let ROOT_EQ_0 = prove
 (`!n x. root n x = &0 <=> x = &0`,
  REWRITE_TAC[root; REAL_ENTIRE; REAL_EXP_NZ; REAL_SGN_INEQS]);;

let REAL_ROOT_MUL = prove
 (`!n x y. root n (x * y) = root n x * root n y`,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `x = &0` THEN ASM_REWRITE_TAC[REAL_MUL_LZERO; ROOT_0] THEN
  ASM_CASES_TAC `y = &0` THEN ASM_REWRITE_TAC[REAL_MUL_RZERO; ROOT_0] THEN
  REWRITE_TAC[root; REAL_SGN_MUL; REAL_ABS_MUL] THEN
  ASM_SIMP_TAC[LOG_MUL; GSYM REAL_ABS_NZ; real_div] THEN
  REWRITE_TAC[REAL_ADD_RDISTRIB; REAL_EXP_ADD] THEN
  REAL_ARITH_TAC);;

let REAL_ROOT_POW_GEN = prove
 (`!m n x y. root n (x pow m) = (root n x) pow m`,
  INDUCT_TAC THEN ASM_REWRITE_TAC[REAL_ROOT_MUL; ROOT_1; real_pow]);;

let REAL_ROOT_POW = prove
 (`!n x. ODD n \/ ~(n = 0) /\ &0 <= x ==> root n (x pow n) = x`,
  SIMP_TAC[REAL_ROOT_POW_GEN; REAL_POW_ROOT]);;

let ROOT_UNIQUE = prove
 (`!n x y. y pow n = x /\ (ODD n \/ ~(n = 0) /\ &0 <= y) ==> root n x = y`,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN ASSUME_TAC) THEN
  UNDISCH_THEN `(y:real) pow n = x` (SUBST_ALL_TAC o SYM) THEN
  MATCH_MP_TAC REAL_ROOT_POW THEN ASM_REWRITE_TAC[]);;

let REAL_ROOT_INV = prove
 (`!n x. root n (inv x) = inv(root n x)`,
  REPEAT GEN_TAC THEN REWRITE_TAC[root; REAL_SGN_INV; REAL_INV_SGN] THEN
  ASM_CASES_TAC `x = &0` THEN
  ASM_REWRITE_TAC[REAL_SGN_0; REAL_MUL_LZERO; REAL_INV_0] THEN
  REWRITE_TAC[REAL_INV_MUL; REAL_INV_SGN; REAL_ABS_INV] THEN
  ASM_SIMP_TAC[GSYM REAL_EXP_NEG; LOG_INV; GSYM REAL_ABS_NZ] THEN
  REWRITE_TAC[real_div; REAL_MUL_LNEG]);;

let REAL_ROOT_DIV = prove
 (`!n x y. root n (x / y) = root n x / root n y`,
  SIMP_TAC[real_div; REAL_ROOT_MUL; REAL_ROOT_INV]);;

let ROOT_MONO_LT = prove
 (`!n x y. ~(n = 0) /\ x < y ==> root n x < root n y`,
  GEN_TAC THEN REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN `!x y. &0 <= x /\ x < y ==> root n x < root n y`
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_POW_LT2_REV THEN
    EXISTS_TAC `n:num` THEN ASM_REWRITE_TAC[ROOT_WORKS; ROOT_LE_0] THEN
    ASM_REWRITE_TAC[real_sgn] THEN REPEAT
     (COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_POW_ONE; REAL_POW_ZERO]) THEN
    ASM_REAL_ARITH_TAC;
    REPEAT STRIP_TAC THEN ASM_CASES_TAC `&0 <= x` THEN ASM_SIMP_TAC[] THEN
    ASM_CASES_TAC `&0 <= y` THENL
     [MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC `&0` THEN
      ASM_REWRITE_TAC[GSYM REAL_NOT_LE; ROOT_LE_0];
      FIRST_X_ASSUM(MP_TAC o SPECL [`--y:real`; `--x:real`]) THEN
      REWRITE_TAC[ROOT_NEG] THEN ASM_REAL_ARITH_TAC]]);;

let ROOT_MONO_LE = prove
 (`!n x y. x <= y ==> root n x <= root n y`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `n = 0` THENL
   [ASM_REWRITE_TAC[root; real_div; REAL_INV_0; REAL_MUL_RZERO;
                    REAL_EXP_0; REAL_MUL_RID] THEN
    REWRITE_TAC[real_sgn] THEN ASM_REAL_ARITH_TAC;
    ASM_MESON_TAC[REAL_LE_LT; ROOT_0; ROOT_MONO_LT]]);;

let ROOT_MONO_LT_EQ = prove
 (`!n x y. ~(n = 0) ==> (root n x < root n y <=> x < y)`,
  MESON_TAC[ROOT_MONO_LT; REAL_NOT_LT; ROOT_MONO_LE]);;

let ROOT_MONO_LE_EQ = prove
 (`!n x y. ~(n = 0) ==> (root n x <= root n y <=> x <= y)`,
  MESON_TAC[ROOT_MONO_LT; REAL_NOT_LT; ROOT_MONO_LE]);;

let ROOT_INJ = prove
 (`!n x y. ~(n = 0) ==> (root n x = root n y <=> x = y)`,
  SIMP_TAC[GSYM REAL_LE_ANTISYM; ROOT_MONO_LE_EQ]);;

let REAL_ROOT_LE = prove
 (`!n x y. ~(n = 0) /\ &0 <= y
           ==> (root n x <= y <=> x <= y pow n)`,
  MESON_TAC[REAL_ROOT_POW; REAL_POW_LE; ROOT_MONO_LE_EQ]);;

let REAL_LE_ROOT = prove
 (`!n x y. ~(n = 0) /\ &0 <= x
           ==> (x <= root n y <=> x pow n <= y)`,
  MESON_TAC[REAL_ROOT_POW; REAL_POW_LE; ROOT_MONO_LE_EQ]);;

let LOG_ROOT = prove
 (`!n x. ~(n = 0) /\ &0 < x ==> log(root n x) = log x / &n`,
  SIMP_TAC[REAL_EQ_RDIV_EQ; REAL_OF_NUM_LT; LE_1] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  SIMP_TAC[GSYM LOG_POW; ROOT_POS_LT; REAL_POW_ROOT; REAL_LT_IMP_LE]);;

let ROOT_EXP_LOG = prove
 (`!n x. ~(n = 0) /\ &0 < x ==> root n x = exp(log x / &n)`,
  SIMP_TAC[root; real_sgn; real_abs; REAL_LT_IMP_LE; REAL_MUL_LID]);;

let ROOT_PRODUCT = prove
 (`!n f s. FINITE s ==> root n (product s f) = product s (\i. root n (f i))`,
  GEN_TAC THEN GEN_TAC THEN MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  SIMP_TAC[PRODUCT_CLAUSES; REAL_ROOT_MUL; ROOT_1]);;

let SQRT_PRODUCT = prove
 (`!f s. FINITE s ==> sqrt(product s f) = product s (\i. sqrt(f i))`,
  GEN_TAC THEN MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  SIMP_TAC[PRODUCT_CLAUSES; SQRT_MUL; SQRT_1]);;

(* ------------------------------------------------------------------------- *)
(* Real power function. This involves a few arbitrary choices.               *)
(*                                                                           *)
(* The value of x^y is unarguable when x > 0.                                *)
(*                                                                           *)
(* We make 0^0 = 1 to agree with "pow", but otherwise 0^y = 0.               *)
(*                                                                           *)
(* There is a sensible real value for (-x)^(p/q) where q is odd and either   *)
(* p is even [(-x)^y = x^y] or odd [(-x)^y = -x^y].                          *)
(*                                                                           *)
(* In all other cases, we return (-x)^y = -x^y. This is meaningless but at   *)
(* least it covers half the cases above without another case split.          *)
(*                                                                           *)
(* As for laws of indices, we do have x^-y = 1/x^y. Of course we can't  have *)
(* x^(yz) = x^y^z or x^(y+z) = x^y x^z since then (-1)^(1/2)^2 = -1.         *)
(* ------------------------------------------------------------------------- *)

parse_as_infix("rpow",(24,"left"));;

let rpow = new_definition
  `x rpow y = if &0 < x then exp(y * log x)
               else if x = &0 then if y = &0 then &1 else &0
               else if ?m n. ODD(m) /\ ODD(n) /\ (abs y = &m / &n)
                    then --(exp(y * log(--x)))
                    else exp(y * log(--x))`;;

let RPOW_POW = prove
 (`!x n. x rpow &n = x pow n`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC[REAL_EXP_N; EXP_LOG] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_POW_ZERO; REAL_OF_NUM_EQ] THEN
  ASM_SIMP_TAC[EXP_LOG; REAL_ARITH `~(&0 < x) /\ ~(x = &0) ==> &0 < --x`] THEN
  REWRITE_TAC[REAL_POW_NEG; REAL_ABS_NUM] THEN
  SUBGOAL_THEN `(?p q. ODD(p) /\ ODD(q) /\ &n = &p / &q) <=> ODD n`
   (fun th -> SIMP_TAC[th; GSYM NOT_ODD; REAL_NEG_NEG; COND_ID]) THEN
  EQ_TAC THEN REWRITE_TAC[LEFT_IMP_EXISTS_THM] THENL
   [REPEAT GEN_TAC THEN ASM_CASES_TAC `q = 0` THEN
    ASM_REWRITE_TAC[ARITH_ODD] THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_SIMP_TAC[REAL_OF_NUM_EQ; REAL_FIELD
     `~(q = &0) ==> (n = p / q <=> q * n = p)`] THEN
    REWRITE_TAC[REAL_OF_NUM_MUL; REAL_OF_NUM_EQ] THEN
    ASM_MESON_TAC[ODD_MULT];
    DISCH_TAC THEN MAP_EVERY EXISTS_TAC [`n:num`; `1`] THEN
    ASM_REWRITE_TAC[REAL_DIV_1; ARITH_ODD]]);;

let RPOW_0 = prove
 (`!x. x rpow &0 = &1`,
  REWRITE_TAC[RPOW_POW; real_pow]);;

let RPOW_NEG = prove
 (`!x y. x rpow (--y) = inv(x rpow y)`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_MUL_LNEG; REAL_EXP_NEG] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_NEG_EQ_0] THENL
   [COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_INV_0; REAL_INV_1];
    REWRITE_TAC[REAL_ABS_NEG] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_INV_NEG]]);;

let RPOW_ZERO = prove
 (`!y. &0 rpow y = if y = &0 then &1 else &0`,
  REWRITE_TAC[rpow; REAL_LT_REFL]);;

let RPOW_POS_LT = prove
 (`!x y. &0 < x ==> &0 < x rpow y`,
  SIMP_TAC[rpow; REAL_EXP_POS_LT]);;

let RPOW_POS_LE = prove
 (`!x y. &0 <= x ==> &0 <= x rpow y`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `x = &0` THENL
   [ASM_REWRITE_TAC[RPOW_ZERO] THEN MESON_TAC[REAL_POS];
    ASM_SIMP_TAC[RPOW_POS_LT; REAL_LE_LT]]);;

let RPOW_LT2 = prove
 (`!x y z. &0 <= x /\ x < y /\ &0 < z ==> x rpow z < y rpow z`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `x = &0` THEN
  ASM_SIMP_TAC[RPOW_ZERO; REAL_LT_IMP_NZ; RPOW_POS_LT] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[rpow] THEN
  ASM_CASES_TAC `&0 < x /\ &0 < y` THENL
   [ALL_TAC; MATCH_MP_TAC(TAUT `F ==> p`) THEN ASM_REAL_ARITH_TAC] THEN
  ASM_SIMP_TAC[REAL_EXP_MONO_LT; REAL_LT_LMUL_EQ] THEN
  MATCH_MP_TAC LOG_MONO_LT_IMP THEN ASM_REAL_ARITH_TAC);;

let RPOW_LE2 = prove
 (`!x y z. &0 <= x /\ x <= y /\ &0 <= z ==> x rpow z <= y rpow z`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `z = &0` THEN
  ASM_REWRITE_TAC[RPOW_POW; real_pow; REAL_LE_REFL] THEN
  ASM_CASES_TAC `x:real = y` THEN ASM_REWRITE_TAC[REAL_LE_REFL] THEN
  ASM_MESON_TAC[RPOW_LT2; REAL_LE_LT]);;

let REAL_ABS_RPOW = prove
 (`!x y. abs(x rpow y) = abs(x) rpow y`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow] THEN
  ASM_CASES_TAC `x = &0` THEN ASM_REWRITE_TAC[REAL_ABS_NUM; REAL_LT_REFL] THENL
   [REAL_ARITH_TAC; ALL_TAC] THEN
  ASM_REWRITE_TAC[GSYM REAL_ABS_NZ; REAL_ABS_ZERO] THEN
  COND_CASES_TAC THEN
  ASM_SIMP_TAC[REAL_ABS_EXP; REAL_ARITH `&0 < x ==> abs x = x`] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_ABS_NEG; REAL_ABS_EXP] THEN
  AP_TERM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN ASM_REAL_ARITH_TAC);;

let RPOW_ONE = prove
 (`!z. &1 rpow z = &1`,
  REWRITE_TAC[rpow; REAL_LT_01; LOG_1; REAL_MUL_RZERO; REAL_EXP_0]);;

let RPOW_RPOW = prove
 (`!x y z. &0 <= x ==> x rpow y rpow z = x rpow (y * z)`,
  REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_LT] THEN
  ASM_CASES_TAC `x = &0` THEN ASM_REWRITE_TAC[] THENL
   [ASM_REWRITE_TAC[RPOW_ZERO; REAL_ENTIRE] THEN
    ASM_CASES_TAC `y = &0` THEN ASM_REWRITE_TAC[RPOW_ZERO; RPOW_ONE];
    SIMP_TAC[rpow; REAL_EXP_POS_LT; LOG_EXP] THEN
    REWRITE_TAC[REAL_MUL_AC]]);;

let RPOW_LNEG = prove
 (`!x y. --x rpow y =
         if ?m n. ODD m /\ ODD n /\ abs y = &m / &n
         then --(x rpow y) else x rpow y`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow] THEN
  ASM_CASES_TAC `x = &0` THEN
  ASM_REWRITE_TAC[REAL_NEG_0; REAL_ABS_NUM; REAL_LT_REFL] THENL
   [ASM_CASES_TAC `y = &0` THEN ASM_REWRITE_TAC[REAL_NEG_0; COND_ID] THEN
    REWRITE_TAC[REAL_ARITH `abs(&0) = m / n <=> m * inv n = &0`] THEN
    SIMP_TAC[REAL_ENTIRE; REAL_INV_EQ_0; REAL_OF_NUM_EQ] THEN MESON_TAC[ODD];
    ASM_SIMP_TAC[REAL_ARITH `~(x = &0) ==> (&0 < --x <=> ~(&0 < x))`] THEN
    ASM_REWRITE_TAC[REAL_NEG_EQ_0] THEN
    ASM_CASES_TAC `&0 < x` THEN ASM_REWRITE_TAC[REAL_NEG_NEG; COND_ID]]);;

let RPOW_EQ_0 = prove
 (`!x y. x rpow y = &0 <=> x = &0 /\ ~(y = &0)`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow] THEN
  ASM_CASES_TAC `x = &0` THEN ASM_REWRITE_TAC[REAL_LT_REFL] THEN
  REPEAT(COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_NEG_EQ_0; REAL_EXP_NZ]) THEN
  REAL_ARITH_TAC);;

let RPOW_MUL = prove
 (`!x y z. (x * y) rpow z = x rpow z * y rpow z`,
  SUBGOAL_THEN
    `!x y z. &0 <= x /\ &0 <= y ==> (x * y) rpow z = x rpow z * y rpow z`
  ASSUME_TAC THENL
   [REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_LT] THEN
    ASM_CASES_TAC `z = &0` THEN
    ASM_REWRITE_TAC[RPOW_POW; real_pow; REAL_MUL_LID] THEN
    ASM_CASES_TAC `x = &0` THEN ASM_REWRITE_TAC[REAL_MUL_LZERO; RPOW_ZERO] THEN
    ASM_CASES_TAC `y = &0` THEN ASM_REWRITE_TAC[REAL_MUL_RZERO; RPOW_ZERO] THEN
    SIMP_TAC[rpow; REAL_LT_MUL; LOG_MUL; REAL_ADD_LDISTRIB; REAL_EXP_ADD];
    REPEAT GEN_TAC THEN
    REPEAT_TCL DISJ_CASES_THEN (ANTE_RES_THEN (MP_TAC o SPEC `z:real`))
     (REAL_ARITH `&0 <= x /\ &0 <= y \/ &0 <= x /\ &0 <= --y \/
                  &0 <= --x /\ &0 <= y \/ &0 <= --x /\ &0 <= --y`) THEN
    REWRITE_TAC[RPOW_LNEG; REAL_MUL_RNEG; REAL_MUL_LNEG] THEN
    COND_CASES_TAC THEN
    ASM_REWRITE_TAC[REAL_MUL_RNEG; REAL_MUL_LNEG; REAL_EQ_NEG2]]);;

let RPOW_INV = prove
 (`!x y. inv(x) rpow y = inv(x rpow y)`,
  REPEAT GEN_TAC THEN REWRITE_TAC[rpow; REAL_LT_INV_EQ] THEN
  SIMP_TAC[LOG_INV; REAL_MUL_RNEG; REAL_EXP_NEG] THEN
  COND_CASES_TAC THEN REWRITE_TAC[] THEN
  REWRITE_TAC[REAL_INV_EQ_0] THEN
  REPEAT(COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_INV_1; REAL_INV_0]) THEN
  ASM_SIMP_TAC[GSYM REAL_INV_NEG; LOG_INV;
               REAL_ARITH `~(&0 < x) /\ ~(x = &0) ==> &0 < --x`] THEN
  REWRITE_TAC[REAL_MUL_RNEG; REAL_EXP_NEG; REAL_INV_NEG]);;

let REAL_INV_RPOW = prove
 (`!x y. inv(x rpow y) = inv(x) rpow y`,
  REWRITE_TAC[RPOW_INV]);;

let RPOW_DIV = prove
 (`!x y z. (x / y) rpow z = x rpow z / y rpow z`,
  REWRITE_TAC[real_div; RPOW_MUL; RPOW_INV]);;

let RPOW_PRODUCT = prove
 (`!s:A->bool x y.
      FINITE s ==> (product s x) rpow y = product s (\i. x i rpow y)`,
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN
  MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  ASM_SIMP_TAC[PRODUCT_CLAUSES; RPOW_MUL; RPOW_ONE]);;

let RPOW_ADD = prove
 (`!x y z. &0 < x ==> x rpow (y + z) = x rpow y * x rpow z`,
  REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[rpow; REAL_ADD_RDISTRIB; REAL_EXP_ADD]);;

let RPOW_ADD_ALT = prove
 (`!x y z. &0 <= x /\ (x = &0 /\ y + z = &0 ==> y = &0 \/ z = &0)
           ==> x rpow (y + z) = x rpow y * x rpow z`,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `x = &0` THEN ASM_SIMP_TAC[REAL_LE_LT; RPOW_ADD] THEN
  REWRITE_TAC[RPOW_ZERO] THEN
  ASM_CASES_TAC `y = &0` THEN
  ASM_REWRITE_TAC[REAL_MUL_LID; REAL_ADD_LID] THEN
  ASM_CASES_TAC `y + z = &0` THEN ASM_REWRITE_TAC[] THEN
  ASM_REAL_ARITH_TAC);;

let RPOW_SQRT = prove
 (`!x. &0 <= x ==> x rpow (&1 / &2) = sqrt x`,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(REAL_RING
   `x pow 2 = y pow 2 /\ (x + y = &0 ==> x = &0 /\ y = &0)
    ==> x = y`) THEN
  CONJ_TAC THENL
   [ASM_SIMP_TAC[SQRT_POW_2] THEN
    ASM_SIMP_TAC[GSYM RPOW_POW; RPOW_RPOW] THEN
    CONV_TAC REAL_RAT_REDUCE_CONV THEN
    REWRITE_TAC[RPOW_POW; REAL_POW_1];
    MATCH_MP_TAC(REAL_ARITH
     `&0 <= x /\ &0 <= y ==> x + y = &0 ==> x = &0 /\ y = &0`) THEN
    ASM_SIMP_TAC[SQRT_POS_LE; RPOW_POS_LE]]);;

let RPOW_MONO = prove
 (`!a b x. &1 <= x /\ a <= b ==> x rpow a <= x rpow b`,
  SIMP_TAC[rpow; REAL_ARITH `&1 <= x ==> &0 < x`] THEN
  SIMP_TAC[REAL_EXP_MONO_LE; LOG_POS; REAL_LE_RMUL]);;

let RPOW_MONO_INV = prove
 (`!a b x. &0 < x /\ x <= &1 /\ b <= a ==> x rpow a <= x rpow b`,
  REPEAT STRIP_TAC THEN
  GEN_REWRITE_TAC BINOP_CONV [GSYM REAL_INV_INV] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN
  ASM_SIMP_TAC[REAL_LT_INV_EQ; RPOW_POS_LT; GSYM RPOW_INV] THEN
  MATCH_MP_TAC RPOW_MONO THEN
  ASM_SIMP_TAC[REAL_INV_1_LE]);;

let RPOW_1_LE = prove
 (`!a x. &0 <= x /\ x <= &1 /\ &0 <= a ==> x rpow a <= &1`,
  REPEAT STRIP_TAC THEN  MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC `&1 rpow a` THEN CONJ_TAC THENL
   [MATCH_MP_TAC RPOW_LE2 THEN ASM_REAL_ARITH_TAC;
    REWRITE_TAC[RPOW_ONE; REAL_LE_REFL]]);;

let REAL_ROOT_RPOW = prove
 (`!n x. ~(n = 0) /\ (&0 <= x \/ ODD n) ==> root n x = x rpow (inv(&n))`,
  REPEAT GEN_TAC THEN ASM_CASES_TAC `x = &0` THEN
  ASM_SIMP_TAC[ROOT_0; RPOW_ZERO; REAL_INV_EQ_0; REAL_OF_NUM_EQ] THEN
  ASM_CASES_TAC `&0 <= x` THEN ASM_REWRITE_TAC[] THEN STRIP_TAC THENL
   [ASM_SIMP_TAC[ROOT_EXP_LOG; rpow; REAL_LT_LE] THEN AP_TERM_TAC THEN
    REAL_ARITH_TAC;
    ASM_REWRITE_TAC[rpow] THEN COND_CASES_TAC THENL
     [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
    REWRITE_TAC[REAL_ABS_INV; REAL_ABS_NUM] THEN
    REWRITE_TAC[REAL_ARITH `inv x = &1 / x`] THEN
    COND_CASES_TAC THENL [ALL_TAC; ASM_MESON_TAC[ARITH]] THEN
    MATCH_MP_TAC ROOT_UNIQUE THEN
    ASM_REWRITE_TAC[REAL_POW_NEG; GSYM REAL_EXP_N; GSYM NOT_ODD] THEN
    ASM_SIMP_TAC[REAL_OF_NUM_EQ; REAL_FIELD
      `~(n = &0) ==> n * &1 / n * x = x`] THEN
    ONCE_REWRITE_TAC[REAL_ARITH `--x:real = y <=> x = --y`] THEN
    MATCH_MP_TAC EXP_LOG THEN ASM_REAL_ARITH_TAC]);;

let LOG_RPOW = prove
 (`!x y. &0 < x ==> log(x rpow y) = y * log x`,
  SIMP_TAC[rpow; LOG_EXP]);;

let LOG_SQRT = prove
 (`!x. &0 < x ==> log(sqrt x) = log x / &2`,
  SIMP_TAC[GSYM RPOW_SQRT; LOG_RPOW; REAL_LT_IMP_LE] THEN
  REAL_ARITH_TAC);;

(* ------------------------------------------------------------------------- *)
(* Formulation of loop homotopy in terms of maps out of S^1                  *)
(* ------------------------------------------------------------------------- *)

let HOMOTOPIC_CIRCLEMAPS_IMP_HOMOTOPIC_LOOPS = prove
 (`!f:complex->real^N g s.
        homotopic_with (\h. T) (sphere(vec 0,&1),s) f g
        ==> homotopic_loops s (f o cexp o (\t. Cx(&2 * pi * drop t) * ii))
                              (g o cexp o (\t. Cx(&2 * pi * drop t) * ii))`,
  REWRITE_TAC[homotopic_loops; sphere; DIST_0] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC HOMOTOPIC_WITH_COMPOSE_CONTINUOUS_RIGHT THEN
  EXISTS_TAC `{z:complex | norm z = &1}` THEN
  REWRITE_TAC[pathstart; pathfinish; o_THM; DROP_VEC] THEN
  ONCE_REWRITE_TAC[REAL_ARITH `&2 * pi * n = &2 * n * pi`] THEN
  REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; o_THM; IN_ELIM_THM] THEN
  ASM_SIMP_TAC[CEXP_INTEGER_2PI; INTEGER_CLOSED] THEN
  REWRITE_TAC[ONCE_REWRITE_RULE[COMPLEX_MUL_SYM] NORM_CEXP_II] THEN
  MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN REWRITE_TAC[CONTINUOUS_ON_CEXP] THEN
  REWRITE_TAC[CX_MUL] THEN
  REPEAT(MATCH_MP_TAC CONTINUOUS_ON_COMPLEX_MUL THEN
         REWRITE_TAC[CONTINUOUS_ON_CONST]) THEN
  SIMP_TAC[CONTINUOUS_ON_CX_DROP; CONTINUOUS_ON_ID]);;

let HOMOTOPIC_LOOPS_IMP_HOMOTOPIC_CIRCLEMAPS = prove
 (`!p q s:real^N->bool.
        homotopic_loops s p q
        ==> homotopic_with (\h. T) (sphere(vec 0,&1),s)
                                   (p o (\z. lift(Arg z / (&2 * pi))))
                                   (q o (\z. lift(Arg z / (&2 * pi))))`,
 let ulemma = prove
   (`!s. s INTER (UNIV PCROSS {z | &0 <= Im z}) UNION
         s INTER (UNIV PCROSS {z | Im z <= &0}) = s`,
    REWRITE_TAC[EXTENSION; FORALL_PASTECART; IN_INTER; IN_UNION;
                 PASTECART_IN_PCROSS] THEN
    SET_TAC[REAL_LE_TOTAL]) in
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopic_loops; sphere; DIST_0] THEN
  GEN_REWRITE_TAC LAND_CONV [homotopic_with] THEN
  SIMP_TAC[pathstart; pathfinish; LEFT_IMP_EXISTS_THM; HOMOTOPIC_WITH] THEN
  X_GEN_TAC `h:real^(1,1)finite_sum->real^N` THEN STRIP_TAC THEN
  EXISTS_TAC `\w. (h:real^(1,1)finite_sum->real^N)
                  (pastecart (fstcart w)
                             (lift(Arg(sndcart w) / (&2 * pi))))` THEN
  ASM_REWRITE_TAC[FSTCART_PASTECART; SNDCART_PASTECART; o_THM] THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_ON_EQ THEN
    EXISTS_TAC
     `(\z. if &0 <= Im(sndcart z)
           then h (pastecart (fstcart z) (lift(Arg(sndcart z) / (&2 * pi))))
           else h (pastecart (fstcart z)
                             (vec 1 - lift(Arg(cnj(sndcart z)) / (&2 * pi)))))
      :real^(1,2)finite_sum->real^N` THEN
    REWRITE_TAC[FORALL_IN_PCROSS; FSTCART_PASTECART; SNDCART_PASTECART] THEN
    REWRITE_TAC[IN_ELIM_THM] THEN CONJ_TAC THENL
     [MAP_EVERY X_GEN_TAC [`t:real^1`; `z:complex`] THEN STRIP_TAC THEN
      COND_CASES_TAC THEN ASM_REWRITE_TAC[ARG_CNJ] THEN
      COND_CASES_TAC THENL [ASM_MESON_TAC[real; REAL_LE_REFL]; ALL_TAC] THEN
      SIMP_TAC[PI_POS; LIFT_SUB; LIFT_NUM; REAL_FIELD
        `&0 < pi ==> (&2 * pi - z) / (&2 * pi) = &1 - z / (&2 * pi)`] THEN
      REWRITE_TAC[VECTOR_ARITH `a - (a - b):real^N = b`];
      GEN_REWRITE_TAC RAND_CONV [GSYM ulemma] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN REWRITE_TAC[ulemma] THEN
      SIMP_TAC[CLOSED_IN_CLOSED_INTER; CLOSED_HALFSPACE_IM_LE; CLOSED_UNIV;
        CLOSED_PCROSS; REWRITE_RULE[real_ge] CLOSED_HALFSPACE_IM_GE] THEN
      REWRITE_TAC[FORALL_PASTECART; PASTECART_IN_PCROSS; IN_INTER; IN_DIFF;
       FSTCART_PASTECART; SNDCART_PASTECART; IN_UNIV; IN_SING; IN_ELIM_THM;
       GSYM CONJ_ASSOC; REAL_LE_ANTISYM; TAUT `~(p /\ ~p)`] THEN
      REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
       [ALL_TAC;
        REWRITE_TAC[GSYM ARG_EQ_0_PI; GSYM real; ARG_CNJ] THEN
        REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
        SIMP_TAC[REAL_ARITH `&2 * x - x = x`; COND_ID; GSYM LIFT_NUM; PI_POS;
         GSYM LIFT_SUB; REAL_FIELD
          `&0 < pi ==> &1 - pi / (&2 * pi) = pi / (&2 * pi)`] THEN
        COND_CASES_TAC THEN
        SIMP_TAC[REAL_SUB_RZERO; REAL_DIV_REFL; REAL_ENTIRE; REAL_OF_NUM_EQ;
                 ARITH_EQ; PI_NZ] THEN
        SIMP_TAC[real_div; REAL_MUL_LZERO; REAL_SUB_REFL; REAL_SUB_RZERO] THEN
        ASM_SIMP_TAC[LIFT_NUM]] THEN
      GEN_REWRITE_TAC (BINOP_CONV o LAND_CONV) [GSYM o_DEF] THEN
      CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN CONJ_TAC THENL
       [MATCH_MP_TAC CONTINUOUS_ON_PASTECART THEN
        SIMP_TAC[LINEAR_CONTINUOUS_ON; LINEAR_FSTCART] THEN
        REWRITE_TAC[real_div; REWRITE_RULE[REAL_MUL_SYM] LIFT_CMUL] THEN
        MATCH_MP_TAC CONTINUOUS_ON_VMUL THEN
        GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [GSYM o_DEF] THEN
        REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
        SIMP_TAC[LINEAR_CONTINUOUS_ON; LINEAR_SNDCART] THEN
        REWRITE_TAC[o_DEF; GSYM CONTINUOUS_ON_CX_LIFT] THEN
        MP_TAC CONTINUOUS_ON_UPPERHALF_ARG THEN REWRITE_TAC[o_DEF] THEN
        MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; FORALL_PASTECART; IN_INTER;
                    PASTECART_IN_PCROSS; IN_ELIM_THM; SNDCART_PASTECART] THEN
        MAP_EVERY X_GEN_TAC [`t:real^1`; `z:complex`] THEN
        SIMP_TAC[IN_DIFF; IN_ELIM_THM; IN_SING] THEN
        ASM_CASES_TAC `z = Cx(&0)` THEN ASM_REWRITE_TAC[COMPLEX_NORM_0] THEN
        REWRITE_TAC[REAL_OF_NUM_EQ; ARITH_EQ];
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ]
          CONTINUOUS_ON_SUBSET)) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; FORALL_PASTECART; IN_INTER;
                    PASTECART_IN_PCROSS; IN_ELIM_THM; SNDCART_PASTECART;
                    FSTCART_PASTECART] THEN
        SIMP_TAC[IN_INTERVAL_1; LIFT_DROP; DROP_VEC] THEN
        SIMP_TAC[REAL_LE_LDIV_EQ; REAL_LE_RDIV_EQ; PI_POS; REAL_MUL_LZERO;
             REAL_MUL_LID; REAL_ARITH `&0 < &2 * x <=> &0 < x`] THEN
        SIMP_TAC[ARG; REAL_LT_IMP_LE];
        MATCH_MP_TAC CONTINUOUS_ON_PASTECART THEN
        SIMP_TAC[LINEAR_CONTINUOUS_ON; LINEAR_FSTCART] THEN
        MATCH_MP_TAC CONTINUOUS_ON_SUB THEN
        REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
        REWRITE_TAC[real_div; REWRITE_RULE[REAL_MUL_SYM] LIFT_CMUL] THEN
        MATCH_MP_TAC CONTINUOUS_ON_VMUL THEN
        GEN_REWRITE_TAC (LAND_CONV o RAND_CONV) [GSYM o_DEF] THEN
        REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
        GEN_REWRITE_TAC (LAND_CONV o LAND_CONV) [GSYM o_DEF] THEN
        SIMP_TAC[LINEAR_CONTINUOUS_ON; LINEAR_SNDCART; CONTINUOUS_ON_COMPOSE;
                 CONTINUOUS_ON_CNJ] THEN
        REWRITE_TAC[o_DEF; GSYM CONTINUOUS_ON_CX_LIFT] THEN
        MP_TAC CONTINUOUS_ON_UPPERHALF_ARG THEN REWRITE_TAC[o_DEF] THEN
        MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; FORALL_PASTECART; IN_INTER;
                    PASTECART_IN_PCROSS; IN_ELIM_THM; SNDCART_PASTECART] THEN
        MAP_EVERY X_GEN_TAC [`t:real^1`; `z:complex`] THEN
        SIMP_TAC[IN_DIFF; IN_ELIM_THM; IN_SING] THEN
        SIMP_TAC[IM_CNJ; REAL_NEG_GE0; CNJ_EQ_0] THEN
        ASM_CASES_TAC `z = Cx(&0)` THEN ASM_REWRITE_TAC[COMPLEX_NORM_0] THEN
        REWRITE_TAC[REAL_OF_NUM_EQ; ARITH_EQ];
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ]
          CONTINUOUS_ON_SUBSET)) THEN
        REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; FORALL_PASTECART; IN_INTER;
                    PASTECART_IN_PCROSS; IN_ELIM_THM; SNDCART_PASTECART;
                    FSTCART_PASTECART] THEN
        SIMP_TAC[IN_INTERVAL_1; DROP_SUB; DROP_VEC; LIFT_DROP] THEN
        REWRITE_TAC[REAL_ARITH `&0 <= &1 - x /\ &1 - x <= &1 <=>
                                &0 <= x /\ x <= &1`] THEN
        SIMP_TAC[REAL_LE_LDIV_EQ; REAL_LE_RDIV_EQ; PI_POS; REAL_MUL_LZERO;
             REAL_MUL_LID; REAL_ARITH `&0 < &2 * x <=> &0 < x`] THEN
        SIMP_TAC[ARG; REAL_LT_IMP_LE]]];
    REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; FORALL_IN_PCROSS; IN_ELIM_THM] THEN
    REWRITE_TAC[FSTCART_PASTECART; SNDCART_PASTECART] THEN
    REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
     `IMAGE h s SUBSET t ==> y IN s ==> h y IN t`)) THEN
    ASM_REWRITE_TAC[PASTECART_IN_PCROSS; IN_INTERVAL_1; LIFT_DROP] THEN
    SIMP_TAC[DROP_VEC; REAL_LE_LDIV_EQ; REAL_LE_RDIV_EQ; PI_POS;
             REAL_ARITH `&0 < &2 * x <=> &0 < x`] THEN
    SIMP_TAC[REAL_MUL_LZERO; REAL_MUL_LID; ARG; REAL_LT_IMP_LE]]);;

let SIMPLY_CONNECTED_EQ_HOMOTOPIC_CIRCLEMAPS,
    SIMPLY_CONNECTED_EQ_CONTRACTIBLE_CIRCLEMAP =
 (CONJ_PAIR o prove)
 (`(!s:real^N->bool.
        simply_connected s <=>
        !f g:complex->real^N.
              f continuous_on sphere(vec 0,&1) /\
              IMAGE f (sphere(vec 0,&1)) SUBSET s /\
              g continuous_on sphere(vec 0,&1) /\
              IMAGE g (sphere(vec 0,&1)) SUBSET s
              ==> homotopic_with (\h. T) (sphere(vec 0,&1),s) f g) /\
   (!s:real^N->bool.
      simply_connected s <=>
      path_connected s /\
      !f:real^2->real^N.
              f continuous_on sphere(vec 0,&1) /\
              IMAGE f (sphere(vec 0,&1)) SUBSET s
              ==> ?a. homotopic_with (\h. T) (sphere(vec 0,&1),s) f (\x. a))`,
  REWRITE_TAC[AND_FORALL_THM] THEN GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(p ==> q) /\ (q ==> r) /\ (r ==> p) ==> (p <=> q) /\ (p <=> r)`) THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[simply_connected] THEN DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`f:complex->real^N`; `g:complex->real^N`] THEN
    STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPECL
     [`(f:complex->real^N) o cexp o (\t. Cx(&2 * pi * drop t) * ii)`;
      `(g:complex->real^N) o cexp o (\t. Cx(&2 * pi * drop t) * ii)`]) THEN
    ONCE_REWRITE_TAC[TAUT `p1 /\ q1 /\ r1 /\ p2 /\ q2 /\ r2 <=>
                           (p1 /\ r1 /\ q1) /\ (p2 /\ r2 /\ q2)`] THEN
    REWRITE_TAC[GSYM HOMOTOPIC_LOOPS_REFL] THEN
    ASM_SIMP_TAC[HOMOTOPIC_CIRCLEMAPS_IMP_HOMOTOPIC_LOOPS;
                 HOMOTOPIC_WITH_REFL] THEN
    DISCH_THEN(MP_TAC o MATCH_MP HOMOTOPIC_LOOPS_IMP_HOMOTOPIC_CIRCLEMAPS) THEN
    MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT] HOMOTOPIC_WITH_EQ) THEN
    REWRITE_TAC[IN_SPHERE_0; LIFT_DROP; o_DEF] THEN X_GEN_TAC `z:complex` THEN
    REPEAT STRIP_TAC THEN AP_TERM_TAC THEN MP_TAC(SPEC `z:complex` ARG) THEN
    ASM_REWRITE_TAC[COMPLEX_MUL_LID] THEN
    DISCH_THEN(STRIP_ASSUME_TAC o GSYM) THEN SIMP_TAC[PI_POS;
      REAL_FIELD `&0 < pi ==> &2 * pi * x / (&2 * pi) = x`] THEN
    ASM_MESON_TAC[COMPLEX_MUL_SYM];
    DISCH_TAC THEN CONJ_TAC THENL
     [REWRITE_TAC[PATH_CONNECTED_EQ_HOMOTOPIC_POINTS] THEN
      MAP_EVERY X_GEN_TAC [`a:real^N`; `b:real^N`] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC o SPECL
       [`(\x. a):complex->real^N`; `(\x. b):complex->real^N`]) THEN
      REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN DISCH_THEN
       (MP_TAC o MATCH_MP HOMOTOPIC_CIRCLEMAPS_IMP_HOMOTOPIC_LOOPS) THEN
      REWRITE_TAC[o_DEF; LINEPATH_REFL];
      X_GEN_TAC `f:complex->real^N` THEN STRIP_TAC THEN
      EXISTS_TAC `f(Cx(&1)):real^N` THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      ASM_REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[SUBSET; FORALL_IN_IMAGE; IN_SPHERE_0]) THEN
      REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; IN_SPHERE_0] THEN
      REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      REWRITE_TAC[COMPLEX_NORM_CX] THEN REAL_ARITH_TAC];
    STRIP_TAC THEN
    ASM_REWRITE_TAC[SIMPLY_CONNECTED_EQ_CONTRACTIBLE_LOOP_SOME] THEN
    X_GEN_TAC `p:real^1->real^N` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC
     `(p:real^1->real^N) o (\z. lift(Arg z / (&2 * pi)))`) THEN
    ANTS_TAC THENL
     [MP_TAC(ISPECL [`s:real^N->bool`; `p:real^1->real^N`]
        HOMOTOPIC_LOOPS_REFL) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o MATCH_MP
        HOMOTOPIC_LOOPS_IMP_HOMOTOPIC_CIRCLEMAPS) THEN
      SIMP_TAC[HOMOTOPIC_WITH_REFL];
      MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `a:real^N` THEN
      STRIP_TAC THEN FIRST_ASSUM
       (MP_TAC o MATCH_MP HOMOTOPIC_CIRCLEMAPS_IMP_HOMOTOPIC_LOOPS) THEN
      FIRST_ASSUM(MP_TAC o MATCH_MP HOMOTOPIC_WITH_IMP_SUBSET) THEN
      REWRITE_TAC[SUBSET; FORALL_IN_IMAGE; IN_SPHERE_0; o_DEF] THEN
      DISCH_THEN(MP_TAC o SPEC `Cx(&1)` o CONJUNCT2) THEN
      REWRITE_TAC[COMPLEX_NORM_CX; REAL_ABS_NUM] THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[LINEPATH_REFL] THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] HOMOTOPIC_LOOPS_TRANS) THEN
      MATCH_MP_TAC HOMOTOPIC_LOOPS_EQ THEN ASM_REWRITE_TAC[] THEN
      REWRITE_TAC[IN_INTERVAL_1; FORALL_LIFT; LIFT_DROP; DROP_VEC] THEN
      X_GEN_TAC `t:real` THEN STRIP_TAC THEN ASM_CASES_TAC `t = &1` THENL
       [ASM_REWRITE_TAC[REAL_ARITH `&2 * pi * &1 = &2 * &1 * pi`] THEN
        SIMP_TAC[CEXP_INTEGER_2PI; INTEGER_CLOSED; ARG_NUM] THEN
        REWRITE_TAC[real_div; REAL_MUL_LZERO; LIFT_NUM] THEN
        ASM_MESON_TAC[pathstart; pathfinish];
        AP_TERM_TAC THEN AP_TERM_TAC THEN SIMP_TAC[PI_POS; REAL_FIELD
         `&0 < pi ==> (t = x / (&2 * pi) <=> x = &2 * pi * t)`] THEN
        MATCH_MP_TAC EQ_TRANS THEN EXISTS_TAC `Im(Cx (&2 * pi * t) * ii)` THEN
        CONJ_TAC THENL [MATCH_MP_TAC ARG_CEXP; ALL_TAC] THEN
        SIMP_TAC[IM_MUL_II; RE_CX; REAL_ARITH
          `a < &2 * pi <=> a < &2 * pi * &1`] THEN
        ASM_SIMP_TAC[REAL_LE_MUL; REAL_LT_LMUL_EQ; REAL_OF_NUM_LT; ARITH;
                     PI_POS; REAL_LT_IMP_LE; REAL_POS; REAL_LE_MUL] THEN
        ASM_REWRITE_TAC[REAL_LT_LE]]]]);;

let HOMOTOPY_EQUIVALENT_SIMPLE_CONNECTEDNESS = prove
 (`!s:real^M->bool t:real^N->bool.
        s homotopy_equivalent t
        ==> (simply_connected s <=> simply_connected t)`,
  REWRITE_TAC[SIMPLY_CONNECTED_EQ_HOMOTOPIC_CIRCLEMAPS] THEN
  REWRITE_TAC[HOMOTOPY_EQUIVALENT_HOMOTOPIC_TRIVIALITY]);;

(* ------------------------------------------------------------------------- *)
(* Homeomorphism of simple closed curves to circles.                         *)
(* ------------------------------------------------------------------------- *)

let HOMEOMORPHIC_SIMPLE_PATH_IMAGE_CIRCLE = prove
 (`!g:real^1->real^N a:real^2 r.
        simple_path g /\ pathfinish g = pathstart g /\ &0 < r
        ==> (path_image g) homeomorphic sphere(a,r)`,
  REPEAT STRIP_TAC THEN
  TRANS_TAC HOMEOMORPHIC_TRANS `sphere(vec 0:real^2,&1)` THEN
  ASM_SIMP_TAC[HOMEOMORPHIC_SPHERES; REAL_LT_01] THEN MP_TAC(ISPECL
   [`g:real^1->real^N`; `g:real^1->real^N`; `path_image(g:real^1->real^N)`]
   HOMOTOPIC_LOOPS_IMP_HOMOTOPIC_CIRCLEMAPS) THEN
  REWRITE_TAC[HOMOTOPIC_LOOPS_REFL; HOMOTOPIC_WITH_REFL; SUBSET_REFL] THEN
  ASM_SIMP_TAC[SIMPLE_PATH_IMP_PATH] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN REWRITE_TAC[homeomorphic] THEN
  EXISTS_TAC `(g:real^1->real^N) o (\z. lift(Arg z / (&2 * pi)))` THEN
  MATCH_MP_TAC HOMEOMORPHISM_COMPACT THEN
  ASM_REWRITE_TAC[COMPACT_SPHERE] THEN CONJ_TAC THENL
   [MATCH_MP_TAC SUBSET_ANTISYM THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[SUBSET; path_image; FORALL_IN_IMAGE; IN_INTERVAL_1] THEN
    X_GEN_TAC `t:real^1` THEN REWRITE_TAC[DROP_VEC] THEN STRIP_TAC THEN
    REWRITE_TAC[IN_IMAGE; o_THM; IN_SPHERE_0] THEN
    ASM_CASES_TAC `t:real^1 = vec 1` THENL
     [EXISTS_TAC `Cx(&1)` THEN
      ASM_REWRITE_TAC[ARG_NUM; COMPLEX_NORM_CX; real_div; REAL_MUL_LZERO] THEN
      REWRITE_TAC[LIFT_NUM; REAL_ABS_NUM] THEN
      ASM_MESON_TAC[pathstart; pathfinish];
      EXISTS_TAC `cexp(ii * Cx(&2 * pi * drop t))` THEN
      REWRITE_TAC[NORM_CEXP_II] THEN AP_TERM_TAC THEN
      W(MP_TAC o PART_MATCH (lhand o rand) ARG_CEXP o
        lhand o rand o rand o snd) THEN
      REWRITE_TAC[IM_MUL_II; RE_CX] THEN ANTS_TAC THENL
       [ASM_SIMP_TAC[REAL_LE_MUL; PI_POS_LE; REAL_POS] THEN
        SIMP_TAC[REAL_ARITH `&2 * pi * x < &2 * pi <=> pi * x < pi * &1`;
                 REAL_LT_LMUL_EQ; PI_POS] THEN
        ASM_REWRITE_TAC[REAL_LT_LE] THEN
        ASM_REWRITE_TAC[GSYM LIFT_EQ; LIFT_DROP; LIFT_NUM];
        DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[GSYM DROP_EQ; LIFT_DROP] THEN
        MP_TAC PI_POS THEN CONV_TAC REAL_FIELD]];
    MAP_EVERY X_GEN_TAC [`w:complex`; `z:complex`] THEN
    REWRITE_TAC[IN_SPHERE_0] THEN STRIP_TAC THEN
    MAP_EVERY (SUBST1_TAC o last o CONJUNCTS o C SPEC ARG)
     [`w:complex`; `z:complex`] THEN
    FIRST_X_ASSUM(MP_TAC o SYM o SYM) THEN
    ASM_REWRITE_TAC[o_DEF; COMPLEX_MUL_LID] THEN DISCH_TAC THEN
    AP_TERM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
    MATCH_MP_TAC(REAL_FIELD
     `&0 < pi /\ x / (&2 * pi) = y / (&2 * pi) ==> x = y`) THEN
    REWRITE_TAC[PI_POS; GSYM LIFT_EQ] THEN
    FIRST_ASSUM(MP_TAC o GEN_REWRITE_RULE I [simple_path]) THEN
    DISCH_THEN(MP_TAC  o SPECL
     [`lift(Arg w / (&2 * pi))`; `lift(Arg z / (&2 * pi))`] o CONJUNCT2) THEN
    ASM_REWRITE_TAC[GSYM LIFT_NUM; IN_INTERVAL_1; LIFT_DROP; LIFT_EQ] THEN
    ASM_SIMP_TAC[REAL_LE_RDIV_EQ; REAL_LE_LDIV_EQ; PI_POS;
                 REAL_ARITH `&0 < &2 * x <=> &0 < x`;
                 REAL_FIELD `&0 < y ==> (x / y = &1 <=> x = y)`] THEN
    SIMP_TAC[REAL_MUL_LZERO; REAL_MUL_LID; ARG; REAL_LT_IMP_LE;
             REAL_LT_IMP_NE]]);;

let HOMEOMORPHIC_SIMPLE_PATH_IMAGES = prove
 (`!g:real^1->real^M h:real^1->real^N.
        simple_path g /\ pathfinish g = pathstart g /\
        simple_path h /\ pathfinish h = pathstart h
        ==> (path_image g) homeomorphic (path_image h)`,
  REPEAT STRIP_TAC THEN
  TRANS_TAC HOMEOMORPHIC_TRANS `sphere(vec 0:real^2,&1)` THEN
  CONJ_TAC THENL [ALL_TAC; ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM]] THEN
  MATCH_MP_TAC HOMEOMORPHIC_SIMPLE_PATH_IMAGE_CIRCLE THEN
  ASM_REWRITE_TAC[REAL_LT_01]);;

let ENR_PATH_IMAGE_SIMPLE_PATH = prove
 (`!g:real^1->real^N. simple_path g ==> ENR(path_image g)`,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC `pathfinish g:real^N = pathstart g` THENL
   [MP_TAC(ISPECL [`g:real^1->real^N`; `vec 0:real^2`; `&1`]
        HOMEOMORPHIC_SIMPLE_PATH_IMAGE_CIRCLE) THEN
    ASM_REWRITE_TAC[REAL_LT_01] THEN
    DISCH_THEN(SUBST1_TAC o MATCH_MP HOMEOMORPHIC_ENRNESS) THEN
    REWRITE_TAC[ENR_SPHERE];
    REWRITE_TAC[ENR] THEN EXISTS_TAC `(:real^N)` THEN
    REWRITE_TAC[OPEN_UNIV] THEN
    MATCH_MP_TAC ABSOLUTE_RETRACT_PATH_IMAGE_ARC THEN
    ASM_REWRITE_TAC[ARC_SIMPLE_PATH; SUBSET_UNIV]]);;

let ANR_PATH_IMAGE_SIMPLE_PATH = prove
 (`!g:real^1->real^N. simple_path g ==> ANR(path_image g)`,
  SIMP_TAC[ENR_PATH_IMAGE_SIMPLE_PATH; ENR_IMP_ANR]);;


print_endline "transcendentals.ml loaded"
