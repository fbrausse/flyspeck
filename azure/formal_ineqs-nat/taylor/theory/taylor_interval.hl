open Binomial
open Vectors
open Topology
open Realanalysis
open Ssreflect
open Ssrfun
open Ssrbool
open Ssrnat
open Interval_arith
open Matan
open Hol_core
include Taylor_interval1
(* Section LinearApproxArith *)
Sections.begin_section "LinearApproxArith";;
(Sections.add_section_var (mk_var ("f1", (`:real->real`))); Sections.add_section_var (mk_var ("f2", (`:real->real`))));;
(Sections.add_section_var (mk_var ("f1_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("f2_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("df1_lo", (`:real`))); Sections.add_section_var (mk_var ("df1_hi", (`:real`))); Sections.add_section_var (mk_var ("df2_lo", (`:real`))); Sections.add_section_var (mk_var ("df2_hi", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("df_lo", (`:real`))); Sections.add_section_var (mk_var ("df_hi", (`:real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "approx1" (`lin_approx f1 x f1_bounds (df1_lo, df1_hi)`));;

(* Lemma lin_approx_scale *)
let lin_approx_scale = Sections.section_proof ["c"]
`&0 <= c ==> interval_arith (c * f1 x) f_bounds /\
	df_lo <= c * df1_lo /\ c * df1_hi <= df_hi ==>
	lin_approx (\x. c * f1 x) x f_bounds (df_lo, df_hi)`
[
   (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["c0"]) THEN (move ["ineqs"]));
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (split_tac));
   ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["int_f1"])) THEN (case THEN (move ["f1'"])) THEN (case THEN ((move ["df1"]) THEN (move ["int_f1'"])))));
   (((fun arg_tac -> arg_tac (Arg_term (`c * f1'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("int_f1'", [])) (disch_tac [])) THEN (clear_assumption "int_f1'") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineqs2"])) THEN (split_tac) THEN (((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`c * df1_lo`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_LMUL", [REAL_LE_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`c * df1_hi`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_LMUL", [REAL_LE_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_hyp "approx2" (`lin_approx f2 x f2_bounds (df2_lo, df2_hi)`));;

(* Lemma lin_approx_add *)
let lin_approx_add = Sections.section_proof []
`interval_arith (f1 x + f2 x) f_bounds /\
	df_lo <= df1_lo + df2_lo /\ df1_hi + df2_hi <= df_hi ==>
	lin_approx (\x. f1 x + f2 x) x f_bounds (df_lo, df_hi)`
[
   (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineqs"]));
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (split_tac));
   ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN ((use_arg_then2 ("approx2", [])) (disch_tac [])) THEN (clear_assumption "approx2") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("approx2", [])) (disch_tac [])) THEN (clear_assumption "approx2") THEN ((use_arg_then2 ("approx1", [])) (disch_tac [])) THEN (clear_assumption "approx1") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["int_f1"])) THEN (case THEN (move ["f1'"])) THEN (case THEN ((move ["df1"]) THEN (move ["int_f1'"])))));
   (BETA_TAC THEN (case THEN (move ["int_f2"])) THEN (case THEN (move ["f2'"])) THEN (case THEN ((move ["df2"]) THEN (move ["int_f2'"]))));
   (((fun arg_tac -> arg_tac (Arg_term (`f1' + f2':real`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("int_f2'", [])) (disch_tac [])) THEN (clear_assumption "int_f2'") THEN ((use_arg_then2 ("int_f1'", [])) (disch_tac [])) THEN (clear_assumption "int_f1'") THEN ((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section LinearApproxArith *)
let lin_approx_scale = Sections.finalize_theorem lin_approx_scale;;
let lin_approx_add = Sections.finalize_theorem lin_approx_add;;
Sections.end_section "LinearApproxArith";;

(* Section SecondDerivativeBound *)
Sections.begin_section "SecondDerivativeBound";;
(Sections.add_section_var (mk_var ("f1", (`:real->real`))); Sections.add_section_var (mk_var ("f2", (`:real->real`))));;
(Sections.add_section_var (mk_var ("int", (`:real#real`))));;
(Sections.add_section_var (mk_var ("dd1", (`:real#real`))); Sections.add_section_var (mk_var ("dd2", (`:real#real`))));;

(* Lemma nth_diff_strong2_eq_alt *)
let nth_diff_strong2_eq_alt = Sections.section_proof ["f";"x"]
`nth_diff_strong 2 f x <=> ?s. real_open s /\ x IN s /\
	!y. y IN s ==> (f has_real_derivative derivative f y) (atreal y) /\
	(derivative f has_real_derivative nth_derivative 2 f y) (atreal y)`
[
   ((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))));
   ((split_tac) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["df"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (case THEN (move ["_"])) THEN (move ["h"])));
   ((((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN ((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (simp_tac)) THEN (((((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`derivative f y`))) (term_tac exists_tac)) THEN (done_tac));
   ((BETA_TAC THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((fun arg_tac ->(use_arg_then2 ("nth_derivative0", [nth_derivative0]))(fun tmp_arg1 -> (use_arg_then2 ("nth_derivative1", [nth_derivative1]))(fun tmp_arg2 -> arg_tac (Arg_theorem (CONJ (get_arg_thm tmp_arg1) (get_arg_thm tmp_arg2))))))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma nth_diff_strong2_eq *)
let nth_diff_strong2_eq = Sections.section_proof ["f";"x"]
`nth_diff_strong 2 f x <=> ?s. real_open s /\ x IN s /\
	!y. y IN s ==> f real_differentiable atreal y /\ derivative f real_differentiable atreal y`
[
   ((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL nth_differentiable)))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))));
   ((split_tac) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["df"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])) THEN (done_tac));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose *)
let lin_approx_compose = Sections.section_proof ["f";"g";"y";"g_bounds";"f_bounds";"d_bounds"]
`nth_diff_strong_int 2 g_bounds f ==>
	  g real_differentiable atreal y ==>
	  interval_arith (g y) g_bounds ==>
	  bounded_on_int f g_bounds f_bounds ==>
	  interval_arith (derivative g y * derivative f (g y)) d_bounds ==>
	  lin_approx (\x. f (g x)) y f_bounds d_bounds`
[
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["g_int"]) THEN (move ["f_int"]) THEN (move ["dfg_int"]));
   ((fun arg_tac -> arg_tac (Arg_term (`f real_differentiable atreal (g y)`))) (term_tac (have_gen_tac [](move ["dfgy"]))));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("g_int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["ys"])) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("dfg_int", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("f_int", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (exact_tac)) THEN (done_tac));
];;

(* Lemma second_derivative_atn_eq *)
let second_derivative_atn_eq = Sections.section_proof ["x"]
`((\x. inv (&1 + x pow 2)) has_real_derivative 
	(-- &2 * x) * inv (&1 + x pow 2) pow 2) (atreal x)`
[
   (((((use_arg_then2 ("REAL_POW_INV", [REAL_POW_INV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_div", [real_div]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_LMUL", [REAL_NEG_LMUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_INV_ATREAL", [HAS_REAL_DERIVATIVE_INV_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("REAL_ADD_LID", [REAL_ADD_LID])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`&2 * x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&2 * x = x * &1 + &1 * x`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("REAL_POS_NZ", [REAL_POS_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_ADD1", [REAL_LT_ADD1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_atn *)
let second_derivative_atn = Sections.section_proof []
`derivative (derivative atn) = (\x. (-- &2 * x) * inv (&1 + x pow 2) pow 2)`
[
   ((((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac)) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("second_derivative_atn_eq", [second_derivative_atn_eq]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_atn *)
let diff2_atn = Sections.section_proof ["x"]
`nth_diff_strong 2 atn x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATN", [HAS_REAL_DERIVATIVE_ATN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("second_derivative_atn_eq", [second_derivative_atn_eq]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_cos *)
let second_derivative_cos = Sections.section_proof []
`nth_derivative 2 cos = (\x. --cos x)`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]));
   (((((use_arg_then2 ("derivative_neg", [derivative_neg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_cos *)
let diff2_cos = Sections.section_proof ["x"]
`nth_diff_strong 2 cos x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_NEG", [HAS_REAL_DERIVATIVE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sin *)
let second_derivative_sin = Sections.section_proof []
`nth_derivative 2 sin = (\x. --sin x)`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_sin *)
let diff2_sin = Sections.section_proof ["x"]
`nth_diff_strong 2 sin x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_exp *)
let second_derivative_exp = Sections.section_proof []
`nth_derivative 2 exp = exp`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma diff2_exp *)
let diff2_exp = Sections.section_proof ["x"]
`nth_diff_strong 2 exp x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_log *)
let second_derivative_log = Sections.section_proof ["x"]
`&0 < x ==> nth_derivative 2 log x = --inv (x pow 2)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. inv x)`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv x) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&0 < x ==> ~(x = &0)`)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. -- &1 * a = --a`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_log *)
let diff2_log = Sections.section_proof ["x"]
`&0 < x ==> nth_diff_strong 2 log x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv x`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_inv *)
let second_derivative_inv = Sections.section_proof ["x"]
`~(x = &0) ==> nth_derivative 2 inv x = &2 * inv (x pow 3)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["xn0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. -- inv (x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. -- inv(x * x)) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xn0", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `(x * x) pow 2 = x * x pow 3`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] []))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv x * a = &2 * (x * inv x) * a`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_inv *)
let diff2_inv = Sections.section_proof ["x"]
`~(x = &0) ==> nth_diff_strong 2 inv x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["xn0"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - abs x, x + abs x)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_INV", [REAL_DIFFERENTIABLE_AT_INV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (x * x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - abs y, y + abs y)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_NEG", [REAL_DIFFERENTIABLE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("xn0", [])) (disch_tac [])) THEN (clear_assumption "xn0") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma SQRT_POW *)
let SQRT_POW = Sections.section_proof ["x";"n"]
`&0 <= x ==> sqrt x pow n = sqrt (x pow n)`
[
   ((BETA_TAC THEN (move ["ineq"])) THEN ((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("SQRT_1", [SQRT_1]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("IHn", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_MUL", [SQRT_MUL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_POW_LE", [REAL_POW_LE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sqrt *)
let second_derivative_sqrt = Sections.section_proof ["x"]
`&0 < x ==> nth_derivative 2 sqrt x = -- inv(&4 * sqrt (x pow 3))`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_pos"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`(\x. inv (&2 * sqrt x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv(&2 * sqrt x)) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`~(&2 * sqrt x = &0)`))) (term_tac (have_gen_tac [](move ["ineq"]))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("negb_or", [negb_or]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("x_pos", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_MUL", [REAL_POW_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&2 pow 2 = &4`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma diff2_sqrt *)
let diff2_sqrt = Sections.section_proof ["x"]
`&0 < x ==> nth_diff_strong 2 sqrt x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_pos"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (&2 * sqrt x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (&0, y + &1)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]) ((((use_arg_then2 ("x_pos", [])) (disch_tac [])) THEN (clear_assumption "x_pos") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma real_powS *)
let real_powS = Sections.section_proof ["x";"n"]
`x pow (SUC n) = x * x pow n`
[
   ((((use_arg_then2 ("real_pow", [real_pow]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_acs *)
let second_derivative_acs = Sections.section_proof ["x"]
`abs x < &1 ==> 
	nth_derivative 2 acs x = --(x / sqrt ((&1 - x * x) pow 3))`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. --inv (sqrt (&1 - x * x))) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x /\ ~(sqrt(&1 - x * x) = &0)`))) (term_tac (have_gen_tac [](move ["ineqs"]))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x`))) (term_tac (have_gen_tac [](move ["h"])))));
   (((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - x * x = (&1 - x) * (&1 + x)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_LZERO", [REAL_SUB_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv (&2) * a = (&2 * inv (&2)) * x * a`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_acs *)
let diff2_acs = Sections.section_proof ["x"]
`abs x < &1 ==> nth_diff_strong 2 acs x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs y`))) (term_tac (set_tac "e2")));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. --inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - e2, y + e2)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_NEG", [REAL_DIFFERENTIABLE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - y * y`))) (term_tac (have_gen_tac [](move ["gt0"]))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - y * y = (&1 - y) * (&1 + y)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`(\x. sqrt (&1 - x * x)) = sqrt o (\x. &1 - x * x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_asn *)
let second_derivative_asn = Sections.section_proof ["x"]
`abs x < &1 ==> 
	nth_derivative 2 asn x = x / sqrt ((&1 - x * x) pow 3)`
[
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_theorem ((DISCH_ALL o REAL_DIFF_CONV) `((\x. inv (sqrt (&1 - x * x))) has_real_derivative f) (atreal x)`))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x /\ ~(sqrt(&1 - x * x) = &0)`))) (term_tac (have_gen_tac [](move ["ineqs"]))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - x * x`))) (term_tac (have_gen_tac [](move ["h"])))));
   (((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - x * x = (&1 - x) * (&1 + x)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_LZERO", [REAL_SUB_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_2", [REAL_MUL_2]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. (&2 * x) * inv (&2) * a = (&2 * inv (&2)) * x * a`)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `SUC 2 = 3`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma diff2_asn *)
let diff2_asn = Sections.section_proof ["x"]
`abs x < &1 ==> nth_diff_strong 2 asn x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs x`))) (term_tac (set_tac "e")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - e, x + e)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - abs y`))) (term_tac (set_tac "e2")));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`\x. inv (sqrt (&1 - x * x))`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - e2, y + e2)`))) (term_tac exists_tac))));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL]))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 < &1 - y * y`))) (term_tac (have_gen_tac [](move ["gt0"]))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `&1 - y * y = (&1 - y) * (&1 + y)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("SQRT_EQ_0", [SQRT_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_LT_IMP_NZ", [REAL_LT_IMP_NZ]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`(\x. sqrt (&1 - x * x)) = sqrt o (\x. &1 - x * x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]);
   ((((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("e2_def", [])) (disch_tac [])) THEN (clear_assumption "e2_def") THEN ((use_arg_then2 ("e_def", [])) (disch_tac [])) THEN (clear_assumption "e_def") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_matan *)
let second_derivative_matan = Sections.section_proof ["x"]
`nth_derivative 2 matan x = ddmatan x`
[
   (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_eq_real_derivative", [derivative_eq_real_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ddmatan", [ddmatan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_matan *)
let diff2_matan = Sections.section_proof ["x"]
`-- &1 < x ==> nth_diff_strong 2 matan x`
[
   ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN (move ["x_ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (-- &1, x + &1)`))) (term_tac exists_tac));
   (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))))) THEN ((THENL) (split_tac) [ALL_TAC; ((move ["y"]) THEN (move ["ineq"]))]));
   ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)) THEN (((fun arg_tac -> arg_tac (Arg_term (`dmatan`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (-- &1, y + &1)`))) (term_tac exists_tac))));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((THENL_FIRST) ((THENL) (split_tac) [ALL_TAC; ((move ["z"]) THEN (move ["ineq2"]))]) ((((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y < &1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["y_ineq"]));
   ((((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("matan_second_derivative_abs1", [matan_second_derivative_abs1]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN ((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`\x. inv (&2 * x * (x + &1)) - atn (sqrt x) / (&2 * x * sqrt x)`))) (term_tac (set_tac "f'")));
   (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`real_interval (y - &1, y + &1)`))) (term_tac exists_tac)));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((THENL_FIRST) (split_tac) ((arith_tac) THEN (done_tac)));
   ((BETA_TAC THEN (move ["t"]) THEN (move ["t_ineq"])) THEN ((((use_arg_then2 ("f'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("matan_real_derivative_gt0", [matan_real_derivative_gt0]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN ((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))));
   (((fun arg_tac -> (use_arg_then2 ("matan_has_derivative2_gt0", [matan_has_derivative2_gt0])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((use_arg_then2 ("f'_def", []))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 - _2`))) (term_tac (set_tac "f''"))) THEN (BETA_TAC THEN (move ["h"])));
   (((use_arg_then2 ("f''", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("y_ineq", [])) (disch_tac [])) THEN (clear_assumption "y_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Section SecondDerivativeCompose *)
Sections.begin_section "SecondDerivativeCompose";;

(* Lemma REAL_CONTINUOUS_OPEN_PREIMAGE *)
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.section_proof ["f";"s";"t"]
`f real_continuous_on s ==> real_open s ==> real_open t ==>
	real_open {x | x IN s /\ f x IN t}`
[
   (BETA_TAC THEN (move ["f_cont"]) THEN (move ["open_s"]) THEN (move ["open_t"]));
   (((use_arg_then2 ("REAL_OPEN", [REAL_OPEN]))(thm_tac (new_rewrite [] []))));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`IMAGE lift {x | x IN s /\ f x IN t} = 
	{x | x IN (IMAGE lift s) /\ (lift o f o drop) x IN (IMAGE lift t)}`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))));
   (((((use_arg_then2 ("CONTINUOUS_OPEN_PREIMAGE", [CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN", [REAL_OPEN]))(gsym_then (thm_tac (new_rewrite [] []))))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_ON", [REAL_CONTINUOUS_ON]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((((use_arg_then2 ("EXTENSION", [EXTENSION]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_IMAGE_LIFT_DROP", [IN_IMAGE_LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE_LIFT_DROP", [IN_IMAGE_LIFT_DROP]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (simp_tac)) THEN (split_tac));
   ((BETA_TAC THEN (case THEN (move ["x"])) THEN (case THEN (move ["x_in"])) THEN (move ["x_eq"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`lift x`))) (term_tac exists_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("x_in", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("x_eq", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["x"])) THEN (case THEN (move ["x_in"])) THEN (move ["x_eq"]));
   (((fun arg_tac -> arg_tac (Arg_term (`drop x`))) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma second_derivative_compose *)
let second_derivative_compose = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 g x ==> nth_diff_strong 2 f (g x) ==>
	nth_derivative 2 (\x. f (g x)) x = 
	nth_derivative 2 f (g x) * (derivative g x) pow 2 + derivative f (g x) * nth_derivative 2 g x`
[
   (BETA_TAC THEN (move ["dg"]) THEN (move ["df"]));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   ((THENL_ROT (-1)) (((fun arg_tac -> arg_tac (Arg_term (`\x. derivative f (g x) * derivative g x`))) (term_tac exists_tac)) THEN (split_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["gxs"])) THEN (move ["d_f"]) THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["d_g"])));
   ((fun arg_tac -> arg_tac (Arg_term (`{z | z IN t /\ g z IN s}`))) (term_tac (set_tac "s'")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_open s'`))) (term_tac (have_gen_tac [](move ["open_s'"]))));
   ((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_OPEN_PREIMAGE", [REAL_CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_t", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT", [REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["yt"]));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`t INTER s'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (done_tac));
   ((BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["yt"]) THEN (move ["ys'"])))) THEN ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("d_f", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq_alt", [nth_diff_strong2_eq_alt]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["d_f"]) THEN (case THEN (move ["_"])) THEN (move ["d_g"])));
   ((THENL_ROT (-1)) (((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFF_CHAIN_ATREAL", [REAL_DIFF_CHAIN_ATREAL]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("d_g", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("d_f", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose *)
let diff2_compose = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 g x ==> nth_diff_strong 2 f (g x) ==>
	nth_diff_strong 2 (\x. f (g x)) x`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["dg"]) THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["gxt"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`{z | z IN s /\ g z IN t}`))) (term_tac (set_tac "s'")));
   ((fun arg_tac -> arg_tac (Arg_term (`real_open s'`))) (term_tac (have_gen_tac [](move ["open_s'"]))));
   ((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_CONTINUOUS_OPEN_PREIMAGE", [REAL_CONTINUOUS_OPEN_PREIMAGE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_t", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT", [REAL_CONTINUOUS_ON_EQ_REAL_CONTINUOUS_AT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["y"]) THEN (move ["yt"]));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER s'`))) (term_tac exists_tac)) THEN ((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["ys'"]))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
   (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac));
   ((THENL_ROT (-1)) ((((fun arg_tac -> arg_tac (Arg_term (`\x. derivative g x * derivative f (g x)`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`s INTER s'`))) (term_tac exists_tac))) THEN (split_tac)));
   (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ys'", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["z_in"]));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("z_in", [])) (disch_tac [])) THEN (clear_assumption "z_in") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (simp_tac)) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("ys'", [])) (disch_tac [])) THEN (clear_assumption "ys'") THEN BETA_TAC) THEN (((use_arg_then2 ("s'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("IN_ELIM_THM", [IN_ELIM_THM]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["z"])) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma continuous_not0_exists_open *)
let continuous_not0_exists_open = Sections.section_proof ["f";"x"]
`~(f x = &0) ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> ~(f y = &0)`
[
   ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN (move ["fn0"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`abs (f x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("fn0", [])) (disch_tac [])) THEN (clear_assumption "fn0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("fn0", [])) (disch_tac [])) THEN (clear_assumption "fn0") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_gt_exists_open *)
let continuous_gt_exists_open = Sections.section_proof ["a";"f";"x"]
`a < f x ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> a < f y`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x - a`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_lt_exists_open *)
let continuous_lt_exists_open = Sections.section_proof ["a";"f";"x"]
`f x < a ==> f real_continuous atreal x ==>
	?s. real_open s /\ x IN s /\ !y. y IN s ==> f y < a`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("real_continuous_atreal", [real_continuous_atreal]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`a - f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval (x - d, x + d)`))) (term_tac exists_tac));
   ((THENL_FIRST) (((((use_arg_then2 ("REAL_OPEN_REAL_INTERVAL", [REAL_OPEN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [ALL_TAC; (move ["y"])])) ((((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "df" (`nth_diff_strong 2 f x`));;

(* Lemma second_derivative_compose_atn *)
let second_derivative_compose_atn = Sections.section_proof []
`nth_derivative 2 (\x. atn (f x)) x = 
	(nth_derivative 2 f x * (&1 + f x * f x) - &2 * f x * derivative f x pow 2) / (&1 + f x * f x) pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "lhs1"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "lhs2"))));
   ((((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "rhs1"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`_1 * _2`))) (term_tac (set_tac "rhs2"))));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `lhs1 = rhs1 /\ lhs2 = rhs2 ==> lhs1 - lhs2 = rhs1 - rhs2`))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((((use_arg_then2 ("lhs2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("rhs2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [(`_1 * _2 pow 2`)])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((split_tac) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("rhs1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a * b * c * d = a * (b * c) * d`)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("lhs1_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((fun arg_tac -> (use_arg_then2 ("REAL_LE_SQUARE", [REAL_LE_SQUARE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_cos *)
let second_derivative_compose_cos = Sections.section_proof []
`nth_derivative 2 (\x. cos (f x)) x = 
	--(nth_derivative 2 f x * sin (f x) + cos (f x) * derivative f x pow 2)`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sin *)
let second_derivative_compose_sin = Sections.section_proof []
`nth_derivative 2 (\x. sin (f x)) x = 
	nth_derivative 2 f x * cos (f x) - sin (f x) * derivative f x pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_exp *)
let second_derivative_compose_exp = Sections.section_proof []
`nth_derivative 2 (\x. exp (f x)) x = 
	nth_derivative 2 f x * exp (f x) + exp (f x) * derivative f x pow 2`
[
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_log *)
let second_derivative_compose_log = Sections.section_proof []
`&0 < f x ==>
	nth_derivative 2 (\x. log (f x)) x =
	nth_derivative 2 f x / f x - (derivative f x / f x) pow 2`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_log", [second_derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("REAL_POW_DIV", [REAL_POW_DIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_compose_inv *)
let second_derivative_compose_inv = Sections.section_proof []
`~(f x = &0) ==>
	nth_derivative 2 (\x. inv (f x)) x =
	(&2 * derivative f x pow 2 - nth_derivative 2 f x * f x) / (f x pow 3)`
[
   (BETA_TAC THEN (move ["fn0"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_inv", [second_derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a - b = c - d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("REAL_INV_POW", [REAL_INV_POW]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = a * (b * c) * d`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sqrt *)
let second_derivative_compose_sqrt = Sections.section_proof []
`&0 < f x ==>
	nth_derivative 2 (\x. sqrt (f x)) x =
	(&2 * nth_derivative 2 f x * f x - derivative f x pow 2) / (&4 * sqrt (f x pow 3))`
[
   (BETA_TAC THEN (move ["f_pos"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_sqrt", [second_derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_sub", [real_sub]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_SUB_RDISTRIB", [REAL_SUB_RDISTRIB]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a - b = c - d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (f x pow 3) = sqrt (f x) * f x`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (repeat_tactic 1 9 (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (&2 * a * b) * inv (&4) * c * d = (inv (&2) * c) * a * (b * d)`)))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_POS_NZ", [REAL_POS_NZ]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_acs *)
let second_derivative_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==>
	nth_derivative 2 (\x. acs (f x)) x =
	-- ((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) / 
	sqrt ((&1 - f x * f x) pow 3))`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_acs", [second_derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LNEG", [REAL_MUL_LNEG]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_ADD", [REAL_NEG_ADD]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_NEG2", [REAL_EQ_NEG2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a + b = c + d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - f x * f x`))) (term_tac (set_tac "y")));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= y /\ &0 < y /\ ~(y = &0)`))) (term_tac (have_gen_tac [](move ["y_ineq"]))));
   ((((use_arg_then2 ("y_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. &1 - a * a = (&1 - a) * (&1 + a)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (y pow 3) = sqrt y * y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = c * a * (b * d)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_asn *)
let second_derivative_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==>
	nth_derivative 2 (\x. asn (f x)) x =
	((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) / 
	sqrt ((&1 - f x * f x) pow 3))`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_asn", [second_derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))));
   ((THENL_LAST) ((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. a = c /\ b = d ==> a + b = c + d`))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (split_tac)) ((arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&1 - f x * f x`))) (term_tac (set_tac "y")));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= y /\ &0 < y /\ ~(y = &0)`))) (term_tac (have_gen_tac [](move ["y_ineq"]))));
   ((((use_arg_then2 ("y_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a. &1 - a * a = (&1 - a) * (&1 + a)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_ENTIRE", [REAL_ENTIRE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LT_MUL", [REAL_LT_MUL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`sqrt (y pow 3) = sqrt y * y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("SQRT_POW", [SQRT_POW]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SQRT_POW_2", [SQRT_POW_2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b c d. (a * b) * c * d = c * a * (b * d)`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_matan *)
let second_derivative_compose_matan = Sections.section_proof []
`-- &1 < f x ==>
	nth_derivative 2 (\x. matan (f x)) x =
	nth_derivative 2 f x * dmatan (f x) + derivative f x pow 2 * ddmatan (f x)`
[
   (BETA_TAC THEN (move ["f_ineq"]));
   ((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("second_derivative_matan", [second_derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((arith_tac) THEN (done_tac));
];;

(* Lemma diff2_compose_atn *)
let diff2_compose_atn = Sections.section_proof []
`nth_diff_strong 2 (\x. atn (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_cos *)
let diff2_compose_cos = Sections.section_proof []
`nth_diff_strong 2 (\x. cos (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_sin *)
let diff2_compose_sin = Sections.section_proof []
`nth_diff_strong 2 (\x. sin (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_exp *)
let diff2_compose_exp = Sections.section_proof []
`nth_diff_strong 2 (\x. exp (f x)) x`
[
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_log *)
let diff2_compose_log = Sections.section_proof []
`&0 < f x ==> nth_diff_strong 2 (\x. log (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_inv *)
let diff2_compose_inv = Sections.section_proof []
`~(f x = &0) ==> nth_diff_strong 2 (\x. inv (f x)) x`
[
   ((BETA_TAC THEN (move ["fn0"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_sqrt *)
let diff2_compose_sqrt = Sections.section_proof []
`&0 < f x ==> nth_diff_strong 2 (\x. sqrt (f x)) x`
[
   ((BETA_TAC THEN (move ["f_pos"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_acs *)
let diff2_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==> nth_diff_strong 2 (\x. acs (f x)) x`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_asn *)
let diff2_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==> nth_diff_strong 2 (\x. asn (f x)) x`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_compose_matan *)
let diff2_compose_matan = Sections.section_proof []
`-- &1 < f x ==> nth_diff_strong 2 (\x. matan (f x)) x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN ((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section SecondDerivativeCompose *)
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.finalize_theorem REAL_CONTINUOUS_OPEN_PREIMAGE;;
let second_derivative_compose = Sections.finalize_theorem second_derivative_compose;;
let diff2_compose = Sections.finalize_theorem diff2_compose;;
let continuous_not0_exists_open = Sections.finalize_theorem continuous_not0_exists_open;;
let continuous_gt_exists_open = Sections.finalize_theorem continuous_gt_exists_open;;
let continuous_lt_exists_open = Sections.finalize_theorem continuous_lt_exists_open;;
let second_derivative_compose_atn = Sections.finalize_theorem second_derivative_compose_atn;;
let second_derivative_compose_cos = Sections.finalize_theorem second_derivative_compose_cos;;
let second_derivative_compose_sin = Sections.finalize_theorem second_derivative_compose_sin;;
let second_derivative_compose_exp = Sections.finalize_theorem second_derivative_compose_exp;;
let second_derivative_compose_log = Sections.finalize_theorem second_derivative_compose_log;;
let second_derivative_compose_inv = Sections.finalize_theorem second_derivative_compose_inv;;
let second_derivative_compose_sqrt = Sections.finalize_theorem second_derivative_compose_sqrt;;
let second_derivative_compose_acs = Sections.finalize_theorem second_derivative_compose_acs;;
let second_derivative_compose_asn = Sections.finalize_theorem second_derivative_compose_asn;;
let second_derivative_compose_matan = Sections.finalize_theorem second_derivative_compose_matan;;
let diff2_compose_atn = Sections.finalize_theorem diff2_compose_atn;;
let diff2_compose_cos = Sections.finalize_theorem diff2_compose_cos;;
let diff2_compose_sin = Sections.finalize_theorem diff2_compose_sin;;
let diff2_compose_exp = Sections.finalize_theorem diff2_compose_exp;;
let diff2_compose_log = Sections.finalize_theorem diff2_compose_log;;
let diff2_compose_inv = Sections.finalize_theorem diff2_compose_inv;;
let diff2_compose_sqrt = Sections.finalize_theorem diff2_compose_sqrt;;
let diff2_compose_acs = Sections.finalize_theorem diff2_compose_acs;;
let diff2_compose_asn = Sections.finalize_theorem diff2_compose_asn;;
let diff2_compose_matan = Sections.finalize_theorem diff2_compose_matan;;
Sections.end_section "SecondDerivativeCompose";;

(* Lemma second_derivative_mul *)
let second_derivative_mul = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
  nth_diff_strong 2 g x ==>
  nth_derivative 2 (\x. f x * g x) x =
  f x * nth_derivative 2 g x + &2 * derivative f x * derivative g x + nth_derivative 2 f x * g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_mul", [nth_derivative_mul])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `!n. 0 <= SUC n`)))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("subnn", [subnn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 - 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BINOM_1", [BINOM_1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BINOM_REFL", [BINOM_REFL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_ASSOC", [REAL_ADD_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_div *)
let second_derivative_div = Sections.section_proof ["f";"g";"x"]
`~(g x = &0) ==>
	nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x / g x) x = 
	((nth_derivative 2 f x * g x - f x * nth_derivative 2 g x) * g x -
	&2 * derivative g x * (derivative f x * g x - f x * derivative g x)) / (g x pow 3)`
[
   (BETA_TAC THEN (move ["gn0"]) THEN (move ["diff_f"]) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`derivative g x`))) (term_tac (set_tac "dg"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`derivative f x`))) (term_tac (set_tac "df"))));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 g x`))) (term_tac (set_tac "ddg"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 f x`))) (term_tac (set_tac "ddf"))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("second_derivative_mul", [second_derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("second_derivative_compose_inv", [second_derivative_compose_inv]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("derivative_compose_inv", [derivative_compose_inv]))(thm_tac (new_rewrite [] []))));
   ((((use_arg_then2 ("diff_g", [])) (disch_tac [])) THEN (clear_assumption "diff_g") THEN BETA_TAC) THEN ((((use_arg_then2 ("nth_diff_strong2_eq", [nth_diff_strong2_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (done_tac));
   ((((use_arg_then2 ("ddf_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ddg_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg_def", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))));
   ((fun arg_tac -> arg_tac (Arg_term (`_1 + _2`))) (term_tac (set_tac "lhs")));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_RING `!f g x. ((ddf * g x - f x * ddg) * g x - &2 * dg * (df * g x - f x * dg)) * 
						inv (g x pow 3) =
			f x * (&2 * dg pow 2 - ddg * g x) * inv (g x pow 3) +
			&2 * df * --(g x * inv (g x pow 3)) * dg +
			ddf * (g x * g x * inv (g x pow 3))`)))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> arg_tac (Arg_term (`g x * inv (g x pow 3) = inv (g x pow 2)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `3 = SUC 2`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`g x * inv (g x pow 2) = inv (g x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("TWO", [TWO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_powS", [real_powS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_INV_MUL", [REAL_INV_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RINV", [REAL_MUL_RINV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((fun arg_tac -> (use_arg_then2 ("REAL_POW_2", [REAL_POW_2])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`g x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("lhs_def", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff2_div *)
let diff2_div = Sections.section_proof ["f";"g";"x"]
`~(g x = &0) ==> nth_diff_strong 2 f x ==> nth_diff_strong 2 g x ==>
	nth_diff_strong 2 (\x. f x / g x) x`
[
   ((BETA_TAC THEN (move ["gn0"]) THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_diff_mul", [nth_diff_mul])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\x. inv (g x)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   ((((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((split_tac) THEN ((TRY done_tac)) THEN (move ["y"])));
   (((((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma second_derivative_scale *)
let second_derivative_scale = Sections.section_proof ["f";"c";"x"]
`nth_diff_strong 2 f x ==>
	nth_derivative 2 (\x. c * f x) x = c * nth_derivative 2 f x`
[
   ((BETA_TAC THEN (move ["df0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (move ["df"]))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((BETA_TAC THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale", [nth_derivative_scale])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_add *)
let second_derivative_add = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x + g x) x = nth_derivative 2 f x + nth_derivative 2 g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_add", [nth_derivative_add])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sub *)
let second_derivative_sub = Sections.section_proof ["f";"g";"x"]
`nth_diff_strong 2 f x ==>
	nth_diff_strong 2 g x ==>
	nth_derivative 2 (\x. f x - g x) x = nth_derivative 2 f x - nth_derivative 2 g x`
[
   ((BETA_TAC THEN (move ["df0"]) THEN (move ["dg0"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(x,x)`))) (term_tac (set_tac "int"))));
   ((fun arg_tac -> arg_tac (Arg_term (`interval_arith x int /\ nth_diff_strong_int 2 int f /\ nth_diff_strong_int 2 int g`))) (term_tac (have_gen_tac [](case THEN ((move ["ineq"]) THEN (case THEN ((move ["df"]) THEN (move ["dg"]))))))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("int_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("CONST_INTERVAL", [CONST_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   (((split_tac) THEN (move ["y"])) THEN (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ANTISYM", [REAL_LE_ANTISYM]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_sub", [nth_derivative_sub])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_bounds *)
let second_derivative_compose_bounds = Sections.section_proof ["f";"g";"int";"g_bounds";"dd_bounds"]
`nth_diff_strong_int 2 int g ==>
	bounded_on_int g int g_bounds ==>
	nth_diff_strong_int 2 g_bounds f ==>
	bounded_on_int (\x. nth_derivative 2 f (g x) * derivative g x pow 2 + 
			derivative f (g x) * nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f (g x)) int dd_bounds`
[
   ((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   ((BETA_TAC THEN (move ["dg"]) THEN (move ["g_bounded"]) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose", [diff2_compose]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose", [second_derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_atn_bounds *)
let second_derivative_atn_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. (-- &2 * x) * inv(&1 + x pow 2) pow 2) int dd_bounds ==>
	has_bounded_second_derivative atn int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("second_derivative_atn", [second_derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_atn", [diff2_atn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_atn_bounds *)
let second_derivative_compose_atn_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (nth_derivative 2 f x * (&1 + f x * f x) - &2 * f x * derivative f x pow 2) /
			(&1 + f x * f x) pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. atn (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_atn", [diff2_compose_atn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_atn", [second_derivative_compose_atn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_cos_bounds *)
let second_derivative_cos_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. -- cos x) int dd_bounds ==>
	has_bounded_second_derivative cos int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_cos", [second_derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_cos", [diff2_cos]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_cos_bounds *)
let second_derivative_compose_cos_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. --(nth_derivative 2 f x * sin (f x) 
		+ cos (f x) * derivative f x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative (\x. cos (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_cos", [diff2_compose_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_cos", [second_derivative_compose_cos]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sin_bounds *)
let second_derivative_sin_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int (\x. -- sin x) int dd_bounds ==>
	has_bounded_second_derivative sin int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_sin", [second_derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_sin", [diff2_sin]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sin_bounds *)
let second_derivative_compose_sin_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * cos (f x) 
		- sin (f x) * derivative f x pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. sin (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_sin", [diff2_compose_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_sin", [second_derivative_compose_sin]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_exp_bounds *)
let second_derivative_exp_bounds = Sections.section_proof ["dd_bounds"]
`bounded_on_int exp int dd_bounds ==>
	has_bounded_second_derivative exp int dd_bounds`
[
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]));
   ((THENL_LAST) (split_tac) (((((use_arg_then2 ("second_derivative_exp", [second_derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff2_exp", [diff2_exp]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_exp_bounds *)
let second_derivative_compose_exp_bounds = Sections.section_proof ["f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * exp (f x) 
		+ exp (f x) * derivative f x pow 2) int dd_bounds ==>
	has_bounded_second_derivative (\x. exp (f x)) int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["df"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_compose_exp", [diff2_compose_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_exp", [second_derivative_compose_exp]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_log_bounds *)
let second_derivative_log_bounds = Sections.section_proof ["dd_bounds"]
`interval_pos int ==>
	bounded_on_int (\x. --inv (x pow 2)) int dd_bounds ==>
	has_bounded_second_derivative log int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_pos"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_log", [diff2_log]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_log", [second_derivative_log]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_log_bounds *)
let second_derivative_compose_log_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_pos f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x / f x - (derivative f x / f x) pow 2)
			int dd_bounds ==>
	has_bounded_second_derivative (\x. log (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> &0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_log", [diff2_compose_log]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_log", [second_derivative_compose_log]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_inv_bounds *)
let second_derivative_inv_bounds = Sections.section_proof ["dd_bounds"]
`interval_not_zero int ==>
	bounded_on_int (\x. &2 * inv (x pow 3)) int dd_bounds ==>
	has_bounded_second_derivative inv int dd_bounds`
[
   ((((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int0"]) THEN (move ["bounded"])) THEN ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])));
   (((((use_arg_then2 ("diff2_inv", [diff2_inv]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_inv", [second_derivative_inv]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_inv_bounds *)
let second_derivative_compose_inv_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_not_zero f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (&2 * derivative f x pow 2 - nth_derivative 2 f x * f x) / f x pow 3) 
			int dd_bounds ==>
	has_bounded_second_derivative (\x. inv (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f0"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> ~(f x = &0)`))) (term_tac (have_gen_tac [](move ["fn0"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_inv", [diff2_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fn0", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_inv", [second_derivative_compose_inv]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fn0", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sqrt_bounds *)
let second_derivative_sqrt_bounds = Sections.section_proof ["dd_bounds"]
`interval_pos int ==>
	bounded_on_int (\x. --inv (&4 * sqrt (x pow 3))) int dd_bounds ==>
	has_bounded_second_derivative sqrt int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_pos"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_sqrt", [diff2_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_sqrt", [second_derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_sqrt_bounds *)
let second_derivative_compose_sqrt_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_pos f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (&2 * nth_derivative 2 f x * f x - derivative f x pow 2) /
			(&4 * sqrt (f x pow 3))) 
			int dd_bounds ==>
	has_bounded_second_derivative (\x. sqrt (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> &0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_sqrt", [diff2_compose_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_sqrt", [second_derivative_compose_sqrt]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_pos", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_acs_bounds *)
let second_derivative_acs_bounds = Sections.section_proof ["dd_bounds"]
`iabs int < &1 ==>
	bounded_on_int (\x. --(x / sqrt ((&1 - x * x) pow 3))) int dd_bounds ==>
	has_bounded_second_derivative acs int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_abs"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_acs", [diff2_acs]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_acs", [second_derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_acs_bounds *)
let second_derivative_compose_acs_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> iabs f_bounds < &1 ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. --((nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) /
				sqrt ((&1 - f x * f x) pow 3))) int dd_bounds ==>
	has_bounded_second_derivative (\x. acs (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_abs"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["fabs"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_acs", [diff2_compose_acs]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_acs", [second_derivative_compose_acs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_asn_bounds *)
let second_derivative_asn_bounds = Sections.section_proof ["dd_bounds"]
`iabs int < &1 ==>
	bounded_on_int (\x. x / sqrt ((&1 - x * x) pow 3)) int dd_bounds ==>
	has_bounded_second_derivative asn int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_abs"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_asn", [diff2_asn]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_asn", [second_derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_asn_bounds *)
let second_derivative_compose_asn_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> iabs f_bounds < &1 ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. (nth_derivative 2 f x * (&1 - f x * f x) + f x * derivative f x pow 2) /
				sqrt ((&1 - f x * f x) pow 3)) int dd_bounds ==>
	has_bounded_second_derivative (\x. asn (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_abs"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["fabs"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_asn", [diff2_compose_asn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_asn", [second_derivative_compose_asn]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("fabs", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma interval_arith_gt *)
let interval_arith_gt = Sections.section_proof ["x";"int";"f"]
`interval_arith x int /\ interval_gt f int ==> f < x`
[
   (((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_gt", [interval_gt]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma second_derivative_matan_bounds *)
let second_derivative_matan_bounds = Sections.section_proof ["dd_bounds"]
`interval_gt (-- &1) int ==>
	bounded_on_int ddmatan int dd_bounds ==>
	has_bounded_second_derivative matan int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["int_gt"]) THEN (move ["bounded"]));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_matan", [diff2_matan]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_matan", [second_derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_compose_matan_bounds *)
let second_derivative_compose_matan_bounds = Sections.section_proof ["f";"f_bounds";"dd_bounds"]
`bounded_on_int f int f_bounds ==> interval_gt (-- &1) f_bounds ==>
	nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. nth_derivative 2 f x * dmatan (f x) + derivative f x pow 2 * ddmatan (f x))
			int dd_bounds ==>
	has_bounded_second_derivative (\x. matan (f x)) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["f_bounded"]) THEN (move ["f_int"]) THEN (move ["df"]) THEN (move ["bounded"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> -- &1 < f x`))) (term_tac (have_gen_tac [](move ["f_ineq"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("interval_arith_gt", [interval_arith_gt])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((split_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("diff2_compose_matan", [diff2_compose_matan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("second_derivative_compose_matan", [second_derivative_compose_matan]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_ineq", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("bounded", [bounded]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_scale_bounds *)
let second_derivative_scale_bounds = Sections.section_proof ["c";"f";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	bounded_on_int (\x. c * nth_derivative 2 f x) int dd_bounds ==>
	has_bounded_second_derivative (\x. c * f x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_scale", [nth_diff_scale]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_scale", [second_derivative_scale]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (exact_tac) THEN (done_tac));
];;

(* Lemma second_derivative_add_bounds *)
let second_derivative_add_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. nth_derivative 2 f x + nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x + g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_add", [nth_diff_add]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_add", [second_derivative_add]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_sub_bounds *)
let second_derivative_sub_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. nth_derivative 2 f x - nth_derivative 2 g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x - g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_sub", [nth_diff_sub]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_sub", [second_derivative_sub]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_mul_bounds *)
let second_derivative_mul_bounds = Sections.section_proof ["f";"g";"dd_bounds"]
`nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. f x * nth_derivative 2 g x + &2 * derivative f x * derivative g x +
			nth_derivative 2 f x * g x) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x * g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   (((((use_arg_then2 ("nth_diff_mul", [nth_diff_mul]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("second_derivative_mul", [second_derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma second_derivative_div_bounds *)
let second_derivative_div_bounds = Sections.section_proof ["f";"g";"g_bounds";"dd_bounds"]
`bounded_on_int g int g_bounds ==> interval_not_zero g_bounds ==>
	nth_diff_strong_int 2 int f ==>
	nth_diff_strong_int 2 int g ==>
	bounded_on_int (\x. ((nth_derivative 2 f x * g x - f x * nth_derivative 2 g x) * g x -
	  &2 * derivative g x * (derivative f x * g x - f x * derivative g x)) / g x pow 3) int dd_bounds ==>
	has_bounded_second_derivative (\x. f x / g x) int dd_bounds`
[
   (((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))))) THEN (move ["bg"]) THEN (move ["gn0"]) THEN (simp_tac) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["b"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!x. interval_arith x int ==> ~(g x = &0)`))) (term_tac (have_gen_tac [](move ["g0"]))));
   ((BETA_TAC THEN (move ["x"]) THEN (move ["ineq"])) THEN (((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`g_bounds`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("bg", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((THENL_FIRST) ((split_tac) THEN (move ["x"]) THEN (move ["ineq"])) (((((use_arg_then2 ("diff2_div", [diff2_div]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g0", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac)));
   (((((use_arg_then2 ("second_derivative_div", [second_derivative_div]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("g0", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section SecondDerivativeBound *)
let nth_diff_strong2_eq_alt = Sections.finalize_theorem nth_diff_strong2_eq_alt;;
let nth_diff_strong2_eq = Sections.finalize_theorem nth_diff_strong2_eq;;
let lin_approx_compose = Sections.finalize_theorem lin_approx_compose;;
let second_derivative_atn_eq = Sections.finalize_theorem second_derivative_atn_eq;;
let second_derivative_atn = Sections.finalize_theorem second_derivative_atn;;
let diff2_atn = Sections.finalize_theorem diff2_atn;;
let second_derivative_cos = Sections.finalize_theorem second_derivative_cos;;
let diff2_cos = Sections.finalize_theorem diff2_cos;;
let second_derivative_sin = Sections.finalize_theorem second_derivative_sin;;
let diff2_sin = Sections.finalize_theorem diff2_sin;;
let second_derivative_exp = Sections.finalize_theorem second_derivative_exp;;
let diff2_exp = Sections.finalize_theorem diff2_exp;;
let second_derivative_log = Sections.finalize_theorem second_derivative_log;;
let diff2_log = Sections.finalize_theorem diff2_log;;
let second_derivative_inv = Sections.finalize_theorem second_derivative_inv;;
let diff2_inv = Sections.finalize_theorem diff2_inv;;
let SQRT_POW = Sections.finalize_theorem SQRT_POW;;
let second_derivative_sqrt = Sections.finalize_theorem second_derivative_sqrt;;
let diff2_sqrt = Sections.finalize_theorem diff2_sqrt;;
let real_powS = Sections.finalize_theorem real_powS;;
let second_derivative_acs = Sections.finalize_theorem second_derivative_acs;;
let diff2_acs = Sections.finalize_theorem diff2_acs;;
let second_derivative_asn = Sections.finalize_theorem second_derivative_asn;;
let diff2_asn = Sections.finalize_theorem diff2_asn;;
let second_derivative_matan = Sections.finalize_theorem second_derivative_matan;;
let diff2_matan = Sections.finalize_theorem diff2_matan;;
let REAL_CONTINUOUS_OPEN_PREIMAGE = Sections.finalize_theorem REAL_CONTINUOUS_OPEN_PREIMAGE;;
let second_derivative_compose = Sections.finalize_theorem second_derivative_compose;;
let diff2_compose = Sections.finalize_theorem diff2_compose;;
let continuous_not0_exists_open = Sections.finalize_theorem continuous_not0_exists_open;;
let continuous_gt_exists_open = Sections.finalize_theorem continuous_gt_exists_open;;
let continuous_lt_exists_open = Sections.finalize_theorem continuous_lt_exists_open;;
let second_derivative_compose_atn = Sections.finalize_theorem second_derivative_compose_atn;;
let second_derivative_compose_cos = Sections.finalize_theorem second_derivative_compose_cos;;
let second_derivative_compose_sin = Sections.finalize_theorem second_derivative_compose_sin;;
let second_derivative_compose_exp = Sections.finalize_theorem second_derivative_compose_exp;;
let second_derivative_compose_log = Sections.finalize_theorem second_derivative_compose_log;;
let second_derivative_compose_inv = Sections.finalize_theorem second_derivative_compose_inv;;
let second_derivative_compose_sqrt = Sections.finalize_theorem second_derivative_compose_sqrt;;
let second_derivative_compose_acs = Sections.finalize_theorem second_derivative_compose_acs;;
let second_derivative_compose_asn = Sections.finalize_theorem second_derivative_compose_asn;;
let second_derivative_compose_matan = Sections.finalize_theorem second_derivative_compose_matan;;
let diff2_compose_atn = Sections.finalize_theorem diff2_compose_atn;;
let diff2_compose_cos = Sections.finalize_theorem diff2_compose_cos;;
let diff2_compose_sin = Sections.finalize_theorem diff2_compose_sin;;
let diff2_compose_exp = Sections.finalize_theorem diff2_compose_exp;;
let diff2_compose_log = Sections.finalize_theorem diff2_compose_log;;
let diff2_compose_inv = Sections.finalize_theorem diff2_compose_inv;;
let diff2_compose_sqrt = Sections.finalize_theorem diff2_compose_sqrt;;
let diff2_compose_acs = Sections.finalize_theorem diff2_compose_acs;;
let diff2_compose_asn = Sections.finalize_theorem diff2_compose_asn;;
let diff2_compose_matan = Sections.finalize_theorem diff2_compose_matan;;
let second_derivative_mul = Sections.finalize_theorem second_derivative_mul;;
let second_derivative_div = Sections.finalize_theorem second_derivative_div;;
let diff2_div = Sections.finalize_theorem diff2_div;;
let second_derivative_scale = Sections.finalize_theorem second_derivative_scale;;
let second_derivative_add = Sections.finalize_theorem second_derivative_add;;
let second_derivative_sub = Sections.finalize_theorem second_derivative_sub;;
let second_derivative_compose_bounds = Sections.finalize_theorem second_derivative_compose_bounds;;
let second_derivative_atn_bounds = Sections.finalize_theorem second_derivative_atn_bounds;;
let second_derivative_compose_atn_bounds = Sections.finalize_theorem second_derivative_compose_atn_bounds;;
let second_derivative_cos_bounds = Sections.finalize_theorem second_derivative_cos_bounds;;
let second_derivative_compose_cos_bounds = Sections.finalize_theorem second_derivative_compose_cos_bounds;;
let second_derivative_sin_bounds = Sections.finalize_theorem second_derivative_sin_bounds;;
let second_derivative_compose_sin_bounds = Sections.finalize_theorem second_derivative_compose_sin_bounds;;
let second_derivative_exp_bounds = Sections.finalize_theorem second_derivative_exp_bounds;;
let second_derivative_compose_exp_bounds = Sections.finalize_theorem second_derivative_compose_exp_bounds;;
let second_derivative_log_bounds = Sections.finalize_theorem second_derivative_log_bounds;;
let second_derivative_compose_log_bounds = Sections.finalize_theorem second_derivative_compose_log_bounds;;
let second_derivative_inv_bounds = Sections.finalize_theorem second_derivative_inv_bounds;;
let second_derivative_compose_inv_bounds = Sections.finalize_theorem second_derivative_compose_inv_bounds;;
let second_derivative_sqrt_bounds = Sections.finalize_theorem second_derivative_sqrt_bounds;;
let second_derivative_compose_sqrt_bounds = Sections.finalize_theorem second_derivative_compose_sqrt_bounds;;
let second_derivative_acs_bounds = Sections.finalize_theorem second_derivative_acs_bounds;;
let second_derivative_compose_acs_bounds = Sections.finalize_theorem second_derivative_compose_acs_bounds;;
let second_derivative_asn_bounds = Sections.finalize_theorem second_derivative_asn_bounds;;
let second_derivative_compose_asn_bounds = Sections.finalize_theorem second_derivative_compose_asn_bounds;;
let interval_arith_gt = Sections.finalize_theorem interval_arith_gt;;
let second_derivative_matan_bounds = Sections.finalize_theorem second_derivative_matan_bounds;;
let second_derivative_compose_matan_bounds = Sections.finalize_theorem second_derivative_compose_matan_bounds;;
let second_derivative_scale_bounds = Sections.finalize_theorem second_derivative_scale_bounds;;
let second_derivative_add_bounds = Sections.finalize_theorem second_derivative_add_bounds;;
let second_derivative_sub_bounds = Sections.finalize_theorem second_derivative_sub_bounds;;
let second_derivative_mul_bounds = Sections.finalize_theorem second_derivative_mul_bounds;;
let second_derivative_div_bounds = Sections.finalize_theorem second_derivative_div_bounds;;
Sections.end_section "SecondDerivativeBound";;

(* Section TaylorArith *)
Sections.begin_section "TaylorArith";;
let cell_domain = new_definition `cell_domain x y z w <=> 
	x <= y /\ y <= z /\ y - x <= w /\ z - y <= w`;;

(* Lemma taylor_x *)
let taylor_x = Sections.section_proof ["x";"y";"z";"w"]
`cell_domain x y z w ==>
	taylor_interval (\x. x) x y z w (y, y) (&1, &1) (&0, &0)`
[
   ((((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineqs"]));
   ((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx_x", [lin_approx_x]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["_"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["q"]) THEN (simp_tac)));
   (((((use_arg_then2 ("REAL_CONTINUOUS_AT_ID", [REAL_CONTINUOUS_AT_ID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]));
   ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma taylor_const *)
let taylor_const = Sections.section_proof ["c";"x";"y";"z";"w"]
`cell_domain x y z w ==>
	taylor_interval (\x. c) x y z w (c, c) (&0, &0) (&0, &0)`
[
   ((((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineqs"]));
   ((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx_const", [lin_approx_const]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))));
   (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["_"])) THEN ((fun arg_tac -> arg_tac (Arg_term (`(:real)`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_UNIV", [REAL_OPEN_UNIV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_UNIV", [IN_UNIV]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["q"]) THEN (simp_tac)));
   (((((use_arg_then2 ("REAL_CONTINUOUS_CONST", [REAL_CONTINUOUS_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]));
   ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i < 2 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("TWO", [TWO]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("nth_derivative2", [nth_derivative2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("y", (`:real`))); Sections.add_section_var (mk_var ("z", (`:real`))); Sections.add_section_var (mk_var ("w", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("dd_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("f_lo", (`:real`))); Sections.add_section_var (mk_var ("f_hi", (`:real`))); Sections.add_section_var (mk_var ("df_lo", (`:real`))); Sections.add_section_var (mk_var ("df_hi", (`:real`))));;

(* Lemma taylor_f_bounds *)
let taylor_f_bounds = Sections.section_proof ["df";"dd";"lo";"hi";"t"]
`taylor_interval f x y z w (f_lo, f_hi) df_bounds dd_bounds ==>
	iabs df_bounds = df ==>
	iabs dd_bounds = dd ==>
	w * (df + w * dd * inv(&2)) <= t ==>
	f_hi + t <= hi ==> lo <= f_lo - t ==>
	bounded_on_int f (x, z) (lo, hi)`
[
   (BETA_TAC THEN (move ["taylor_f"]) THEN (move ["iabs_df"]) THEN (move ["iabs_dd"]) THEN (move ["t_ineq"]) THEN (move ["hi_ineq"]) THEN (move ["lo_ineq"]));
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (move ["ineq"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_upper_bound", [taylor_upper_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_lower_bound", [taylor_lower_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iabs_df", []))(thm_tac (new_rewrite [] []))))) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN (move ["ineq1"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN (move ["ineq2"]));
   ((((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN ((use_arg_then2 ("hi_ineq", [])) (disch_tac [])) THEN (clear_assumption "hi_ineq") THEN ((use_arg_then2 ("lo_ineq", [])) (disch_tac [])) THEN (clear_assumption "lo_ineq") THEN ((use_arg_then2 ("ineq2", [])) (disch_tac [])) THEN (clear_assumption "ineq2") THEN ((use_arg_then2 ("ineq1", [])) (disch_tac [])) THEN (clear_assumption "ineq1") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_df_bounds *)
let taylor_df_bounds = Sections.section_proof ["dd";"lo";"hi"]
`taylor_interval f x y z w f_bounds (df_lo, df_hi) dd_bounds ==>
	iabs dd_bounds = dd ==>
	df_hi + w * dd <= hi ==>
	lo <= df_lo - w * dd ==>
	bounded_on_int (derivative f) (x, z) (lo, hi)`
[
   (BETA_TAC THEN (move ["taylor_f"]) THEN (move ["iabs_dd"]) THEN (move ["hi_ineq"]) THEN (move ["lo_ineq"]));
   (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (move ["ineq"]));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_derivative_lower_bound", [taylor_derivative_lower_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("taylor_derivative_upper_bound", [taylor_derivative_upper_bound])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("EQ_SYM", [EQ_SYM])) (fun fst_arg -> (use_arg_then2 ("iabs_dd", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("taylor_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("hi_ineq", [])) (disch_tac [])) THEN (clear_assumption "hi_ineq") THEN ((use_arg_then2 ("lo_ineq", [])) (disch_tac [])) THEN (clear_assumption "lo_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma bounded_on_int_compose *)
let bounded_on_int_compose = Sections.section_proof ["g";"int";"g_bounds"]
`bounded_on_int g int g_bounds ==>
	bounded_on_int f g_bounds f_bounds ==>
	bounded_on_int (\x. f (g x)) int f_bounds`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] []))))) THEN (move ["g_bounded"]) THEN (move ["f_bounded"]) THEN (move ["x"]) THEN (move ["ineq"]) THEN (simp_tac));
   (((((use_arg_then2 ("f_bounded", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("g_bounded", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma bounded_on_int_imp_interval_arith *)
let bounded_on_int_imp_interval_arith = Sections.section_proof ["int"]
`bounded_on_int f int f_bounds ==>
	interval_arith y int ==> interval_arith (f y) f_bounds`
[
   ((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (move ["bounded_f"]) THEN (move ["int_y"]));
   ((((use_arg_then2 ("bounded_f", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma taylor_interval_narrow *)
let taylor_interval_narrow = Sections.section_proof ["x0";"z0";"w0"]
`taylor_interval f x y z w f_bounds df_bounds dd_bounds ==>
	cell_domain x0 y z0 w0 ==>
	x <= x0 ==> z0 <= z ==>
	taylor_interval f x0 y z0 w0 f_bounds df_bounds dd_bounds`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("cell_domain", [cell_domain]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ((case THEN ((move ["ineq"]) THEN (move ["lin"]))) THEN (move ["dd"]))) THEN (move ["c"]) THEN (move ["i1"]) THEN (move ["i2"]));
   ((THENL_FIRST) (((((use_arg_then2 ("lin", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (split_tac)) ((((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("c", [])) (disch_tac [])) THEN (clear_assumption "c") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("dd", [])) (disch_tac [])) THEN (clear_assumption "dd") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"])));
   ((split_tac) THEN (move ["p"]) THEN (move ["int_p"]));
   ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("int_p", [])) (disch_tac [])) THEN (clear_assumption "int_p") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL interval_arith)))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("i2", [])) (disch_tac [])) THEN (clear_assumption "i2") THEN ((use_arg_then2 ("i1", [])) (disch_tac [])) THEN (clear_assumption "i1") THEN ((use_arg_then2 ("int_p", [])) (disch_tac [])) THEN (clear_assumption "int_p") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL interval_arith)))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section TaylorArith *)
let taylor_x = Sections.finalize_theorem taylor_x;;
let taylor_const = Sections.finalize_theorem taylor_const;;
let taylor_f_bounds = Sections.finalize_theorem taylor_f_bounds;;
let taylor_df_bounds = Sections.finalize_theorem taylor_df_bounds;;
let bounded_on_int_compose = Sections.finalize_theorem bounded_on_int_compose;;
let bounded_on_int_imp_interval_arith = Sections.finalize_theorem bounded_on_int_imp_interval_arith;;
let taylor_interval_narrow = Sections.finalize_theorem taylor_interval_narrow;;
Sections.end_section "TaylorArith";;

(* Close the module *)
let _ = print_endline "taylor/theory/taylor_interval-compiled.hl loaded";;
