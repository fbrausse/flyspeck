open Hol_core
open Ssreflect
open Binomial
open Vectors
open Topology
open Derivatives
open Convex
open Dimension
open Realanalysis
open Ssrfun
open Ssrbool
open Ssrnat
open Taylor_interval
open Interval_arith

(* Module Multivariate_taylor*)

open Ssreflect;;
open Ssrfun;;
open Ssrbool;;
open Ssrnat;;
open Taylor_interval;;
open Interval_arith;;
prioritize_overload `:real^N`;;
prioritize_real();;
let partial = new_definition `partial i f x = derivative (f o (\t. (x:real^N) + t % basis i)) (&0)`;;
let all_n = define `(all_n n [] s <=> T) /\ (all_n n (CONS h t) s <=> s n h /\ all_n (SUC n) t s)`;;
let m_lin_approx = new_definition `m_lin_approx (f:real^N->real) x f_bounds df_bounds_list <=> 
	(lift o f) differentiable at x /\
	interval_arith (f x) f_bounds /\
	all_n 1 df_bounds_list (\i int. interval_arith (partial i f x) int)`;;

(* Section Misc *)
Sections.begin_section "Misc";;

(* Lemma f_lift_neg *)
let f_lift_neg = Sections.section_proof ["f"]
`lift o (\x. --f x) = (\x. --(lift o f) x)`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_NEG", [LIFT_NEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma f_lift_scale *)
let f_lift_scale = Sections.section_proof ["f";"c"]
`lift o (\x. c * f x) = (\x. c % (lift o f) x)`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_CMUL", [LIFT_CMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma f_lift_add *)
let f_lift_add = Sections.section_proof ["f";"g"]
`lift o (\x. f x + g x) = (\x. (lift o f) x + (lift o g) x)`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_ADD", [LIFT_ADD]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma f_lift_sub *)
let f_lift_sub = Sections.section_proof ["f";"g"]
`lift o (\x. f x - g x) = (\x. (lift o f) x - (lift o g) x)`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_SUB", [LIFT_SUB]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma f_binary_drop *)
let f_binary_drop = Sections.section_proof ["op";"f";"g"]
`(\t. op (f t) (g t)) o drop = (\x. op (f (drop x)) (g (drop x)))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma f_unary_drop *)
let f_unary_drop = Sections.section_proof ["op";"f"]
`(\t. op (f t)) o drop = (\x. op (f (drop x)))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Section MoreFrechet *)
Sections.begin_section "MoreFrechet";;
(Sections.add_section_var (mk_var ("f", (`:real^N -> real^M`))); Sections.add_section_var (mk_var ("g", (`:real^N -> real^M`))));;
(Sections.add_section_var (mk_var ("x", (`:real^N`))); Sections.add_section_var (mk_var ("y", (`:real^N`))));;

(* Lemma frechet_compose *)
let frechet_compose = Sections.section_proof ["f";"g";"x"]
`f differentiable at (g x) ==>
	g differentiable at x ==>
	frechet_derivative (f o g) (at x) = frechet_derivative f (at (g x)) o frechet_derivative g (at x)`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["dg"])) THEN (((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)));
   (((use_arg_then2 ("DIFF_CHAIN_AT", [DIFF_CHAIN_AT])) (thm_tac apply_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma frechet_const *)
let frechet_const = Sections.section_proof ["z"]
`frechet_derivative (\x. y) (at z) = (\x. vec 0)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN (((use_arg_then2 ("HAS_DERIVATIVE_CONST", [HAS_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma frechet_id *)
let frechet_id = Sections.section_proof []
`frechet_derivative (\x. x) (at y) = (\x. x)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN (((use_arg_then2 ("HAS_DERIVATIVE_ID", [HAS_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma frechet_vmul *)
let frechet_vmul = Sections.section_proof ["z"]
`frechet_derivative (\x. drop x % y) (at z) = (\x. drop x % y)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_VMUL_DROP", [HAS_DERIVATIVE_VMUL_DROP])) (thm_tac apply_tac)));
   (((use_arg_then2 ("HAS_DERIVATIVE_ID", [HAS_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))));
];;
(Sections.add_section_hyp "df" (`f differentiable at x`));;

(* Lemma frechet_neg *)
let frechet_neg = Sections.section_proof []
`frechet_derivative (\x. --f x) (at x) = (\y. --frechet_derivative f (at x) y)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_NEG", [HAS_DERIVATIVE_NEG])) (thm_tac apply_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma frechet_scale *)
let frechet_scale = Sections.section_proof ["c"]
`frechet_derivative (\x. c % f x) (at x) = (\y. c % frechet_derivative f (at x) y)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_CMUL", [HAS_DERIVATIVE_CMUL])) (thm_tac apply_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`g differentiable at x`));;

(* Lemma frechet_add *)
let frechet_add = Sections.section_proof []
`frechet_derivative (\x. f x + g x) (at x) = 
	(\y. frechet_derivative f (at x) y + frechet_derivative g (at x) y)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_ADD", [HAS_DERIVATIVE_ADD])) (thm_tac apply_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma frechet_sub *)
let frechet_sub = Sections.section_proof []
`frechet_derivative (\x. f x - g x) (at x) = 
	(\y. frechet_derivative f (at x) y - frechet_derivative g (at x) y)`
[
   ((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_SUB", [HAS_DERIVATIVE_SUB])) (thm_tac apply_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Finalization of the section MoreFrechet *)
let frechet_compose = Sections.finalize_theorem frechet_compose;;
let frechet_const = Sections.finalize_theorem frechet_const;;
let frechet_id = Sections.finalize_theorem frechet_id;;
let frechet_vmul = Sections.finalize_theorem frechet_vmul;;
let frechet_neg = Sections.finalize_theorem frechet_neg;;
let frechet_scale = Sections.finalize_theorem frechet_scale;;
let frechet_add = Sections.finalize_theorem frechet_add;;
let frechet_sub = Sections.finalize_theorem frechet_sub;;
Sections.end_section "MoreFrechet";;

(* Lemma differentiable_compose_at *)
let differentiable_compose_at = Sections.section_proof ["f";"g";"x"]
`f differentiable at (g x) ==>
	g differentiable at x ==>
	(f o g) differentiable at x`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["dg"])) THEN (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("frechet_compose", [frechet_compose]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((use_arg_then2 ("DIFF_CHAIN_AT", [DIFF_CHAIN_AT])) (thm_tac apply_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma jacobian_compose *)
let jacobian_compose = Sections.section_proof ["f";"g";"x"]
`f differentiable at (g x) ==>
	g differentiable at x ==>
	jacobian (f o g) (at x) = jacobian f (at (g x)) ** jacobian g (at x)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]));
   (((repeat_tactic 1 9 (((use_arg_then2 ("jacobian", [jacobian]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("frechet_compose", [frechet_compose]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("MATRIX_COMPOSE", [MATRIX_COMPOSE]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LINEAR_FRECHET_DERIVATIVE", [LINEAR_FRECHET_DERIVATIVE]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma frechet_eq_jacobian *)
let frechet_eq_jacobian = Sections.section_proof ["f";"x"]
`f differentiable at x ==>
	frechet_derivative f (at x) = (\h. jacobian f (at x) ** h)`
[
   (BETA_TAC THEN (move ["df"]));
   (((((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("JACOBIAN_WORKS", [JACOBIAN_WORKS]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Section Product *)
Sections.begin_section "Product";;

(* Lemma REAL_LET_MUL2 *)
let REAL_LET_MUL2 = Sections.section_proof ["w";"x";"y";"z"]
`&0 < w /\ w <= x /\ &0 <= y /\ y < z ==> w * y < x * z`
[
   (BETA_TAC THEN (move ["ineq"]));
   ((THENL) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`w = x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case) [(move ["w_eq_x"]); (move ["wnx"])]);
   (((((use_arg_then2 ("w_eq_x", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LT_LMUL", [REAL_LT_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_LT_MUL2", [REAL_LT_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("wnx", [])) (disch_tac [])) THEN (clear_assumption "wnx") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma has_derivative_x12 *)
let has_derivative_x12 = Sections.section_proof ["y"]
`(lift o (\x:real^2. x$1 * x$2) has_derivative lift o (\x. y$2 * x$1 + y$1 * x$2)) (at y)`
[
   ((((use_arg_then2 ("has_derivative_at", [has_derivative_at]))(thm_tac (new_rewrite [] [])))) THEN (split_tac));
   ((((use_arg_then2 ("linear", [linear]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_MUL_COMPONENT", [VECTOR_MUL_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_ADD", [LIFT_ADD]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_CMUL", [LIFT_CMUL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_ADD", [LIFT_ADD]))(thm_tac (new_rewrite [] []))))));
   ((VECTOR_ARITH_TAC) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_ADD", [LIFT_ADD]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_SUB", [LIFT_SUB]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_CMUL", [LIFT_CMUL]))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("LIM_AT", [LIM_AT]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("dist", [dist]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_SUB_RZERO)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NORM_LIFT", [NORM_LIFT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(thm_tac (new_rewrite [] [])))))) THEN (move ["e"]) THEN (move ["e0"]));
   (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `(x:real^2)$1 * x$2 - ((y:real^2)$1 * y$2 + y$2 * (x$1 - y$1) + y$1 * (x$2 - y$2)) =
		(x$2 - y$2) * (x$1 - y$1)`)))(thm_tac (new_rewrite [] []))));
   (((use_arg_then2 ("e", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("e0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (case THEN ((move ["norm0"]) THEN (move ["norm_e"])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_ABS_MUL", [REAL_ABS_MUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ABS_INV", [REAL_ABS_INV]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ABS_NORM", [REAL_ABS_NORM]))(thm_tac (new_rewrite [] [])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((fun arg_tac -> arg_tac (Arg_term (`x - y:real^2`))) (term_tac (set_tac "p"))));
   ((fun arg_tac -> (use_arg_then2 ("NORM_BOUND_COMPONENT_LT", [NORM_BOUND_COMPONENT_LT])) (fun fst_arg -> (use_arg_then2 ("norm_e", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["ineq"])));
   ((((use_arg_then2 ("REAL_LTE_TRANS", [REAL_LTE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LTE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`inv (infnorm p) * infnorm p * e`))) (term_tac exists_tac)));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 < infnorm p`))) (term_tac (have_gen_tac [](move ["infnorm_0"])))) (((((use_arg_then2 ("INFNORM_POS_LT", [INFNORM_POS_LT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NORM_POS_LT", [NORM_POS_LT]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac)));
   ((THENL_ROT (-1)) (split_tac));
   (((((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LINV", [REAL_MUL_LINV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("INFNORM_EQ_0", [INFNORM_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NORM_POS_LT", [NORM_POS_LT]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_LET_MUL2", [REAL_LET_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_INV", [REAL_LT_INV]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_LE_INV2", [REAL_LE_INV2]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("INFNORM_LE_NORM", [INFNORM_LE_NORM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_ABS_POS", [REAL_ABS_POS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`infnorm p = abs (p$1) \/ infnorm p = abs (p$2)`))) (term_tac (have_gen_tac []ALL_TAC)));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL INFNORM_2)))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac));
   (((THENL_FIRST) (case THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("REAL_LT_LMUL", [REAL_LT_LMUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("DIMINDEX_2", [DIMINDEX_2]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma lambda_eq_vsum *)
let lambda_eq_vsum = Sections.section_proof ["f"]
`(\x:A. lambda i. f i x) =  
	(\x. vsum (1..dimindex (:N)) (\i. f i x % (basis i:real^N)))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["x"]));
   (((((use_arg_then2 ("CART_EQ", [CART_EQ]))(thm_tac (new_rewrite [] [])))) THEN (move ["i"]) THEN (move ["ineq"])) THEN ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("VSUM_COMPONENT", [VSUM_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac))));
   (((fun arg_tac -> arg_tac (Arg_term (`1.. _`))) (term_tac (set_tac "A"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`A DIFF {i}`))) (term_tac (set_tac "B"))));
   ((fun arg_tac -> arg_tac (Arg_term (`DISJOINT B {i} /\ A = B UNION {i}`))) (term_tac (have_gen_tac [](move ["cond"]))));
   ((((use_arg_then2 ("DISJOINT", [DISJOINT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("EXTENSION", [EXTENSION]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("B_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("A_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_DIFF", [IN_DIFF]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_SING", [IN_SING]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NOT_IN_EMPTY", [NOT_IN_EMPTY]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((THENL_FIRST) ((split_tac) THEN (move ["x"])) (((repeat_tactic 1 9 (((use_arg_then2 ("negb_and", [negb_and]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("negbK", [negbK]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("orbA", [orbA]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("IN_UNION", [IN_UNION]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_DIFF", [IN_DIFF]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_SING", [IN_SING]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x = i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((simp_tac) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("cond", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_UNION", [SUM_UNION]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("cond", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("B_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_DIFF", [FINITE_DIFF]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("A_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_SING", [FINITE_SING]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("SUM_SING", [SUM_SING]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_MUL_COMPONENT", [VECTOR_MUL_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("BASIS_COMPONENT", [BASIS_COMPONENT])) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b. a = b + a * &1 <=> b = &0`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_EQ_0", [SUM_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (move ["j"]));
   ((((((use_arg_then2 ("IN_DIFF", [IN_DIFF]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_SING", [IN_SING]))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq_j"]) THEN (simp_tac)) THEN ((((use_arg_then2 ("BASIS_COMPONENT", [BASIS_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ])) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("ineq_j", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_MUL_RZERO", [REAL_MUL_RZERO]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_lambda *)
let has_derivative_lambda = Sections.section_proof ["f";"f'";"y"]
`(!i. i IN 1..dimindex (:M) ==> (lift o (f i) has_derivative lift o (f' i)) (at (y:real^N))) ==>
	(((\x. lambda i. f i x):real^N->real^M) has_derivative (\x. lambda i. f' i x) ) (at y)`
[
   ((BETA_TAC THEN (move ["df"])) THEN (repeat_tactic 1 9 (((use_arg_then2 ("lambda_eq_vsum", [lambda_eq_vsum]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("HAS_DERIVATIVE_VSUM", [HAS_DERIVATIVE_VSUM])) (thm_tac apply_tac)));
   (((((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["ineq"]) THEN (simp_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!f. (\x:real^N. f i x % (basis i:real^M)) = (\x. drop ((lift o f i) x) % basis i)`))) (term_tac (have_gen_tac [](move ["eq"]))));
   ((BETA_TAC THEN (move ["g"])) THEN ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((fun arg_tac -> (use_arg_then2 ("eq", [])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("eq", [])) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL HAS_DERIVATIVE_VMUL_DROP)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma vector2_eq_lambda *)
let vector2_eq_lambda = Sections.section_proof ["x";"y"]
`(vector [x; y]:real^2) = (lambda i. if i = 1 then x else y)`
[
   ((((((use_arg_then2 ("CART_EQ", [CART_EQ]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIMINDEX_2", [DIMINDEX_2]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"])) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `1 <= i /\ i <= 2 <=> i = 1 \/ i = 2`)))(thm_tac (new_rewrite [] [])))));
   ((case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [1; 3] []))))) THEN ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_2)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIMINDEX_2", [DIMINDEX_2]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma has_derivative_vector2 *)
let has_derivative_vector2 = Sections.section_proof ["f";"g";"f'";"g'";"y"]
`(lift o f has_derivative lift o f') (at y) ==>
	(lift o g has_derivative lift o g') (at y) ==>
	((\x. vector [f x; g x]:real^2) has_derivative (\x. vector [f' x; g' x]:real^2)) (at y)`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["dg"])) THEN (repeat_tactic 1 9 (((use_arg_then2 ("vector2_eq_lambda", [vector2_eq_lambda]))(thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("has_derivative_lambda", [has_derivative_lambda])) (thm_tac apply_tac)) THEN (((((use_arg_then2 ("DIMINDEX_2", [DIMINDEX_2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"])));
   ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `1 <= i /\ i <= 2 <=> i = 1 \/ i = 2`)))(thm_tac (new_rewrite [] [])))) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [2; 4] [])))) THEN (simp_tac)) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `~(2 = 1)`)))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;

(* Lemma has_derivative_mul *)
let has_derivative_mul = Sections.section_proof ["f";"g";"f'";"g'";"y"]
`(lift o f has_derivative lift o f') (at y) ==>
	(lift o g has_derivative lift o g') (at y) ==>
	(lift o (\x. f x * g x) has_derivative lift o (\x. f' x * g y + f y * g' x)) (at y)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]));
   ((fun arg_tac -> arg_tac (Arg_term (`lift o (\x. f x * g x) = (lift o (\p. p$1 * p$2)) o (\x. vector [f x; g x]:real^2)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (move ["x"])) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_2)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`vector [f y; g y]:real^2`))) (term_tac (set_tac "q")));
   ((fun arg_tac -> arg_tac (Arg_term (`lift o (\x. f' x * g y + f y * g' x) = 
	(lift o (\x:real^2. q$2 * x$1 + q$1 * x$2)) o (\x. vector [f' x; g' x])`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("q_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_2)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("DIFF_CHAIN_AT", [DIFF_CHAIN_AT])) (thm_tac apply_tac)) THEN (simp_tac)) THEN ((((use_arg_then2 ("q_def", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_x12", [has_derivative_x12]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_vector2", [has_derivative_vector2]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma f_eq_lift_drop *)
let f_eq_lift_drop = Sections.section_proof ["f"]
`f = lift o (drop o f)`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma differentiable_mul *)
let differentiable_mul = Sections.section_proof ["f";"g";"y"]
`lift o f differentiable (at y) ==>
	lift o g differentiable (at y) ==>
	lift o (\x. f x * g x) differentiable (at y)`
[
   ((repeat_tactic 2 0 (((use_arg_then2 ("differentiable", [differentiable]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["f'"])) THEN (move ["df"]) THEN (case THEN (move ["g'"])) THEN (move ["dg"]));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((((fun arg_tac -> (use_arg_then2 ("f_eq_lift_drop", [f_eq_lift_drop])) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("f_eq_lift_drop", [f_eq_lift_drop])) (fun fst_arg -> (use_arg_then2 ("g'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (move ["df"]) THEN (move ["dg"])));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("has_derivative_mul", [has_derivative_mul])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (((use_arg_then2 ("HAS_DERIVATIVE_IMP_DIFFERENTIABLE", [HAS_DERIVATIVE_IMP_DIFFERENTIABLE])) (thm_tac apply_tac)) THEN (done_tac));
];;

(* Lemma frechet_mul *)
let frechet_mul = Sections.section_proof ["f";"g";"y"]
`lift o f differentiable at y ==>
	lift o g differentiable at y ==>
	frechet_derivative (lift o (\x. f x * g x)) (at y) =
		(\x. g y % frechet_derivative (lift o f) (at y) x + 
		     f y % frechet_derivative (lift o g) (at y) x)`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("f_eq_lift_drop", [f_eq_lift_drop]))(thm_tac (new_rewrite [] [(`frechet_derivative _1 _2`)]))))) THEN (move ["df"]));
   ((((use_arg_then2 ("f_eq_lift_drop", [f_eq_lift_drop]))(thm_tac (new_rewrite [] [(`frechet_derivative _1 _2`)])))) THEN (move ["dg"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("has_derivative_mul", [has_derivative_mul])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))))) THEN (move ["x"]));
   (((((use_arg_then2 ("LIFT_ADD", [LIFT_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_CMUL", [LIFT_CMUL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Finalization of the section Product *)
let REAL_LET_MUL2 = Sections.finalize_theorem REAL_LET_MUL2;;
let has_derivative_x12 = Sections.finalize_theorem has_derivative_x12;;
let lambda_eq_vsum = Sections.finalize_theorem lambda_eq_vsum;;
let has_derivative_lambda = Sections.finalize_theorem has_derivative_lambda;;
let vector2_eq_lambda = Sections.finalize_theorem vector2_eq_lambda;;
let has_derivative_vector2 = Sections.finalize_theorem has_derivative_vector2;;
let has_derivative_mul = Sections.finalize_theorem has_derivative_mul;;
let f_eq_lift_drop = Sections.finalize_theorem f_eq_lift_drop;;
let differentiable_mul = Sections.finalize_theorem differentiable_mul;;
let frechet_mul = Sections.finalize_theorem frechet_mul;;
Sections.end_section "Product";;

(* Finalization of the section Misc *)
let f_lift_neg = Sections.finalize_theorem f_lift_neg;;
let f_lift_scale = Sections.finalize_theorem f_lift_scale;;
let f_lift_add = Sections.finalize_theorem f_lift_add;;
let f_lift_sub = Sections.finalize_theorem f_lift_sub;;
let f_binary_drop = Sections.finalize_theorem f_binary_drop;;
let f_unary_drop = Sections.finalize_theorem f_unary_drop;;
let frechet_compose = Sections.finalize_theorem frechet_compose;;
let frechet_const = Sections.finalize_theorem frechet_const;;
let frechet_id = Sections.finalize_theorem frechet_id;;
let frechet_vmul = Sections.finalize_theorem frechet_vmul;;
let frechet_neg = Sections.finalize_theorem frechet_neg;;
let frechet_scale = Sections.finalize_theorem frechet_scale;;
let frechet_add = Sections.finalize_theorem frechet_add;;
let frechet_sub = Sections.finalize_theorem frechet_sub;;
let differentiable_compose_at = Sections.finalize_theorem differentiable_compose_at;;
let jacobian_compose = Sections.finalize_theorem jacobian_compose;;
let frechet_eq_jacobian = Sections.finalize_theorem frechet_eq_jacobian;;
let REAL_LET_MUL2 = Sections.finalize_theorem REAL_LET_MUL2;;
let has_derivative_x12 = Sections.finalize_theorem has_derivative_x12;;
let lambda_eq_vsum = Sections.finalize_theorem lambda_eq_vsum;;
let has_derivative_lambda = Sections.finalize_theorem has_derivative_lambda;;
let vector2_eq_lambda = Sections.finalize_theorem vector2_eq_lambda;;
let has_derivative_vector2 = Sections.finalize_theorem has_derivative_vector2;;
let has_derivative_mul = Sections.finalize_theorem has_derivative_mul;;
let f_eq_lift_drop = Sections.finalize_theorem f_eq_lift_drop;;
let differentiable_mul = Sections.finalize_theorem differentiable_mul;;
let frechet_mul = Sections.finalize_theorem frechet_mul;;
Sections.end_section "Misc";;

(* Section Partial *)
Sections.begin_section "Partial";;

(* Lemma real_derivative_compose_frechet *)
let real_derivative_compose_frechet = Sections.section_proof ["f";"h";"t"]
`(lift o f) differentiable at (h t) ==>
	(h o drop) differentiable at (lift t) ==>
	((f o h) has_real_derivative (drop o (frechet_derivative (lift o f) (at (h t)) o 
			frechet_derivative (h o drop) (at (lift t))) o lift) (&1)) (atreal t)`
[
   (BETA_TAC THEN (move ["diff_f"]) THEN (move ["diff_h"]));
   ((((use_arg_then2 ("diff_h", [])) (disch_tac [])) THEN ((use_arg_then2 ("diff_f", [])) (disch_tac [])) THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FRECHET_DERIVATIVE_WORKS", [FRECHET_DERIVATIVE_WORKS]))(thm_tac (new_rewrite [] []))))));
   ((fun arg_tac -> arg_tac (Arg_term (`frechet_derivative _1 _2`))) (term_tac (set_tac "f'")));
   ((fun arg_tac -> arg_tac (Arg_term (`frechet_derivative _1 _2`))) (term_tac (set_tac "h'")));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dh"]));
   (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL HAS_REAL_FRECHET_DERIVATIVE_AT)))(thm_tac (new_rewrite [] []))));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`lift o (f o h) o drop = (lift o f) o (h o drop)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((repeat_tactic 1 9 (((use_arg_then2 ("o_ASSOC", [o_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`(\x. (drop o (f' o h') o lift) (&1) % x) = f' o h'`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))));
   (((((use_arg_then2 ("DIFF_CHAIN_AT", [DIFF_CHAIN_AT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dh", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`linear f' /\ linear h'`))) (term_tac (have_gen_tac [](move ["lin"]))));
   (((((use_arg_then2 ("h'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("f'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("LINEAR_FRECHET_DERIVATIVE", [LINEAR_FRECHET_DERIVATIVE]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`x = drop x % lift (&1)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [2] [])))))));
   (((((use_arg_then2 ("DROP_EQ", [DROP_EQ]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("DROP_CMUL", [DROP_CMUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("LINEAR_CMUL", [LINEAR_CMUL]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("DROP_EQ", [DROP_EQ]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("DROP_CMUL", [DROP_CMUL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma real_derivative_compose_jacobian *)
let real_derivative_compose_jacobian = Sections.section_proof ["f";"h";"t"]
`(lift o f) differentiable at (h t) ==>
	(h o drop) differentiable at (lift t) ==>
	((f o h) has_real_derivative (jacobian (lift o f) (at (h t)) ** 
				jacobian (h o drop) (at (lift t)))$1$1) (atreal t)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["dh"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_derivative_compose_frechet", [real_derivative_compose_frechet])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dh", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("frechet_eq_jacobian", [frechet_eq_jacobian]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   ((((use_arg_then2 ("MATRIX_VECTOR_MUL_ASSOC", [MATRIX_VECTOR_MUL_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("matrix_vector_mul", [matrix_vector_mul]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_LAMBDA", [DROP_LAMBDA]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIMINDEX_1", [DIMINDEX_1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   (((((use_arg_then2 ("LIFT_COMPONENT", [LIFT_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma diff_imp_real_diff *)
let diff_imp_real_diff = Sections.section_proof ["f";"h";"t"]
`(lift o f) differentiable at (h t) ==> 
	(h o drop) differentiable at (lift t) ==>
	(f o h) real_differentiable atreal t`
[
   (BETA_TAC THEN (move ["diff_f"]) THEN (move ["diff_h"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_derivative_compose_frechet", [real_derivative_compose_frechet])) (fun fst_arg -> (use_arg_then2 ("diff_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("diff_h", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`(drop o _ o lift) (&1)`))) (term_tac (set_tac "fh'")));
   (((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN (move ["dfh"])) THEN ((use_arg_then2 ("fh'", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma diff_direction *)
let diff_direction = Sections.section_proof ["y";"e";"net"]
`((\t. y + t % e) o drop) differentiable net`
[
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`(\t. y + t % e) o drop = (\x. y + drop x % e)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("DIFFERENTIABLE_ADD", [DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))));
   ((use_arg_then2 ("HAS_DERIVATIVE_IMP_DIFFERENTIABLE", [HAS_DERIVATIVE_IMP_DIFFERENTIABLE])) (thm_tac apply_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. drop x % e`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_VMUL_DROP", [HAS_DERIVATIVE_VMUL_DROP])) (thm_tac apply_tac)) THEN (((use_arg_then2 ("HAS_DERIVATIVE_ID", [HAS_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma frechet_direction *)
let frechet_direction = Sections.section_proof ["y";"e";"t"]
`frechet_derivative ((\t. y + t % e) o drop) (at (lift t)) = (\x. drop x % e)`
[
   ((((use_arg_then2 ("f_unary_drop", [f_unary_drop]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("frechet_add", [frechet_add]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("HAS_DERIVATIVE_IMP_DIFFERENTIABLE", [HAS_DERIVATIVE_IMP_DIFFERENTIABLE])) (thm_tac apply_tac)));
   (((fun arg_tac -> arg_tac (Arg_term (`\x. drop x % e`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("HAS_DERIVATIVE_VMUL_DROP", [HAS_DERIVATIVE_VMUL_DROP])) (thm_tac apply_tac)) THEN (((use_arg_then2 ("HAS_DERIVATIVE_ID", [HAS_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("frechet_vmul", [frechet_vmul]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("frechet_const", [frechet_const]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_ADD_LID", [VECTOR_ADD_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma real_dir_derivative_frechet *)
let real_dir_derivative_frechet = Sections.section_proof ["f";"y";"e";"t"]
`(lift o f) differentiable at (y + t % e) ==>
	((f o (\t. y + t % e)) has_real_derivative 
		(drop (frechet_derivative (lift o f) (at (y + t % e)) e))) (atreal t)`
[
   (BETA_TAC THEN (move ["df"]));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_derivative_compose_frechet", [real_derivative_compose_frechet])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\t. y + t % e`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff_direction", [diff_direction]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("frechet_direction", [frechet_direction]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_MUL_LID", [VECTOR_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma real_dir_derivative_jacobian *)
let real_dir_derivative_jacobian = Sections.section_proof ["f";"y";"e";"t"]
`(lift o f) differentiable at (y + t % e) ==>
	((f o (\t. y + t % e)) has_real_derivative 
		drop (jacobian (lift o f) (at (y + t % e)) ** e)) (atreal t)`
[
   (BETA_TAC THEN (move ["df"]));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_dir_derivative_frechet", [real_dir_derivative_frechet])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("e", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("frechet_eq_jacobian", [frechet_eq_jacobian]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma partial_eq_frechet *)
let partial_eq_frechet = Sections.section_proof ["f";"y";"i"]
`(lift o f) differentiable at (y:real^N) ==>
	partial i f y = drop (frechet_derivative (lift o f) (at y) (basis i))`
[
   ((BETA_TAC THEN (move ["df"])) THEN (((use_arg_then2 ("partial", [partial]))(thm_tac (new_rewrite [] [])))));
   ((((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_dir_derivative_frechet", [real_dir_derivative_frechet])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`basis i:real^N`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`&0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma partial_eq_jacobian *)
let partial_eq_jacobian = Sections.section_proof ["f";"y";"i"]
`(lift o f) differentiable at y ==>
	partial i f y = drop (jacobian (lift o f) (at y) ** basis i)`
[
   (BETA_TAC THEN (move ["df"]));
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("JACOBIAN_WORKS", [JACOBIAN_WORKS]))(thm_tac (new_rewrite [] []))))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma partial_eq_jacobian_column *)
let partial_eq_jacobian_column = Sections.section_proof ["f";"y";"i"]
`(lift o (f:real^N->real)) differentiable at y ==>
	i IN 1..dimindex (:N) ==>
	partial i f y = drop (column i (jacobian (lift o f) (at y)))`
[
   ((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["df"]) THEN (move ["ineq"]));
   (((((use_arg_then2 ("partial_eq_jacobian", [partial_eq_jacobian]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("MATRIX_VECTOR_MUL_BASIS", [MATRIX_VECTOR_MUL_BASIS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma partial_eq_jacobian_entry *)
let partial_eq_jacobian_entry = Sections.section_proof ["f";"y";"i"]
`(lift o (f:real^N->real)) differentiable at y ==>
	i IN 1..dimindex (:N) ==>
	partial i f y = (jacobian (lift o f) (at y))$1$i`
[
   ((BETA_TAC THEN (move ["df"]) THEN (move ["ineq"])) THEN ((((use_arg_then2 ("partial_eq_jacobian_column", [partial_eq_jacobian_column]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("column", [column]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_LAMBDA", [DROP_LAMBDA]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("y", (`:real^N`))));;
(Sections.add_section_var (mk_var ("i", (`:num`))));;

(* Lemma partial_eq0 *)
let partial_eq0 = Sections.section_proof ["f"]
`~(i IN 1..dimindex (:N)) ==>
	partial i f y = &0`
[
   ((BETA_TAC THEN (move ["ineq"])) THEN (((use_arg_then2 ("partial", [partial]))(thm_tac (new_rewrite [] [])))));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`basis i = (vec 0):real^N`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((((use_arg_then2 ("BASIS_EQ_0", [BASIS_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then2 ("VECTOR_MUL_RZERO", [VECTOR_MUL_RZERO]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))));
   ((fun arg_tac -> arg_tac (Arg_term (`derivative (f o (\t. y)) = derivative (\t. f y)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((AP_TERM_TAC) THEN ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_compose *)
let derivative_compose = Sections.section_proof ["f";"g";"x"]
`f real_differentiable atreal (g x) ==>
	g real_differentiable atreal x ==>
	derivative (f o g) x = derivative f (g x) * derivative g x`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`f o g = \x. f (g x)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma projection_has_derivative *)
let projection_has_derivative = Sections.section_proof ["i";"net"]
`i IN 1..dimindex (:N) ==>
	(lift o (\x:real^N. x$i) has_derivative lift o (\x. x$i)) net`
[
   ((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineq"]));
   ((fun arg_tac -> arg_tac (Arg_term (`lift o (\x:real^N. x$i) = (\x. x$i % vec 1)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (move ["x"])) THEN ((((use_arg_then2 ("DROP_EQ", [DROP_EQ]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_CMUL", [DROP_CMUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_VEC", [DROP_VEC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL HAS_DERIVATIVE_VMUL_COMPONENT)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("HAS_DERIVATIVE_ID", [HAS_DERIVATIVE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma projection_diff *)
let projection_diff = Sections.section_proof ["i";"net"]
`i IN 1..dimindex (:N) ==>
	(lift o (\x:real^N. x$i)) differentiable net`
[
   ((((use_arg_then2 ("differentiable", [differentiable]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("projection_has_derivative", [projection_has_derivative])) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("net", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   (((fun arg_tac -> arg_tac (Arg_term (`lift o \x:real^N. x$i`))) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma frechet_projection *)
let frechet_projection = Sections.section_proof ["i";"x"]
`i IN 1..dimindex (:N) ==>
	frechet_derivative (lift o (\x:real^N. x$i)) (at x)  = lift o (\x:real^N. x$i)`
[
   ((BETA_TAC THEN (move ["ineq"])) THEN (((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("FRECHET_DERIVATIVE_AT", [FRECHET_DERIVATIVE_AT])) (thm_tac apply_tac)));
   ((((use_arg_then2 ("projection_has_derivative", [projection_has_derivative]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma has_derivative_vector_frechet *)
let has_derivative_vector_frechet = Sections.section_proof ["h";"t";"i"]
`i IN 1..dimindex (:N) ==>
	(h o drop) differentiable at (lift t) ==>
	((\s. (h:real->real^N) s$i) has_real_derivative
		(frechet_derivative (h o drop) (at (lift t)) (lift (&1)))$i) (atreal t)`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["dh"]));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`(\s. h s$i) = (\x. x$i) o h`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_derivative_compose_frechet", [real_derivative_compose_frechet])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\x:real^N. x$i`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("h", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("dh", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("projection_diff", [projection_diff]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`(drop o _ o lift) (&1)`))) (term_tac (set_tac "lhs")));
   ((fun arg_tac -> arg_tac (Arg_term (`(frechet_derivative _1 _2 _3)$i`))) (term_tac (set_tac "rhs")));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`lhs = rhs`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   (((((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("frechet_projection", [frechet_projection]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("rhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_vector_jacobian *)
let has_derivative_vector_jacobian = Sections.section_proof ["h";"t";"i"]
`i IN 1..dimindex (:N) ==>
	(h o drop) differentiable at (lift t) ==>
	((\s. (h:real->real^N) s$i) has_real_derivative (jacobian (h o drop) (at (lift t)))$i$1) (atreal t)`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["dh"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("has_derivative_vector_frechet", [has_derivative_vector_frechet])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dh", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((fun arg_tac -> arg_tac (Arg_term (`(frechet_derivative _1 _2 _3)$i`))) (term_tac (set_tac "lhs")));
   ((fun arg_tac -> arg_tac (Arg_term (`jacobian _1 _2$i$1`))) (term_tac (set_tac "rhs")));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`lhs = rhs`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   ((((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("frechet_eq_jacobian", [frechet_eq_jacobian]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`lift (&1) = basis 1`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("DROP_EQ", [DROP_EQ]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("LIFT_DROP", [LIFT_DROP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("basis", [basis]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_LAMBDA", [DROP_LAMBDA]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("MATRIX_VECTOR_MUL_BASIS", [MATRIX_VECTOR_MUL_BASIS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIMINDEX_GE_1", [DIMINDEX_GE_1]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("column", [column]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(gsym_then (thm_tac (new_rewrite [] []))))))) THEN (done_tac));
];;

(* Lemma derivative_vector_jacobian *)
let derivative_vector_jacobian = Sections.section_proof ["h";"t";"i"]
`i IN 1..dimindex (:N) ==>
	((h:real->real^N) o drop) differentiable at (lift t) ==>
	derivative (\s. h s$i) t = jacobian (h o drop) (at (lift t))$i$1`
[
   ((BETA_TAC THEN (move ["ineq"]) THEN (move ["dh"])) THEN ((use_arg_then2 ("derivative_unique", [derivative_unique])) (thm_tac apply_tac)) THEN (((use_arg_then2 ("has_derivative_vector_jacobian", [has_derivative_vector_jacobian]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma real_derivative_compose_partial *)
let real_derivative_compose_partial = Sections.section_proof ["f";"h";"t"]
`(lift o (f:real^N -> real)) differentiable at (h t) ==>
	(h o drop) differentiable at (lift t) ==>
	((f o h) has_real_derivative
		sum (1..dimindex (:N)) (\i. partial i f (h t) * derivative (\s. h s$i) t)) (atreal t)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["dh"]));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_derivative_compose_jacobian", [real_derivative_compose_jacobian])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dh", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   (((fun arg_tac -> arg_tac (Arg_term (`_$1$1`))) (term_tac (set_tac "lhs"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`sum _ _2`))) (term_tac (set_tac "rhs"))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`lhs = rhs`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   (((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("matrix_mul", [matrix_mul]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIMINDEX_GE_1", [DIMINDEX_GE_1]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((simp_tac THEN TRY done_tac)));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIMINDEX_GE_1", [DIMINDEX_GE_1]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("rhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["i"]) THEN (move ["ineq"]) THEN (simp_tac));
   (((((use_arg_then2 ("partial_eq_jacobian_entry", [partial_eq_jacobian_entry]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_EQ_MUL_LCANCEL", [REAL_EQ_MUL_LCANCEL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_vector_jacobian", [derivative_vector_jacobian]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma real_dir_derivative_partial *)
let real_dir_derivative_partial = Sections.section_proof ["f";"e";"t"]
`(lift o f) differentiable at (y + t % e) ==>
	((f o (\t. y + t % e)) has_real_derivative
		sum (1..dimindex (:N)) (\i. e$i * (partial i f o (\t. y + t % e)) t)) (atreal t)`
[
   (BETA_TAC THEN (move ["df"]));
   (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("real_dir_derivative_jacobian", [real_dir_derivative_jacobian])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("e", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC);
   ((((use_arg_then2 ("matrix_vector_mul", [matrix_vector_mul]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DROP_LAMBDA", [DROP_LAMBDA]))(thm_tac (new_rewrite [] [])))));
   (((fun arg_tac -> arg_tac (Arg_term (`sum _1 _2`))) (term_tac (set_tac "lhs"))) THEN ((fun arg_tac -> arg_tac (Arg_term (`sum _1 _2`))) (term_tac (set_tac "rhs"))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`lhs = rhs`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   (((((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("rhs_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["i"]) THEN (move ["ineq"]) THEN (simp_tac)));
   (((((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("partial_eq_jacobian_entry", [partial_eq_jacobian_entry]))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real^N -> real`))); Sections.add_section_var (mk_var ("g", (`:real^N -> real`))));;
(Sections.add_section_hyp "df" (`(lift o f) differentiable at y`));;

(* Lemma partial_uni_compose *)
let partial_uni_compose = Sections.section_proof ["u"]
`u real_differentiable atreal (f y) ==>
	partial i (u o f) y = derivative u (f y) * partial i f y`
[
   ((BETA_TAC THEN (move ["du"])) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("partial", [partial]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_ASSOC", [o_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_compose", [derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((((use_arg_then2 ("diff_imp_real_diff", [diff_imp_real_diff]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("diff_direction", [diff_direction]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma partial_neg *)
let partial_neg = Sections.section_proof []
`partial i (\x. --f x) y = --partial i f y`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_lift_neg", [f_lift_neg]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_NEG", [DIFFERENTIABLE_NEG]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 0 10 (((use_arg_then2 ("frechet_neg", [frechet_neg]))(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("DROP_NEG", [DROP_NEG]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
];;

(* Lemma partial_scale *)
let partial_scale = Sections.section_proof ["c"]
`partial i (\x. c * f x) y = c * partial i f y`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_lift_scale", [f_lift_scale]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CMUL", [DIFFERENTIABLE_CMUL]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 0 10 (((use_arg_then2 ("frechet_scale", [frechet_scale]))(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("DROP_CMUL", [DROP_CMUL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`(lift o g) differentiable at y`));;

(* Lemma partial_add *)
let partial_add = Sections.section_proof []
`partial i (\x. f x + g x) y = partial i f y + partial i g y`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_lift_add", [f_lift_add]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_ADD", [DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 0 10 (((use_arg_then2 ("frechet_add", [frechet_add]))(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("DROP_ADD", [DROP_ADD]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma partial_sub *)
let partial_sub = Sections.section_proof []
`partial i (\x. f x - g x) y = partial i f y - partial i g y`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("f_lift_sub", [f_lift_sub]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_SUB", [DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 0 10 (((use_arg_then2 ("frechet_sub", [frechet_sub]))(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("DROP_SUB", [DROP_SUB]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma partial_mul *)
let partial_mul = Sections.section_proof []
`partial i (\x. f x * g x) y = partial i f y * g y + f y * partial i g y`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("partial", [partial]))(thm_tac (new_rewrite [] []))))) THEN ((fun arg_tac -> arg_tac (Arg_term (`\t. y + t % basis i`))) (term_tac (set_tac "h"))));
   ((fun arg_tac -> arg_tac (Arg_term (`(\x. f x * g x) o h = (\t. (f o h) t * (g o h) t)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((THENL_ROT (-1)) (((use_arg_then2 ("derivative_mul", [derivative_mul]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("h_def", []))(gsym_then (thm_tac (new_rewrite [1; 4] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (use_arg_then2 ("g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`h (&0) = y`))) (term_tac (have_gen_tac [](move ["h0"])))) (((((use_arg_then2 ("h_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`(h o drop) differentiable at (lift (&0))`))) (term_tac (have_gen_tac [](move ["dh"])))) (((((use_arg_then2 ("h_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("diff_direction", [diff_direction]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("diff_imp_real_diff", [diff_imp_real_diff]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("h0", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Finalization of the section Partial *)
let real_derivative_compose_frechet = Sections.finalize_theorem real_derivative_compose_frechet;;
let real_derivative_compose_jacobian = Sections.finalize_theorem real_derivative_compose_jacobian;;
let diff_imp_real_diff = Sections.finalize_theorem diff_imp_real_diff;;
let diff_direction = Sections.finalize_theorem diff_direction;;
let frechet_direction = Sections.finalize_theorem frechet_direction;;
let real_dir_derivative_frechet = Sections.finalize_theorem real_dir_derivative_frechet;;
let real_dir_derivative_jacobian = Sections.finalize_theorem real_dir_derivative_jacobian;;
let partial_eq_frechet = Sections.finalize_theorem partial_eq_frechet;;
let partial_eq_jacobian = Sections.finalize_theorem partial_eq_jacobian;;
let partial_eq_jacobian_column = Sections.finalize_theorem partial_eq_jacobian_column;;
let partial_eq_jacobian_entry = Sections.finalize_theorem partial_eq_jacobian_entry;;
let partial_eq0 = Sections.finalize_theorem partial_eq0;;
let derivative_compose = Sections.finalize_theorem derivative_compose;;
let projection_has_derivative = Sections.finalize_theorem projection_has_derivative;;
let projection_diff = Sections.finalize_theorem projection_diff;;
let frechet_projection = Sections.finalize_theorem frechet_projection;;
let has_derivative_vector_frechet = Sections.finalize_theorem has_derivative_vector_frechet;;
let has_derivative_vector_jacobian = Sections.finalize_theorem has_derivative_vector_jacobian;;
let derivative_vector_jacobian = Sections.finalize_theorem derivative_vector_jacobian;;
let real_derivative_compose_partial = Sections.finalize_theorem real_derivative_compose_partial;;
let real_dir_derivative_partial = Sections.finalize_theorem real_dir_derivative_partial;;
let partial_uni_compose = Sections.finalize_theorem partial_uni_compose;;
let partial_neg = Sections.finalize_theorem partial_neg;;
let partial_scale = Sections.finalize_theorem partial_scale;;
let partial_add = Sections.finalize_theorem partial_add;;
let partial_sub = Sections.finalize_theorem partial_sub;;
let partial_mul = Sections.finalize_theorem partial_mul;;
Sections.end_section "Partial";;

(* Section PartialMonotone *)
Sections.begin_section "PartialMonotone";;

(* Lemma derivative_translation *)
let derivative_translation = Sections.section_proof ["f";"x"]
`f real_differentiable atreal x ==>
	derivative f x = derivative (f o (\t. x + t)) (&0)`
[
   (BETA_TAC THEN (move ["diff_f"]));
   ((((use_arg_then2 ("derivative_compose", [derivative_compose]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_ADD", [REAL_DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_add", [derivative_add]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (arith_tac) THEN (done_tac));
];;
(Sections.add_section_type (mk_var ("f", (`:real^N->real`))));;

(* Lemma partial_increasing_left *)
let partial_increasing_left = Sections.section_proof ["f";"j";"u";"x";"z";"lo"]
`(!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = z$i) ==>
	u$j = x$j ==>
	(!y. y IN interval [x,z] ==> (lift o f) differentiable at y) ==>
	(!y. y IN interval [x,z] ==> &0 <= partial j f y) ==>
	(!y. y IN interval [x,u] ==> lo <= f y) ==>
	(!y. y IN interval [x,z] ==> lo <= f y)`
[
   (((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(thm_tac (new_rewrite [] [])))))) THEN (move ["uz_eq"]) THEN (move ["ux_eq"]) THEN (move ["diff_f"]) THEN (move ["partial_pos"]) THEN (move ["f_bound"]) THEN (move ["y"]) THEN (move ["y_in"]));
   ((((use_arg_then2 ("partial_pos", [])) (disch_tac [])) THEN (clear_assumption "partial_pos") THEN ((use_arg_then2 ("diff_f", [])) (disch_tac [])) THEN (clear_assumption "diff_f") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["diff_f"]) THEN (move ["partial_pos"])));
   ((fun arg_tac -> arg_tac (Arg_term (`(lambda i. if i = j then x$j else y$i):real^N`))) (term_tac (set_tac "y'")));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`f y' <= f y`))) (term_tac (have_gen_tac []ALL_TAC))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (REWRITE_RULE[GSYM IMP_IMP] REAL_LE_TRANS))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("f_bound", [])) (disch_tac [])) THEN (clear_assumption "f_bound") THEN (DISCH_THEN apply_tac) THEN (move ["i"]) THEN (move ["i_in"])));
   ((((use_arg_then2 ("y'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((THENL_FIRST) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`i = j`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ij"])) (((((use_arg_then2 ("ux_eq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("uz_eq", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("y_in", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   (((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`j IN 1..dimindex (:N)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case)) THEN ((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["j_in"])));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`y' = y`))) (term_tac (have_gen_tac []ALL_TAC)))) ((BETA_TAC THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then2 ("CART_EQ", [CART_EQ]))(thm_tac (new_rewrite [] [])))) THEN (move ["i"]) THEN (move ["i_in"]));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`~(i = j)`))) (term_tac (have_gen_tac [](move ["inj"])))) ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN ((use_arg_then2 ("j_in", [])) (disch_tac [])) THEN (clear_assumption "j_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("y'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`f o (\t. y' + t % basis j)`))) (term_tac (set_tac "g")));
   ((fun arg_tac -> arg_tac (Arg_term (`f y' = g (&0)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_MUL_LZERO", [VECTOR_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_ADD_RID", [VECTOR_ADD_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`f y = g (y$j - x$j)`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (AP_TERM_TAC));
   ((((use_arg_then2 ("CART_EQ", [CART_EQ]))(thm_tac (new_rewrite [] [])))) THEN (move ["i"]) THEN (move ["i_in"]));
   ((((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_MUL_COMPONENT", [VECTOR_MUL_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BASIS_COMPONENT", [BASIS_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`i = j`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ij"])) THEN ((((use_arg_then2 ("y'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((arith_tac) THEN (done_tac));
   (((simp_tac) THEN (((use_arg_then2 ("ij", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`real_interval [&0, y$j - x$j]`))) (term_tac (set_tac "s")));
   ((fun arg_tac -> arg_tac (Arg_term (`!t. t IN s ==> y' + t % basis j IN interval [x,z]`))) (term_tac (have_gen_tac [](move ["in_s"]))));
   (((((use_arg_then2 ("s_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(thm_tac (new_rewrite [] []))))) THEN (move ["t"]) THEN (move ["t_ineq"]) THEN (move ["i"]) THEN (move ["i_ineq"]));
   ((repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("VECTOR_MUL_COMPONENT", [VECTOR_MUL_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("BASIS_COMPONENT", [BASIS_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("y'_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL LAMBDA_BETA)))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`i = j`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["ij"])));
   (((((use_arg_then2 ("REAL_MUL_RZERO", [REAL_MUL_RZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("y_in", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((((use_arg_then2 ("t_ineq", [])) (disch_tac [])) THEN (clear_assumption "t_ineq") THEN ((fun arg_tac -> (use_arg_then2 ("y_in", [])) (fun fst_arg -> (use_arg_then2 ("i_ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((use_arg_then2 ("ij", []))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!t. t IN s ==> (g has_real_derivative (partial j f (y' + t % basis j))) (atreal t within s)`))) (term_tac (have_gen_tac [](move ["ds"]))));
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("in_s", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["p_in"])) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATREAL_WITHIN", [HAS_REAL_DERIVATIVE_ATREAL_WITHIN])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_ATREAL_WITHIN") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("partial", [partial]))(thm_tac (new_rewrite [] [])))));
   ((fun arg_tac -> arg_tac (Arg_term (`f o _`))) (term_tac (set_tac "h")));
   ((fun arg_tac -> arg_tac (Arg_term (`h = g o (\t'. t + t')`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("h_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["r"])) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_ADD_RDISTRIB)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_ADD_ASSOC)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("derivative_translation", [derivative_translation]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("diff_imp_real_diff", [diff_imp_real_diff]))(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("diff_direction", [diff_direction]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 <= y$j - x$j`))) (term_tac (have_gen_tac [](move ["pos"])))) ((((fun arg_tac -> (use_arg_then2 ("y_in", [])) (fun fst_arg -> (use_arg_then2 ("j_in", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("HAS_REAL_DERIVATIVE_INCREASING_IMP", [HAS_REAL_DERIVATIVE_INCREASING_IMP])) (fun fst_arg -> (use_arg_then2 ("g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\t. partial j f (y' + t % basis j)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("s", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`&0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`y$j - x$j`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (((((use_arg_then2 ("s_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("IS_REALINTERVAL_INTERVAL", [IS_REALINTERVAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((((use_arg_then2 ("ds", []))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (simp_tac)) THEN (DISCH_THEN apply_tac));
   ((((use_arg_then2 ("s_def", []))(gsym_then (thm_tac (new_rewrite [2; 3] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("pos", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("in_s", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("partial_pos", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma partial_decreasing_left *)
let partial_decreasing_left = Sections.section_proof ["f";"j";"u";"x";"z";"hi"]
`(!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = z$i) ==>
	u$j = x$j ==>
	(!y. y IN interval [x,z] ==> (lift o f) differentiable at y) ==>
	(!y. y IN interval [x,z] ==> partial j f y <= &0) ==>
	(!y. y IN interval [x,u] ==> f y <= hi) ==>
	(!y. y IN interval [x,z] ==> f y <= hi)`
[
   (BETA_TAC THEN (move ["u_eq_i"]) THEN (move ["u_eq_j"]) THEN (move ["diff_f"]) THEN (move ["partial_f"]) THEN (move ["f_bound"]) THEN (move ["y"]) THEN (move ["y_in"]));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("partial_increasing_left", [partial_increasing_left])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(\p. -- f p)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("j", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("u", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("z", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`--hi`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("u_eq_i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("u_eq_j", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   ((THENL_FIRST) (ANTS_TAC) ((BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("diff_f", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("DIFFERENTIABLE_NEG", [DIFFERENTIABLE_NEG])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (((use_arg_then2 ("f_lift_neg", [f_lift_neg]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (ANTS_TAC);
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("partial_neg", [partial_neg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_NEG_GE0", [REAL_NEG_GE0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("partial_f", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_FIRST) (ANTS_TAC) ((BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("f_bound", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (arith_tac) THEN (done_tac)));
   ((((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("y_in", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma partial_translation *)
let partial_translation = Sections.section_proof ["f";"i";"p";"y"]
`lift o f differentiable at (p + y) ==>
	partial i (f o (\x. p + x)) y = partial i f (p + y)`
[
   (BETA_TAC THEN (move ["diff"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!net. (\x. p + x) differentiable net`))) (term_tac (have_gen_tac [](move ["diff_p"]))));
   ((BETA_TAC THEN (move ["net"])) THEN ((((use_arg_then2 ("DIFFERENTIABLE_ADD", [DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_ID", [DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 1 (((use_arg_then2 ("o_ASSOC", [o_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CHAIN_AT", [DIFFERENTIABLE_CHAIN_AT]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("frechet_compose", [frechet_compose]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("frechet_add", [frechet_add]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_ID", [DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("frechet_const", [frechet_const]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("frechet_id", [frechet_id]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("VECTOR_ADD_LID", [VECTOR_ADD_LID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("I_DEF", [I_DEF]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("I_O_ID", [I_O_ID]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma partial_rev_translation *)
let partial_rev_translation = Sections.section_proof ["f";"i";"p";"y"]
`lift o f differentiable at (p - y) ==>
	partial i (f o (\x. p - x)) y = --partial i f (p - y)`
[
   (BETA_TAC THEN (move ["diff"]));
   ((fun arg_tac -> arg_tac (Arg_term (`!net. (\x. p - x) differentiable net`))) (term_tac (have_gen_tac [](move ["diff_p"]))));
   ((BETA_TAC THEN (move ["net"])) THEN ((((use_arg_then2 ("DIFFERENTIABLE_SUB", [DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_ID", [DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 1 (((use_arg_then2 ("o_ASSOC", [o_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CHAIN_AT", [DIFFERENTIABLE_CHAIN_AT]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("frechet_compose", [frechet_compose]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("frechet_sub", [frechet_sub]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_ID", [DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((((use_arg_then2 ("frechet_const", [frechet_const]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("frechet_id", [frechet_id]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL VECTOR_SUB_LZERO)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("partial_eq_frechet", [partial_eq_frechet]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac));
   (((((use_arg_then2 ("LINEAR_NEG", [LINEAR_NEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("LINEAR_FRECHET_DERIVATIVE", [LINEAR_FRECHET_DERIVATIVE]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("DROP_NEG", [DROP_NEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma partial_increasing_right *)
let partial_increasing_right = Sections.section_proof ["f";"j";"u";"x";"z";"hi"]
`(!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = x$i) ==>
	u$j = z$j ==>
	(!y. y IN interval [x,z] ==> (lift o f) differentiable at y) ==>
	(!y. y IN interval [x,z] ==> &0 <= partial j f y) ==>
	(!y. y IN interval [u,z] ==> f y <= hi) ==>
	(!y. y IN interval [x,z] ==> f y <= hi)`
[
   (BETA_TAC THEN (move ["u_eq_i"]) THEN (move ["u_eq_j"]) THEN (move ["diff_f"]) THEN (move ["partial_f"]) THEN (move ["f_bound"]) THEN (move ["y"]) THEN (move ["y_in"]));
   (((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`j IN 1..dimindex (:N)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case)) THEN ((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["j_in"])));
   ((((use_arg_then2 ("f_bound", [])) (disch_tac [])) THEN (clear_assumption "f_bound") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(thm_tac (new_rewrite [] []))))) THEN (move ["y_ineq"]) THEN (move ["i"]) THEN (move ["i_in"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`~(i = j)`))) (term_tac (have_gen_tac [](move ["inj"])))) ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN ((use_arg_then2 ("j_in", [])) (disch_tac [])) THEN (clear_assumption "j_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("u_eq_i", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("y_ineq", []))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("partial_decreasing_left", [partial_decreasing_left])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f o (\p:real^N. x + (z - p))`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("j", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x + (z - u):real^N`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("z", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("hi", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (ANTS_TAC);
   ((BETA_TAC THEN (move ["i"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("u_eq_i", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["eq1"]) THEN (move ["inj"])) THEN ((((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("eq1", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) (ANTS_TAC) (((((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("u_eq_j", []))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`!p. p IN interval [x,z] ==> x + (z - p) IN interval [x,z]`))) (term_tac (have_gen_tac [](move ["Hp"]))));
   ((BETA_TAC THEN (move ["p"])) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(thm_tac (new_rewrite [] []))))) THEN (move ["p_in"]) THEN (move ["i"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("p_in", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!y. _ y`))) (term_tac (set_tac "dP")));
   ((fun arg_tac -> arg_tac (Arg_term (`dP`))) (term_tac (have_gen_tac [](move ["P"]))));
   ((((use_arg_then2 ("dP_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])));
   (((((use_arg_then2 ("o_ASSOC", [o_ASSOC]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_CHAIN_AT", [DIFFERENTIABLE_CHAIN_AT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("DIFFERENTIABLE_ADD", [DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_SUB", [DIFFERENTIABLE_SUB]))(thm_tac (new_rewrite [] [])))))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_ID", [DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("DIFFERENTIABLE_CONST", [DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] [])))) THEN ((simp_tac THEN TRY done_tac)) THEN (((use_arg_then2 ("Hp", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("P", [])) (disch_tac [])) THEN (clear_assumption "P") THEN BETA_TAC THEN (simp_tac)) THEN ((((use_arg_then2 ("dP_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["diff"])));
   (ANTS_TAC);
   (BETA_TAC THEN (move ["p"]) THEN (move ["p_in"]));
   ((fun arg_tac -> arg_tac (Arg_theorem (VECTOR_ARITH `!x z p. x + z - p = (x + z) - p:real^N`))) (fun arg -> thm_tac MP_TAC arg THEN (move ["assoc"])));
   ((((use_arg_then2 ("assoc", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("partial_rev_translation", [partial_rev_translation]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("assoc", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("Hp", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("REAL_NEG_LE0", [REAL_NEG_LE0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("partial_f", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("Hp", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (ANTS_TAC);
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("f_bound", []))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("p_in", [])) (disch_tac [])) THEN (clear_assumption "p_in") THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL IN_INTERVAL)))(thm_tac (new_rewrite [] []))))) THEN (move ["ineq"]) THEN (move ["i"]) THEN (move ["i_ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("i_ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_ADD_COMPONENT", [VECTOR_ADD_COMPONENT]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("VECTOR_SUB_COMPONENT", [VECTOR_SUB_COMPONENT]))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x + z - y:real^N`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC)) THEN BETA_TAC) THEN ((((use_arg_then2 ("o_THM", [o_THM]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)));
   ((((fun arg_tac -> arg_tac (Arg_theorem (VECTOR_ARITH `!x z y:real^N. x + z - (x + z - y) = y`)))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN apply_tac));
   ((((use_arg_then2 ("Hp", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Finalization of the section PartialMonotone *)
let derivative_translation = Sections.finalize_theorem derivative_translation;;
let partial_increasing_left = Sections.finalize_theorem partial_increasing_left;;
let partial_decreasing_left = Sections.finalize_theorem partial_decreasing_left;;
let partial_translation = Sections.finalize_theorem partial_translation;;
let partial_rev_translation = Sections.finalize_theorem partial_rev_translation;;
let partial_increasing_right = Sections.finalize_theorem partial_increasing_right;;
Sections.end_section "PartialMonotone";;

