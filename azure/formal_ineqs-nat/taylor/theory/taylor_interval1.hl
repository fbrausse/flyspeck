open Binomial
open Vectors
open Topology
open Realanalysis
open Ssreflect
open Ssrfun
open Ssrbool
open Ssrnat
open Interval_arith
open Matan
open Hol_core
open Hol_core

(* Module Taylor_interval*)

open Ssreflect;;
open Ssrfun;;
open Ssrbool;;
open Ssrnat;;
open Interval_arith;;
open Matan;;
prioritize_real();;
let derivative = new_definition `derivative f = \y. @d. (f has_real_derivative d) (atreal y)`;;
let nth_derivative = new_definition `nth_derivative n f = iter n derivative f`;;
let nth_differentiable = define `(nth_differentiable 0 f x <=> f real_continuous atreal x) /\
	(nth_differentiable (SUC n) f x <=> nth_differentiable n f x /\ 
			nth_derivative n f real_differentiable atreal x)`;;
let nth_differentiable_on = new_definition `nth_differentiable_on n s f <=>
	!x. x IN s ==> nth_differentiable n f x`;;
let nth_differentiable_on_int = new_definition `nth_differentiable_on_int n int f <=>
	!x. interval_arith x int ==> nth_differentiable n f x`;;
let nth_diff_weak = new_definition `nth_diff_weak n f x <=> f real_continuous atreal x /\ 
	?F. F 0 = f /\ !i. i < n ==> (F i has_real_derivative F (SUC i) x) (atreal x)`;;
let nth_diff_strong = new_definition `nth_diff_strong n f x <=> 
	?s. real_open s /\ x IN s /\ nth_differentiable_on n s f`;;
let nth_diff_strong_int = new_definition `nth_diff_strong_int n int f <=>
	!x. interval_arith x int ==> nth_diff_strong n f x`;;

(* Section NthDerivatives *)
Sections.begin_section "NthDerivatives";;

(* Lemma derivative_eq_real_derivative *)
let derivative_eq_real_derivative = Sections.section_proof []
`derivative = real_derivative`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative", [derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_derivative", [real_derivative]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_cond *)
let has_derivative_cond = Sections.section_proof ["f";"x"]
`(?d. (f has_real_derivative d) (atreal x)) ==>
	(f has_real_derivative (derivative f x)) (atreal x)`
[
   (BETA_TAC THEN (case THEN (move ["d"])) THEN (move ["df"]));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`derivative f x = d`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) (exact_tac));
   (((((use_arg_then2 ("derivative", [derivative]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (((use_arg_then2 ("SELECT_UNIQUE", [SELECT_UNIQUE])) (thm_tac apply_tac)) THEN (simp_tac) THEN (move ["y"])) THEN ((THENL) (split_tac) [(move ["df2"]); ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)))]));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma has_derivative_alt *)
let has_derivative_alt = Sections.section_proof ["f";"x"]
`f real_differentiable atreal x ==>
	(f has_real_derivative (derivative f x)) (atreal x)`
[
   (((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_cond", [has_derivative_cond])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma derivative_unique *)
let derivative_unique = Sections.section_proof ["f";"f'";"x"]
`(f has_real_derivative f') (atreal x) ==> derivative f x = f'`
[
   ((BETA_TAC THEN (move ["df"])) THEN (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_cond", [has_derivative_cond]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma derivative_unique_on *)
let derivative_unique_on = Sections.section_proof ["s";"f";"f'"]
`(!x. x IN s ==> (f has_real_derivative f' x) (atreal x)) ==>
	(!x. x IN s ==> f' x = derivative f x)`
[
   (BETA_TAC THEN (move ["df"]) THEN (move ["x"]) THEN (move ["xs"]));
   (((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`f' x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma has_derivative_lemma *)
let has_derivative_lemma = Sections.section_proof ["f";"f'";"x"]
`f real_differentiable atreal x /\
	derivative f x = f' ==>
	(f has_real_derivative f') (atreal x)`
[
   ((BETA_TAC THEN (case THEN ((move ["diff"]) THEN (((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] [])))))))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative0 *)
let nth_derivative0 = Sections.section_proof ["f"]
`nth_derivative 0 f = f`
[
   (((((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL iter)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivativeS *)
let nth_derivativeS = Sections.section_proof ["n";"f"]
`nth_derivative (SUC n) f = derivative (nth_derivative n f)`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iterS", [iterS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_Sderivative *)
let nth_Sderivative = Sections.section_proof ["n";"f"]
`nth_derivative (SUC n) f = nth_derivative n (derivative f)`
[
   (((((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iterSr", [iterSr]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative", [nth_derivative]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma nth_derivative1 *)
let nth_derivative1 = Sections.section_proof ["f"]
`nth_derivative 1 f = derivative f`
[
   (((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative2 *)
let nth_derivative2 = Sections.section_proof ["f"]
`nth_derivative 2 f = derivative (derivative f)`
[
   (((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 = SUC(SUC 0)`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("iterS", [iterS]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL iter)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative_add *)
let nth_derivative_add = Sections.section_proof ["n";"m";"f"]
`nth_derivative n (nth_derivative m f) = nth_derivative (n + m) f`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative", [nth_derivative]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iter_add", [iter_add]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_diff_continuous *)
let nth_diff_continuous = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x ==>
	f real_continuous atreal x`
[
   (((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN ((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((BETA_TAC THEN (case THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("IHn", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma nth_differentiable_cond *)
let nth_differentiable_cond = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x ==>
   !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) ((((use_arg_then2 ("ltn0", [ltn0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("IHn", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["df_n"]) THEN (move ["dfn"]))) THEN (move ["i"]));
   (((((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqSS", [leqSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leq_eqVlt", [leq_eqVlt]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) case [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df_n", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN ((TRY done_tac)))]));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_differentiable_on_cond *)
let nth_differentiable_on_cond = Sections.section_proof ["n";"s";"f"]
`nth_differentiable_on n s f ==>
 !x. x IN s ==> 
  !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (move ["cond"]) THEN (move ["x"]));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("cond", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (done_tac));
];;

(* Lemma nth_differentiable_eq *)
let nth_differentiable_eq = Sections.section_proof ["n";"f";"x"]
`nth_differentiable n f x <=>
  f real_continuous atreal x /\
  !i. i < n ==> (nth_derivative i f has_real_derivative (nth_derivative (SUC i) f x)) (atreal x)`
[
   ((THENL) (split_tac) [(move ["dn_f"]); (case THEN (move ["f_cont"]))]);
   (((((fun arg_tac -> (use_arg_then2 ("nth_diff_continuous", [nth_diff_continuous])) (fun fst_arg -> (use_arg_then2 ("dn_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (disch_tac [])) THEN (clear_assumption "nth_differentiable_cond") THEN (exact_tac)) THEN (done_tac));
   (((THENL) (((use_arg_then2 ("n", [])) (disch_tac [])) THEN (clear_assumption "n") THEN elim) [ALL_TAC; ((move ["n"]) THEN (move ["IHn"]))]) THEN (((((use_arg_then2 ("nth_differentiable", [nth_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqSS", [leqSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leq_eqVlt", [leq_eqVlt]))(thm_tac (new_rewrite [] []))))) THEN (move ["cond"])));
   ((THENL_FIRST) ((((use_arg_then2 ("IHn", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((BETA_TAC THEN (move ["i"]) THEN (move ["i_lt_n"])) THEN (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)) THEN (done_tac)));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC n) f x`))) (term_tac exists_tac)));
   (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (exact_tac));
];;

(* Lemma nth_differentiable_on_int2 *)
let nth_differentiable_on_int2 = Sections.section_proof ["f";"int"]
`nth_differentiable_on_int 2 int f ==>
	?f' f''. f' = derivative f /\ f'' = nth_derivative 2 f /\
		!x. interval_arith x int ==> (f has_real_derivative f' x) (atreal x) /\
					(f' has_real_derivative f'' x) (atreal x)`
[
   ((((use_arg_then2 ("nth_differentiable_on_int", [nth_differentiable_on_int]))(thm_tac (new_rewrite [] [])))) THEN (move ["h"]));
   ((((fun arg_tac -> arg_tac (Arg_term (`derivative f`))) (term_tac exists_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative 2 f`))) (term_tac exists_tac))) THEN (simp_tac) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((use_arg_then2 ("nth_derivative1", [nth_derivative1]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then2 ("nth_derivative0", [nth_derivative0])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `2 = SUC 1`)))(thm_tac (new_rewrite [] [])))));
   (((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then2 ("nth_differentiable_cond", [nth_differentiable_cond])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`2`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma nth_mth_diff *)
let nth_mth_diff = Sections.section_proof ["n";"m";"f";"x"]
`n <= m ==> nth_differentiable m f x ==> nth_differentiable n f x`
[
   ((BETA_TAC THEN (move ["n_le_m"])) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (move ["cond"])))) THEN ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (move ["i"]) THEN (move ["i_lt"])));
   ((((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("n_le_m", [])) (disch_tac [])) THEN (clear_assumption "n_le_m") THEN ((use_arg_then2 ("ltn_leq_trans", [ltn_leq_trans])) (disch_tac [])) THEN (clear_assumption "ltn_leq_trans") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
];;

(* Lemma nth_differentiable1 *)
let nth_differentiable1 = Sections.section_proof ["f";"x"]
`nth_differentiable 1 f x <=> f real_differentiable atreal x`
[
   (((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL nth_differentiable)))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); (move ["df"])]));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_diff_imp_diff *)
let nth_diff_imp_diff = Sections.section_proof ["n";"f";"x"]
`0 < n ==> nth_differentiable n f x ==>
	f real_differentiable atreal x`
[
   ((((((use_arg_then2 ("ltE", [ltE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["ineq"]) THEN (move ["df"])) THEN (((use_arg_then2 ("nth_differentiable1", [nth_differentiable1]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("nth_mth_diff", [nth_mth_diff])) (disch_tac [])) THEN (clear_assumption "nth_mth_diff") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("n", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma nth_derivative_continuous *)
let nth_derivative_continuous = Sections.section_proof ["n";"f";"x";"i"]
`nth_differentiable n f x ==> i < n ==>
	nth_derivative i f real_continuous atreal x`
[
   ((((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["df"]));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (move ["cond"])) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL", [REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_IMP_CONTINUOUS_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] [])))) THEN ((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC i) f x`))) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma ith_derivative_differentiable *)
let ith_derivative_differentiable = Sections.section_proof ["i";"n";"f";"x"]
`nth_differentiable n f x ==> i < n ==>
	nth_differentiable (n - i) (nth_derivative i f) x`
[
   (BETA_TAC THEN (move ["dnf"]));
   ((((use_arg_then2 ("dnf", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (move ["cond"]) THEN (move ["i_lt_n"])));
   (((((fun arg_tac -> (use_arg_then2 ("nth_derivative_continuous", [nth_derivative_continuous])) (fun fst_arg -> (use_arg_then2 ("dnf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["j"]) THEN (move ["j_lt_ni"]));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative_add", [nth_derivative_add]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("addSn", [addSn]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("cond", []))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("j_lt_ni", [])) (disch_tac [])) THEN (clear_assumption "j_lt_ni") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma nth_diff_strong_imp_diff *)
let nth_diff_strong_imp_diff = Sections.section_proof ["n";"f";"x"]
`nth_diff_strong n f x ==>	nth_differentiable n f x`
[
   (((((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"]))) THEN ((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (move ["h"])));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Section DerivativeArith *)
Sections.begin_section "DerivativeArith";;

(* Section ElementaryDerivatives *)
Sections.begin_section "ElementaryDerivatives";;

(* Lemma derivative_x *)
let derivative_x = Sections.section_proof []
`derivative (\x. x) = (\x. &1)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ID", [HAS_REAL_DERIVATIVE_ID]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_const *)
let derivative_const = Sections.section_proof ["c"]
`derivative (\x. c) = (\x. &0)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_CONST", [HAS_REAL_DERIVATIVE_CONST]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_inv *)
let derivative_inv = Sections.section_proof ["x"]
`~(x = &0) ==> derivative inv x = -- inv (x * x)`
[
   (BETA_TAC THEN (move ["xn0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_INV_BASIC", [HAS_REAL_DERIVATIVE_INV_BASIC]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_atn *)
let derivative_atn = Sections.section_proof []
`derivative atn = (\x. inv (&1 + x * x))`
[
   (((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATN", [HAS_REAL_DERIVATIVE_ATN]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_exp *)
let derivative_exp = Sections.section_proof []
`derivative exp = exp`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_EXP", [HAS_REAL_DERIVATIVE_EXP]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_log *)
let derivative_log = Sections.section_proof ["x"]
`&0 < x ==> derivative log x = inv x`
[
   ((BETA_TAC THEN (move ["x_ineq"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOG", [HAS_REAL_DERIVATIVE_LOG]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_sin *)
let derivative_sin = Sections.section_proof []
`derivative sin = cos`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SIN", [HAS_REAL_DERIVATIVE_SIN]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_cos *)
let derivative_cos = Sections.section_proof []
`derivative cos = (\x. --sin x)`
[
   ((((use_arg_then2 ("eq_ext", [eq_ext]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["x"]) THEN (simp_tac));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_COS", [HAS_REAL_DERIVATIVE_COS]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_asn *)
let derivative_asn = Sections.section_proof ["x"]
`abs x < &1 ==> derivative asn x = inv(sqrt(&1 - x * x))`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ASN", [HAS_REAL_DERIVATIVE_ASN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_acs *)
let derivative_acs = Sections.section_proof ["x"]
`abs x < &1 ==> derivative acs x = --inv(sqrt(&1 - x * x))`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ACS", [HAS_REAL_DERIVATIVE_ACS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_sqrt *)
let derivative_sqrt = Sections.section_proof ["x"]
`&0 < x ==> derivative sqrt x = inv (&2 * sqrt x)`
[
   (BETA_TAC THEN (move ["xg0"]));
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_SQRT", [HAS_REAL_DERIVATIVE_SQRT]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma derivative_matan *)
let derivative_matan = Sections.section_proof ["x"]
`derivative matan x = dmatan x`
[
   (((((use_arg_then2 ("derivative_eq_real_derivative", [derivative_eq_real_derivative]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dmatan", [dmatan]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma matan_differentiable *)
let matan_differentiable = Sections.section_proof ["x"]
`-- &1 < x ==> matan real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["x_ineq"]));
   (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`x < &1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (move ["x_ineq2"]));
   ((((use_arg_then2 ("matan_real_derivative_abs1", [matan_real_derivative_abs1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("x_ineq2", [])) (disch_tac [])) THEN (clear_assumption "x_ineq2") THEN ((use_arg_then2 ("x_ineq", [])) (disch_tac [])) THEN (clear_assumption "x_ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))));
   ((fun arg_tac -> (use_arg_then2 ("matan_has_derivative_gt0", [matan_has_derivative_gt0])) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   ((fun arg_tac -> arg_tac (Arg_term (`inv _1 - _2`))) (term_tac (set_tac "t")));
   ((BETA_TAC THEN (move ["h"])) THEN ((use_arg_then2 ("t", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("x_ineq2", [])) (disch_tac [])) THEN (clear_assumption "x_ineq2") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma derivative_composition *)
let derivative_composition = Sections.section_proof ["f";"g";"x"]
`f real_differentiable atreal x ==>
	g real_differentiable atreal (f x) ==>
	derivative (\x. g (f x)) x = derivative f x * derivative g (f x)`
[
   ((BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_alt", [has_derivative_alt])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["df"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_derivative_alt", [has_derivative_alt])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["dg"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)));
   ((THENL_FIRST) (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL HAS_REAL_DERIVATIVE_CHAIN))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`derivative g`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`\y. y = f x`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (ANTS_TAC)) ((BETA_TAC THEN (move ["y"]) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((BETA_TAC THEN (case THEN (move ["_"]))) THEN (DISCH_THEN apply_tac) THEN (done_tac));
];;

(* Section ElementaryCompose *)
Sections.begin_section "ElementaryCompose";;

(* Lemma REAL_DIFFERENTIABLE_AT_INV *)
let REAL_DIFFERENTIABLE_AT_INV = Sections.section_proof ["x"]
`~(x = &0) ==> inv real_differentiable atreal x`
[
   (BETA_TAC THEN (move ["xn0"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(\x. x:real)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (((simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xn0", []))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_hyp "df" (`f real_differentiable atreal x`));;

(* Lemma derivative_compose_atn *)
let derivative_compose_atn = Sections.section_proof []
`(\x. atn (f x)) real_differentiable atreal x /\
	derivative (\x. atn (f x)) x = derivative f x / (&1 + f x * f x)`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`atn`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ATN", [REAL_DIFFERENTIABLE_AT_ATN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ATN", [REAL_DIFFERENTIABLE_AT_ATN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_atn", [derivative_atn]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_exp *)
let derivative_compose_exp = Sections.section_proof []
`(\x. exp (f x)) real_differentiable atreal x /\
	derivative (\x. exp (f x)) x = exp (f x) * derivative f x`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`exp`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_EXP", [REAL_DIFFERENTIABLE_AT_EXP]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_EXP", [REAL_DIFFERENTIABLE_AT_EXP]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_exp", [derivative_exp]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_log *)
let derivative_compose_log = Sections.section_proof []
`&0 < f x ==> (\x. log (f x)) real_differentiable atreal x /\
	derivative (\x. log (f x)) x = derivative f x / f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`log`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_LOG", [REAL_DIFFERENTIABLE_AT_LOG]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_log", [derivative_log]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_cos *)
let derivative_compose_cos = Sections.section_proof []
`(\x. cos (f x)) real_differentiable atreal x /\
	derivative (\x. cos (f x)) x = --(sin (f x) * derivative f x)`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`cos`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_COS", [REAL_DIFFERENTIABLE_AT_COS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_COS", [REAL_DIFFERENTIABLE_AT_COS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_cos", [derivative_cos]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_LMUL", [REAL_NEG_LMUL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_sin *)
let derivative_compose_sin = Sections.section_proof []
`(\x. sin (f x)) real_differentiable atreal x /\
	derivative (\x. sin (f x)) x = cos (f x) * derivative f x`
[
   (split_tac);
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sin`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SIN", [REAL_DIFFERENTIABLE_AT_SIN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_sin", [derivative_sin]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_inv *)
let derivative_compose_inv = Sections.section_proof []
`~(f x = &0) ==>
	(\x. inv (f x)) real_differentiable atreal x /\
	derivative (\x. inv (f x)) x = -- inv (f x * f x) * derivative f x`
[
   ((THENL_FIRST) ((BETA_TAC THEN (move ["fn0"])) THEN (split_tac)) ((((use_arg_then2 ("REAL_DIFFERENTIABLE_INV_ATREAL", [REAL_DIFFERENTIABLE_INV_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_INV_ATREAL") THEN (DISCH_THEN apply_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("derivative_inv", [derivative_inv]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_INV", [REAL_DIFFERENTIABLE_AT_INV]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_sqrt *)
let derivative_compose_sqrt = Sections.section_proof []
`&0 < f x ==>
	(\x. sqrt (f x)) real_differentiable atreal x /\
	derivative (\x. sqrt (f x)) x = derivative f x / (&2 * sqrt (f x))`
[
   ((BETA_TAC THEN (move ["f_pos"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`sqrt`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_AT_SQRT") THEN (DISCH_THEN apply_tac)) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_SQRT", [REAL_DIFFERENTIABLE_AT_SQRT]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_sqrt", [derivative_sqrt]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_acs *)
let derivative_compose_acs = Sections.section_proof []
`abs (f x) < &1 ==>
	(\x. acs (f x)) real_differentiable atreal x /\
	derivative (\x. acs (f x)) x = -- (derivative f x / sqrt (&1 - f x * f x))`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`acs`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ACS", [REAL_DIFFERENTIABLE_AT_ACS]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_acs", [derivative_acs]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("REAL_MUL_RNEG", [REAL_MUL_RNEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_asn *)
let derivative_compose_asn = Sections.section_proof []
`abs (f x) < &1 ==>
	(\x. asn (f x)) real_differentiable atreal x /\
	derivative (\x. asn (f x)) x = derivative f x / sqrt (&1 - f x * f x)`
[
   ((BETA_TAC THEN (move ["f_abs"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`asn`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_AT_ASN", [REAL_DIFFERENTIABLE_AT_ASN]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_asn", [derivative_asn]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_compose_matan *)
let derivative_compose_matan = Sections.section_proof []
`-- &1 < f x ==>
	(\x. matan (f x)) real_differentiable atreal x /\
	derivative (\x. matan (f x)) x = dmatan (f x) * derivative f x`
[
   ((BETA_TAC THEN (move ["f_ineq"])) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("o_THM", [o_THM])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`matan`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_COMPOSE_ATREAL", [REAL_DIFFERENTIABLE_COMPOSE_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_COMPOSE_ATREAL") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("derivative_composition", [derivative_composition]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("matan_differentiable", [matan_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   (((((use_arg_then2 ("derivative_matan", [derivative_matan]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section ElementaryCompose *)
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
Sections.end_section "ElementaryCompose";;

(* Finalization of the section ElementaryDerivatives *)
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
Sections.end_section "ElementaryDerivatives";;
(Sections.add_section_var (mk_var ("f", (`:real -> real`))); Sections.add_section_var (mk_var ("g", (`:real -> real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("c", (`:real`))));;
(Sections.add_section_hyp "df" (`f real_differentiable atreal x`));;

(* Lemma derivative_scale *)
let derivative_scale = Sections.section_proof []
`derivative (\x. c * f x) x = c * derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_neg *)
let derivative_neg = Sections.section_proof []
`derivative (\x. -- f x) x = -- derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_NEG", [HAS_REAL_DERIVATIVE_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_pow *)
let derivative_pow = Sections.section_proof ["n"]
`derivative (\x. f x pow n) x = &n * f x pow (n - 1) * derivative f x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_POW_ATREAL", [HAS_REAL_DERIVATIVE_POW_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`g real_differentiable atreal x`));;

(* Lemma derivative_add *)
let derivative_add = Sections.section_proof []
`derivative (\x. f x + g x) x = derivative f x + derivative g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_mul *)
let derivative_mul = Sections.section_proof []
`derivative (\x. f x * g x) x = f x * derivative g x + derivative f x * g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_MUL_ATREAL", [HAS_REAL_DERIVATIVE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_sub *)
let derivative_sub = Sections.section_proof []
`derivative (\x. f x - g x) x = derivative f x - derivative g x`
[
   ((((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma derivative_div *)
let derivative_div = Sections.section_proof []
`~(g x = &0) ==> 
  derivative (\x. f x / g x) x = (derivative f x * g x - f x * derivative g x) / (g x * g x)`
[
   ((BETA_TAC THEN (move ["gn0"])) THEN (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_DIV_ATREAL", [HAS_REAL_DERIVATIVE_DIV_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section DerivativeArith *)
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
let derivative_scale = Sections.finalize_theorem derivative_scale;;
let derivative_neg = Sections.finalize_theorem derivative_neg;;
let derivative_pow = Sections.finalize_theorem derivative_pow;;
let derivative_add = Sections.finalize_theorem derivative_add;;
let derivative_mul = Sections.finalize_theorem derivative_mul;;
let derivative_sub = Sections.finalize_theorem derivative_sub;;
let derivative_div = Sections.finalize_theorem derivative_div;;
Sections.end_section "DerivativeArith";;

(* Section MoreDerivativeArith *)
Sections.begin_section "MoreDerivativeArith";;

(* Lemma differentiable_sum_numseg *)
let differentiable_sum_numseg = Sections.section_proof ["G";"n";"m";"x"]
`(!i. i IN n..m ==> G i real_differentiable atreal x) ==>
	(\x. sum (n..m) (\i. G i x)) real_differentiable atreal x`
[
   ((((THENL) (((use_arg_then2 ("m", [])) (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN (move ["dG"])) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n = 0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_eq_0"])) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("n_eq_0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n <= SUC m`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_le_Sm"])));
   ((((use_arg_then2 ("IHm", [])) (disch_tac [])) THEN (clear_assumption "IHm") THEN (DISCH_THEN apply_tac) THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((((use_arg_then2 ("REAL_DIFFERENTIABLE_ADD", [REAL_DIFFERENTIABLE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IHm", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("n_le_Sm", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["ineq"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma derivative_sum_numseg *)
let derivative_sum_numseg = Sections.section_proof ["G";"n";"m";"x"]
`(!i. i IN n..m ==> G i real_differentiable atreal x) ==>
	derivative (\x. sum (n..m) (\i. G i x)) x = sum (n..m) (\i. derivative (G i) x)`
[
   ((((THENL) (((use_arg_then2 ("m", [])) (disch_tac [])) THEN (clear_assumption "m") THEN elim) [ALL_TAC; ((move ["m"]) THEN (move ["IHm"]))]) THEN (move ["dG"])) THEN (repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_term (`n = 0`))) (disch_tac [])) THEN case THEN (simp_tac)) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg])))) THEN (done_tac));
   ((THENL_ROT (-1)) (((fun arg_tac -> (use_arg_then2 ("EXCLUDED_MIDDLE", [EXCLUDED_MIDDLE])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`n <= SUC m`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN case THEN (simp_tac) THEN (move ["n_le_Sm"])));
   ((((use_arg_then2 ("IHm", [])) (disch_tac [])) THEN (clear_assumption "IHm") THEN (DISCH_THEN apply_tac) THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((use_arg_then2 ("IHm", []))(gsym_then (thm_tac (new_rewrite [] [])))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_in"])) THEN (((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac));
   ((((use_arg_then2 ("derivative_add", [derivative_add]))(thm_tac (new_rewrite [] [])))) THEN ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("dG", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("leqnn", [leqnn]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_in"]));
   ((((use_arg_then2 ("dG", [])) (disch_tac [])) THEN (clear_assumption "dG") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("i_in", [])) (disch_tac [])) THEN (clear_assumption "i_in") THEN BETA_TAC) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section MoreDerivativeArith *)
let differentiable_sum_numseg = Sections.finalize_theorem differentiable_sum_numseg;;
let derivative_sum_numseg = Sections.finalize_theorem derivative_sum_numseg;;
Sections.end_section "MoreDerivativeArith";;

(* Lemma HAS_REAL_DERIVATIVE_LOCAL *)
let HAS_REAL_DERIVATIVE_LOCAL = Sections.section_proof ["f";"g";"x";"g'"]
`(g has_real_derivative g') (atreal x) /\
	(?s. real_open s /\ x IN s /\ (!y. y IN s ==> f y = g y))
	==> (f has_real_derivative g') (atreal x)`
[
   (BETA_TAC THEN (case THEN (move ["dg"])) THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["f_eq_g"]));
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((fun arg_tac -> (use_arg_then2 ("HAS_REAL_DERIVATIVE_WITHIN_REAL_OPEN", [HAS_REAL_DERIVATIVE_WITHIN_REAL_OPEN])) (fun fst_arg -> (use_arg_then2 ("open_s", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac))) THEN (move ["dg"])));
   (((fun arg_tac -> (use_arg_then2 ("HAS_REAL_DERIVATIVE_TRANSFORM_WITHIN", [HAS_REAL_DERIVATIVE_TRANSFORM_WITHIN])) (fun fst_arg -> (use_arg_then2 ("dg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`&1`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_LT_01", [REAL_LT_01]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ALL_TAC) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("f_eq_g", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma differentiable_local *)
let differentiable_local = Sections.section_proof ["f";"g";"x";"s"]
`g real_differentiable atreal x /\ real_open s /\ x IN s /\
	(!y. y IN s ==> f y = g y) ==> f real_differentiable atreal x`
[
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["f'"])) THEN (move ["dg"]) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["eq"]));
   (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac)));
   (((use_arg_then2 ("g", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("dg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Section NthDerivativeArith *)
Sections.begin_section "NthDerivativeArith";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))); Sections.add_section_var (mk_var ("g", (`:real->real`))));;
(Sections.add_section_var (mk_var ("int", (`:real#real`))));;
(Sections.add_section_var (mk_var ("n", (`:num`))));;
(Sections.add_section_hyp "df" (`nth_diff_strong_int n int f`));;

(* Lemma nth_derivative_scale_strong *)
let nth_derivative_scale_strong = Sections.section_proof ["c";"i";"x"]
`interval_arith x int ==> i <= n ==>
	?s. real_open s /\ x IN s /\ 
	!y. y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y`
[
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (move ["df"])));
   (((DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"]))) THEN (((((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))) THEN (move ["diff"])));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["yt"])))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\y. c * nth_derivative i f y`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((fun arg_tac -> (use_arg_then2 ("diff", [])) (fun fst_arg -> (use_arg_then2 ("ys", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)));
   ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_scale_strong_all *)
let nth_derivative_scale_strong_all = Sections.section_proof ["c";"x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong", [nth_derivative_scale_strong])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
	(!y. y IN s ==> nth_derivative i (\y. c * f y) y = c * nth_derivative i f y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_scale *)
let nth_derivative_scale = Sections.section_proof ["c";"i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. c * f x) x = c * nth_derivative i f x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong", [nth_derivative_scale_strong])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_scale *)
let nth_diff_scale = Sections.section_proof ["c"]
`nth_diff_strong_int n int (\x. c * f x)`
[
   ((((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_scale_strong_all", [nth_derivative_scale_strong_all])) (fun fst_arg -> (use_arg_then2 ("c", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["diff2"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER t`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (move ["yt"])))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_LMUL", [REAL_CONTINUOUS_LMUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff2", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. c * nth_derivative i f y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_LMUL_ATREAL", [HAS_REAL_DERIVATIVE_LMUL_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN (((fun arg_tac -> (use_arg_then2 ("diff2", [])) (fun fst_arg -> (use_arg_then2 ("yt", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;
(Sections.add_section_hyp "dg" (`nth_diff_strong_int n int g`));;

(* Lemma nth_derivative_add_strong *)
let nth_derivative_add_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y + nth_derivative i g y)`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_add_strong_all *)
let nth_derivative_add_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
		nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_add_strong", [nth_derivative_add_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y + g y) y = nth_derivative i f y + nth_derivative i g y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_add *)
let nth_derivative_add = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x + g x) x = nth_derivative i f x + nth_derivative i g x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_add_strong", [nth_derivative_add_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_add *)
let nth_diff_add = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x + g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_add_strong_all", [nth_derivative_add_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ADD", [REAL_CONTINUOUS_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y + nth_derivative i g y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_ADD", [HAS_REAL_DERIVATIVE_ADD]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_sub_strong *)
let nth_derivative_sub_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL_FIRST) ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]) ((repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y - nth_derivative i g y)`))) (term_tac exists_tac));
   ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_sub_strong_all *)
let nth_derivative_sub_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
		nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_sub_strong", [nth_derivative_sub_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y - g y) y = nth_derivative i f y - nth_derivative i g y)`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_sub *)
let nth_derivative_sub = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x - g x) x = nth_derivative i f x - nth_derivative i g x`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_sub_strong", [nth_derivative_sub_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_sub *)
let nth_diff_sub = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x - g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_sub_strong_all", [nth_derivative_sub_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_SUB", [REAL_CONTINUOUS_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN ((TRY done_tac)));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`(\y. nth_derivative i f y - nth_derivative i g y)`))) (term_tac exists_tac));
   ((THENL_FIRST) ((((use_arg_then2 ("HAS_REAL_DERIVATIVE_SUB", [HAS_REAL_DERIVATIVE_SUB]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) ((((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["z"]) THEN (move ["zs"]) THEN (simp_tac)));
   ((((use_arg_then2 ("diff", [])) (disch_tac [])) THEN (clear_assumption "diff") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma nth_derivative_mul_strong *)
let nth_derivative_mul_strong = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
   ?s. real_open s /\ x IN s /\ 
      !y. y IN s ==> nth_derivative i (\y. f y * g y) y = 
	sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`
[
   ((((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC) THEN (((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))))) THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["ineq"])));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sf"])) THEN (case THEN (move ["open_sf"])) THEN (case THEN (move ["xsf"]))) THEN (((use_arg_then2 ("df", [])) (disch_tac [])) THEN (clear_assumption "df") THEN BETA_TAC THEN (move ["_"])));
   ((((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["sg"])) THEN (case THEN (move ["open_sg"])) THEN (case THEN (move ["xsg"]))) THEN (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN (clear_assumption "dg") THEN BETA_TAC THEN (move ["_"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] [])))))) THEN (move ["diff_g"]) THEN (move ["diff_f"]));
   ((THENL) (((use_arg_then2 ("i", [])) (disch_tac [])) THEN (clear_assumption "i") THEN elim) [(move ["_"]); ((move ["i"]) THEN (move ["IHi"]))]);
   (((use_arg_then2 ("sf", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("open_sf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["_"]) THEN (simp_tac)));
   (((((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivative0", [nth_derivative0]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   (((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ltE", [ltE]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["i_lt_n"]));
   ((((fun arg_tac -> (use_arg_then2 ("IHi", [])) (fun fst_arg -> (fun arg_tac -> (use_arg_then2 ("ltnW", [ltnW])) (fun fst_arg -> (use_arg_then2 ("i_lt_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["t"])) THEN (case THEN (move ["open_t"])) THEN (case THEN (move ["xt"])) THEN (move ["eq"])) THEN (((use_arg_then2 ("IHi", [])) (disch_tac [])) THEN (clear_assumption "IHi") THEN BETA_TAC THEN (move ["_"])));
   ((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xt", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsf", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("xsg", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (move ["y"]) THEN (case THEN (move ["ysf"])) THEN (case THEN ((move ["ysg"]) THEN (move ["yt"]))));
   (((use_arg_then2 ("derivative_unique", [derivative_unique])) (disch_tac [])) THEN (clear_assumption "derivative_unique") THEN (DISCH_THEN apply_tac));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_LOCAL", [HAS_REAL_DERIVATIVE_LOCAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_LOCAL") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\y. sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`))) (term_tac exists_tac));
   ((THENL_ROT (-1)) (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`sf INTER sg INTER t`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("yt", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("ysg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   ((BETA_TAC THEN (move ["z"]) THEN (move ["z_in"]) THEN (simp_tac)) THEN (((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   (((use_arg_then2 ("has_derivative_lemma", [has_derivative_lemma])) (disch_tac [])) THEN (clear_assumption "has_derivative_lemma") THEN (DISCH_THEN apply_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!k. k IN 0..i ==>
	nth_derivative k f real_differentiable atreal y /\
	nth_derivative (i - k) g real_differentiable atreal y`))) (term_tac (have_gen_tac [](move ["diff_cond"]))));
   (((((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (move ["k"]) THEN (move ["ineq"]) THEN (simp_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC k) f y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ysf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC (i - k)) g y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ysg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!k. k IN 0..i ==> 
	(\y. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)
		real_differentiable atreal y`))) (term_tac (have_gen_tac [](move ["diff_cond2"]))));
   (BETA_TAC THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (done_tac));
   (((((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("derivative_sum_numseg", [derivative_sum_numseg]))(thm_tac (new_rewrite [] [])))))) THEN ((simp_tac) THEN (((use_arg_then2 ("diff_cond2", []))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((TRY done_tac))));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0..i) _`))) (term_tac (set_tac "lhs")));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0 + 1..i + 1) (\k. &(binom (i, k - 1)) * nth_derivative k f y * nth_derivative (SUC i - k) g y)`))) (term_tac (set_tac "sum1")));
   ((fun arg_tac -> arg_tac (Arg_term (`sum (0..i + 1) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (SUC i - k) g y)`))) (term_tac (set_tac "sum2")));
   ((fun arg_tac -> arg_tac (Arg_term (`lhs = sum1 + sum2`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))));
   ((((use_arg_then2 ("sum1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_OFFSET", [SUM_OFFSET]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("addn1", [addn1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("succnK", [succnK]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subSS", [subSS]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("sum2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("addn1", [addn1]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 <= SUC i`)))(thm_tac (new_rewrite [] [])))) THEN (simp_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`binom(i, SUC i) = 0`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))))) ((((use_arg_then2 ("BINOM_EQ_0", [BINOM_EQ_0]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("REAL_MUL_LZERO", [REAL_MUL_LZERO]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_ADD_NUMSEG", [SUM_ADD_NUMSEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("lhs_def", []))(gsym_then (thm_tac (new_rewrite [] []))))));
   (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((((use_arg_then2 ("derivative_scale", [derivative_scale]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] [])))))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   (((((use_arg_then2 ("REAL_ADD_LDISTRIB", [REAL_ADD_LDISTRIB]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_MUL_LCANCEL", [REAL_EQ_MUL_LCANCEL]))(thm_tac (new_rewrite [] []))))) THEN (DISJ2_TAC));
   ((((use_arg_then2 ("derivative_mul", [derivative_mul]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))) THEN ((repeat_tactic 0 10 (((use_arg_then2 ("diff_cond", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(gsym_then (thm_tac (new_rewrite [] [])))))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`SUC (i - k) = SUC i - k`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((done_tac) THEN (done_tac)));
   ((((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_CLAUSES_LEFT", [SUM_CLAUSES_LEFT]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("sum2_def", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (repeat_tactic 0 1 (((use_arg_then2 ("SUM_CLAUSES_LEFT", [SUM_CLAUSES_LEFT]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (TRY ((arith_tac))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_LID", [REAL_MUL_LID]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ADD_ASSOC", [REAL_ADD_ASSOC]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_ADD_LCANCEL", [REAL_EQ_ADD_LCANCEL]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("sum1_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("SUM_ADD_NUMSEG", [SUM_ADD_NUMSEG]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> (use_arg_then2 ("addn1", [addn1])) (fun fst_arg -> (use_arg_then2 ("i", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   (((use_arg_then2 ("SUM_EQ", [SUM_EQ])) (thm_tac apply_tac)) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((((use_arg_then2 ("REAL_ADD_RDISTRIB", [REAL_ADD_RDISTRIB]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_EQ_MUL_RCANCEL", [REAL_EQ_MUL_RCANCEL]))(thm_tac (new_rewrite [] []))))) THEN (DISJ1_TAC));
   ((THENL_FIRST) (((THENL) (((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN ((use_arg_then2 ("k", [])) (disch_tac [])) THEN (clear_assumption "k") THEN case) [ALL_TAC; (move ["k"])]) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) ((arith_tac) THEN (done_tac)));
   (((((use_arg_then2 ("binom", [binom]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subSS", [subSS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("subn0", [subn0]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_OF_NUM_ADD", [REAL_OF_NUM_ADD]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma nth_derivative_mul_strong_all *)
let nth_derivative_mul_strong_all = Sections.section_proof ["x"]
`interval_arith x int ==>
	?s. real_open s /\ x IN s /\ 
	!i y. i <= n /\ y IN s ==> 
	  nth_derivative i (\y. f y * g y) y = 
		sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`
[
   (BETA_TAC THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_derivative_mul_strong", [nth_derivative_mul_strong])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (move ["h"]));
   ((fun arg_tac -> arg_tac (Arg_term (`\i s. real_open s /\ x IN s /\ 
   (!y. y IN s ==> nth_derivative i (\y. f y * g y) y = 
	sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f y * nth_derivative (i - k) g y))`))) (term_tac (set_tac "P")));
   ((fun arg_tac -> arg_tac (Arg_term (`!i. i <= n:num ==> P i ((@) (P i))`))) (term_tac (have_gen_tac [](move ["sel_P"]))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["i_le_n"])) THEN ((use_arg_then2 ("SELECT_AX", [SELECT_AX])) (thm_tac apply_tac)));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (move ["cond"]));
   (((use_arg_then2 ("s", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`INTERS (IMAGE (\i. (@) (P i)) (0..n))`))) (term_tac (set_tac "S")));
   ((use_arg_then2 ("S", [])) (term_tac exists_tac));
   ((((use_arg_then2 ("S_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_OPEN_INTERS", [REAL_OPEN_INTERS]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_IMAGE", [FINITE_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("FINITE_NUMSEG", [FINITE_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("IN_INTERS", [IN_INTERS]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_IMAGE", [IN_IMAGE]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["t"]) THEN (case THEN (move ["i"])) THEN (case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))) THEN ((((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("sel_P", [])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN (done_tac));
   (BETA_TAC THEN (move ["i"]) THEN (move ["y"]) THEN (case THEN (move ["i_le_n"])));
   ((((fun arg_tac -> (use_arg_then2 ("sel_P", [])) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((((use_arg_then2 ("P_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (simp_tac)) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["_"])) THEN (move ["y_in"]) THEN ((fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`(@) (P i)`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))));
   ((THENL_FIRST) (ANTS_TAC) (((use_arg_then2 ("i", [])) (term_tac exists_tac)) THEN (((use_arg_then2 ("IN_NUMSEG_0", [IN_NUMSEG_0]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   (((use_arg_then2 ("y_in", [])) (disch_tac [])) THEN (clear_assumption "y_in") THEN (exact_tac));
];;

(* Lemma nth_derivative_mul *)
let nth_derivative_mul = Sections.section_proof ["i";"x"]
`interval_arith x int ==> i <= n ==>
	nth_derivative i (\x. f x * g x) x = 
  	  sum (0..i) (\k. &(binom (i, k)) * nth_derivative k f x * nth_derivative (i - k) g x)`
[
   (BETA_TAC THEN (move ["ineq"]) THEN (move ["i_le_n"]));
   ((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("nth_derivative_mul_strong", [nth_derivative_mul_strong])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("i_le_n", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"])) THEN (move ["h"]));
   (((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN (exact_tac));
];;

(* Lemma nth_diff_mul *)
let nth_diff_mul = Sections.section_proof []
`nth_diff_strong_int n int (\x. f x * g x)`
[
   (((use_arg_then2 ("dg", [])) (disch_tac [])) THEN ((use_arg_then2 ("df", [])) (disch_tac [])) THEN BETA_TAC);
   ((repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("nth_differentiable_eq", [nth_differentiable_eq]))(thm_tac (new_rewrite [] []))))));
   (BETA_TAC THEN (move ["df"]) THEN (move ["dg"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((fun arg_tac -> (use_arg_then2 ("nth_derivative_mul_strong_all", [nth_derivative_mul_strong_all])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["open_s"])) THEN (case THEN (move ["xs"])) THEN (move ["diff"]));
   (((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tf"])) THEN (case THEN (move ["open_tf"])) THEN (case THEN (move ["xtf"])) THEN (move ["diff_f"]));
   (((fun arg_tac -> (use_arg_then2 ("dg", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["tg"])) THEN (case THEN (move ["open_tg"])) THEN (case THEN (move ["xtg"])) THEN (move ["diff_g"]));
   (((fun arg_tac -> arg_tac (Arg_term (`s INTER tf INTER tg`))) (term_tac exists_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_OPEN_INTER", [REAL_OPEN_INTER]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (repeat_tactic 1 9 (((use_arg_then2 ("IN_INTER", [IN_INTER]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("xs", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtf", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("xtg", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))));
   (BETA_TAC THEN (move ["y"]) THEN (case THEN ((move ["ys"]) THEN (case THEN ((move ["ytf"]) THEN (move ["ytg"]))))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_MUL", [REAL_CONTINUOUS_MUL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_f", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("diff_g", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["i"]) THEN (move ["i_lt_n"]));
   ((((use_arg_then2 ("nth_derivativeS", [nth_derivativeS]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_alt", [has_derivative_alt]))(thm_tac (new_rewrite [] [])))));
   (((use_arg_then2 ("differentiable_local", [differentiable_local])) (disch_tac [])) THEN (clear_assumption "differentiable_local") THEN (DISCH_THEN apply_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`\y. sum (0..i) (\k. &(binom(i, k)) * nth_derivative k f y * nth_derivative (i - k) g y)`))) (term_tac exists_tac)) THEN ((use_arg_then2 ("s", [])) (term_tac exists_tac)));
   ((THENL_LAST) (((((use_arg_then2 ("open_s", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ys", []))(thm_tac (new_rewrite [1] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))))) THEN (split_tac)) ((BETA_TAC THEN (move ["z"]) THEN (move ["zs"])) THEN ((((use_arg_then2 ("diff", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("ltnW", [ltnW]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((((use_arg_then2 ("differentiable_sum_numseg", [differentiable_sum_numseg]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_NUMSEG", [IN_NUMSEG]))(thm_tac (new_rewrite [] []))))) THEN (move ["k"]) THEN (move ["k_in"]) THEN (simp_tac));
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac))) THEN (((use_arg_then2 ("ETA_AX", [ETA_AX]))(fun arg -> ONCE_REWRITE_TAC[get_arg_thm arg]))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC k) f y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_f", [])) (fun fst_arg -> (use_arg_then2 ("ytf", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`nth_derivative (SUC (i - k)) g y`))) (term_tac exists_tac)) THEN (((fun arg_tac -> (use_arg_then2 ("diff_g", [])) (fun fst_arg -> (use_arg_then2 ("ytg", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("i_lt_n", [])) (disch_tac [])) THEN (clear_assumption "i_lt_n") THEN ((use_arg_then2 ("k_in", [])) (disch_tac [])) THEN (clear_assumption "k_in") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section NthDerivativeArith *)
let nth_derivative_scale_strong = Sections.finalize_theorem nth_derivative_scale_strong;;
let nth_derivative_scale_strong_all = Sections.finalize_theorem nth_derivative_scale_strong_all;;
let nth_derivative_scale = Sections.finalize_theorem nth_derivative_scale;;
let nth_diff_scale = Sections.finalize_theorem nth_diff_scale;;
let nth_derivative_add_strong = Sections.finalize_theorem nth_derivative_add_strong;;
let nth_derivative_add_strong_all = Sections.finalize_theorem nth_derivative_add_strong_all;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_add = Sections.finalize_theorem nth_diff_add;;
let nth_derivative_sub_strong = Sections.finalize_theorem nth_derivative_sub_strong;;
let nth_derivative_sub_strong_all = Sections.finalize_theorem nth_derivative_sub_strong_all;;
let nth_derivative_sub = Sections.finalize_theorem nth_derivative_sub;;
let nth_diff_sub = Sections.finalize_theorem nth_diff_sub;;
let nth_derivative_mul_strong = Sections.finalize_theorem nth_derivative_mul_strong;;
let nth_derivative_mul_strong_all = Sections.finalize_theorem nth_derivative_mul_strong_all;;
let nth_derivative_mul = Sections.finalize_theorem nth_derivative_mul;;
let nth_diff_mul = Sections.finalize_theorem nth_diff_mul;;
Sections.end_section "NthDerivativeArith";;

(* Finalization of the section NthDerivatives *)
let derivative_eq_real_derivative = Sections.finalize_theorem derivative_eq_real_derivative;;
let has_derivative_cond = Sections.finalize_theorem has_derivative_cond;;
let has_derivative_alt = Sections.finalize_theorem has_derivative_alt;;
let derivative_unique = Sections.finalize_theorem derivative_unique;;
let derivative_unique_on = Sections.finalize_theorem derivative_unique_on;;
let has_derivative_lemma = Sections.finalize_theorem has_derivative_lemma;;
let nth_derivative0 = Sections.finalize_theorem nth_derivative0;;
let nth_derivativeS = Sections.finalize_theorem nth_derivativeS;;
let nth_Sderivative = Sections.finalize_theorem nth_Sderivative;;
let nth_derivative1 = Sections.finalize_theorem nth_derivative1;;
let nth_derivative2 = Sections.finalize_theorem nth_derivative2;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_continuous = Sections.finalize_theorem nth_diff_continuous;;
let nth_differentiable_cond = Sections.finalize_theorem nth_differentiable_cond;;
let nth_differentiable_on_cond = Sections.finalize_theorem nth_differentiable_on_cond;;
let nth_differentiable_eq = Sections.finalize_theorem nth_differentiable_eq;;
let nth_differentiable_on_int2 = Sections.finalize_theorem nth_differentiable_on_int2;;
let nth_mth_diff = Sections.finalize_theorem nth_mth_diff;;
let nth_differentiable1 = Sections.finalize_theorem nth_differentiable1;;
let nth_diff_imp_diff = Sections.finalize_theorem nth_diff_imp_diff;;
let nth_derivative_continuous = Sections.finalize_theorem nth_derivative_continuous;;
let ith_derivative_differentiable = Sections.finalize_theorem ith_derivative_differentiable;;
let nth_diff_strong_imp_diff = Sections.finalize_theorem nth_diff_strong_imp_diff;;
let derivative_x = Sections.finalize_theorem derivative_x;;
let derivative_const = Sections.finalize_theorem derivative_const;;
let derivative_inv = Sections.finalize_theorem derivative_inv;;
let derivative_atn = Sections.finalize_theorem derivative_atn;;
let derivative_exp = Sections.finalize_theorem derivative_exp;;
let derivative_log = Sections.finalize_theorem derivative_log;;
let derivative_sin = Sections.finalize_theorem derivative_sin;;
let derivative_cos = Sections.finalize_theorem derivative_cos;;
let derivative_asn = Sections.finalize_theorem derivative_asn;;
let derivative_acs = Sections.finalize_theorem derivative_acs;;
let derivative_sqrt = Sections.finalize_theorem derivative_sqrt;;
let derivative_matan = Sections.finalize_theorem derivative_matan;;
let matan_differentiable = Sections.finalize_theorem matan_differentiable;;
let derivative_composition = Sections.finalize_theorem derivative_composition;;
let REAL_DIFFERENTIABLE_AT_INV = Sections.finalize_theorem REAL_DIFFERENTIABLE_AT_INV;;
let derivative_compose_atn = Sections.finalize_theorem derivative_compose_atn;;
let derivative_compose_exp = Sections.finalize_theorem derivative_compose_exp;;
let derivative_compose_log = Sections.finalize_theorem derivative_compose_log;;
let derivative_compose_cos = Sections.finalize_theorem derivative_compose_cos;;
let derivative_compose_sin = Sections.finalize_theorem derivative_compose_sin;;
let derivative_compose_inv = Sections.finalize_theorem derivative_compose_inv;;
let derivative_compose_sqrt = Sections.finalize_theorem derivative_compose_sqrt;;
let derivative_compose_acs = Sections.finalize_theorem derivative_compose_acs;;
let derivative_compose_asn = Sections.finalize_theorem derivative_compose_asn;;
let derivative_compose_matan = Sections.finalize_theorem derivative_compose_matan;;
let derivative_scale = Sections.finalize_theorem derivative_scale;;
let derivative_neg = Sections.finalize_theorem derivative_neg;;
let derivative_pow = Sections.finalize_theorem derivative_pow;;
let derivative_add = Sections.finalize_theorem derivative_add;;
let derivative_mul = Sections.finalize_theorem derivative_mul;;
let derivative_sub = Sections.finalize_theorem derivative_sub;;
let derivative_div = Sections.finalize_theorem derivative_div;;
let differentiable_sum_numseg = Sections.finalize_theorem differentiable_sum_numseg;;
let derivative_sum_numseg = Sections.finalize_theorem derivative_sum_numseg;;
let HAS_REAL_DERIVATIVE_LOCAL = Sections.finalize_theorem HAS_REAL_DERIVATIVE_LOCAL;;
let differentiable_local = Sections.finalize_theorem differentiable_local;;
let nth_derivative_scale_strong = Sections.finalize_theorem nth_derivative_scale_strong;;
let nth_derivative_scale_strong_all = Sections.finalize_theorem nth_derivative_scale_strong_all;;
let nth_derivative_scale = Sections.finalize_theorem nth_derivative_scale;;
let nth_diff_scale = Sections.finalize_theorem nth_diff_scale;;
let nth_derivative_add_strong = Sections.finalize_theorem nth_derivative_add_strong;;
let nth_derivative_add_strong_all = Sections.finalize_theorem nth_derivative_add_strong_all;;
let nth_derivative_add = Sections.finalize_theorem nth_derivative_add;;
let nth_diff_add = Sections.finalize_theorem nth_diff_add;;
let nth_derivative_sub_strong = Sections.finalize_theorem nth_derivative_sub_strong;;
let nth_derivative_sub_strong_all = Sections.finalize_theorem nth_derivative_sub_strong_all;;
let nth_derivative_sub = Sections.finalize_theorem nth_derivative_sub;;
let nth_diff_sub = Sections.finalize_theorem nth_diff_sub;;
let nth_derivative_mul_strong = Sections.finalize_theorem nth_derivative_mul_strong;;
let nth_derivative_mul_strong_all = Sections.finalize_theorem nth_derivative_mul_strong_all;;
let nth_derivative_mul = Sections.finalize_theorem nth_derivative_mul;;
let nth_diff_mul = Sections.finalize_theorem nth_diff_mul;;
Sections.end_section "NthDerivatives";;
let lin_approx = new_definition `lin_approx f x f_bounds df_bounds <=> 
	interval_arith (f x) f_bounds /\
	(?f'. (f has_real_derivative f') (atreal x) /\ interval_arith f' df_bounds)`;;
let has_bounded_second_derivative = new_definition `has_bounded_second_derivative f int dd_bounds <=>
	nth_diff_strong_int 2 int f /\ 
	bounded_on_int (nth_derivative 2 f) int dd_bounds`;;
let taylor_interval = new_definition 
  `taylor_interval f x y z w f_bounds df_bounds ddf_bounds <=>
	x <= y /\ y <= z /\ y - x <= w /\ z - y <= w /\
	lin_approx f y f_bounds df_bounds /\
	has_bounded_second_derivative f (x, z) ddf_bounds`;;

(* Lemma nth_diff_strong_imp_diff_int *)
let nth_diff_strong_imp_diff_int = Sections.section_proof ["n";"int";"f"]
`nth_diff_strong_int n int f ==>
	nth_differentiable_on_int n int f`
[
   ((((use_arg_then2 ("nth_diff_strong_int", [nth_diff_strong_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on_int", [nth_differentiable_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_diff_strong", [nth_diff_strong]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("nth_differentiable_on", [nth_differentiable_on]))(thm_tac (new_rewrite [] [])))));
   (BETA_TAC THEN (move ["h"]) THEN (move ["x"]) THEN (move ["ineq"]));
   ((((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("ineq", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["s"])) THEN (case THEN (move ["_"])) THEN (case THEN (move ["xs"]))) THEN (exact_tac) THEN (done_tac));
];;

(* Lemma has_bounded_second_derivative_old *)
let has_bounded_second_derivative_old = Sections.section_proof ["f";"int";"dd_bounds"]
`has_bounded_second_derivative f int dd_bounds ==>
	?f' f''. (!x. interval_arith x int ==> (f has_real_derivative f' x) (atreal x) /\
       		(f' has_real_derivative f'' x) (atreal x) /\	interval_arith (f'' x) dd_bounds)`
[
   ((((use_arg_then2 ("has_bounded_second_derivative", [has_bounded_second_derivative]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_diff_strong_imp_diff_int", [nth_diff_strong_imp_diff_int])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("nth_differentiable_on_int2", [nth_differentiable_on_int2])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])));
   ((BETA_TAC THEN (case THEN (move ["eq1"])) THEN (case THEN (move ["eq2"])) THEN (move ["h"]) THEN (move ["b"])) THEN ((((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((use_arg_then2 ("f''", [])) (term_tac exists_tac))) THEN (move ["x"]) THEN (move ["ineq"])));
   ((((use_arg_then2 ("b", [])) (disch_tac [])) THEN (clear_assumption "b") THEN BETA_TAC) THEN (((((use_arg_then2 ("bounded_on_int", [bounded_on_int]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("eq2", []))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["b"])));
   (((repeat_tactic 1 9 (((use_arg_then2 ("h", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("b", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma exists_and_left *)
let exists_and_left = Sections.section_proof ["P";"Q"]
`(?x. P x /\ Q x) ==> (?x. P x)`
[
   (BETA_TAC THEN (case THEN (move ["x"])) THEN (case THEN ((move ["Px"]) THEN (move ["_"]))));
   (((use_arg_then2 ("x", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma lim_ineq *)
let lim_ineq = Sections.section_proof ["a";"b"]
`(!e. &0 < e ==> a <= b + e) <=> (a <= b)`
[
   ((THENL_ROT (-1)) ((THENL) (split_tac) [ALL_TAC; ((move ["ineq"]) THEN (move ["e"]) THEN (move ["e0"]))]));
   (((((fun arg_tac -> (use_arg_then2 ("REAL_ADD_RID", [REAL_ADD_RID])) (fun fst_arg -> (use_arg_then2 ("a", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_ADD2", [REAL_LE_ADD2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LT_IMP_LE", [REAL_LT_IMP_LE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("contraLR", [contraLR])) (disch_tac [])) THEN (clear_assumption "contraLR") THEN (DISCH_THEN apply_tac)) THEN (((((use_arg_then2 ("NOT_FORALL_THM", [NOT_FORALL_THM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("NOT_IMP", [NOT_IMP]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_NOT_LE", [REAL_NOT_LE]))(thm_tac (new_rewrite [] [])))))) THEN (move ["ba"])));
   (((fun arg_tac -> arg_tac (Arg_term (`(a - b) / &2`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("ba", [])) (disch_tac [])) THEN (clear_assumption "ba") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_leq *)
let continuous_leq = Sections.section_proof ["f";"c";"a"]
`(?b. a < b /\ !x. x IN real_interval (a, b) ==> f x <= c) /\
	f real_continuous atreal a ==> f a <= c`
[
   (BETA_TAC THEN (case THEN ((case THEN (move ["b"])) THEN (case THEN (move ["ab"])) THEN (move ["ineq"]))));
   (((((use_arg_then2 ("REAL_CONTINUOUS_ATREAL", [REAL_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REALLIM_ATREAL", [REALLIM_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (move ["f_cont"]));
   ((((use_arg_then2 ("lim_ineq", [lim_ineq]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["e"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("f_cont", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   ((fun arg_tac -> arg_tac (Arg_term (`a + min (b - a) d / &2`))) (term_tac (set_tac "r")));
   ((THENL_FIRST) ((((fun arg_tac -> (use_arg_then2 ("cond", [])) (fun fst_arg -> (use_arg_then2 ("r", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (ANTS_TAC)) ((((use_arg_then2 ("ab", [])) (disch_tac [])) THEN (clear_assumption "ab") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((use_arg_then2 ("r_def", [])) (disch_tac [])) THEN (clear_assumption "r_def") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac)));
   ((THENL_LAST) ((((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (use_arg_then2 ("r", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (ANTS_TAC)) ((arith_tac) THEN (done_tac)));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ab", [])) (disch_tac [])) THEN (clear_assumption "ab") THEN ((use_arg_then2 ("d0", [])) (disch_tac [])) THEN (clear_assumption "d0") THEN ((use_arg_then2 ("r_def", [])) (disch_tac [])) THEN (clear_assumption "r_def") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_reflection *)
let continuous_reflection = Sections.section_proof ["f";"x"]
`f real_continuous atreal x <=>
	(\x. f (--x)) real_continuous atreal (--x)`
[
   (((repeat_tactic 1 9 (((use_arg_then2 ("REAL_CONTINUOUS_ATREAL", [REAL_CONTINUOUS_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REALLIM_ATREAL", [REALLIM_ATREAL]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN ((split_tac) THEN (move ["h"]) THEN (move ["e"]) THEN (move ["e0"])));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("e0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   (((use_arg_then2 ("d", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("d0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["ineqs"])) THEN (((use_arg_then2 ("cond", [])) (disch_tac [])) THEN (clear_assumption "cond") THEN (DISCH_THEN apply_tac)));
   ((((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> (use_arg_then2 ("h", [])) (fun fst_arg -> (use_arg_then2 ("e0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (case THEN (move ["d"])) THEN (case THEN (move ["d0"])) THEN (move ["cond"]));
   (((use_arg_then2 ("d", [])) (term_tac exists_tac)) THEN (((((use_arg_then2 ("d0", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"]) THEN (move ["ineqs"])));
   ((((fun arg_tac -> (use_arg_then2 ("cond", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`--y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] [])))) THEN (DISCH_THEN apply_tac) THEN (((use_arg_then2 ("ineqs", [])) (disch_tac [])) THEN (clear_assumption "ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma continuous_leq_segment *)
let continuous_leq_segment = Sections.section_proof ["f";"c";"a";"b"]
`a < b ==> f real_continuous atreal a ==> f real_continuous atreal b ==>
	(!x. x IN real_interval (a, b) ==> f x <= c) ==>
	(!x. x IN real_interval [a, b] ==> f x <= c)`
[
   (BETA_TAC THEN (move ["ab"]) THEN (move ["f_cont_a"]) THEN (move ["f_cont_b"]) THEN (move ["ineq"]) THEN (move ["x"]));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 2 0 (((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b. a <= b <=> (a = b \/ a < b)`)))(thm_tac (new_rewrite [] []))))));
   (case THEN ((THENL) case [((((conv_thm_tac DISCH_THEN)(gsym_then (thm_tac (new_rewrite [] []))))) THEN (move ["_"])); (move ["ax"])]));
   ((((use_arg_then2 ("continuous_leq", [continuous_leq])) (disch_tac [])) THEN (clear_assumption "continuous_leq") THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("f_cont_a", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN ((use_arg_then2 ("b", [])) (term_tac exists_tac)) THEN (done_tac));
   ((THENL_LAST) ((THENL) case [(((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))); (move ["xb"])]) ((((use_arg_then2 ("ineq", [])) (disch_tac [])) THEN (clear_assumption "ineq") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`\x. f (--x)`))) (term_tac (set_tac "g")));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`!x. f x = g (--x)`))) (term_tac (have_gen_tac [](move ["fg"])))) (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   ((((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("continuous_leq", [continuous_leq])) (disch_tac [])) THEN (clear_assumption "continuous_leq") THEN (DISCH_THEN apply_tac)) THEN (split_tac));
   (((fun arg_tac -> arg_tac (Arg_term (`--a`))) (term_tac exists_tac)) THEN (((((use_arg_then2 ("REAL_LT_NEG", [REAL_LT_NEG]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("ab", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (move ["y"])));
   ((((fun arg_tac -> (use_arg_then2 ("ineq", [])) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`--y`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_NEG_NEG", [REAL_NEG_NEG]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("g_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("continuous_reflection", [continuous_reflection]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma pair_eq *)
let pair_eq = Sections.section_proof ["p"]
`p = (FST p, SND p)`
[
   (done_tac);
];;

(* Section Taylor *)
Sections.begin_section "Taylor";;

(* Lemma iabs_alt *)
let iabs_alt = Sections.section_proof ["lo";"hi";"a"]
`interval_arith a (lo, hi) ==> iabs (lo, hi) = max (abs lo) (abs hi)`
[
   (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma iabs_pos *)
let iabs_pos = Sections.section_proof ["lo";"hi";"a"]
`interval_arith a (lo, hi) ==> &0 <= iabs (lo, hi)`
[
   (((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;
(Sections.add_section_var (mk_var ("f", (`:real -> real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))); Sections.add_section_var (mk_var ("y", (`:real`))); Sections.add_section_var (mk_var ("z", (`:real`))); Sections.add_section_var (mk_var ("w", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("ddf_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("dd_bound", (`:real`))));;
(Sections.add_section_hyp "dd_bound_eq" (`dd_bound = iabs ddf_bounds`));;
(Sections.add_section_hyp "tif" (`taylor_interval f x y z w f_bounds df_bounds ddf_bounds`));;

(* Lemma f_continuous *)
let f_continuous = Sections.section_proof []
`!t. t IN real_interval [x, z] ==> f real_continuous atreal t`
[
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["t"]) THEN (move ["t_in"]));
   (((use_arg_then2 ("HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL", [HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_IMP_CONTINUOUS_ATREAL") THEN (DISCH_THEN apply_tac));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC))))));
   (BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   (((fun arg_tac -> arg_tac (Arg_term (`f' t`))) (term_tac exists_tac)) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
];;

(* Lemma taylor_error *)
let taylor_error = Sections.section_proof ["t"]
`x <= t /\ t <= z ==> 
	abs (f t - f y) <= w * iabs df_bounds + w * w * dd_bound / &2`
[
   (BETA_TAC THEN (move ["t_ineqs"]));
   (((use_arg_then2 ("tif", [])) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["domain_ineqs"])) THEN (move ["lin_app"])));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`abs (t - y) <= w`))) (term_tac (have_gen_tac [](move ["abs_ty"]))));
   ((((use_arg_then2 ("t_ineqs", [])) (disch_tac [])) THEN (clear_assumption "t_ineqs") THEN ((use_arg_then2 ("domain_ineqs", [])) (disch_tac [])) THEN (clear_assumption "domain_ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`interval_arith y (x, z)`))) (term_tac (have_gen_tac [](move ["y_in"])))) ((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= dd_bound /\ !p. p IN real_interval [x, z] ==> abs (f'' p) <= dd_bound`))) (term_tac (have_gen_tac [](move ["dd_prop"]))));
   ((((use_arg_then2 ("dd_bound_eq", []))(thm_tac (new_rewrite [] [])))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("y_in", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`abs (f t - (f y + f' y * (t - y) pow 1)) <= dd_bound * abs (t - y) pow (1 + 1) / &2`))) (term_tac (have_gen_tac []ALL_TAC))));
   (((fun arg_tac -> arg_tac (Arg_term (`f' y * _`))) (term_tac (set_tac "b1"))) THEN (((fun arg_tac -> arg_tac (Arg_term (`dd_bound * _`))) (term_tac (set_tac "b2"))) THEN (move ["ineq1"])));
   ((((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`abs (f t - (f y + b1)) + abs b1`))) (term_tac exists_tac)) THEN (split_tac));
   (((((fun arg_tac -> arg_tac (Arg_theorem (REAL_ARITH `!a b. a - b = (a - (b + b1)) + b1`)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ABS_TRIANGLE", [REAL_ABS_TRIANGLE]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("REAL_ADD_SYM", [REAL_ADD_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_ADD2", [REAL_LE_ADD2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("b1_def", []))(gsym_then (thm_tac (new_rewrite [1] []))))) THEN (((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_ABS_MUL", [REAL_ABS_MUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_ABS_POS", [REAL_ABS_POS]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("abs_ty", []))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("lin_app", [])) (disch_tac [])) THEN (clear_assumption "lin_app") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN (move ["_"])) THEN (case THEN (move ["ff"])) THEN (case THEN (move ["df'"]))));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`ff = f' y`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) (((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac)));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac)) THEN ((((use_arg_then2 ("df'", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac)) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("b2", [])) (term_tac exists_tac)));
   ((((use_arg_then2 ("ineq1", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("b2_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("real_div", [real_div]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_MUL_ASSOC", [REAL_MUL_ASSOC]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `1 + 1 = 2`)))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_INV", [REAL_LE_INV]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LE_MUL", [REAL_LE_MUL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 0 10 (((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] [])))))) THEN (TRY ((arith_tac))));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_POW_2", [REAL_POW_2]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_MUL2", [REAL_LE_MUL2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] [])))));
   (((((use_arg_then2 ("REAL_LE_POW_2", [REAL_LE_POW_2]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbT", [andbT]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_LE_SQUARE_ABS", [REAL_LE_SQUARE_ABS]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_ABS_ABS", [REAL_ABS_ABS]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("abs_ty", [])) (disch_tac [])) THEN (clear_assumption "abs_ty") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\i. if i = 0 then f else if i = 1 then f' else if i = 2 then f'' else I`))) (term_tac (set_tac "Df")));
   ((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 + 1 = 1 /\ ~(1 = 0) /\ 1 + 1 = 2 /\ 
	~(2 = 1) /\ ~(2 = 1) /\ ~(2 = 0)`))) (fun arg -> thm_tac MP_TAC arg THEN (move ["arith"])));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_TAYLOR", [REAL_TAYLOR])) (fun fst_arg -> (use_arg_then2 ("Df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`1`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`real_interval [x, z]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dd_bound", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (ANTS_TAC);
   (((((use_arg_then2 ("IS_REALINTERVAL_INTERVAL", [IS_REALINTERVAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["p"]) THEN (case THEN (move ["p_in"]))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i <= 1 <=> i = 0 \/ i = 1`)))(thm_tac (new_rewrite [] [])))));
   ((case THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN ((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATREAL_WITHIN", [HAS_REAL_DERIVATIVE_ATREAL_WITHIN])) (thm_tac apply_tac)) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN ((fun arg_tac -> (fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("t_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL SUM_CLAUSES_NUMSEG)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 <= 1 /\ ~(1 = 0)`)))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("FACT", [FACT]))(thm_tac (new_rewrite [] [])))));
   (((repeat_tactic 1 9 (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `FACT 1 = 1 /\ FACT (1 + 1) = 2`)))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIV_1", [REAL_DIV_1]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma taylor_upper_bound *)
let taylor_upper_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	f t <= SND f_bounds + (w * iabs df_bounds + w * w * dd_bound / &2)`
[
   (((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC THEN (move ["eq"]));
   (BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_error", [taylor_error])) (thm_tac (match_mp_then snd_th MP_TAC)))));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["_"])) THEN (case THEN (move ["f_int"])) THEN (move ["_"]) THEN (move ["_"])));
   ((((use_arg_then2 ("f_int", [])) (disch_tac [])) THEN (clear_assumption "f_int") THEN BETA_TAC) THEN ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_lower_bound *)
let taylor_lower_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	FST f_bounds - (w * iabs df_bounds + w * w * dd_bound / &2) <= f t`
[
   ((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["eq"])));
   (BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_error", [taylor_error])) (thm_tac (match_mp_then snd_th MP_TAC)))));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] []))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["_"])) THEN (case THEN (move ["f_int"])) THEN (move ["_"]) THEN (move ["_"])));
   ((((use_arg_then2 ("f_int", [])) (disch_tac [])) THEN (clear_assumption "f_int") THEN BETA_TAC) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (arith_tac));
];;

(* Lemma taylor_derivative_error *)
let taylor_derivative_error = Sections.section_proof []
`!t. x <= t /\ t <= z ==> 
	abs (derivative f t - derivative f y) <= w * dd_bound`
[
   (BETA_TAC THEN (move ["t"]) THEN (move ["t_ineqs"]));
   (((use_arg_then2 ("tif", [])) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC)) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["domain_ineqs"])) THEN (move ["_"])));
   ((DISCH_THEN (fun snd_th -> (use_arg_then2 ("has_bounded_second_derivative_old", [has_bounded_second_derivative_old])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN BETA_TAC THEN (case THEN (move ["f'"])) THEN (case THEN (move ["f''"])) THEN (move ["df"]));
   ((fun arg_tac -> arg_tac (Arg_term (`abs (t - y) <= w`))) (term_tac (have_gen_tac [](move ["abs_ty"]))));
   ((((use_arg_then2 ("t_ineqs", [])) (disch_tac [])) THEN (clear_assumption "t_ineqs") THEN ((use_arg_then2 ("domain_ineqs", [])) (disch_tac [])) THEN (clear_assumption "domain_ineqs") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`!p. x <= p /\ p <= z ==> derivative f p = f' p`))) (term_tac (have_gen_tac [](move ["der_eq"]))));
   (((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("EQ_SYM_EQ", [EQ_SYM_EQ]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("derivative_unique_on", [derivative_unique_on])) (disch_tac [])) THEN (clear_assumption "derivative_unique_on") THEN (DISCH_THEN apply_tac)));
   ((((((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC)))) THEN (simp_tac)) THEN (done_tac));
   ((repeat_tactic 1 9 (((use_arg_then2 ("der_eq", []))(thm_tac (new_rewrite [] []))))) THEN ((TRY done_tac)));
   ((fun arg_tac -> arg_tac (Arg_term (`&0 <= dd_bound /\ !p. p IN real_interval [x, z] ==> abs (f'' p) <= dd_bound`))) (term_tac (have_gen_tac [](move ["dd_prop"]))));
   (((((use_arg_then2 ("dd_bound_eq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (split_tac));
   ((((fun arg_tac -> (use_arg_then2 ("df", [])) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("ddf_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] [])))))) THEN (arith_tac) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("df", [])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN ((((use_arg_then2 ("pair_eq", [pair_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   ((fun arg_tac -> arg_tac (Arg_term (`\i. if i = 0 then f' else if i = 1 then f'' else I`))) (term_tac (set_tac "Df")));
   ((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `0 + 1 = 1 /\ ~(1 = 0) /\ 1 + 1 = 2 /\ 
	~(2 = 1) /\ ~(2 = 1) /\ ~(2 = 0)`))) (fun arg -> thm_tac MP_TAC arg THEN (move ["arith"])));
   ((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_TAYLOR", [REAL_TAYLOR])) (fun fst_arg -> (use_arg_then2 ("Df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`0`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (fun arg_tac -> arg_tac (Arg_term (`real_interval [x, z]`))) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("dd_bound", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN ALL_TAC));
   (ANTS_TAC);
   (((((use_arg_then2 ("IS_REALINTERVAL_INTERVAL", [IS_REALINTERVAL_INTERVAL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))) THEN (split_tac));
   ((BETA_TAC THEN (move ["i"]) THEN (move ["p"]) THEN (case THEN (move ["p_in"]))) THEN ((((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `i <= 0 <=> i = 0`)))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))));
   (((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)) THEN (((use_arg_then2 ("HAS_REAL_DERIVATIVE_ATREAL_WITHIN", [HAS_REAL_DERIVATIVE_ATREAL_WITHIN])) (disch_tac [])) THEN (clear_assumption "HAS_REAL_DERIVATIVE_ATREAL_WITHIN") THEN (DISCH_THEN apply_tac)));
   (((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
   ((BETA_TAC THEN (move ["p"]) THEN (move ["p_in"])) THEN ((((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   (((repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
   ((BETA_TAC THEN ((fun arg_tac -> (fun arg_tac ->  (conv_thm_tac DISCH_THEN)  (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("t", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (thm_tac MP_TAC))) THEN ((repeat_tactic 1 9 (((use_arg_then2 ("IN_REAL_INTERVAL", [IN_REAL_INTERVAL]))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("domain_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("t_ineqs", []))(thm_tac (new_rewrite [] []))))) THEN (simp_tac)));
   ((((use_arg_then2 ("ONE", [ONE]))(thm_tac (new_rewrite [1] [])))) THEN (((use_arg_then2 ("SUM_SING_NUMSEG", [SUM_SING_NUMSEG]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac) THEN (((use_arg_then2 ("Df_def", []))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("ONE", [ONE]))(gsym_then (thm_tac (new_rewrite [] []))))));
   ((((fun arg_tac -> arg_tac (Arg_theorem (GEN_ALL real_pow)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("arith", []))(thm_tac (new_rewrite [] []))))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("FACT", [FACT]))(thm_tac (new_rewrite [] []))))) THEN (((fun arg_tac -> arg_tac (Arg_theorem (ARITH_RULE `FACT 1 = 1`)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_DIV_1", [REAL_DIV_1]))(thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("REAL_MUL_RID", [REAL_MUL_RID]))(thm_tac (new_rewrite [] [])))));
   ((((use_arg_then2 ("REAL_POW_1", [REAL_POW_1]))(thm_tac (new_rewrite [] [])))) THEN (move ["ineq"]));
   ((((use_arg_then2 ("REAL_LE_TRANS", [REAL_LE_TRANS])) (disch_tac [])) THEN (clear_assumption "REAL_LE_TRANS") THEN (DISCH_THEN apply_tac)) THEN ((fun arg_tac -> arg_tac (Arg_term (`dd_bound * abs (t - y)`))) (term_tac exists_tac)));
   (((((use_arg_then2 ("ineq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_MUL_SYM", [REAL_MUL_SYM]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("REAL_LE_RMUL", [REAL_LE_RMUL]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("dd_prop", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("abs_ty", []))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma derivative_interval *)
let derivative_interval = Sections.section_proof []
`FST df_bounds <= derivative f y /\ derivative f y <= SND df_bounds`
[
   ((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("df_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun arg -> thm_tac MP_TAC arg THEN (move ["eq"])));
   ((((use_arg_then2 ("tif", [])) (disch_tac [])) THEN (clear_assumption "tif") THEN BETA_TAC) THEN (((((use_arg_then2 ("taylor_interval", [taylor_interval]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andbA", [andbA]))(thm_tac (new_rewrite [] [])))))) THEN ALL_TAC THEN (case THEN ALL_TAC) THEN (case THEN (move ["ineqs"])) THEN (case THEN (move ["g"])) THEN (case THEN ((move ["fg"]) THEN (move ["g_int"]))) THEN (move ["_"])));
   ((THENL_FIRST) (((THENL_ROT 1)) ((fun arg_tac -> arg_tac (Arg_term (`derivative f y = g`))) (term_tac (have_gen_tac [](((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))))))) ((((use_arg_then2 ("g_int", [])) (disch_tac [])) THEN (clear_assumption "g_int") THEN BETA_TAC) THEN ((((use_arg_then2 ("eq", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("REAL_DERIVATIVE_UNIQUE_ATREAL", [REAL_DERIVATIVE_UNIQUE_ATREAL])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("y", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (DISCH_THEN apply_tac));
   (((((use_arg_then2 ("fg", []))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("has_derivative_cond", [has_derivative_cond]))(thm_tac (new_rewrite [] [])))) THEN ((TRY done_tac))) THEN ((use_arg_then2 ("g", [])) (term_tac exists_tac)) THEN (done_tac));
];;

(* Lemma taylor_derivative_upper_bound *)
let taylor_derivative_upper_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	derivative f t <= SND df_bounds + w * dd_bound`
[
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_derivative_error", [taylor_derivative_error])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (((use_arg_then2 ("derivative_interval", [derivative_interval])) (disch_tac [])) THEN (clear_assumption "derivative_interval") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma taylor_derivative_lower_bound *)
let taylor_derivative_lower_bound = Sections.section_proof []
`!t. x <= t /\ t <= z ==>
	FST df_bounds - w * dd_bound <= derivative f t`
[
   ((BETA_TAC THEN (move ["t"]) THEN (DISCH_THEN (fun snd_th -> (use_arg_then2 ("taylor_derivative_error", [taylor_derivative_error])) (thm_tac (match_mp_then snd_th MP_TAC))))) THEN (((use_arg_then2 ("derivative_interval", [derivative_interval])) (disch_tac [])) THEN (clear_assumption "derivative_interval") THEN BETA_TAC) THEN (arith_tac) THEN (done_tac));
];;

(* Finalization of the section Taylor *)
let iabs_alt = Sections.finalize_theorem iabs_alt;;
let iabs_pos = Sections.finalize_theorem iabs_pos;;
let f_continuous = Sections.finalize_theorem f_continuous;;
let taylor_error = Sections.finalize_theorem taylor_error;;
let taylor_upper_bound = Sections.finalize_theorem taylor_upper_bound;;
let taylor_lower_bound = Sections.finalize_theorem taylor_lower_bound;;
let taylor_derivative_error = Sections.finalize_theorem taylor_derivative_error;;
let derivative_interval = Sections.finalize_theorem derivative_interval;;
let taylor_derivative_upper_bound = Sections.finalize_theorem taylor_derivative_upper_bound;;
let taylor_derivative_lower_bound = Sections.finalize_theorem taylor_derivative_lower_bound;;
Sections.end_section "Taylor";;

(* Section LinearApproximation *)
Sections.begin_section "LinearApproximation";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;

(* Lemma lin_approx_eq *)
let lin_approx_eq = Sections.section_proof []
`lin_approx f x f_bounds df_bounds <=>
	(f real_differentiable atreal x /\ interval_arith (f x) f_bounds /\
	interval_arith (derivative f x) df_bounds)`
[
   (((((use_arg_then2 ("lin_approx", [lin_approx]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("real_differentiable", [real_differentiable]))(thm_tac (new_rewrite [] []))))) THEN ((THENL) (split_tac) [(case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (case THEN (move ["f'"])) THEN (case THEN ((move ["df'"]) THEN (move ["int_f'"]))))); ((case THEN ((case THEN (move ["f'"])) THEN (move ["df"]))) THEN (case THEN ((((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] [])))) THEN (move ["df_int"]))))]));
   ((THENL_FIRST) (split_tac) (((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN (done_tac)));
   ((((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (done_tac));
   ((((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] [])))) THEN ((use_arg_then2 ("f'", [])) (term_tac exists_tac)) THEN ((((use_arg_then2 ("df", []))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_unique", [derivative_unique])) (fun fst_arg -> (use_arg_then2 ("f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f'", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("x", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;

(* Lemma lin_approx_imp_f_interval *)
let lin_approx_imp_f_interval = Sections.section_proof []
`interval_arith (f x) f_bounds`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma lin_approx_imp_df_interval *)
let lin_approx_imp_df_interval = Sections.section_proof []
`interval_arith (derivative f x) df_bounds`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Lemma lin_approx_imp_f_diff *)
let lin_approx_imp_f_diff = Sections.section_proof []
`f real_differentiable atreal x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (simp_tac)) THEN (done_tac));
];;

(* Finalization of the section LinearApproximation *)
let lin_approx_eq = Sections.finalize_theorem lin_approx_eq;;
let lin_approx_imp_f_interval = Sections.finalize_theorem lin_approx_imp_f_interval;;
let lin_approx_imp_df_interval = Sections.finalize_theorem lin_approx_imp_df_interval;;
let lin_approx_imp_f_diff = Sections.finalize_theorem lin_approx_imp_f_diff;;
Sections.end_section "LinearApproximation";;

(* Section MoreLinearApproximation *)
Sections.begin_section "MoreLinearApproximation";;
(Sections.add_section_var (mk_var ("f", (`:real->real`))); Sections.add_section_var (mk_var ("g", (`:real->real`))));;
(Sections.add_section_var (mk_var ("x", (`:real`))));;
(Sections.add_section_var (mk_var ("f_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("df_bounds", (`:real#real`))));;
(Sections.add_section_var (mk_var ("g_bounds", (`:real#real`))); Sections.add_section_var (mk_var ("dg_bounds", (`:real#real`))));;

(* Lemma interval_arith_not_zero *)
let interval_arith_not_zero = Sections.section_proof ["x";"int"]
`interval_arith x int ==> interval_not_zero int ==>
	~(x = &0)`
[
   (((((fun arg_tac -> (use_arg_then2 ("PAIR", [PAIR])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_not_zero", [interval_not_zero]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma interval_arith_pos *)
let interval_arith_pos = Sections.section_proof ["x";"int"]
`interval_arith x int ==> interval_pos int ==> &0 < x`
[
   ((((use_arg_then2 ("int", [])) (disch_tac [])) THEN (clear_assumption "int") THEN case) THEN ((((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_pos", [interval_pos]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma interval_arith_abs *)
let interval_arith_abs = Sections.section_proof ["x";"int";"y"]
`interval_arith x int ==> iabs int < y ==> abs x < y`
[
   (((((fun arg_tac -> (use_arg_then2 ("PAIR", [PAIR])) (fun fst_arg -> (use_arg_then2 ("int", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(gsym_then (thm_tac (new_rewrite [] []))))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("iabs", [iabs]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
];;

(* Lemma lin_approx_x *)
let lin_approx_x = Sections.section_proof []
`lin_approx (\x. x) x (x, x) (&1, &1)`
[
   (((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_x", [derivative_x]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_ID", [REAL_DIFFERENTIABLE_ID]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] [])))))) THEN (done_tac));
];;

(* Lemma lin_approx_const *)
let lin_approx_const = Sections.section_proof ["c"]
`lin_approx (\x. c) x (c, c) (&0, &0)`
[
   ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("derivative_const", [derivative_const]))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (simp_tac) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_CONST", [REAL_DIFFERENTIABLE_CONST]))(thm_tac (new_rewrite [] [])))));
   ((repeat_tactic 1 9 (((use_arg_then2 ("REAL_LE_REFL", [REAL_LE_REFL]))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Section LinearApproxUnivariateComposition *)
Sections.begin_section "LinearApproxUnivariateComposition";;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;

(* Lemma lin_approx_compose_atn *)
let lin_approx_compose_atn = Sections.section_proof []
`(\x. atn (f x)) real_differentiable atreal x /\
	derivative (\x. atn (f x)) x = derivative f x / (&1 + f x * f x)`
[
   ((((use_arg_then2 ("derivative_compose_atn", [derivative_compose_atn])) (disch_tac [])) THEN (clear_assumption "derivative_compose_atn") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_exp *)
let lin_approx_compose_exp = Sections.section_proof []
`(\x. exp (f x)) real_differentiable atreal x /\
	derivative (\x. exp (f x)) x = exp (f x) * derivative f x`
[
   ((((use_arg_then2 ("derivative_compose_exp", [derivative_compose_exp])) (disch_tac [])) THEN (clear_assumption "derivative_compose_exp") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_log *)
let lin_approx_compose_log = Sections.section_proof []
`interval_pos f_bounds ==>
	(\x. log (f x)) real_differentiable atreal x /\
	derivative (\x. log (f x)) x = derivative f x / f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"])))) ((((use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (disch_tac [])) THEN (clear_assumption "interval_arith_pos") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_log", [derivative_compose_log])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_pos", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_cos *)
let lin_approx_compose_cos = Sections.section_proof []
`(\x. cos (f x)) real_differentiable atreal x /\
	derivative (\x. cos (f x)) x = --(sin (f x) * derivative f x)`
[
   ((((use_arg_then2 ("derivative_compose_cos", [derivative_compose_cos])) (disch_tac [])) THEN (clear_assumption "derivative_compose_cos") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_sin *)
let lin_approx_compose_sin = Sections.section_proof []
`(\x. sin (f x)) real_differentiable atreal x /\
	derivative (\x. sin (f x)) x = cos (f x) * derivative f x`
[
   ((((use_arg_then2 ("derivative_compose_sin", [derivative_compose_sin])) (disch_tac [])) THEN (clear_assumption "derivative_compose_sin") THEN (DISCH_THEN apply_tac)) THEN (((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_compose_inv *)
let lin_approx_compose_inv = Sections.section_proof []
`interval_not_zero f_bounds ==>
	(\x. inv (f x)) real_differentiable atreal x /\
	derivative (\x. inv (f x)) x = -- inv (f x * f x) * derivative f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f0"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`~(f x = &0)`))) (term_tac (have_gen_tac [](move ["fn0"])))) ((((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_inv", [derivative_compose_inv])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("fn0", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_sqrt *)
let lin_approx_compose_sqrt = Sections.section_proof []
`interval_pos f_bounds ==>
	(\x. sqrt (f x)) real_differentiable atreal x /\
	derivative (\x. sqrt (f x)) x = derivative f x / (&2 * sqrt (f x))`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`&0 < f x`))) (term_tac (have_gen_tac [](move ["f_pos"])))) ((((use_arg_then2 ("interval_arith_pos", [interval_arith_pos])) (disch_tac [])) THEN (clear_assumption "interval_arith_pos") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_sqrt", [derivative_compose_sqrt])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_pos", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_acs *)
let lin_approx_compose_acs = Sections.section_proof []
`iabs f_bounds < &1 ==>
	(\x. acs (f x)) real_differentiable atreal x /\
	derivative (\x. acs (f x)) x = -- (derivative f x / sqrt (&1 - f x * f x))`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["f_abs"])))) ((((use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (disch_tac [])) THEN (clear_assumption "interval_arith_abs") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_acs", [derivative_compose_acs])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_abs", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_asn *)
let lin_approx_compose_asn = Sections.section_proof []
`iabs f_bounds < &1 ==>
	(\x. asn (f x)) real_differentiable atreal x /\
	derivative (\x. asn (f x)) x = derivative f x / sqrt (&1 - f x * f x)`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((THENL_FIRST) ((fun arg_tac -> arg_tac (Arg_term (`abs (f x) < &1`))) (term_tac (have_gen_tac [](move ["f_abs"])))) ((((use_arg_then2 ("interval_arith_abs", [interval_arith_abs])) (disch_tac [])) THEN (clear_assumption "interval_arith_abs") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("f_bounds", [])) (term_tac exists_tac)) THEN (done_tac)));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_asn", [derivative_compose_asn])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_abs", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Lemma lin_approx_compose_matan *)
let lin_approx_compose_matan = Sections.section_proof []
`interval_gt (-- &1) f_bounds ==>
	(\x. matan (f x)) real_differentiable atreal x /\
	derivative (\x. matan (f x)) x = dmatan (f x) * derivative f x`
[
   ((((use_arg_then2 ("approx_f", [])) (disch_tac [])) THEN (clear_assumption "approx_f") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN ALL_TAC THEN (case THEN ((move ["df"]) THEN (move ["h"]))) THEN (move ["f_ineq"])));
   ((fun arg_tac -> arg_tac (Arg_term (`-- &1 < f x`))) (term_tac (have_gen_tac [](move ["f_ineq2"]))));
   ((((use_arg_then2 ("h", [])) (disch_tac [])) THEN (clear_assumption "h") THEN ((use_arg_then2 ("f_ineq", [])) (disch_tac [])) THEN (clear_assumption "f_ineq") THEN BETA_TAC) THEN ((((fun arg_tac -> (use_arg_then2 ("pair_eq", [pair_eq])) (fun fst_arg -> (use_arg_then2 ("f_bounds", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_gt", [interval_gt]))(thm_tac (new_rewrite [] [])))) THEN (((use_arg_then2 ("interval_arith", [interval_arith]))(thm_tac (new_rewrite [] []))))) THEN (arith_tac) THEN (done_tac));
   (((fun arg_tac -> (fun arg_tac -> (use_arg_then2 ("derivative_compose_matan", [derivative_compose_matan])) (fun fst_arg -> (use_arg_then2 ("df", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (fun fst_arg -> (use_arg_then2 ("f_ineq2", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg))) (disch_tac [])) THEN (exact_tac));
];;

(* Finalization of the section LinearApproxUnivariateComposition *)
let lin_approx_compose_atn = Sections.finalize_theorem lin_approx_compose_atn;;
let lin_approx_compose_exp = Sections.finalize_theorem lin_approx_compose_exp;;
let lin_approx_compose_log = Sections.finalize_theorem lin_approx_compose_log;;
let lin_approx_compose_cos = Sections.finalize_theorem lin_approx_compose_cos;;
let lin_approx_compose_sin = Sections.finalize_theorem lin_approx_compose_sin;;
let lin_approx_compose_inv = Sections.finalize_theorem lin_approx_compose_inv;;
let lin_approx_compose_sqrt = Sections.finalize_theorem lin_approx_compose_sqrt;;
let lin_approx_compose_acs = Sections.finalize_theorem lin_approx_compose_acs;;
let lin_approx_compose_asn = Sections.finalize_theorem lin_approx_compose_asn;;
let lin_approx_compose_matan = Sections.finalize_theorem lin_approx_compose_matan;;
Sections.end_section "LinearApproxUnivariateComposition";;
(Sections.add_section_hyp "approx_f" (`lin_approx f x f_bounds df_bounds`));;
(Sections.add_section_hyp "approx_g" (`lin_approx g x g_bounds dg_bounds`));;

(* Lemma lin_approx_imp_add_diff *)
let lin_approx_imp_add_diff = Sections.section_proof []
`(\x. f x + g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_ADD", [REAL_DIFFERENTIABLE_ADD])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_ADD") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_sub_diff *)
let lin_approx_imp_sub_diff = Sections.section_proof []
`(\x. f x - g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_SUB", [REAL_DIFFERENTIABLE_SUB])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_SUB") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_mul_diff *)
let lin_approx_imp_mul_diff = Sections.section_proof []
`(\x. f x * g x) real_differentiable atreal x`
[
   (((use_arg_then2 ("REAL_DIFFERENTIABLE_MUL_ATREAL", [REAL_DIFFERENTIABLE_MUL_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_MUL_ATREAL") THEN (DISCH_THEN apply_tac));
   (((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Lemma lin_approx_imp_div_diff *)
let lin_approx_imp_div_diff = Sections.section_proof []
`interval_not_zero g_bounds ==> (\x. f x / g x) real_differentiable atreal x`
[
   ((BETA_TAC THEN (move ["gn0"])) THEN (((use_arg_then2 ("REAL_DIFFERENTIABLE_DIV_ATREAL", [REAL_DIFFERENTIABLE_DIV_ATREAL])) (disch_tac [])) THEN (clear_assumption "REAL_DIFFERENTIABLE_DIV_ATREAL") THEN (DISCH_THEN apply_tac)));
   ((((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_f", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (((fun arg_tac -> (use_arg_then2 ("lin_approx_imp_f_diff", [lin_approx_imp_f_diff])) (fun fst_arg -> (use_arg_then2 ("approx_g", [])) (fun snd_arg -> combine_args_then arg_tac fst_arg snd_arg)))(thm_tac (new_rewrite [] [])))) THEN (repeat_tactic 1 9 (((use_arg_then2 ("andTb", [andTb]))(thm_tac (new_rewrite [] []))))));
   ((((use_arg_then2 ("interval_arith_not_zero", [interval_arith_not_zero])) (disch_tac [])) THEN (clear_assumption "interval_arith_not_zero") THEN (DISCH_THEN apply_tac)) THEN ((use_arg_then2 ("g_bounds", [])) (term_tac exists_tac)));
   ((((use_arg_then2 ("approx_g", [])) (disch_tac [])) THEN (clear_assumption "approx_g") THEN BETA_TAC) THEN ((((use_arg_then2 ("lin_approx_eq", [lin_approx_eq]))(thm_tac (new_rewrite [] [])))) THEN (((conv_thm_tac DISCH_THEN)(thm_tac (new_rewrite [] []))))) THEN (done_tac));
];;

(* Finalization of the section MoreLinearApproximation *)
let interval_arith_not_zero = Sections.finalize_theorem interval_arith_not_zero;;
let interval_arith_pos = Sections.finalize_theorem interval_arith_pos;;
let interval_arith_abs = Sections.finalize_theorem interval_arith_abs;;
let lin_approx_x = Sections.finalize_theorem lin_approx_x;;
let lin_approx_const = Sections.finalize_theorem lin_approx_const;;
let lin_approx_compose_atn = Sections.finalize_theorem lin_approx_compose_atn;;
let lin_approx_compose_exp = Sections.finalize_theorem lin_approx_compose_exp;;
let lin_approx_compose_log = Sections.finalize_theorem lin_approx_compose_log;;
let lin_approx_compose_cos = Sections.finalize_theorem lin_approx_compose_cos;;
let lin_approx_compose_sin = Sections.finalize_theorem lin_approx_compose_sin;;
let lin_approx_compose_inv = Sections.finalize_theorem lin_approx_compose_inv;;
let lin_approx_compose_sqrt = Sections.finalize_theorem lin_approx_compose_sqrt;;
let lin_approx_compose_acs = Sections.finalize_theorem lin_approx_compose_acs;;
let lin_approx_compose_asn = Sections.finalize_theorem lin_approx_compose_asn;;
let lin_approx_compose_matan = Sections.finalize_theorem lin_approx_compose_matan;;
let lin_approx_imp_add_diff = Sections.finalize_theorem lin_approx_imp_add_diff;;
let lin_approx_imp_sub_diff = Sections.finalize_theorem lin_approx_imp_sub_diff;;
let lin_approx_imp_mul_diff = Sections.finalize_theorem lin_approx_imp_mul_diff;;
let lin_approx_imp_div_diff = Sections.finalize_theorem lin_approx_imp_div_diff;;
Sections.end_section "MoreLinearApproximation";;

