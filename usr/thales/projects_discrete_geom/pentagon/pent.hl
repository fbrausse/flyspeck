(* Thomas Hales April 12, 2015 *)
(*
to load.
start loading hol light. Break out after the first few files have loaded.
then run init.hl.

*)



module Pent = struct

let i16 = mk_interval (16.0,16.0);;

let m r = mk_interval(r,r);;


let imem r i = (i.lo <= r && r <= i.hi);;

let eps = 1.0e-10;;


(* ******************************************************************************** *)
(* trig functions *)
(* ******************************************************************************** *)

let pi = 4.0 *. atan (1.0);;
let pi2 = 2.0 *. atan (1.0);;

let cos1 = cos(pi /. 5.0);;
let sin1 = sin(pi/. 5.0);;

let rho = cos1;;
let irho = m rho;;

let ee = sin1;;
let iee = m ee;;
let ff = ee /. (2.0 *. rho);;

(* critical area: *)
let adl = (1.0 +. cos1)*. (3.0 *. cos1 *. sin1) /. 2.0;;


let isqrt x = 
  mk_interval (sqrt(max 0.0 x.lo),sqrt(max 0.0 x.hi));;

let iups x1 x2 x3 = 
  two * (x1 * x2 + x2 * x3 + x3 * x1) - x1*x1 - x2*x2 - x3*x3;;

let iarea y1 y2 y3 = 
  let x1 = y1 * y1 in
  let x2 = y2 * y2 in
  let x3 = y3 * y3 in
    isqrt (iups x1 x2 x3 ) / four;;

let area y1 y2 y3 = 
  let x1 = y1 *. y1 in
  let x2 = y2 *. y2 in
  let x3 = y3 *. y3 in
  let ups = 2.0 *. (x1 *. x2 +. x2 *. x3 +. x3 *. x1) -. 
    x1*.x1 -. x2*.x2 -. x3*.x3 in
    sqrt(ups) /. 4.0;;

let areamin_acute y1 y2 y3 = 
  area y1.lo y2.lo y3.lo;;


(*
let rec isin y = 
  let _ = y.lo > -10.0 or raise Unstable in
   if y.lo < 0.0 then isin (y + m (2.0 *. pi))
   else 
     let _ = y.hi < 30.0 or raise Unstable in
       if y.hi -. y.lo >= 2.0 *. pi then mk_interval(-1.0,1.0)
       else
	 if y.hi > 4.0 *. pi +. eps then isin (y - m (2.0 *. pi))
	 else
	   let s1 = sin y.lo in
	   let s2 = sin y.hi in
	   let has1 = imem (pi /. 2.0) y or imem (5.0 *. pi /. 2.0) y in
	   let hasm = imem (3.0 *. pi /. 2.0) y or imem (7.0 *. pi /. 2.0) y in
	     mk_interval ((if hasm then -1.0 else min s1 s2),
			  (if has1 then 1.0 else max s1 s2));;
*)

let icos y = 
  if (y.lo >= 0.0 && y.hi <= pi) then mk_interval(cos y.hi,cos y.lo)
  else if (y.lo >= -. pi2 && y.hi <= 0.0) then mk_interval(cos y.lo,cos y.hi)
  else 
    let tpi = 2.0 *. pi in
    let y = y - m (tpi *. (floor (y.lo/. tpi))) in
        if (y.hi <= pi) then mk_interval(cos y.hi,cos y.lo) 
	else if (y.hi -. y.lo > pi2) then raise Unstable 
	else 
	  let c1 = cos y.hi in
	  let c2 = cos y.lo in
	  let has1 = imem (tpi) y in
	  let hasm = imem (pi2) y or imem (3.0 *. pi2) y in
	    mk_interval ((if hasm then -1.0 else min c1 c2),
			  (if has1 then 1.0 else max c1 c2));;

let isin y = icos (y - m ( pi /. 2.0 ));;

let iacos y = (* corrected may 1, 2015 *)
  let _ = y.hi >= -1.0 or raise Unstable in
  let _ = y.lo <= 1.0 or raise Unstable in
  let a1 = if y.lo <= -1.0 then pi else acos y.lo in
  let a2 = if y.hi >= 1.0 then 0.0 else acos y.hi in
    mk_interval (a2,a1);;

let iasin y = 
  (m (pi /. 2.0)) - iacos y;;

iacos (m 0.22);;

iasin (m 0.22);;


(* law of cosines *)

let iloc a b theta = 
  isqrt(a * a + b * b - two * a * b * icos (theta));;

iloc (m 0.1) (m 0.2) (m 0.3);;

let loc a b theta = 
  sqrt( a *. a +. b *. b -. 2.0 *. a *. b *. cos(theta));;

loc 0.1 0.2 0.3;;

let arc a b cop =
  acos (((a *. a) +. (b *. b) -. (cop *. cop)) /. (2.0 *. a *. b));;

let iarc a b cop = 
  iacos (((a * a) + (b*b) - (cop*cop)) / (two * a * b));;


let iarc_acute a b cop =  (* for acute triangles *)
  mk_interval(arc a.hi b.hi cop.lo, arc a.lo b.lo cop.hi);;

arc 0.1 0.2 0.1085659;;

let lawsines a alpha beta gamma = 
  let aa = a / isin alpha in
    (aa * isin beta, aa * isin gamma);;

let ilawbeta alpha a b = 
  iasin (b * isin alpha / a);;

let lawbeta alpha a b = asin (b *. sin alpha /. a);;

(m 3.0) * (ilawbeta (m (pi /. 3.0)) one one);;

ilawbeta (m 0.4) (m 1.1) (m 1.2);;
loc (1.1) (1.2)  (pi -. 0.4 -. 0.438763);;
loc (1.2) (2.101079) (0.4);;

(* ******************************************************************************** *)
(* periodizing angles of the pentagon into range -pi/5..pi/5 *)
(* ******************************************************************************** *)

(* period mod 1 *)

let periodize1 ix = 
  if (ix.hi  >= 1.0 +. ix.lo) then [mk_interval(0.0,1.0)]
  else
    let iy = ix - m (floor ix.lo) in
      if iy.hi <= 1.0 then [iy] else
	[mk_interval (iy.lo,1.0);mk_interval(0.0,iy.hi -. 1.0)];;

periodize1 (mk_interval(3.3 ,4.4 ));;
periodize1 (mk_interval(3.3 ,3.8 ));;
periodize1 (mk_interval(3.7 ,4.2 ));;
periodize1 (mk_interval(-3.7 ,-2.8 ));;

(* arbitrary period *)

let periodize ix r = 
  let r = abs_float r in
  let _ = r > eps or failwith "underflow periodize" in
    map (( * ) (m r)) (periodize1 (ix / (m r)));;

periodize (mk_interval(3.3 ,4.4 )) 0.2;;
periodize (mk_interval(3.3 ,3.35 )) 0.2;;
periodize (mk_interval(3.37 ,3.42 )) 0.2;;

(* arbitrary period, arbitrary starting point *)

let periodize_min ix r a = 
  let iy = ix - m a in
    map (( + ) (m a)) (periodize iy r);;

periodize_min (mk_interval(3.3 ,4.4 )) 0.2 0.1;;
periodize_min (mk_interval(3.37 ,3.43 )) 0.2 0.1;;
periodize_min (mk_interval(3.45 ,3.54 )) 0.2 0.1;;

(* this puts the angle in the range (-pi/5,pi/5), splitting the
angle if necessary *)
let periodize_angle = 0;;

let periodize_pent ix = 
  periodize_min ix (2.0 *. pi /. 5.0) (-. pi /. 5.0);;

periodize_pent (mk_interval (0.6,0.8));;

(* ******************************************************************************** *)
(* ******************************************************************************** *)

let ell h psi =
  let r = isqrt (h * h + irho* irho) in
  let theta = iacos (h / r) in
    isqrt (one + r * r - two * r * icos (psi + theta));;

let ellx  = 
  let mm = m (3.0 *. pi /. 10.0) in
  fun x alpha ->
    ell (iee - x) (alpha + mm);;

(* N.B.  theta has a jump discontinuity near pm pi/5, which is an inconvenience
   for the interval calculation. We try to deal with this gracefully
   by allowing theta to exceed pi/5:
   theta.hi <= pi/5 + grace. 
   
   NB. May 2, 2015: pet now puts angles in range. 
   So we now always allow theta to exceed pi/5.
*)

let thetax xalpha alpha = 
  let grace = 0.1 in 
  let h = xalpha - iee in
  let r = isqrt (h*h + irho*irho) in
  let psi = iasin (h / r) in 
  let elx = ellx xalpha alpha in 
  let yalpha = two * iee - xalpha in
  let gamma = 
    if (yalpha.lo > 0.1) then iarc r yalpha one 
    else (m pi) - iarc r xalpha one in 
  let sgnf = m (3.0 *. pi /. 10.0) + alpha + gamma - m pi in
  let sgn = if sgnf.lo >=0.0 then 1 else 
    if sgnf.hi <= 0.0 then -1 else 0 in
  let thetapp = iarc elx one r in 
  let phipp = iarc elx r one in 
  let phi = if sgn=1 then phipp else 
    if sgn= -1 then -phipp else mk_interval (-. phipp.hi,phipp.hi) in
  let theta1 = m (pi /. 5.0) + phi - psi in 
  let is_inrange  = true in
(*    
    let b1 = (theta1.lo <= pi/. 5.0) in
    let b2 = (theta1.hi <= pi/. 5.0 +. grace) in
    let _ = not(b1) or b2 or raise Unstable in
      b1 in 
*)
  let theta = if is_inrange  then theta1 else theta1 - m (2.0 *. pi /. 5.0) in
  let thetap = if sgn=1 then thetapp else 
    if sgn= -1 then -thetapp else mk_interval (-. thetapp.hi,thetapp.hi) in
    (elx,theta, thetap);;

thetax (m 0.1) (m 0.2);;
thetax (m 0.2) (m 0.19);;

let pinwheeledge alpha beta xgamma = 
  let gamma = m (pi /. 5.0) - (alpha + beta) in
  let mm = m (2.0 *. pi /. 5.0) in
  let (xalpha,xbeta) = lawsines xgamma (mm - alpha) (mm - beta) (mm - gamma) in
    ((ellx xalpha alpha), (ellx xbeta beta), (ellx xgamma gamma));;

pinwheeledge (m 0.1) (m 0.2)  (m 0.3);;

let deltajedge alpha beta xalpha = 
  let gamma = m (pi /. 5.0) - (alpha + beta) in
  let mm = m (2.0 *. pi /. 5.0) in
  let alpha' = mm - alpha in
  let beta' = mm - beta in
  let gamma' = mm - gamma in
  let (yalpha,ygamma) = lawsines (two * iee) (beta') (alpha') (gamma') in
  let xbeta = two * iee - (ygamma + xalpha) in
  let xgamma = two * iee - yalpha in
    ((ellx xalpha alpha'), (ellx xbeta beta'), (ellx xgamma gamma'));;

deltajedge (m 0.05) (m 0.06)  (m 0.1);;
iarea (m 1.94) (m 1.88) (m 1.93);;
deltajedge (m 0.0) (m 0.0) (m 0.0);;
pinwheeledge (m 0.0) (m (pi /. 5.0)) (two * iee);; (* same as deltajedge, up to symmetry *)
ellx (m 0.0) (m 0.0);;
ellx (m 0.0) (m (2.0 *. pi /. 5.0));;



let ljedge alpha beta xgamma = 
  let gamma = m (3.0 *. pi /. 5.0) - (alpha+beta) in
  let alphap = m (2.0 *. pi /. 5.0) - alpha in
  let betap = m (2.0 *. pi /. 5.0) - beta in
  let gammap = m (2.0 *. pi /. 5.0) - gamma in
  let delta1 = m (pi) - (gammap + m (2.0 *. pi /. 5.0)) in
  let delta2 = m (pi) - delta1 in
  let (x1,x2) = lawsines xgamma delta1 (m(2.0 *. pi /. 5.0)) gammap in
  let x3 = two*iee - x1 in
  let (x4,x5) = lawsines x3 betap delta2 alphap in
  let x6 = x5 - x2 in
    ((ellx x4 alpha),(ellx x6 beta),(ellx xgamma gamma));;

ljedge (m 0.1) (m 0.2)  (m 0.3);;

let ljedgealt alpha beta xalpha = 
  let gamma = m (3.0 *. pi /. 5.0) - (alpha+beta) in
  let alphap = m (2.0 *. pi /. 5.0) - alpha in
  let betap = m (2.0 *. pi /. 5.0) - beta in
  let gammap = m (2.0 *. pi /. 5.0) - gamma in
  let delta1 = m (pi) - (gammap + m (2.0 *. pi /. 5.0)) in
  let delta2 = m (pi) - delta1 in
  let (x3,x5) = lawsines xalpha delta2 betap alphap in
  let x1 = two*iee - x3 in
  let (xgamma,x2) = lawsines x1 (m(2.0 *. pi /. 5.0)) delta1 gammap in
  let x6 = x5 - x2 in
    ((ellx xalpha alpha),(ellx x6 beta),(ellx xgamma gamma));;    

let ljedgealt_full alpha beta xalpha = 
  let gamma = m (3.0 *. pi /. 5.0) - (alpha+beta) in
  let alphap = m (2.0 *. pi /. 5.0) - alpha in
  let betap = m (2.0 *. pi /. 5.0) - beta in
  let gammap = m (2.0 *. pi /. 5.0) - gamma in
  let delta1 = m (pi) - (gammap + m (2.0 *. pi /. 5.0)) in
  let delta2 = m (pi) - delta1 in
  let (x3,x5) = lawsines xalpha delta2 betap alphap in
  let x1 = two*iee - x3 in
  let (xgamma,x2) = lawsines x1 (m(2.0 *. pi /. 5.0)) delta1 gammap in
  let x6 = x5 - x2 in
    (alpha,beta,gamma,alphap,betap,gammap,x1,x2,x3,xalpha,x5,x6,
    ((ellx xalpha alpha),(ellx x6 beta),(ellx xgamma gamma)));;    


ljedgealt (m 0.1) (m 0.2) (m 0.753251);;

let tjedge alpha beta xgamma = 
  let gamma = m (pi) - (alpha + beta) in
  let alphap = m (2.0 *. pi /. 5.0) - alpha in
  let betap = m (2.0 *. pi /. 5.0) - beta in
  let gammap = m (2.0 *. pi /. 5.0) - gamma in
  let delta1 = m pi - (gammap + m (2.0 *. pi /. 5.0)) in
  let delta2 = m pi - delta1 in
  let delta3 = m pi - (alphap + delta2) in
  let delta4 = m pi - (betap + m (2.0 *. pi /. 5.0)) in
  let (x1,x2) = lawsines xgamma delta1 (m (2.0 *. pi /. 5.0)) gammap in
  let x3 = two * iee - x1 in
  let (x4, x5) = lawsines x3 delta3 delta2 alphap in
  let x6 = two * iee - (x5 - x2) in
  let (x7,x8) = lawsines x6 (m (2.0 *. pi /. 5.0)) betap delta4 in
  let x9 = x4 - x7 in
    ((ellx x9 alpha),(ellx x6 beta),(ellx xgamma gamma));;

tjedge (m 0.1) (m 0.2) (m 0.3);;

(* ******************************************************************************** *)
(* pent existence test = pet  *)
(* ******************************************************************************** *)

let rec existsany2 p l1 l2 =
  match l1 with
    [] -> false
  | (h1::t1) -> exists (p h1) l2 or existsany2 p t1 l2;;

let rec forallpair2 p l1 l2 = 
  match l1 with
      [] -> true
    | (h1::t1) -> forall (p h1) l2 && forallpair2 p t1 l2;;

let splitsign itheta = 
  if (itheta.hi <= 0.0) or (itheta.lo >= 0.0) then [itheta]
  else [mk_interval(itheta.lo, 0.0);mk_interval(0.0,itheta.hi)];;

(* iflip = ineg;; 
let iflip x =   mk_interval(-. x.hi,-. x.lo);;
*)

let inegb b x = if b then ineg x else x;;

ineg (mk_interval (-2.0,-1.0));;

let wabs = 0;;

let theta_order  itheta itheta' = 
  let s i = (i.lo < 0.0) in
(*  let fl i = inegb (s i)  in *)
  let sgnfst (i,i') = (inegb (s i) i,inegb (s i) i') in
  let reset (i,i') = 
    let neg2nd = s i' in 
    let i'' = inegb (s i') i' in 
    let i = if (i.hi > i''.hi) then mk_interval (i.lo,i''.hi) else i in
    let i'' = if i''.lo < i.lo then mk_interval (i.lo,i''.hi) else i'' in
    let _ = (icheck i && icheck i'') or failwith "interval out of range" in
      (i,i'',neg2nd) in
  let process =  reset o sgnfst in
  let (b,b') = (s itheta,s itheta') in
  let wtheta = inegb b itheta in
  let wtheta' = inegb b' itheta' in
    if wtheta.hi <= wtheta'.lo then [process ( itheta,itheta')]
    else if wtheta'.hi <= wtheta.lo then [process (itheta',itheta)]
    else [process (itheta,itheta');  process (itheta',itheta)];;
      
let case_pet_pos l (itheta,itheta'') =
  let theta'' = itheta''.hi in
  let locx th = loc l 1.0 th in
  let beta th = lawbeta th (locx th) 1.0 in
  let r th = rho /. cos (beta th +. pi/. 5.0 -. theta'' ) in
  let f th = (locx th >= r th) in
    f itheta.lo or f itheta.hi;;

let case_pet_neg l (itheta,itheta'') =
  let theta = itheta.hi in
  let locx = loc l 1.0 theta in
  let beta = lawbeta theta locx 1.0 in
  let target = pi /. 5.0 -. beta in
  let theta'' = 
    if itheta''.lo >= target then itheta''.lo
    else if itheta''.hi <= target then itheta''.hi
    else target in
  let r = rho /. cos (pi /. 5.0 -. (beta +. theta'')) in
    locx >= r;;

let pet0 l (itheta, itheta'',neg2nd) = 
  let locx = loc 1.0 l itheta.hi in
    if locx >= 1.0 then true
    else if locx <  rho then false
    else if neg2nd then case_pet_neg l (itheta,itheta'') 
    else case_pet_pos l (itheta,itheta'');;

let pet il itheta itheta' = 
  let split i = List.flatten (map splitsign  (periodize_pent i)) in
  let ithetas = split itheta in
  let ithetas' = split itheta' in
  let pet1 i i' = exists (pet0 il.hi) (theta_order i i') in
    existsany2 (pet1) ithetas ithetas';;

(* pet tests *)
Random.init 0;;
let rf a b = a +. Random.float ((b -. a)/. 2.0);;
rf 1.0 2.0;;
let ri eps = mk_interval ((rf (-. eps) 0.0), (rf 0.0 eps));;
let rin eps = 
  let neps = -. eps in
  let eps2 = neps /. 10.0 in
    mk_interval ((rf neps eps2),(rf eps2 0.0));;

let testpet _ = 
  let eps = 0.001 in
  let alpha = m (rf 0.0 (2.0 *. pi /. 5.0 -. eps)) + ri eps in
  let xalpha = m (rf 0.0 (2.0 *. ee -. eps)) + ri eps in
  let (elx,theta,theta') = thetax xalpha alpha in
  let b = pet elx theta theta' in
  let si = string_of_interval in
  let _ = b or (report ("false: x:" ^ si xalpha ^ " alpha: " ^ si alpha);true) in
    b;;

let _  = setify (map testpet (1--1000))=[true] or failwith "test pet";;

let testpet2 _ =  (* pet should fail with edge ellx shrinks a bit *)
  let eps = 0.001 in
  let alpha = m (rf 0.0 (2.0 *. pi /. 5.0)) in
  let xalpha = m (rf 0.0 (2.0 *. ee)) in
  let (elx,theta,theta') = thetax xalpha alpha in
  let elx = elx + rin eps in 
  let b = not(pet elx theta theta') in
  let si = string_of_interval in
  let _ = b or (report ("false: x:" ^ si xalpha ^ " alpha: " ^ si alpha);true) in
    b;;

let _ = setify (map testpet2 (1--1000)) = [true] or failwith "test pet2";;


(* ******************************************************************************** *)
(* split domain along largest dimension *)
(* ******************************************************************************** *)

let rec maxwidth c (i,w) = function 
  | [] -> (i,w)
  | x::xs -> 
      let t = x.hi -. x.lo in 
      let c' = Pervasives.(+) c 1 in
      if t >= w then maxwidth c' (c,t) xs else maxwidth c' (i,w) xs;;
   
let testi = [mk_interval (1.0,2.0);mk_interval(2.0,3.5);mk_interval(2.3,3.2)];;
maxwidth 0 (0,0.0) testi;;

let string_of_interval x = "("^string_of_float x.lo ^","^string_of_float x.hi^")";;
let join_semi = String.concat ";";;
let string_of_list f xs = "["^join_semi (map f xs)^"]";;

let splitlist eps xs = 
  let _ = not(xs=[]) or failwith "empty list" in
  let (i,w) = maxwidth 0 (0,0.0) xs in
  let _ = w > eps or failwith ("splitlist width" ^ string_of_float w ^ " " ^ string_of_int i ^","^string_of_list string_of_interval xs) in
  let (us,v::vs) = chop_list i xs in
  let t = (v.lo +. v.hi) /. 2.0 in
  let v1 = mk_interval(v.lo,t) in
  let v2 = mk_interval(t,v.hi) in
    (us @ (v1 :: vs)),(us @ (v2 :: vs));;
	  
splitlist 0.2 testi;;

let prepost pre post f x = 
  let ys = pre x in
  let (x1,x2) = f ys in
    (post x1,post x2);;

let split eps pre post = prepost pre post (splitlist eps);;

let rec recurser eps n onef = function
  | [] -> (n,true)
  | abx :: xs -> 
      if onef abx then recurser eps (succ n) onef xs 
	  else
	    let (a1,a2) = 
	      splitlist eps abx in
	      recurser eps (succ n) onef (a1::a2::xs);;

let recursetofinish onef = 
  let wrap3 onef abx = 
    let [a;b;x] = abx in
      onef (a,b,x) in
    recurser (1.0e-8) 0 (wrap3 onef);;

(*
let rec recursetofinish_old n onef = function
  | [] -> (n,true)
  | abx :: xs -> 
      if onef abx then recursetofinish_old (succ n) onef xs 
	  else
	    let (a1,a2) = 
	      split (1.0e-8) (fun (a,b,x)->[a;b;x]) (fun [a;b;x]->(a,b,x)) abx in
	      recursetofinish_old (succ n) onef (a1::a2::xs);;
*)

let recurseltofinish = recurser (1.0e-8) 0;;

(* add epsilon to calculations to allow a safety margin for
   floating point approximations.
*)

let ( >> ) x y = x > y +. eps;;
let ( >>> ) ix iy = ix.lo >> iy.hi;;


(* ******************************************************************************** *)
(* Set up computational instances *)
(* ******************************************************************************** *)

(*
let split_old eps pre post x = 
  let ys = pre x in
  let (us,vs) = splitlist eps ys in
    (post us,post vs);;
*)


(* test that all subcritical pinwheels have an edge > 1.72 *)

let onepinwheel172 abx = 
  let (alpha,beta,xgamma) = abx in
  if (beta.lo >> alpha.hi) then true
  else if m (pi /. 5.0) >>> (alpha + two * beta) then true
  else if zero  >>> m (pi/. 5.0) - (alpha + beta) then true
  else 
    try
    let (l1,l2,l3) = pinwheeledge alpha beta xgamma in
      if (iarea l1 l2 l3) >>> (m adl) then true
      else
	if (max l1.lo (max l2.lo l3.lo) >> 1.72) then true else false
    with | Unstable -> false;;

(*
let onelj abx = 
  let (alpha,beta,xgamma) = abx in
  let ab = alpha+beta in
    if m (pi /. 5.0) >>> ab then true
    else if ab >> m (3.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = ljedge alpha beta xgamma in
	  if (max l1.lo (max l2.lo l3.lo) >> 1.72) or ((iarea l1 l2 l3) >>> m adl) then true
	  else false
      with | Unstable -> false;;
*)

let oneljalt abx = 
  let (alpha,beta,xalpha) = abx in
  let ab = alpha+beta in
    if m (pi /. 5.0) >>> ab then true
    else if ab >>> m (3.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = ljedgealt alpha beta xalpha in
	  if (max l1.lo (max l2.lo l3.lo) >> 1.72) or ((iarea l1 l2 l3) >>> m adl) then true
	  else false
      with | Unstable -> false;;

let oneljalt abx = 
  let (alpha,beta,xalpha) = abx in
  let ab = alpha+beta in
    if m (pi /. 5.0) >>> ab then true
    else if ab >>> m (3.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = ljedgealt alpha beta xalpha in
	  if (max l1.lo (max l2.lo l3.lo) >> 1.72) or ((iarea l1 l2 l3) >>> m adl) then true
	  else false
      with | Unstable -> false;;

(* non anonaly test JJZ area > 1.345 *)

let oneJJZ abx = 
  let (alpha,beta,xalpha) = abx in
  let ab = alpha+beta in
    if m (pi /. 5.0) >>> ab then true
    else if ab >>> m (3.0 *. pi /. 5.0) then true
    else
      try
	let     (_,_,gamma,alphap,betap,gammap,x1,x2,x3,_,x5,x6,
		 (l1,l2,l3)) = ljedgealt_full alpha beta xalpha in
	  if (iarea l1 l2 l3 >>> m 1.345) or (x6 >>> iee) or (iee >>> x6) then true
	  else false
      with | Unstable -> false;;


let onetj abx = 
  let (alpha,beta,xgamma) = abx in
  let ab = alpha+beta in
    if m (3.0 *. pi /. 5.0) >>> ab then true
    else if ab >>> m (4.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = tjedge alpha beta xgamma in
	  if (max l1.lo (max l2.lo l3.lo) >> 1.72) or ((iarea l1 l2 l3) >>> m adl) then true
	  else false
      with | Unstable -> false;;


(* returns true, so that all subcritical pinwheels have an edge > 1.72 *)

mktest ("onepinwheel172",fun () ->
	  time (recursetofinish onepinwheel172) 
	    [[(mk_interval (0.0,pi/. 5.0)); 
	      (mk_interval(0.0,pi/. 5.0) ); 
	      (mk_interval (0.0,2.0*. sin1))]]);;

(*
recursetofinish onelj [(mk_interval (0.0,2.0 *. pi/. 5.0)), (mk_interval(0.0,0.96) ), (mk_interval (0.0,2.0*. sin1))];;
*)

mktest ("oneljalt",fun() -> 
	  recursetofinish oneljalt 
	    [[(mk_interval (0.0,2.0 *. pi/. 5.0)); 
	      (mk_interval(0.0,2.0 *. pi /. 5.0) ); 
	      (mk_interval (0.0,2.0*. sin1))]]);;

mktest ("oneJJZ",fun() ->
	  recursetofinish oneJJZ 
	    [[(mk_interval (0.0,2.0 *. pi/. 5.0)); 
	      (mk_interval(0.0,2.0 *. pi /. 5.0) );  
	      (m (2.0*. sin1))]]);;

mktest ("onetj",fun() -> recursetofinish onetj 
	  [[(mk_interval (pi/. 5.0,2.0 *. pi/. 5.0)); 
	    (mk_interval(pi/. 5.0,2.0 *. pi /. 5.0) ); 
	    (mk_interval (0.0,2.0*. sin1))]]);;


(*
let (l1,l2,l3) = ljedgealt (m 1.0127) (m 0.0) (m 1.1755) in
  iarea l1 l2 l3;;

let abx = (m 0.0785398069771), (m 0.549778705016), (m 0.827671209719);;
onelj abx;;
ljedge (m 0.0785398069771) (m 0.549778705016) (m 0.827671209719);;
*)

(* next: absolute area minimization *)

let amin = 1.237;;

let onepinwheelabsmin abx = 
  (* symmetry reductions *)
  let (alpha,beta,xgamma) = abx in
  if (beta >>> alpha) then true
  else if m (pi /. 5.0) >>> (alpha + two * beta) then true
  else if zero  >>> m (pi/. 5.0) - (alpha + beta) then true
  else 
    try
    let (l1,l2,l3) = pinwheeledge alpha beta xgamma in
      ((areamin_acute l1 l2 l3) >> amin)
    with | Unstable -> false;;

(* 1041153 cases, 51 sec. before revision *)
(* 65645 cases, 2.77 secs after revision of area *)

mktest ("onepinwheelabsmin",fun() ->
	  time (recursetofinish onepinwheelabsmin) 
	    [[(mk_interval (0.0,pi/. 5.0)); 
	      (mk_interval(0.0,pi/. 5.0) ); 
	      (mk_interval (0.0,2.0*. sin1))]]);;


let onedeltajamin abx = 
  let (alpha,beta,xalpha) = abx in
  if (beta >>> alpha) then true
  else if (alpha + beta)  >>> m (pi/. 5.0) then true
  else 
    try
    let (l1,l2,l3) = deltajedge alpha beta xalpha in
      ((areamin_acute l1 l2 l3) >> 1.5)
    with | Unstable -> false;;

mktest ("onedeltajmin",fun() ->
	  (recursetofinish onedeltajamin) 
	    [[(mk_interval (0.0,pi/. 5.0)); 
	      (mk_interval(0.0,pi/. 5.0) ); 
	      (mk_interval (0.0,2.0*. (ee -. ff)))]]);;

let ljedge = 0;;

let oneljamin abx = 
  let (alpha,beta,xalpha) = abx in
  let ab = alpha+beta in
    if m (pi /. 5.0) >>> ab then true
    else if ab >>> m (3.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = ljedgealt alpha beta xalpha in
	  ((areamin_acute l1 l2 l3) >>  amin) 
      with | Unstable -> false;;

(* 346263 cases, 18 seconds *)

mktest ("oneljamin",fun() ->
	time (recursetofinish oneljamin) 
	  [[(mk_interval (0.0,2.0 *. pi/. 5.0)); 
	    (mk_interval(0.0,2.0 *. pi /. 5.0) ); 
	    (mk_interval (0.0,2.0*. sin1))]]);;

let onetjamin abx = 
  let (alpha,beta,xgamma) = abx in
  let ab = alpha+beta in
    if m (3.0 *. pi /. 5.0) >>> ab then true
    else if ab >>> m (4.0 *. pi /. 5.0) then true
    else
      try
	let (l1,l2,l3) = tjedge alpha beta xgamma in
	  ((areamin_acute l1 l2 l3) >> amin) 	  
      with | Unstable -> false;;

(* 3406713 cases old iarea function. Now 167221 cases. *)

mktest ("onetjamin",fun() ->
	  recursetofinish onetjamin 
	    [[(mk_interval (pi/. 5.0,2.0 *. pi/. 5.0)); 
	      (mk_interval(pi/. 5.0,2.0 *. pi /. 5.0) ); 
	      (mk_interval (0.0,2.0*. sin1))]]);;

end;;
