(* ========================================================================= *)
(* FLYSPECK - BOOK FORMALIZATION                                             *)
(*                                                                           *)
(* Chapter: nonlinear inequalities                                           *)
(* Author:  Thomas Hales      *)
(* Date: 2015-12-22                                                          *)
(* ========================================================================= *)



(* C++ generation of code to test auto_lib.hl.

This code used to be part of auto_lib.hl, but it was separated out
to make a clean separation of the informal code from the rest of the project.

*)

module Test_auto_lib = struct

open Auto_lib;;

let tmpfile = flyspeck_dir^"/../informal_code/interval_code/test_auto.cc";;

let interval_code =
  f0_code  ^ f6to6_code ^ f6_code ^ fn_code^
  testing_code;;

(* based on optimize, but is enhanced with autogenerated code interval_code.  *)

let mkfile_code t s tags  = 
  let cpp_header = Optimize.cpp_header() in
  let cpp_tail = Optimize.cpp_tail() in
  let isquad = Optimize.is_quad_cluster tags in
  let p = if isquad then Optimize.mk_cppq_proc else Optimize.mk_cpp_proc in
  Flyspeck_lib.output_filestring tmpfile
   (join_lines [cpp_header;interval_code;(p t s tags);cpp_tail]);;

(*
let testid = "9563139965 d";;

let idq = hd(Ineq.getexact testid);;

let [(_,tags,post)] = Optimize.preprocess_split_idq idq;;

mkfile_code false post testid tags;;
*)

(* 
   This is an enhanced version of what is in optimize.hl.
   It uses mkfile_code, which adds autogenerated interval_code to what is in Optimize.mkfile_cppq.
*)

let execute_interval ex tags s testineq = 
  let interval_dir = flyspeck_dir^"/../informal_code/interval_code" in
  let _ = mkfile_code testineq s tags in
  let _ = Optimize.compile_cpp() in 
  let _ =  (not ex) or  (0=  Sys.command(interval_dir^"/test_auto")) or 
    failwith "interval execution error" in
    ();;

let testsplit_idq ex idq = 
  let splits = Optimize.preprocess_split_idq idq in
    map (fun (s,tags,testineq) -> execute_interval ex tags s testineq) splits;;

let testsplit ex s = testsplit_idq ex (hd (Ineq.getexact s));;


(* *************************************************************************** *)
(* Prep.prep_ineqs cases. *)
(* no further processing for these. *)
(* *************************************************************************** *)

let test_noprocessing_idq ex idq = 
  let (s,tags,testineq) = Optimize.idq_fields idq in
    execute_interval ex tags s testineq;;

(* let ineqs = !Prep.pre_ineqs *)

let test_prep ineqs ex s = 
  let idq = filter (fun idq -> idq.idv = s) ineqs in
    test_noprocessing_idq ex (hd idq);;

let test_prep_case_split ineqs ex (s,case,t) =
  let s' = Printf.sprintf "%s split(%d/%d)" s case t in
(*  let _ = Sys.command("sleep 3") in *)
    test_prep ineqs ex s';;




end;;

