(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Nonlinear                                                  *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2014-06-09                                                           *)
(* ========================================================================== *)

(*


*)

(* Load the build.hl up through the file merge_ineq.hl, then add the following *)

flyspeck_needs "general/serialization.hl";;
flyspeck_needs "nonlinear/prep.hl";; (* slow to load *)
flyspeck_needs "nonlinear/scripts.hl";;
flyspeck_needs "nonlinear/break_case_type.hl";;
flyspeck_needs "nonlinear/break_case_log.hl";;
flyspeck_needs "nonlinear/break_case_exec.hl";;

(* 

This uses the data from break_case_log.hl to create a collection of
terms with small domains that can in principle be verified in a short amount.



We then need to run the 5070 independent inequalities obtained as
Break_case_exec.get_nth case_number
as case_number ranges from 0 to 5069.
Each process only needs to work with a single case_number.

The C++ times are all around 1sec, giving an expected time of 2000-3000 secs in
the formally verified mode.  If they are taking much longer than this, kill the
jobs and I'll rework them.

The exact term returned by Break_case_exec.get_nth needs to be converted to a thm
by the nonlinear inequality prover.  If th is the theorem,
the data saved out to storage should contain at least the following information.

(case_number,Serialization.full_digest_thm th).

the function full_digest_thm is the Md5 digest of the theorem as a hexadecimal string.
It is not necessary to save the theorem itself out to storage in any way.  The Md5 digest suffices.

It would be useful to have additional information as well to help check answers later 
such as timestamps, OS, svn versions of HOL Light and Flyspeck, version of OCaml, etc.

Comments:

1. In the terms to be proved, I have left in the assumption 
`&0 < delta_x x1 x2 x3 x4 x5 x6 /\
    &0 < x1 /\
    &0 < x2 /\
    &0 < x3 /\
    &0 < x4 /\
    &0 < x5 /\
    &0 < x6`

in each inequality.  The inequalities are true without the assumption, but I left it in, thinking
that it might be useful to you.  If it doesn't help, throw it out.

2. ineq_conv does some initial expanding of definitions.
Most of the relevant definitions for expansion
appear in general/sphere.hl, a few others are in nonlinear/nonlin_def.

Nonlin_def.halfbump_x1;;
Nonlin_def.halfbump_x;;
Sphere.bump;;
Nonlin_def.unit6;;
Nonlin_def.sqrt_x1;;
Nonlin_def.sqrt_x2;; etc.

For lfun, rewrite with
Functional_equation.functional1_lfun;;

3.  Once you have the theorems, I'll attempt a reconstruction of the pieces.

======================================================================
June 14, 2014

I have a new batch of inequalities that are ready to be verified.
This batch represents 23.5% of the total nonlinear inequalities in terms
of runtime.  The inequalities are all well-behaved over the entire domain
for computations with delta_x.  (It is always positive whenever it appears
in a denominator, sqrt, or atn.)

The code is in the same file as before: break_case_exec.hl

There are 6200 cases.  The terms to be verified are generated by
Break_case_exec.get_nth_delta j
as j ranges from 0 to 6199.

There are many more functions in this batch.
I have lists of theorems
Break_case_exec.rational_expansions;
Break_case_exec.sqrt_expansions;
Break_case_exec.trig_expansions1;
Break_case_exec.trig_expansions;
that give a good way to rewrite the functions down to the level of the
basic real constants and primitive univariate functions.  In general,
these theorems should perform better than the definitions.

The primitive univariate functions that come up are
"sqrt";"atn";"sin";"cos";"acs";"asn";"matan"

I'm not sure if you have implemented the matan function.
For x > 0, matan x = atn (sqrt x)/(sqrt x).  This function has an
analytic continuation extending it to x > -1.  The implementation
of the needed calculations of matan and its derivatives
in C++ are in the file interval_code/univariate.cc lines 369 ++.
The approximations used there work well in practice on the given
inequalities.


*)

module Experimental_oxl_run = struct

(*
  Break_case_exec.ineq_conv (Break_case_exec.get_nth 3);;
*)

(* Modify inequalities returned by Break_case_exec.get_nth as follows:
   1) Remove the assumption &0 < delta_x x1 x2 x3 x4 x5 x6 /\ ...
   2) Rewrite with |- const1 = sol0 / pi
*)

  let remove_assumptions ineq =
    let ltm, rtm = dest_comb ineq in
      mk_comb (ltm, rand rtm);;

    let get_ineq i =
      let name, case = List.nth Break_case_exec.all_oxl_parameters i in
      let ineq0 = Break_case_exec.get_nth i in
      let ineq1 = remove_assumptions ineq0 in
      let ineq2 = (rand o concl o REWRITE_CONV[SYM Nonlinear_lemma.sol0_over_pi_EQ_const1]) ineq1 in
	name, case, ineq2;;
	
(*
   Save string representations of inequalities in a file.
*)
    let get_and_save sep fname cases =
      let out = open_out fname in
      let p = Pervasives.output_string out in
      let rec save_all cases =
	match cases with
	  | [] -> ()
	  | c :: cs ->
	      let _ = print_endline (Printf.sprintf "Case: %d\n" c) in
	      let _ =
		try
		  let name, case, ineq = get_ineq c in
		  let str = string_of_term ineq in
		  let str = Str.global_replace (Str.regexp "\n") " " str in
		  let str = Str.global_replace (Str.regexp "--#") "-- #" str in
		  let str = Printf.sprintf "%d: (%s,%d): %s%s" c name case str sep in
		    p str
		with Failure msg ->
		  print_endline ("FAILURE: " ^ msg);
		  p (Printf.sprintf "%d: FAILURE%s" c sep) in
		save_all cs 
      in
      let _ = save_all cases in
      let _ = close_out out in
	();;

    let save_all() = get_and_save "\n" "oxl.txt" (0--7271);;

end;;

