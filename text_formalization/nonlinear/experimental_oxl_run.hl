(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Nonlinear                                                  *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2014-06-09                                                           *)
(* ========================================================================== *)

(*


*)

(* Load the build.hl up through the file merge_ineq.hl, then add the following *)

flyspeck_needs "general/serialization.hl";;
flyspeck_needs "nonlinear/prep.hl";; (* slow to load *)
flyspeck_needs "nonlinear/scripts.hl";;
flyspeck_needs "nonlinear/break_case_type.hl";;
flyspeck_needs "nonlinear/break_case_log.hl";;
flyspeck_needs "nonlinear/break_case_exec.hl";;

(* 

This uses the data from break_case_log.hl to create a collection of
terms with small domains that can in principle be verified in a short amount.



We then need to run the 5070 independent inequalities obtained as
Break_case_exec.get_nth case_number
as case_number ranges from 0 to 5069.
Each process only needs to work with a single case_number.

The C++ times are all around 1sec, giving an expected time of 2000-3000 secs in
the formally verified mode.  If they are taking much longer than this, kill the
jobs and I'll rework them.

The exact term returned by Break_case_exec.get_nth needs to be converted to a thm
by the nonlinear inequality prover.  If th is the theorem,
the data saved out to storage should contain at least the following information.

(case_number,Serialization.full_digest_thm th).

the function full_digest_thm is the Md5 digest of the theorem as a hexadecimal string.
It is not necessary to save the theorem itself out to storage in any way.  The Md5 digest suffices.

It would be useful to have additional information as well to help check answers later 
such as timestamps, OS, svn versions of HOL Light and Flyspeck, version of OCaml, etc.

Comments:

1. In the terms to be proved, I have left in the assumption 
`&0 < delta_x x1 x2 x3 x4 x5 x6 /\
    &0 < x1 /\
    &0 < x2 /\
    &0 < x3 /\
    &0 < x4 /\
    &0 < x5 /\
    &0 < x6`

in each inequality.  The inequalities are true without the assumption, but I left it in, thinking
that it might be useful to you.  If it doesn't help, throw it out.

2. ineq_conv does some initial expanding of definitions.
Most of the relevant definitions for expansion
appear in general/sphere.hl, a few others are in nonlinear/nonlin_def.

Nonlin_def.halfbump_x1;;
Nonlin_def.halfbump_x;;
Sphere.bump;;
Nonlin_def.unit6;;
Nonlin_def.sqrt_x1;;
Nonlin_def.sqrt_x2;; etc.

For lfun, rewrite with
Functional_equation.functional1_lfun;;

3.  Once you have the theorems, I'll attempt a reconstruction of the pieces.

======================================================================
June 14, 2014

I have a new batch of inequalities that are ready to be verified.
This batch represents 23.5% of the total nonlinear inequalities in terms
of runtime.  The inequalities are all well-behaved over the entire domain
for computations with delta_x.  (It is always positive whenever it appears
in a denominator, sqrt, or atn.)

The code is in the same file as before: break_case_exec.hl

There are 6200 cases.  The terms to be verified are generated by
Break_case_exec.get_nth_delta j
as j ranges from 0 to 6199.

There are many more functions in this batch.
I have lists of theorems
Break_case_exec.rational_expansions;
Break_case_exec.sqrt_expansions;
Break_case_exec.trig_expansions1;
Break_case_exec.trig_expansions;
that give a good way to rewrite the functions down to the level of the
basic real constants and primitive univariate functions.  In general,
these theorems should perform better than the definitions.

The primitive univariate functions that come up are
"sqrt";"atn";"sin";"cos";"acs";"asn";"matan"

I'm not sure if you have implemented the matan function.
For x > 0, matan x = atn (sqrt x)/(sqrt x).  This function has an
analytic continuation extending it to x > -1.  The implementation
of the needed calculations of matan and its derivatives
in C++ are in the file interval_code/univariate.cc lines 369 ++.
The approximations used there work well in practice on the given
inequalities.


*)

module Experimental_oxl_run = struct

(*
  Break_case_exec.ineq_conv (Break_case_exec.get_nth 3);;
*)

(* 
   Modify inequalities returned by Break_case_exec.get_nth as follows:
   1) Remove the assumption &0 < delta_x x1 x2 x3 x4 x5 x6 /\ ...
*)

  let remove_assumptions ineq =
    let ltm, rtm = dest_comb ineq in
      mk_comb (ltm, rand rtm);;
  
  let get_oxl_ineq i =
    let name, case = List.nth Break_case_exec.all_oxl_parameters i in
    let ineq0 = Break_case_exec.get_nth i in
      name, case, ineq0;;

(*  
  let get_delta_ineq i =
    let name, case = List.nth Break_case_exec.all_delta_ok_parameters i in
    let ineq0 = Break_case_exec.get_nth_delta i in
      name, case, ineq0;;
*)

  let get_ineq i =
    let name, case = List.nth Break_case_exec.all_parameters i in
    let ineq0 = Break_case_exec.get_nth i in
      name, case, ineq0;;

(*
  Save string representations of inequalities in a file.
  sep - a separator between strings
  fname_true - an output file name for cases with check = true
  fname_false - an output file name for cases with check = false
  get_ineq - get_ineq i returns the i-th case inequality and its id
  check - tests a given inequality; the inequality is saved if the test is successful
  cases - a list of cases (numbers)
*)
  let get_and_save sep fname_true fname_false get_ineq check cases =
    let verbose_saved = !verbose in
    let _ = verbose := false in
    let n_true = ref 0 and
	n_false = ref 0 in
    let out_true = open_out fname_true and
	out_false = open_out fname_false in
    let p_true = Pervasives.output_string out_true and
	p_false = Pervasives.output_string out_false in
    let rec save_all cases =
      match cases with
	| [] -> ()
	| c :: cs ->
	    let _ = print_endline (Printf.sprintf "Case: %d" c) in
	    let _ =
	      try
		let name, case, ineq = get_ineq c in
		let str = string_of_term ineq in
		let str = Str.global_replace (Str.regexp "\n") " " str in
		let str = Str.global_replace (Str.regexp "--#") "-- #" str in
		  if check ineq then
		    let str = Printf.sprintf "%d: %d,(%s,%d): %s%s" 
		      !n_true c name case str sep in
		      incr n_true; p_true str
		  else
		    let str = Printf.sprintf "%d: %d,(%s,%d): %s%s" 
		      !n_false c name case str sep in
		      incr n_false; p_false str
	      with Failure msg ->
		let str = Printf.sprintf "%d: (%d): FAILURE%s" !n_true c sep in
		  print_endline ("FAILURE: " ^ msg);
		  incr n_true;
		  p_true str in
	      save_all cs 
    in
      save_all cases;
      close_out out_true;
      close_out out_false;
      verbose := verbose_saved;;
  
  let save_all_oxl() = get_and_save "\n" "oxl.txt" "oxl_false.txt" get_oxl_ineq (fun _ -> true) (0--7271);;

(*
  let save_all_delta() = get_and_save "\n" "delta.txt" "delta_false.txt" get_delta_ineq (fun _ -> true)  (0--6199);;
*)

  let rec get_constants tm =
    match tm with
      | Const (name, _) -> [name]
      | Comb (a, b) -> union (get_constants a) (get_constants b)
      | Abs (_, b) -> get_constants b
      | Var _ -> [];;

  let check_ineq =
    let rewrite = REWRITE_CONV (map snd Break_case_exec.rational_expansions @
				  map snd Break_case_exec.sqrt_expansions @
 				  map snd Break_case_exec.trig_expansions1 @
				  map snd Break_case_exec.trig_expansions) in
    let names = ["sin"; "cos"; "asn"; "matan"] in
      fun ineq_tm ->
	let tm0 = (rand o concl o rewrite) ineq_tm in
	let cs = get_constants tm0 in
	let r = intersect names cs in
	  r = [];;
	    
  let check_ineqs get_ineq check cases =
    let rec test cs =
      match cs with
	| [] -> ()
	| c :: cs ->
	    let _, _, ineq = get_ineq c in
	    let r = check ineq in
	    let str = Printf.sprintf "%d: %b" c r in
	    let _ = print_endline str in
	      test cs in
      test cases;;

(*
  let save_all_delta2() = get_and_save "\n" "delta1.txt" "delta2.txt" get_delta_ineq check_ineq  (0--6199);;
*)

  let save0() = get_and_save "\n" "ineqs0.txt" "ineqs0_trig.txt" get_ineq check_ineq
    (0--7271);;

  let save1() = get_and_save "\n" "ineqs1.txt" "ineqs1_trig.txt" get_ineq check_ineq 
    (7272--(7272+6199));;

  let save2() = get_and_save "\n" "ineqs2.txt" "ineqs2_trig.txt" get_ineq check_ineq 
    ((7272+6200)--23241);;

  
(* check_ineqs get_delta_ineq check_ineq (6000--6020);;
   get_delta_ineq 6005;; *)

end;;

