(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Nonlinear                                                         *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2012-06-08                                                           *)
(* ========================================================================== *)

(*

There are many nonlinear inequalities in the database, which have
been broken into pieces to simplify verification.  However, the text
"Dense Sphere Packings" uses the inequalities in a merged formed that
combine many separate pieces.  Here we merge the inequalities
into the form used in the text.

In particular the 5*46 inequalities of nonlinear/ineqdata3q1h.hl have
been merged into a single inequality: ox3q1h_merge (in 13 variables).
The assumption ox3q1h is the conjunction of these 230 inequalities.

This file is rather slow to load because it processes hundreds of
inequalities.
*)



flyspeck_needs "nonlinear/ineqdata3q1h.hl";;

module Merge_ineq = struct

(* ========================================================================== *)
(* Merge ineqdata3q1h.hl into a single inequality *)
(* ========================================================================== *)

let idq_of_string s = hd(Ineq.getexact s);;

(* idq_of_string "OXLZLEZ 6346351218 1 18";; *)


(* merge the inequalities in ineqdata3q1h.hl *)

let ox n i = 
  (idq_of_string (Printf.sprintf "OXLZLEZ 6346351218 %d %d" i n)).ineq;;

let tm0 n = ox n 0;;
let tm1 n = ox n 1;;
let tm2 n = ox n 2;;
let tm3 n = ox n 3;;
let tm4 n = ox n 4;;

let numcases = List.length Ineqdata3q1h.records;;

let ox_conj n = end_itlist (curry mk_conj) [tm0 n;tm1 n;tm2 n;tm3 n;tm4 n];;
let ox3q1h_term() =  
  end_itlist (curry mk_conj) (map ox_conj (0--(numcases-1)));;
let ox3q1h() =  new_definition (mk_eq (`ox3q1h:bool`,ox3q1h_term()));;
let ox3q1h_mp = MP_TAC(ox3q1h());;

let [yv;a12;a23;a34;a14;b12;b23;b34;b14;c1;c2;c3;c4] = 
  map (fun t -> mk_var(t,`:real`))
    (Str.split (Str.regexp " ")
       "y a12 a23 a34 a14 b12 b23 b34 b14 c1 c2 c3 c4");;

let y12 = `(a12 + b12)/ &2`;;
let y23 = `(a23 + b23)/ &2`;;
let y34 = `(a34 + b34)/ &2`;;
let y41 = `(a14 + b14)/ &2`;;

let specl x = concl o (SPECL x) o ASSUME;;
let spec1 = specl[yv;a12;a14;c1;b14;b12];;
let spec2 = specl[yv;a23;a12;c2;b12;b23];;
let spec3 = specl[yv;a34;a23;c3;b23;b34];;
let spec4 = specl[yv;a14;a34;c4;b14;b34];;
let spec0 = specl[yv;y12;y23;y34;y41];;
let in1 n  = spec1 (tm1 n);;
let in2 n = spec2 (tm2 n);;
let in3 n = spec3 (tm3 n);;
let in4 n = spec4  (tm4 n);;
let in0 n = spec0  (tm0 n);;

(* labels: y=spine, aij lower edge shared between i & j. bij = top edge.
   ci = edge opp spine on simplex i *)
prioritize_real();;

(*
let getinstantiation = 
  let concl1 = ` (gamma4fgcy y1 y2 y3 y4 y5 y6 lmfun / w +
		    cb * beta_bump_force_y y1 y2 y3 y4 y5 y6 +
        cd * dih_y y1 y2 y3 y4 y5 y6 +
        cy * y1 +
        cab * (y2 + y3 + y5 + y6) +
        cc >
        &0)` in
  fun in2 -> 
    let u =  hd(tl(snd (strip_comb in2))) in
      (term_match [] (concl1)) u;;
*)

let combinator_lemma = 
  prove_by_refinement(`!cd cy1 cy2 cy3 cy4 cab1 cab2 cab3 cab4 cc1 cc2 cc3 cc4.
   ((dih_y y a12 a14 c1 b14 b12 +
      dih_y y a23 a12 c2 b12 b23 +
      dih_y y a34 a23 c3 b23 b34 +
      dih_y y a14 a34 c4 b14 b34 =
      &2 * pi) /\ (&2 * pi * cd +
 (cy1 + cy2 + cy3 + cy4) * y +
 &2 * (cab1 + cab2) * (a12 + b12) / &2 +
 &2 * (cab2 + cab3) * (a23 + b23) / &2 +
 &2 * (cab3 + cab4) * (a34 + b34) / &2 +
 &2 * (cab4 + cab1) * (a14 + b14) / &2 +
 cc1 +
 cc2 +
 cc3 +
 cc4 <
 &0) /\ ( gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 +
     &1 * beta_bump_force_y y a12 a14 c1 b14 b12 +
     cd * dih_y y a12 a14 c1 b14 b12 +
     cy1 * y +
     cab1 * (a12 + a14 + b14 + b12) +
     cc1 >
     &0) /\ 
   (gamma4fgcy y a23 a12 c2 b12 b23 lmfun / &1 +
     &0 * beta_bump_force_y y a23 a12 c2 b12 b23 +
     cd * dih_y y a23 a12 c2 b12 b23 +
     cy2 * y +
     cab2 * (a23 + a12 + b12 + b23) +
     cc2 > &0) /\
   (gamma4fgcy y a34 a23 c3 b23 b34 lmfun / &1 +
     &0 * beta_bump_force_y y a34 a23 c3 b23 b34 +
     cd * dih_y y a34 a23 c3 b23 b34 +
     cy3 * y +
     cab3 * (a34 + a23 + b23 + b34) +
     cc3 >
     &0) /\
    (gamma4fgcy y a14 a34 c4 b14 b34 lmfun / &1 +
     &0 * beta_bump_force_y y a14 a34 c4 b14 b34 +
     cd * dih_y y a14 a34 c4 b14 b34 +
     cy4 * y +
     cab4 * (a14 + a34 + b14 + b34) +
     cc4 >
     &0) ==> 
    (  gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 +
     beta_bump_force_y y a12 a14 c1 b14 b12 +
     gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
     gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
     gamma4fgcy y a14 a34 c4 b14 b34 lmfun >
     &0 
     ))`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  REPEAT(FIRST_X_ASSUM_ST `gamma4fgcy` MP_TAC);
  MATCH_MP_TAC (arith `(a + b+c+d - e < &0)   ==> ((a > &0) ==> (b > &0) ==> (c > &0) ==> (d > &0) ==> (e> &0))`);
  FIRST_X_ASSUM MP_TAC;
  MATCH_MP_TAC (arith `(t = e) ==> ((t< &0) ==> (e < &0))`);
  REWRITE_TAC[arith `&2 * pi * cd = (&2 * pi) * cd`];
  FIRST_X_ASSUM (fun t -> SUBST1_TAC (SYM t));
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)


let template_OX = `!in0 in1 in2 in3 in4
  y' y''
  c1' c1'' c2' c2'' c3' c3'' c4' c4''
  a12' a12'' a23' a23'' a34' a34'' a14' a14''
  b12' b12'' b23' b23'' b34' b34'' b14' b14''.
  (in0 /\ in1 /\ in2 /\ in3 /\ in4) ==>
  ineq [(y',y,y'');
   (c1',c1,c1'');
   (c2',c2,c2'');
   (c3',c3,c3'');
   (c4',c4,c4'');
   (a12',a12,a12'');
   (a23',a23,a23'');
   (a34',a34,a34'');
   (a14',a14,a14'');
   (b12',b12,b12'');
   (b23',b23,b23'');
   (b34',b34,b34'');
   (b14',b14,b14'')
   ]
  ((dih_y y a12 a14 c1 b14 b12  + 
  dih_y y a23 a12 c2 b12 b23  +
  dih_y y a34 a23 c3 b23 b34  +
  dih_y y a14 a34 c4 b14 b34 = &2 * pi) ==>
  (gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 + 
  beta_bump_force_y y a12 a14 c1 b14 b12 +
  gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
  gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
  gamma4fgcy y a14 a34 c4 b14 b34 lmfun > &0))`;;

let template_OX2 = `!
  y' y''
  c1' c1'' c2' c2'' c3' c3'' c4' c4''
  a12' a12'' a23' a23'' a34' a34'' a14' a14''
  b12' b12'' b23' b23'' b34' b34'' b14' b14''.
  ox3q1h ==>
  ineq [(y',y,y'');
   (c1',c1,c1'');
   (c2',c2,c2'');
   (c3',c3,c3'');
   (c4',c4,c4'');
   (a12',a12,a12'');
   (a23',a23,a23'');
   (a34',a34,a34'');
   (a14',a14,a14'');
   (b12',b12,b12'');
   (b23',b23,b23'');
   (b34',b34,b34'');
   (b14',b14,b14'')
   ]
  ((dih_y y a12 a14 c1 b14 b12  + 
  dih_y y a23 a12 c2 b12 b23  +
  dih_y y a34 a23 c3 b23 b34  +
  dih_y y a14 a34 c4 b14 b34 = &2 * pi) ==>
  (gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 + 
  beta_bump_force_y y a12 a14 c1 b14 b12 +
  gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
  gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
  gamma4fgcy y a14 a34 c4 b14 b34 lmfun > &0))`;;


let dest_triple x = 
  let (a,b) = dest_pair x in
  let (b,c) = dest_pair b in (b,(a,c));;

let getbounds tm =
  let xx1 = hd(snd(strip_comb tm)) in
  let xx2 = dest_list xx1 in
    map dest_triple xx2;;

let allbounds n = setify(List.flatten (map getbounds [in1 n;in2 n;in3 n;in4 n]));;

let goal_OX n = 
  let g1 = specl [in0 n;in1 n;in2 n;in3 n;in4 n] template_OX in
  let a = C assoc (allbounds n) in
  let s1 v g = 
    let (v',v'')  = a v in
      specl [v';v''] g in
    itlist s1 (List.rev [yv;c1;c2;c3;c4;a12;a23;a34;a14;b12;b23;b34;b14]) g1;;

let goal_OX2 n = 
  let g1 = template_OX2 in
  let a = C assoc (allbounds n) in
  let s1 v g = 
    let (v',v'')  = a v in
      specl [v';v''] g in
    itlist s1 (List.rev [yv;c1;c2;c3;c4;a12;a23;a34;a14;b12;b23;b34;b14]) g1;;


let mk13ner n = prove_by_refinement(
  goal_OX n,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.ineq];
  REPEAT STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `/\` MP_TAC);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[arith `a <= b /\ a <= c ==> a <= (b + c)/ &2`; arith `b <= a /\ c <= a ==> (b + c)/ &2 <= a` ];
  FIRST_X_ASSUM_ST `dih_y` MP_TAC;
  REWRITE_TAC[TAUT `(a ==> b==>c ==>d==>e==>f==>g)<=>(a /\ b /\ c /\ d/\ e /\ f ==>g)`];
  DISCH_THEN (fun t -> ASSUME_TAC (MATCH_MP combinator_lemma t));
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mk_ox3q1h n = prove_by_refinement(
  goal_OX2 n,
  (* {{{ proof *)
  [
 REPEAT WEAK_STRIP_TAC;
  MATCH_MP_TAC (mk13ner n);
  BY(BY(ox3q1h_mp THEN ASM_REWRITE_TAC[] THEN REPEAT WEAK_STRIP_TAC THEN ASM_REWRITE_TAC[]))
  ]);;
  (* }}} *)

let ox3q1h_46() = map mk_ox3q1h (0--(numcases-1));;

(* now start combining inequalities from ineqdata31h.hl *)


let ineq_APPEND = prove_by_refinement(
  `!v f u. ineq (APPEND u v) f = ineq u (ineq v f)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  GEN_TAC;
  LIST_INDUCT_TAC;
    REWRITE_TAC[APPEND];
    BY(REWRITE_TAC[APPEND;Sphere.ineq]);
  REWRITE_TAC[APPEND;Sphere.ineq];
  SUBGOAL_THEN `?(a:real) (b:real) (c:real). h = (a,b,c)` MP_TAC;
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAK_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Sphere.ineq];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let pathL_pathR = prove_by_refinement(
  `!c x.
    (FST c <= x /\ x <= SND c) <=> (
      (FST(pathL c) <= x /\ x <= SND(pathL c)) \/
      (FST(pathR c) <= x /\ x <= SND(pathR c)))
`,
  (* {{{ proof *)
  [
  REPEAT STRIP_TAC;
  SUBGOAL_THEN `?(a:real) (b:real). c = (a,b)` MP_TAC;
    BY(REWRITE_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAK_STRIP_TAC;
  ASM_REWRITE_TAC[Sphere.pathL;Sphere.pathR];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let ineq_pathL_pathR = prove_by_refinement(
  `!u c x f.
    ineq (APPEND u (CONS (FST(pathL c),x,SND(pathL c)) v)) f /\ 
    ineq (APPEND u (CONS (FST(pathR c),x,SND(pathR c)) v)) f ==>
    ineq (APPEND u (CONS (FST c,x,SND c) v)) f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ineq_APPEND];
  REWRITE_TAC[Sphere.ineq];
  REPEAT WEAK_STRIP_TAC;
  ONCE_REWRITE_TAC[pathL_pathR];
  REPEAT (FIRST_X_ASSUM MP_TAC);
  BY(ASM_CASES_TAC `FST (pathL c) <= x /\ x <= SND (pathL c)` THEN ASM_CASES_TAC ` FST (pathR c) <= x /\ x <= SND (pathR c)` THEN ASM_REWRITE_TAC[] THEN REPEAT WEAK_STRIP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let chop0 = prove_by_refinement(
  `!l. l = APPEND [] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let chop1 = prove_by_refinement(
  `!l. CONS a l = APPEND [a] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let chop2 = prove_by_refinement(
  `!l. CONS a1 (CONS a2 l) = APPEND [a1;a2] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let chop3 = prove_by_refinement(
  `!l. CONS a1 (CONS a2 (CONS a3 l)) = APPEND [a1;a2;a3] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let chop4 = prove_by_refinement(
  `!l. CONS a1 (CONS a2 (CONS a3 (CONS a4 l))) = APPEND [a1;a2;a3;a4] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let chop5 = prove_by_refinement(
  `!l. CONS a1 (CONS a2 (CONS a3 (CONS a4 (CONS a5 l)))) = APPEND [a1;a2;a3;a4;a5] l`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[APPEND])
  ]);;
  (* }}} *)

let CHOP_LIST_TAC n = 
  let chop = List.nth [chop0;chop1;chop2;chop3;chop4;chop5] n in
    ONCE_REWRITE_TAC[chop];;

let CHOP_LIST_RULE n = 
  let chop = List.nth [chop0;chop1;chop2;chop3;chop4;chop5] n in
    ONCE_REWRITE_RULE[chop];;

let get_cover i = 
  let zipr = zip (0--(numcases-1)) Ineqdata3q1h.records  in
  let fil = filter (fun (_,t) -> t.caseno=i) zipr in
  let v = List.rev in
      map 
	(fun (k,t) -> 
	   (k,(v t.branch1,v t.branch2,v t.branch3,v t.branch4,v t.branch5))) 
	     fil;;

let op1 gc k = 
  let thm = REWRITE_RULE[FST;SND] (UNDISCH (mk_ox3q1h k)) in
    (thm,assoc k gc);;

let prep n = 
  let gc = get_cover n in 
  let vs = map fst gc in
    map (op1 gc) vs;;

let merge_match (th1,r1) (th2,r2) =
  let ((bx,nx),r3) = Ineqdata3q1h.combine (r1,r2) in
  let (th1',th2') = if bx then (th1,th2) else (th2,th1) in
  let th3 = CHOP_LIST_RULE nx (CONJ th1' th2') in
  let th4 = MATCH_MP ineq_pathL_pathR th3 in
  let th5 = REWRITE_RULE[APPEND;FST;SND] th4 in
    (th5,r3);;

let rec combine_l = function
    [] -> []
  | [a] -> [a]
  | a::b::cs ->
      try (merge_match a b)::cs 
      with Failure _ -> a::combine_l (b::cs);;

let rec combine_r x = 
  let x'= combine_l x in
    if (x'=x) then x else combine_r x';;

let combos = map (combine_r o prep) (1--4);;    
let partial_merge = end_itlist CONJ (map fst (List.flatten combos));;

let hminus_h0_hplus = prove_by_refinement(
  `!x. (&2 * hminus <= x /\ x <= &2 * hplus) <=> ((&2 * hminus <= x /\ x <= &2 *h0) \/ (&2 * h0 <= x /\ x <= &2 * hplus))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MP_TAC Nonlinear_lemma.hminus_lt_h0;
  MP_TAC Nonlinear_lemma.h0_lt_hplus;
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let ox3q1h_merge = prove_by_refinement(
  `ox3q1h ==>
   !y c1 c2 c3 c4 a12 a23 a34 a14 b12 b23 b34 b14.
        ineq
       [&2 * hminus,y,&2 * hplus; &2 * hminus,c1,&2 * hplus; &2,c2,&2 * hminus; 
       &2,
       c3,
       &2 * hminus; &2,c4,&2 * hminus; &2,a12,&2 * hminus; &2,a23,&2 * hminus; 
       &2,
       a34,
       &2 * hminus; &2,a14,&2 * hminus; &2,b12,&2 * hminus; &2,
                                                            b23,
                                                            &2 * hminus; 
       &2,
       b34,
       &2 * hminus; &2,b14,&2 * hminus]
       (dih_y y a12 a14 c1 b14 b12 +
        dih_y y a23 a12 c2 b12 b23 +
        dih_y y a34 a23 c3 b23 b34 +
        dih_y y a14 a34 c4 b14 b34 =
        &2 * pi
        ==> gamma4fgcy y a12 a14 c1 b14 b12 lmfun / &2 +
            beta_bump_force_y y a12 a14 c1 b14 b12 +
            gamma4fgcy y a23 a12 c2 b12 b23 lmfun +
            gamma4fgcy y a34 a23 c3 b23 b34 lmfun +
            gamma4fgcy y a14 a34 c4 b14 b34 lmfun >
            &0)`,
  (* {{{ proof *)
  [
  REPEAT WEAK_STRIP_TAC;
  MP_TAC partial_merge;
  CHOP_LIST_TAC (2);
  REWRITE_TAC[ineq_APPEND];
  REPLICATE_TAC 3 (ONCE_REWRITE_TAC[Sphere.ineq]);
  REWRITE_TAC[hminus_h0_hplus];
  BY(BOOL_CASES_TAC `&2 * hminus <= y /\ y <= &2 * h0` THEN BOOL_CASES_TAC `&2 * h0 <= y /\ y <= &2 * hplus` THEN BOOL_CASES_TAC `&2 * hminus <= c1 /\ c1 <= &2 * h0` THEN BOOL_CASES_TAC `&2 * h0 <= c1 /\ c1 <= &2 * hplus` THEN REWRITE_TAC[] THEN ASM_MESON_TAC[])
  ]);;
  (* }}} *)

 end;;
