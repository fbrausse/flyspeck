(* ========================================================================= *)
(* FLYSPECK - BOOK FORMALIZATION                                             *)
(*                                                                           *)
(* Chapter: nonlinear inequalities                                           *)
(* Author:  Thomas Hales      *)
(* Date: 2012-06-02                                                          *)
(* ========================================================================= *)

(* to fix:
   proj_y1 = sqrt_x1 ,etc.
*)

(* generating ocaml code of the the functions that appear in nonlinear ineqs.
   Then generating interval arithmetic c++ code for Function definitions. *)

(*
Generate interval C++ code for various functions
using lemmas from functional_equation.hl

*)

(*
let lemma = Functional_equation.functional_rhazim_x;;
let lemma2 = Functional_equation.functional_rhazim2_x;;
*)

let join_comma = Flyspeck_lib.join_comma;;
let join_lines = Flyspeck_lib.join_lines;;



flyspeck_needs  "../development/thales/nonlinear/functional_equation.hl";;
flyspeck_needs "nonlinear/optimize.hl";;
flyspeck_needs  "nonlinear/parse_ineq.hl";;


let functions() = 
  [
    (* constants *)
    Float.pi_atn;
    Functional_equation.cos797;
   Sphere.h0;
    Sphere.sqrt3;
    Sphere.sqrt8;
    Sphere.sol0;
    Sphere.tau0;
    Sphere.mm1;
    Sphere.mm2;
    Functional_equation.rh0;
    SYM Nonlinear_lemma.sol0_over_pi_EQ_const1;
    (* single variable *)
    Sphere.gchi;
    Sphere.matan;
    Sphere.lfun;
    Sphere.flat_term;
    Nonlinear_lemma.rho_alt;
    Sphere.sqn;
    REWRITE_RULE[Sphere.flat_term] Sphere.flat_term_x;
  (* 3 vars *)
    Nonlinear_lemma.quad_root_plus_curry;
   Sphere.ups_x;
   Sphere.eta_x;
   Sphere.arclength;
   Sphere.arc_hhn;
    (* general 6 *)
   Functional_equation.scalar6;
   Functional_equation.promote1_to_6;
   Functional_equation.promote3_to_6;
   Nonlinear_lemma.unit6;
   Nonlinear_lemma.proj_x1;
   Nonlinear_lemma.proj_x2;
   Nonlinear_lemma.proj_x3;
   Nonlinear_lemma.proj_x4;
   Nonlinear_lemma.proj_x5;
   Nonlinear_lemma.proj_x6;
   Functional_equation.proj_y1;
   Functional_equation.functional_proj_y2;
   Functional_equation.functional_proj_y3;
   Functional_equation.functional_proj_y4;
   Functional_equation.functional_proj_y5;
   Functional_equation.functional_proj_y6;
   Sphere.delta_x;
   Sphere.delta_x4;
   Sphere.dih_x;
   Sphere.sol_x;
   Sphere.rho_x;
   Sphere.rad2_x;
   Functional_equation.compose6;
   Functional_equation.uni;
   Functional_equation.constant6;
   Functional_equation.two6;
   Functional_equation.zero6;
   Functional_equation.four6;
   Functional_equation.add6;
   Functional_equation.sub6;
   Functional_equation.mul6;
   Functional_equation.div6;
   Functional_equation.mk_126;
   Functional_equation.mk_135;
 (* by hand:  Functional_equation.domain6; *)
   Functional_equation.rotate234;
   Functional_equation.rotate126;
   Functional_equation.rotate345;
   Functional_equation.functional_rotate2;
   Functional_equation.functional_rotate3;
   Functional_equation.functional_rotate4;
   Functional_equation.functional_rotate5;
   Functional_equation.functional_rotate6;
Functional_equation.functional_eta2_126;
Functional_equation.functional_x1_delta_x;
Functional_equation.functional_delta4_squared_x;
Functional_equation.functional_vol_x;
Functional_equation.functional_dih2_x;
Functional_equation.functional_dih3_x;
Functional_equation.functional_dih4_x;
Functional_equation.functional_dih5_x;
Functional_equation.functional_dih6_x;
Functional_equation.functional_lfun_y1;
Functional_equation.functional_ldih_x;
Functional_equation.functional_ldih2_x;
Functional_equation.functional_ldih3_x;
Functional_equation.functional_ldih6_x;
Functional_equation.functional_eulerA_x;
Functional_equation.functional_gchi1_x;
Functional_equation.functional_gchi2_x;
Functional_equation.functional_gchi3_x;
Functional_equation.functional_gchi4_x;
Functional_equation.functional_gchi5_x;
Functional_equation.functional_gchi6_x;
Functional_equation.functional_eta2_135;
Functional_equation.functional_vol3_x_sqrt;
Functional_equation.functional_vol3f_x_lfun;
Functional_equation.functional_vol3f_x_sqrt2_lmplus;
Functional_equation.functional_asn797k;
Functional_equation.functional_asnFnhk;
Functional_equation.functional_acs_sqrt_x1_d4;
Functional_equation.functional_acs_sqrt_x2_d4;
Functional_equation.functional_arclength_x_123;
Functional_equation.functional_arclength_234;
Functional_equation.functional_arclength_126;
Functional_equation.functional_sol_euler_x_divsqrtdelta;
Functional_equation.functional_sol246_euler_x_div_sqrtdelta;
Functional_equation.functional_sol345_euler_x_div_sqrtdelta;
Functional_equation.functional_sol156_euler_x_div_sqrtdelta;
Functional_equation.functional_dih_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih3_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih5_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih_x_126_s2;
Functional_equation.functional_dih2_x_126_s2;
Functional_equation.functional_dih3_x_126_s2;
Functional_equation.functional_dih4_x_126_s2;
Functional_equation.functional_dih5_x_126_s2;
Functional_equation.functional_dih6_x_126_s2;
Functional_equation.functional_dih_x_135_s2;
Functional_equation.functional_dih2_x_135_s2;
Functional_equation.functional_dih3_x_135_s2;
Functional_equation.functional_dih4_x_135_s2;
Functional_equation.functional_dih5_x_135_s2;
Functional_equation.functional_dih6_x_135_s2;
Functional_equation.functional_ldih_x_126_s2;
Functional_equation.functional_ldih2_x_126_s2;
Functional_equation.functional_ldih6_x_126_s2;
Functional_equation.functional_ldih_x_135_s2;
Functional_equation.functional_ldih3_x_135_s2;
Functional_equation.functional_ldih5_x_135_s2;
Functional_equation.functional_edge_flat2_x;
Functional_equation.functional_euler_3flat_x;
Functional_equation.functional_euler_2flat_x;
Functional_equation.functional_euler_1flat_x;
Functional_equation.functional_rhazim_x;
Functional_equation.functional_rhazim2_x;
Functional_equation.functional_rhazim3_x;
Functional_equation.functional_taum_x;
Functional_equation.functional_taum_3flat_x;
Functional_equation.functional_taum_2flat_x;
Functional_equation.functional_taum_1flat_x;
Functional_equation.functional_delta_x_126_s2;
Functional_equation.functional_delta_x_135_s2;
Functional_equation.functional_delta_pent_x;
Functional_equation.functional_vol3_x_135_s2;
Functional_equation.functional_ldih_x_div_sqrtdelta_posbranch;
Functional_equation.functional_ldih2_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih3_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih5_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih6_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih_x_n;
Functional_equation.functional_ldih_x_126_n;
Functional_equation.functional_ldih2_x_126_n;
Functional_equation.functional_ldih6_x_126_n;
Functional_equation.functional_ldih_x_135_n;
Functional_equation.functional_ldih3_x_135_n;
Functional_equation.functional_ldih5_x_135_n;
   ];;

let ocaml_code() = 
  let strip_all b = snd(strip_forall (concl (Nonlinear_lemma.strip_let b))) in
  let ocam f = Parse_ineq.ocaml_function (strip_all f) in
  let header = 
  "(* code automatically generated from Parse_ineq.ocaml_code *)\n\n"^
   "module Sphere2 = struct\n\n"^
   "let sqrt = Pervasives.sqrt\n\n" ^
   "let cos = Pervasives.cos\n\n" ^
   "let sin = Pervasives.sin\n\n" ^
   "let log = Pervasives.log\n\n" ^
   "let asn = Pervasives.asin\n\n" ^
   "let atn = Pervasives.atan\n\n" ^
    "let pow2 x = x ** (2.0);;\n\n" in
  let tailer =    "end;;\n" in
    header ^
   (Flyspeck_lib.join_lines (map ocam (functions()))) ^ tailer;;

Flyspeck_lib.output_filestring "/tmp/sphere2.ml" (ocaml_code());;
loadt "/tmp/sphere2.ml";;


let break_functional_lemma thm = 
  let strip_all b = snd(strip_forall (concl (Nonlinear_lemma.strip_let b))) in
  let (h,ts) = strip_comb (strip_all thm) in
  let isdomain h = (fst(dest_const h) = "domain6") in
  let namebody = if isdomain h then tl ts else ts in
   (List.nth namebody 0),List.nth namebody 1;;

let break_term x = break_functional_lemma (ASSUME x);;

let mk_testing_string thm = 
  let (name,body') = break_functional_lemma thm in
  let name' = fst (strip_comb name) in
  let name' = fst (dest_const name') in
  let evalname = 
    let s = Printf.sprintf "Sphere2.%s 6.36 4.2 4.3 4.4 4.5 4.6" name' in
    let (b,s')=  eval_command s in
    let _ = b or failwith ("evalname: "^name') in
    let split = Str.split (Str.regexp "[ \n]") in
    let r = hd (List.rev  (split s')) in
      float_of_string r in
  let mk_string = 
    Printf.sprintf "  epsValue(\"%s\",FunctionLibrary::%s,%12.12f);" name' name' evalname in
    mk_string;;

let all_testing_string() = 
  let can_test = filter (can  mk_testing_string) (functions()) in
    Flyspeck_lib.join_lines (map mk_testing_string can_test);;

let not_tested = filter (not o (can mk_testing_string)) (functions());;

(* following is copied and adapted from optimize.hl *)

let paren s = "("^s^")";;
let i_mk = Optimize.i_mk;;
let string_of_num' = Optimize.string_of_num';;
let dest_decimal = Optimize.dest_decimal;;

let real_ty = `:real`;;

let f1_ty = `:real->real`;;

let f6_ty = `:real->real->real->real->real->real->real` ;;

let f6to6_ty = `:(real->real->real->real->real->real->real) ->
  (real->real->real->real->real->real->real)`;;

let infix6_ty = `:(real->real->real->real->real->real->real) ->
  (real->real->real->real->real->real->real) ->
  (real->real->real->real->real->real->real)` ;;

let scalar6_ty = `:(real->real->real->real->real->real->real) ->
  (real) ->
  (real->real->real->real->real->real->real)` ;;

let tyvar_inst = 
  let realty = `:real` in
  let u = 
    setify(List.flatten (map (type_vars_in_term o concl) (functions()))) in
    map (fun t-> (realty,t)) u;;

type_of (inst [(`:real`,`:A`)] `x:A`);;

let functional_terms = map ((inst tyvar_inst)o concl) (functions());;

let real_types = setify(map (type_of o fst o strip_comb o fst o break_term) functional_terms);;

List.length real_types;;

let terms_with_type ty = 
  filter (fun t -> ty = type_of(fst(strip_comb(
    fst(break_term t))))) functional_terms;;

let f0_terms =  (terms_with_type real_ty);;

let f0_code() = 
  let f0_template = Printf.sprintf
    "static const interval %s (\"%20.20f\");" in
  let f0_mk thm = 
    let (name,body') = break_functional_lemma thm in
    let name' = fst (strip_comb name) in
    let name' = fst (dest_const name') in
    let s = Printf.sprintf "Sphere2.%s" name' in
    let (b,s')=  eval_command s in
    let _ = b or failwith ("evalname: "^name') in
    let split = Str.split (Str.regexp "[ \n]") in
    let r = hd (List.rev  (split s')) in
    let warn = "// Warning: "^name'^" computed by floating point\n" in
    let r' =   float_of_string r in
      warn^(f0_template name' r') in
    Flyspeck_lib.join_lines (map (f0_mk o ASSUME) f0_terms);;

let legacy = ["unit", "x1", "x2", "x3", "x4", "x5", "x6", "y1", "y2",
 "y3", "y4", "y5", "y6", "delta_x", "delta_x4", "x1_delta_x",
 "delta4_squared_x", "vol_x", "sol", "rad2", "dih", "dih2", "dih3",
 "dih4", "dih5", "dih6", "ldih_x", "ldih2_x", "ldih3_x", "ldih5_x",
 "ldih6_x", "upper_dih_x", "eulerA_x", "rhazim_x", "rhazim2_x",
 "rhazim3_x", "gchi1_x", "gchi2_x", "gchi3_x", "gchi4_x", "gchi5_x",
 "gchi6_x", "x1cube", "x1square", "num1", "num2", "num_combo1", "rat1",
 "rat2", "den2", "edge_flat2_x", "edge_flat_x", "flat_term_x", "taum_x",
 "halfbump_x1", "halfbump_x4", "eta2_126", "eta2_135", "eta2_234",
 "eta2_456", "vol3_x_sqrt", "vol3f_x_lfun", "vol3f_x_sqrt2_lmplus",
 "arclength_x_123", "arclength_x_234", "arclength_x_126",
 "arclength_x_345", "norm2hh_x", "asn797k", "asnFnhk", "lfun_y1",
 "acs_sqrt_x1_d4", "acs_sqrt_x2_d4", "sol_euler_x_div_sqrtdelta",
 "sol_euler345_x_div_sqrtdelta", "sol_euler156_x_div_sqrtdelta",
 "sol_euler246_x_div_sqrtdelta", "dih_x_div_sqrtdelta_posbranch",
 "dih2_x_div_sqrtdelta_posbranch", "dih3_x_div_sqrtdelta_posbranch",
 "dih4_x_div_sqrtdelta_posbranch", "dih5_x_div_sqrtdelta_posbranch",
 "dih6_x_div_sqrtdelta_posbranch", "ldih_x_div_sqrtdelta_posbranch",
 "ldih2_x_div_sqrtdelta_posbranch", "ldih3_x_div_sqrtdelta_posbranch",
 "ldih4_x_div_sqrtdelta_posbranch", "ldih5_x_div_sqrtdelta_posbranch",
 "ldih6_x_div_sqrtdelta_posbranch", "surf_x", "vol3r_126_x",
 "dih_x_126_s2", "dih2_x_126_s2", "dih3_x_126_s2", "dih4_x_126_s2",
 "dih5_x_126_s2", "dih6_x_126_s2", "ldih_x_126_s2", "ldih2_x_126_s2",
 "ldih6_x_126_s2", "dih_x_135_s2", "dih2_x_135_s2", "dih3_x_135_s2",
 "dih4_x_135_s2", "dih5_x_135_s2", "dih6_x_135_s2", "ldih_x_135_s2",
 "ldih3_x_135_s2", "ldih5_x_135_s2", "lfun_sqrtx1_div2",
 "delta_x_135_s2", "delta_x_126_s2", "vol3_x_135_s2",
 "gamma3f_x_vLR_lfun", "gamma3f_x_vLR0", "gamma3f_x_vL_lfun",
 "gamma3f_x_vL0", "gamma3f_x_v_lfun", "gamma3f_x_v0", "ldih_x_126_n",
 "ldih2_x_126_n", "ldih6_x_126_n", "ldih_x_135_n", "ldih3_x_135_n",
 "ldih5_x_135_n", "gamma3f_126_x_s_n", "gamma3f_135_x_s_n",
 "gamma3f_vLR_x_nlfun", "gamma3f_vLR_x_n0", "gamma3f_vL_x_nlfun",
 "gamma3f_vL_x_n0", "tau_lowform_x", "tau_residual_x", "delta_y_LC",
 "mdtau_y_LC", "mdtau2uf_y_LC", "euler_3flat_x", "euler_2flat_x",
 "euler_1flat_x", "taum_3flat_x", "taum_2flat_x", "taum_1flat_x",
 "delta_pent_x", "ell_uvx", "ell_vx2", "selling_volume2",
 "selling_surface_nn", "selling_surface_nn2_013",
 "selling_surface_nn01_23", "selling_homog", "fcc_ineq", "taum_x1(&&)",
 "taum_x2(&&)", "taum_x1_x2(&)", "arclength_x1(&&)", "arclength_x2(&&)",
 "surfR126d(&)", "lindih(&)", "delta_126_x(&&&)", "delta_234_x(&&&)",
 "delta_135_x(&&&)", "taum_sub1_x(&)", "delta_sub1_x(&)",
 "taum_sub246_x(&&&)", "taum_sub345_x(&&&)"];;

let native_fun = Optimize.native_fun;;

let native_infix = [
  ("add6","+");
  ("mul6","*");
  ("sub6","-");
  ("div6","/");
  ("scalar6","*");
];;

let native_interval = [
];;

let f0_name   = 
  let f0_auto = map (fst o dest_const o fst o break_term) f0_terms in
  fun s ->
  if (mem s f0_auto) then s
      else 
	try (Lib.assoc s native_interval) with 
	    Failure _ -> failwith (s^" find: real_name") ;;

let fun_name = 
  let fun_auto = map (fst o dest_const o fst o strip_comb o fst o break_term)
    functional_terms in
    fun s->
      try (Lib.assoc s native_fun) with 
	  Failure _ -> 
	    if (mem s fun_auto) then s else failwith ("fun_name not found: "^s);;

let is_comma = 
  let c = "," in
    fun t ->
      let (t,_) = strip_comb t in
	(is_const t && fst (dest_const t) = c);;

let cpp_string_of_term = 
  let rec soh t = 
    if is_var t then fst (dest_var t) else
      let (f,xs) = strip_comb t in
      let ifix i = let [a;b] = xs in paren(soh a ^ " " ^ i ^ " " ^ soh b) in
      let (fv,ty) = 
	if is_var f
	then 
	  let (fv,ty) = (dest_var f) in
	  let _ = warn true ("variable function name: "^fv) in
	    (fv,ty)
	else if (is_const f) then (dest_const f)
	else
	  failwith ("var/const expected:" ^ string_of_term f) in
	match fv with
	  | "real_add" -> ifix "+"
	  | "real_mul" -> ifix "*"
	  | "real_div" -> ifix "/"
	  | "real_sub" -> ifix "-"
	  | "," -> ifix ","
	  | "\\/" -> ifix "\\/"
	  | "real_neg" -> let [a] = xs in "(-" ^ soh a ^ ")"
	  | "real_of_num" -> let [a] = xs in i_mk(soh a)  
	  | "NUMERAL" -> let [a] = xs in string_of_num' (dest_numeral t)
	  | "<" -> let [a;b] = xs in paren(soh a ^ " < " ^ soh b)
	  | ">" -> let [a;b] = xs in paren(soh a ^ " > " ^ soh b)
	  | "+" -> let [a;b] = xs in paren(soh a ^ " + " ^ soh b)
	  | "*" -> let [a;b] = xs in paren(soh a ^ " * " ^ soh b)
	  | "DECIMAL" ->  i_mk(string_of_num' (dest_decimal t))
	  | _ -> 
	      if (ty = real_ty) 
	      then paren(f0_name fv)
	      else if (ty= infix6_ty) or (ty=scalar6_ty)
	      then
		let op = 
		  (try Lib.assoc fv native_infix
		   with Failure _ -> failwith ("parse infix6 "^fv)) in
		  ifix op
	      else 
		(let name = fun_name fv in
		   if (xs=[]) then paren name else
		     let p = if (List.length xs = 1 && is_comma (hd xs))
		     then I else paren in
		     let args = p (join_comma (map soh xs)) in
		       paren (name^args)) in
    fun t -> 
      try (soh t) 
      with Failure s -> failwith (s^" .......   "^string_of_term t);;

(* make functions of 6 variables *)


let f6_code() = 
  let f6_template = Printf.sprintf
    "static const Function %s = %s;\n" in
  let f6_terms = (terms_with_type f6_ty) in
  let f6_auto = 
    let b = (fst o dest_const o fst o strip_comb o fst o break_term) in
    let nat = map fst native_fun in
      filter (fun t -> not (mem (b t) nat)) f6_terms in
  let f6_mk tt = 
    let (name1,body') = break_term tt in
    let name' = fst (strip_comb name1) in
    let name' = fst (dest_const name') in
      f6_template name' (cpp_string_of_term body') in
    join_lines (map f6_mk f6_auto);;

(* make 6 to 6 *)

let f6to6_template = Printf.sprintf
  "static const Function %s(const Function& %s) {
     return %s;
  }\n";;

let f6to6_terms = terms_with_type f6to6_ty;;

let f6to6_mk tt =
  let (name1,body') = break_term tt in
  let (name',param) = strip_comb name1 in
  let _ = List.length param = 1 or 
    failwith ("one parameter expected "^ string_of_term tt) in
  let name' = fst (dest_const name') in
  let param = fst (dest_var (hd param)) in
    f6to6_template name' param (cpp_string_of_term body');;  

let f6to6_code = join_lines (map f6to6_mk f6to6_terms);;


let tmpfile = flyspeck_dir^"/../interval_code/test_auto.cc";;


let interval_code() = (f0_code())  ^ f6to6_code ^ (f6_code());;

(* based on optimize *)

let mkfile_code  t s tags  = 
  let cpp_header = Optimize.cpp_header in
  let cpp_tail = Optimize.cpp_tail in
  Flyspeck_lib.output_filestring tmpfile
   (join_lines [cpp_header();interval_code();(Optimize.mk_cpp_proc t s tags);cpp_tail()]);;

let testid = "9563139965 d";;

let idq = hd(Ineq.getexact testid);;

let [(_,tags,post)] = Optimize.preprocess_split_idq idq;;

mkfile_code post testid tags;;

let execute_interval ex tags s testineq = 
  let interval_dir = flyspeck_dir^"/../interval_code" in
  let _ = mkfile_code testineq s tags in
  let _ = Optimize.compile_cpp() in 
  let _ = (not ex) or (0=  Sys.command(interval_dir^"/test_auto")) or failwith "interval execution error" in
    ();;


Flyspeck_lib.output_filestring "/tmp/auto_lib.cc" interval_code;;
