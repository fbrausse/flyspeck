(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: nonlinear inequalities                                            *)
(* Author:  Thomas Hales     *)
(* Date: 2013-01-28                                                           *)
(* ========================================================================== *)

(* generate all theorems of terms in !Ineq.ineqs from a single assumption `prepared_nonlinear:bool`,
   defined as the conjunction of all inequalities in prep.hl

   nonlinear_imp_the_nonlinear_inequalities:
   nonlinear ==> the_nonlinear_inequalities

   prepared_nonlinear_imp_nonlinear:
   We also show |- prepared_nonlinear |- nonlinear

 *)

flyspeck_needs "nonlinear/prep.hl";;

module Mk_all_ineq = struct

  open Optimize;;
  open Hales_tactic;;

(* ********************************************************************** *)
(* relate `nonlinear` to `the_nonlinear_inequalities` *)
(* ********************************************************************** *)

(* from break_case_exec.hl *)

let rec get_const_names tm = 
    match tm with       
        Var(s,t) -> []
      | Const(s,t) ->  [s] 
      | Comb (t1,t2) -> get_const_names t1 @ get_const_names t2 
      | Abs (t1,t2) -> get_const_names t1 @ get_const_names t2 ;;

let rec all_const_name P = 
    function
      | Abs(_,t) -> all_const_name P t
      | Comb(u,v) -> all_const_name P u && all_const_name P v
      | Var _ -> true
      | Const(s,_) -> P s;;

let some_const_name P t = not (all_const_name (not o P) t);;

let has_quad t = some_const_name (fun s -> mem s ["enclosed";"tauq"]) t;;

let quad_enclosed = 
  let has_quad_idq = filter (fun idq -> has_quad idq.ineq) !Ineq.ineqs in
    setify (map (fun idq -> idq.idv) has_quad_idq);;
    
(* let quad_enclosed = Scripts.quad_enclosed;; *)

let disregard = quad_enclosed;;

let get_ineq s = (find (fun t -> t.idv = s) !Ineq.ineqs).ineq;;

let deprecated_quad_inequalities = 
  let ineql = map get_ineq quad_enclosed in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
    new_definition (mk_eq (`deprecated_quad_inequalities:bool`,ineq_conj));;

let the_nonlinear_inequalities = new_definition'
  `the_nonlinear_inequalities <=>
  (pack_nonlinear_non_ox3q1h /\ ox3q1h /\ 
     main_nonlinear_terminal_v11 /\ lp_ineqs /\ pack_ineq_def_a /\
    kcblrqc_ineq_def)`;;

let mk_nonlinear() = 
  let ineqs = filter (fun t -> not (mem t.idv (disregard))) !Ineq.ineqs in
  let ineql = map (fun idv -> idv.ineq) ineqs in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let d = new_definition (mk_eq (`nonlinear:bool`,ineq_conj)) in
    d;;

let get_nonlinear = 
  let th = mk_nonlinear() in
  let ineqs = filter (fun t -> not (mem t.idv disregard)) !Ineq.ineqs in
(*
  let ineql = map (fun idv -> idv.ineq) ineqs in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`nonlinear:bool`,ineq_conj)) in
*)
  let sl = map (fun ind -> ind.idv) ineqs in
  let th1 = UNDISCH (MATCH_MP (TAUT `(a <=> b) ==> (a ==> b)`) th) in
  let co1 thm = if (is_conj (concl thm)) then CONJUNCT1 thm else thm in
    fun s ->
      let i = index s sl in
      let th2 = funpow i CONJUNCT2 th1 in
	co1 th2;;

(* old version,

let mk_nonlinear = 
  let ineql = map (fun idv -> idv.ineq) !Ineq.ineqs in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let _ = new_definition (mk_eq (`nonlinear:bool`,ineq_conj)) in
    ();;

let get_nonlinear = 
  let ineql = map (fun idv -> idv.ineq) !Ineq.ineqs in
  let sl = map (fun ind -> ind.idv) !Ineq.ineqs in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`nonlinear:bool`,ineq_conj)) in
  let th1 = UNDISCH (MATCH_MP (TAUT `(a <=> b) ==> (a ==> b)`) th) in
  let co1 thm = if (is_conj (concl thm)) then CONJUNCT1 thm else thm in
    fun s ->
      let i = index s sl in
      let th2 = funpow i CONJUNCT2 th1 in
	co1 th2;;

*)

let kcblrqc_ineq_s = ["6988401556"; "4667071578"; "8519146937"; "3296257235"; "5490182221";
   "5735387903"; "3862621143 back"; "3862621143 front"; "3862621143 side";
   "3862621143 revised"; "4240815464 a reduced"; "4240815464 a";
   "6944699408 a reduced";  "6944699408 a";  "7043724150 a reduced v2";
   "7043724150 a"; "3287695934"; "2570626711"; "4652969746 2";
   "4652969746 1"];;

let pack_ineq_s = 
  let has_packid = (fun t -> not(intersect ["UKBRPFE";"WAZLDCD";"BIEFJHU"] (Ineq.flypaper_ids t) = [])) in
  let idl = (filter has_packid !Ineq.ineqs) in
  let tml = map (fun t -> t.idv) idl in
    tml;;

let get_main_nonlinear_s = 
  let is_main = function 
    | Main_estimate -> true
    | _ -> false in
  let has_main ind = 
    exists (is_main) ind.tags in
  let main_ineq_data1 = 
    filter has_main (!Ineq.ineqs) in
  let id = map (fun t-> t.idv) main_ineq_data1 in
    id;;

let main_nonlinear = 
  let is_main = function 
    | Main_estimate -> true
    | _ -> false in
  let has_main ind = 
    exists (is_main) ind.tags in
  let main_ineq_data1 = 
    filter has_main (!Ineq.ineqs) in
  let id = map (fun t-> t.idv) main_ineq_data1 in
  let main_ineq_data = map (fun t -> hd(Ineq.getexact t)) id in
  let ineql = map (fun ind -> ind.ineq) main_ineq_data in
  let sl = map (fun ind -> ind.idv) main_ineq_data in
  let main_ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`main_nonlinear_terminal_v11:bool`,main_ineq_conj)) in
    th;;

let lp_ineqs_s =
  let check_lp_tags =
    let rec check tags =
      match tags with
	| Lp :: _ -> true
	| Tablelp :: _ -> true
	| Lp_aux _ :: _ -> true
	| h :: t -> check t
	| [] -> false in
      fun ineq -> check ineq.tags in
  let ineq_ids = ["6170936724"] in
  let lp_ineqs = filter (fun ineq -> check_lp_tags ineq or mem ineq.idv ineq_ids) !Ineq.ineqs in
    map (fun t -> t.idv) lp_ineqs;;

(*
mem "9563139965D" lp_ineqs_s;;
st 5 [`lp_ineqs`];;
*)

let ox3q1h_s = 
  let idvs = map (fun t -> t.idv) (!Ineq.ineqs) in
  let getprefix idv = filter (fun t -> (String.length idv <= String.length t) &&
			     (String.sub t 0 (String.length idv) = idv)) idvs in
    getprefix "OXLZLEZ 6346351218";;

let packing_ineq_data = Merge_ineq.packing_ineq_data;;

let packing_ineq_data_s = map (fun t -> t.idv) packing_ineq_data;;

let mk_pack_nonlinear = 
  let ineql = map (fun idv -> idv.ineq) packing_ineq_data in
  let packing_ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`pack_nonlinear_non_ox3q1h:bool`,packing_ineq_conj)) in
    th;;

let dequad xs = filter (fun s -> not (mem s quad_enclosed)) xs;;

(* XX We need to eliminated deprecated_quad_inequalities here.
     doesn't work in module mode for some strange reason *)

report "this will take a few minutes...";;

let nonlinear_imp_the_nonlinear_inequalities = Prove_by_refinement.prove_by_refinement(
  `deprecated_quad_inequalities /\ nonlinear ==> the_nonlinear_inequalities`,
  (* {{{ proof *)
  [
  REWRITE_TAC[the_nonlinear_inequalities];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 5;
    MP_TAC deprecated_quad_inequalities;
    ASM_REWRITE_TAC[Tame_lemmas.kcblrqc_ineq_def];
    BY(ASM_SIMP_TAC (map get_nonlinear (dequad kcblrqc_ineq_s)));
  nCONJ_TAC 4;
    BY(REWRITE_TAC (Ysskqoy.pack_ineq_def_a :: map get_nonlinear pack_ineq_s));
  nCONJ_TAC 3;
    MP_TAC deprecated_quad_inequalities;
    ASM_REWRITE_TAC[] THEN DISCH_TAC;
    BY(ASM_SIMP_TAC (Lp_ineqs.lp_ineqs_def :: map get_nonlinear (dequad lp_ineqs_s)));
  nCONJ_TAC 2;
    BY(REWRITE_TAC (main_nonlinear :: map get_nonlinear get_main_nonlinear_s));
  nCONJ_TAC 1;
    BY(REWRITE_TAC (Merge_ineq.ox3q1h() :: map get_nonlinear ox3q1h_s));
  ASM_REWRITE_TAC[];
  BY(REWRITE_TAC (mk_pack_nonlinear :: map get_nonlinear packing_ineq_data_s))
  ]);;
  (* }}} *)

report "done";;

(* ********************************************************************** *)
(* relate prep.hl to `nonlinear` *)
(* ********************************************************************** *)



(*
let prep_ineqs = ref ([]:ineq_datum list);;

let add_inequality i  =
  let _ = prep_ineqs:= i :: !prep_ineqs in
    ();;
*)

let prep_ineqs = Prep.prep_ineqs;;

let mk_prepared_nonlinear = 
  let ineql = map (fun idv -> idv.ineq) (!prep_ineqs) in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let _ = new_definition (mk_eq (`prepared_nonlinear:bool`,ineq_conj)) in
    ();;

let get_prep_nonlinear = 
  let sl = map (fun ind -> ind.idv) !prep_ineqs in
  let ineql = map (fun ind -> ind.ineq) (!prep_ineqs) in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`prepared_nonlinear:bool`,ineq_conj)) in
  let th1 = UNDISCH (MATCH_MP (TAUT `(a <=> b) ==> (a ==> b)`) th) in
  let co1 thm = if (is_conj (concl thm)) then CONJUNCT1 thm else thm in
    fun s ->
      let i = index s sl in
      let th2 = funpow i CONJUNCT2 th1 in
	co1 th2;;

let hasprefix s sl = filter (fun t -> (String.length s <= String.length t) &&
			     (String.sub t 0 (String.length s) = s)) (sl);;

let get_all_prep_nonlinear = 
  let sl = map (fun ind -> ind.idv) !prep_ineqs in
  let ineql = map (fun ind -> ind.ineq) (!prep_ineqs) in
  let ineq_conj = end_itlist (curry mk_conj) ineql in
  let th = new_definition (mk_eq (`prepared_nonlinear:bool`,ineq_conj)) in
  let th1 = UNDISCH (MATCH_MP (TAUT `(a <=> b) ==> (a ==> b)`) th) in
  let co1 thm = if (is_conj (concl thm)) then CONJUNCT1 thm else thm in
  let c i thm = co1 (funpow i CONJUNCT2 thm) in
  let get s = c (index s sl) th1 in
    fun s ->
      let ps = "prep-"^s in
      try [get ps] with
	  Failure _ -> 
	    (let s' = ps^" split(" in
	     let ssl = hasprefix s' sl in
	       map get ssl);;
	    
let example1 = get_all_prep_nonlinear  "GLFVCVK4a 8328676778";;

(* This follows the same sequence in the module Optimize that is used to generate the inequalities
   in prep.hl, finishing off the last step of the proof with a rewrite. *)

let prove_ineq s = 
  let DSPLIT_TAC i = DISCH_TAC THEN (Optimize.SPLIT_H0_TAC i) in
  let LET_ELIM_TAC = CONV_TAC (REDEPTH_CONV let_CONV) in
  let is_xconvert tags = mem Xconvert tags in
  let is_branch tags = mem Branching tags in
  let PNONL = `prepared_nonlinear:bool` in
  let idq = hd(Ineq.getexact s) in
  let (s',tags,inq) = idq_fields idq in
  let _ = report s' in
  let _ = (s = s') or failwith "prove_ineq: wrong ineq" in 
  let thml = get_all_prep_nonlinear s in
    try (s,Hol_pervasives.prove(mk_imp(PNONL,inq),
	  LET_ELIM_TAC THEN
	    EVERY (map DSPLIT_TAC (get_split_tags idq)) THEN 
	    EVERY
	    [LET_ELIM_TAC;
	     PRELIM_REWRITE_TAC;
	     if (is_branch tags) then BRANCH_TAC else ALL_TAC;
	     if (is_xconvert tags) then X_OF_Y_TAC else ALL_TAC;
	     if (is_branch tags && not(is_xconvert tags)) then SERIES3Q1H_5D_TAC else ALL_TAC;
	     STYLIZE_TAC;
	     WRAPUP_TAC;
	     REWRITE_TAC (thml);
            ]))
    with Failure m -> let m' = ("NOT FOUND:"^s^" "^m) in (report m';(m',TRUTH));;


let process s = 
    let idq = hd(Ineq.getexact s) in
      Optimize.preprocess_split_idq idq;;


(*
let example2 = map prove_ineq  ["GLFVCVK4a 8328676778";"4750199435";"GLFVCVK4 2477216213 y4supercrit"];;
prove_ineq "5550839403 delta";;
prove_ineq;;
let v = process "5550839403 delta";;
map (fun (_,_,t) -> t) v;;
get_all_prep_nonlinear "5550839403 delta";;
*)


let exec() = 
  let ineqs = filter (fun t -> not (mem t.idv disregard)) !Ineq.ineqs in
  let sl = map (fun t -> t.idv) ineqs in
    map prove_ineq sl;;


(*
let exec_results = exec();;


let prepared_nonlinear_imp_nonlinear = 
  let inn = map (fun (_,x) -> UNDISCH x) exec_results in
  let ineq_nn = end_itlist (CONJ) inn in
  let def = mk_inequality() in
    EQ_MP (SYM def) ineq_nn;;

*)


(* tests for quads: *)

(*
has_quad (concl main_nonlinear);;
has_quad (concl Lp_ineqs.lp_ineqs_def);;
has_quad (concl (Merge_ineq.ox3q1h()));;
has_quad (concl mk_pack_nonlinear);;
*)

 end;;
