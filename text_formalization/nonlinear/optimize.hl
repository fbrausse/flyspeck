(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: nonlinear inequalities                                            *)
(* Author:  Thomas Hales     *)
(* Date: 2010-08-30                                                           *)
(* ========================================================================== *)


(*
preprocessing for nonlinear ineq.

*)


let svn_version() = 
  let strip_final s = String.sub s 0 (String.length s - 1) in
  let p s = strip_final (process_to_string s) in
  let q s ="svn info "^s^ " | grep Revision | sed 's/Revision: //g'" in
    "svn("^p(q(flyspeck_dir))^","^p(q(hollight_dir))^")";;

flyspeck_needs "general/sphere.hl";;
flyspeck_needs "nonlinear/lemma.hl";;

let ineq = Sphere.ineq;;
let all_forall = Sphere.all_forall;;
let add = Ineq.add;;

let nub = Parse_ineq.nub;;

let join_comma = Parse_ineq.join_comma;;
let join_space = Parse_ineq.join_space;;
let join_lines = Parse_ineq.join_lines;;

let NONLIN = new_definition `NONLIN = F`;;




(* ========================================================================== *)
(*    SPLITTING INEQUALITIES                                                  *)
(* ========================================================================== *)



let split_interval = prove_by_refinement(
  `! a b (y:real). (a <= y /\ y <= b) ==>
  ((a <= y /\ y <= m) \/ (m <= y /\ y <= b) )
   `,
  (* {{{ proof *)
  [
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let split_2h0 = INST [(`&2 * h0`,`m:real`)] split_interval;;

let all_goal() = map (function (_,w) -> w) ((function (_,b,_) -> b) 
  (hd (!current_goalstack)));;

let SPLIT_H0_TAC pos =  
 (REPEAT GEN_TAC) THEN
 (REWRITE_TAC[ineq_expand6]) THEN
 (REPLICATE_TAC (pos) DISCH_TAC) THEN
 (DISCH_THEN (fun t -> MP_TAC (MATCH_MP split_2h0 t))) THEN
 DISCH_THEN DISJ_CASES_TAC    THEN (REPEAT (POP_ASSUM MP_TAC)) THEN (REWRITE_TAC[GSYM ineq_expand6]);;

let split_h0_term i inq = 
  let _ = g inq in
  let _ = e(SPLIT_H0_TAC i) in
    map all_forall (all_goal());;

let get_split idq = 
  let ts = idq.tags in
  let rec gs = (function
    | [] -> []
    | (Split a::_) -> a 
    | _ :: rs -> gs rs) in
    gs ts;;

(* let filter_split not_i = filter (fun t -> not(t=not_i));; *)

let split_h0 (ineq,ss) = 
  let _ = (List.length ss > 0)  or failwith "empty split" in
  let ineql = split_h0_term (hd ss) ineq in
   map (fun t-> (t, tl ss)) ineql;;

let rec split_all_h0 = function
  | [] -> []
  | (i,[])::rs -> i :: split_all_h0 rs
  | r::rs -> split_all_h0 (split_h0 r @ rs);;



(* ========================================================================== *)
(*    PARSING INEQUALITIES                                                    *)
(* ========================================================================== *)


let quoted s = let q = "\"" in (q^s^q);;

let i_mk s = "interval::interval ("^quoted s ^")";;

let string_of_num' = Parse_ineq.string_of_num';;

let dest_decimal = Parse_ineq.dest_decimal;;

 (* these names don't change in cpp *)

let idem_assoc = map (fun a -> (a,a)) [
  "delta_x4";
  "halfbump_x1";"halfbump_x4";
  "dih_x_div_sqrtdelta_posbranch";"dih2_x_div_sqrtdelta_posbranch";
  "dih3_x_div_sqrtdelta_posbranch";"dih4_x_div_sqrtdelta_posbranch";
  "dih5_x_div_sqrtdelta_posbranch";"dih6_x_div_sqrtdelta_posbranch";
  "ldih_x_div_sqrtdelta_posbranch";"ldih2_x_div_sqrtdelta_posbranch";
  "ldih3_x_div_sqrtdelta_posbranch";"ldih4_x_div_sqrtdelta_posbranch";
  "ldih5_x_div_sqrtdelta_posbranch";"ldih6_x_div_sqrtdelta_posbranch";
  "sol_euler_x_div_sqrtdelta";"sol_euler345_x_div_sqrtdelta";
  "sol_euler156_x_div_sqrtdelta";"sol_euler246_x_div_sqrtdelta";
  "taum_x1";"taum_x2";"taum_x1_x2";"arclength_x1";
  "arclength_x_123";"acs_sqrt_x1_d4";"acs_sqrt_x2_d4";
  "gchi2_x";"gchi3_x";"gchi4_x";"gchi5_x";"gchi6_x";
  "ldih_x";"ldih2_x";"ldih3_x";"ldih6_x";
  "asn797k"; "asnFnhk"; "lfun_y1";"surf_x";"surfR126d";
    "sol";   "vol_x";   "gchi1_x";"eta2_126";"eta2_135";];;

(* these names can change in cpp *)

let cpp_assoc = 
  let pref = "taylorSimplex::" in
  let p (a,b) = (a, (pref^b)) in map p 
  (idem_assoc @ [("unit6","unit");
  ("proj_x1","x1");("proj_x2","x2");("proj_x3","x3");
  ("proj_x4","x4");("proj_x5","x5");("proj_x6","x6");
   ("sqrt_x1","y1");   ("sqrt_x2","y2");   ("sqrt_x3","y3");  
   ("sqrt_x4","y4");   ("sqrt_x5","y5");   ("sqrt_x6","y6");
   ("dih_x","dih"); ("dih2_x","dih2");("dih3_x","dih3");
   ("dih4_x","dih4"); ("dih5_x","dih5");("dih6_x","dih6");
  ("mardih_x","marchalDih");  ("mardih2_x","marchalDih2");  
  ("mardih3_x","marchalDih3");
  ("mardih4_x","marchalDih4");  ("mardih5_x","marchalDih5"); 
  ("mardih6_x","marchalDih6");
  ("norm2hh_x","norm2hhx");
  ("rad2_x","rad2");
   ("delta_x","delta");
   ("rhazim_x","rhazim");("rhazim2_x","rhazim2");
  ("rhazim3_x","rhazim3");
  ("promote_pow2","x1square");
("promote_pow3","x1cube");

 ]);;

let cpp0_assoc = 
  [("sqrt8","sqrt8");("pi","pi");("const1","const1");
   ("hminus","hminus");("sqrt3","sqrt3");
  ("arc_hhn","arc_hhn");
  ("adodec","aStrongDodec");
  ("bdodec","bStrongDodec");
  ("ydodec","yStrongDodec");
   ];;


let x6list =  
  [`x1:real`;`x2:real`;`x3:real`;`x4:real`;`x5:real`;`x6:real`];;


let cpp_of_constant s  = 
  try (assoc s cpp0_assoc) with 
      Failure _ -> failwith (s^" find: cpp_of_constant") ;;

let paren s = "("^ s ^")";;

let cpp_of_fun to_string s xs = 
  let (arg,xss) = chop_list (List.length xs - 6) xs in
  let _ = (xss = x6list) or failwith ("x6 list expected in "^s) in
  let hd =  try (assoc s cpp_assoc) with 
      Failure _ -> failwith (s^" not found in cpp_assoc")  in
  let arg_s = map (paren o to_string) arg in
  let p = if (List.length arg > 0) then paren else I in
    (hd ^ " " ^ p(join_comma arg_s));;

let cpp_string_of_term = 
let rec ccform t =
  let soh = ccform in
  if is_var t then fst (dest_var t) else
  let (f,xs) = strip_comb t in
  let ifix i = let [a;b] = xs in paren(soh a ^ " " ^ i ^ " " ^ soh b) in
  let _  = (is_const f) or failwith ("oracle: " ^ string_of_term f) in
  match fst (dest_const f) with
  | "real_add" -> ifix "+"
  | "real_mul" -> ifix "*"
  | "real_div" -> ifix "/"
  | "\\/" -> ifix "\\/"
  | "real_neg" -> let [a] = xs in "(-" ^ soh a ^ ")"
  | "real_of_num" -> let [a] = xs in i_mk(soh a)  
  | "NUMERAL" -> let [a] = xs in string_of_num' (dest_numeral t)
  | "<" -> let [a;b] = xs in "(" ^ soh a ^ " < " ^ soh b ^ ")"
  | ">" -> let [a;b] = xs in "(" ^ soh a ^ " > " ^ soh b ^ ")"
  | "+" -> let [a;b] = xs in "(" ^ soh a ^ " + " ^ soh b ^ ")"
  | "*" -> let [a;b] = xs in "(" ^ soh a ^ " * " ^ soh b ^ ")"
  | "DECIMAL" ->  i_mk(string_of_num' (dest_decimal t))
(*  | "COND" -> let [a;b;c] = xs in paren(soh a ^ " ? " ^ soh b ^ " : " ^ soh c) *)
  | s -> if (xs = []) then "("^cpp_of_constant s^")"  
    else "(" ^ cpp_of_fun ccform s xs  ^ ")" in
  fun t -> try (ccform t) with Failure s -> 
    failwith (s^" .......   "^string_of_term t);;


(* processing cpp code *)

let prep_expand = (
   [Sphere.gamma4f;Sphere.vol4f;Parse_ineq.y_of_x_e;
    Parse_ineq.vol_y_e;Sphere.vol3f;
    Sphere.vol3r;Sphere.vol2f;lfun1;
   Sphere.gamma3f;Sphere.gamma23f;
   GSYM Parse_ineq.quadratic_root_plus_curry;
   REAL_MUL_LZERO;
   REAL_MUL_RZERO;FST;SND;Sphere.pathL;Sphere.pathR;
   Sphere.node2_y;Sphere.node3_y;
   Sphere.rhazim2;Sphere.rhazim3;
   Sphere.rotate2;Sphere.rotate3;Sphere.rotate4;
   Sphere.rotate5;Sphere.rotate6;
   ] @ (!Ineq.dart_classes));;

let prep_term t = 
  let t' = REWRITE_CONV (prep_expand) (Parse_ineq.strip_let_tm t) in
  let (a,b)=  dest_eq (concl t') in
    b;;

let dest_ineq ineq = 
  let t = snd(strip_forall (prep_term (ineq))) in
  let (vs,i) = dest_comb t in
  let (_,vs) = dest_comb vs in
  let vs = dest_list vs in
  let vs = map (fun t -> let (a,b) = dest_pair t in (a,dest_pair b)) vs in
  let vs = map (fun (a,(b,c)) -> (a, b, c)) vs in
    (t,vs,disjuncts i);;

let dest_nonlin t = 
  let (_,r,il) = dest_ineq t in 
  let p1 (a,_,_) = a in
  let p2 (_,b,_) = b in
  let p3 (_,_,c) = c in
  let dest x = try dest_binop `(real_lt)` x with Failure _ -> dest_binop `(real_le)` x in
  let (iis,zzs) = unzip( map (dest) il) in
  let zz = nub zzs in
  let _ = (zz = [`&0`]) or failwith "zero expected" in
  let _ = (map p2 r = x6list) or failwith "x1..x6 expected" in
  (map p1 r, map p3 r,iis);;

(* let join_semi = Parse_ineq.unsplit ";" (fun t -> t);; *)

(*
let cpp_template = Printf.sprintf "
 char* svn = %s;
 char* ineq_id = %s;
 int testRun()
	{
	interval tx[6]={%s};
	interval tz[6]={%s};
	domain x = domain::lowerD(tx);
	domain z = domain::upperD(tz);
	taylorFunction F = %s;
	//F.setReducibleState(0);
        cellOption opt;
	return generic (x,z,F,%d);
	}";;
*)

let cpp_template_taylor (i,s) = Printf.sprintf 
"       taylorFunction F%d = %s;" i s;;

let cpp_template_t iis = 
  join_lines 
    (map cpp_template_taylor (zip (1--(List.length iis)) iis));;

let cpp_template_F i = Printf.sprintf "&F%d" i;;

let cpp_template_Fc len = join_comma 
  (map cpp_template_F (1-- len));;

let cpp_template_gen = Printf.sprintf "
 char* svn = %s;
 char* ineq_id = %s;

 int testRun()
	{
	interval tx[6]={%s};
	interval tz[6]={%s};
	domain x = domain::lowerD(tx);
	domain z = domain::upperD(tz);
        domain x0=x;
        domain z0=z;
        %s
        const taylorFunction* I[%d] = {%s}; // len ...
        cellOption opt;
        opt.allowSharp = %d; // sharp
        opt.onlyCheckDeriv1Negative = %d; // checkderiv
	return prove::recursiveVerifier(0,x,z,x0,z0,I,%d,opt); // len
	}";;

let mk_cpp_proc t s sharp checkderiv= 
  let c = map cpp_string_of_term in
  let f (x,y,z) = (c x,c y,c z) in
  let (aas,bbs,iis) = f (dest_nonlin t) in
  let len = List.length iis in
(*  let _ = (len < 3) or failwith "mk_cpp_proc: higher disjunctions not installed" in *)
  let sq = quoted s in
  let svn = (quoted(svn_version())) in
  let jaas = join_comma aas in
  let jbbs = join_comma bbs in
  (* if (len < 2) then cpp_template svn sq jaas jbbs (hd iis) sharp checkderiv else *)
  cpp_template_gen svn sq jaas jbbs (cpp_template_t iis) 
    len (cpp_template_Fc len) sharp  checkderiv len;;

(* mk_cpp_proc testineq testid;;
    next: put together header, proc, tail and run *)

let tmpfile = flyspeck_dir^"/../interval_code/test_auto.cc";;

(* from glpk_link.ml *)

let load_and_close_channel do_close ic = 
  let rec lf ichan a = 
    try
      lf ic (input_line ic::a)
    with End_of_file -> a in
    let rs = lf ic [] in
      if do_close then close_in ic else ();
      rev rs;;

let load_file filename = 
  let ic = Pervasives.open_in filename in load_and_close_channel true ic;;

let cpp_header() = join_lines (load_file  (flyspeck_dir^"/../interval_code/generic_head.txt"));;

let cpp_tail() = join_lines (load_file  (flyspeck_dir^"/../interval_code/generic_tail.txt"));;

let mkfile_cpp  t s sharp checkderiv = 
  Parse_ineq.output_string tmpfile 
   (join_lines [cpp_header(); (mk_cpp_proc t s sharp checkderiv);cpp_tail()]);;

let compile_cpp () = 
  let err = "/tmp/cpp_err.txt" in
  let e = Sys.command("cd "^flyspeck_dir^"/../interval_code; make test_auto >& "^err) in
  let _ =   (e=0) or (let _ = Sys.command ("cat "^err) in failwith "compiler error") in
    ();;

 let execute_interval ex (t,s,sharp,checkderiv) = 
  let interval_dir = flyspeck_dir^"/../interval_code" in
  let _ =  mkfile_cpp t s sharp checkderiv in
  let _ = compile_cpp() in 
  let _ = (not ex) or (0=  Sys.command(interval_dir^"/test_auto")) or failwith "interval execution error" in
    ();;



(* ========================================================================== *)
(*    MEGA PREP    TACTICS                                                    *)
(* ========================================================================== *)


(* for big series in ineqdata... *)



let OR_RULE rule1 rule2 th = try rule1 th with _ -> rule2 th;;

let rec REPEAT_RULE rule =
  fun t -> if can rule t then REPEAT_RULE rule (rule t) else t;;

let h0_lt_gt = prove_by_refinement(
  `((y <= #2.01) ==> (y <= &2 * h0)) /\
   ((#2.8 <= y) ==> (&2 * h0 <= y)) /\
  (( y <= &2) ==> (y <= &2 * h0)) /\
    ((sqrt8 <= y) ==> (&2 * h0 <= y)) /\   ((&2 * h0 <= y) ==> (&0 <= y)) /\
   ((&2 <= y) ==> (&0 <= y))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.h0;sqrt8_sqrt2];
    MP_TAC sqrt2_lb;
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let sqrtxx = prove_by_refinement(
  `!x. &0 <= x ==> (sqrt(x * x) = x)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[POW_2_SQRT_ABS;REAL_ARITH `x * x = x pow 2`];
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let lmdih_ldih = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&0 <= y1 /\ y1 <= &2 * h0) ==>(y_of_x lmdih_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  y_of_x ldih_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.y_of_x;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun_lfun];
  ]);;
  (* }}} *)

let lmdih3_ldih3 = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&0 <= y3 /\ y3 <= &2 * h0) ==>(y_of_x lmdih3_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  y_of_x ldih3_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.rotate3;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch;Sphere.y_of_x;Sphere.lmdih3_x_div_sqrtdelta_posbranch;Sphere.ldih3_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun_lfun];
  ]);;
  (* }}} *)

let lmdih5_ldih5 = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&0 <= y5 /\ y5 <= &2 * h0) ==>(y_of_x lmdih5_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  y_of_x ldih5_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.rotate5;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch;Sphere.y_of_x;Sphere.lmdih5_x_div_sqrtdelta_posbranch;Sphere.ldih5_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun_lfun];
  ]);;
  (* }}} *)


let lmdih0 = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&2 * h0 <= y1 ) ==>(y_of_x lmdih_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  &0 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.y_of_x;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun0;REAL_ARITH `&0 * x = &0 `;h0_lt_gt];
  ]);;
  (* }}} *)

let lmdih3_0 = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&2 * h0 <= y3 ) ==>(y_of_x lmdih3_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  &0 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.y_of_x;Sphere.lmdih3_x_div_sqrtdelta_posbranch;Sphere.rotate3;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun0;REAL_ARITH `&0 * x = &0 `;h0_lt_gt];
  ]);;
  (* }}} *)

let lmdih5_0 = prove_by_refinement(
  `!y1 y2 y3 y4 y5 y6. (&2 * h0 <= y5 ) ==>(y_of_x lmdih5_x_div_sqrtdelta_posbranch y1 y2 y3 y4 y5 y6 =  &0 )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.y_of_x;Sphere.lmdih5_x_div_sqrtdelta_posbranch;Sphere.rotate5;Sphere.lmdih_x_div_sqrtdelta_posbranch;Sphere.ldih_x_div_sqrtdelta_posbranch];
  MESON_TAC[sqrtxx;lmfun0;REAL_ARITH `&0 * x = &0 `;h0_lt_gt];
  ]);;
  (* }}} *)

(* take care of branching *)

let BRANCH_TAC = EVERY[
REWRITE_TAC[REAL_ARITH `x / &1 = x /\ &0 * x = &0 /\ &0 +x = x`];
  REWRITE_TAC[Sphere.gamma4f;vol4f_lmfun;Sphere.gamma3f;(* vol3f_palt *)];
REWRITE_TAC[ineq_expand6];
DISCH_TAC;
REPEAT GEN_TAC;
REPEAT DISCH_TAC;
ASSUM_LIST (let rec r = function | [] -> ALL_TAC | th::ths -> (MP_TAC (REPEAT_RULE (OR_RULE (MATCH_MP pathL_bound) (MATCH_MP pathR_bound)) th)) THEN r ths in r);
REWRITE_TAC[];
SIMP_TAC[gcy_low;gcy_low_hminus;gcy_high;gcy_high_hplus;h0_lt_gt;lmdih3_ldih3;lmdih5_ldih5;lmdih_ldih;lmdih5_0;lmdih3_0;lmdih0];
SIMP_TAC[lmfun_lfun;lmfun0];
REWRITE_TAC[REAL_ARITH `&0 * x = &0 /\ &0 + x = x`];
REPEAT (DISCH_THEN (fun t-> ALL_TAC));
REPEAT (POP_ASSUM MP_TAC);
REWRITE_TAC[GSYM ineq_expand6];
DISCH_TAC;
EVERY (map SPEC_TAC [(`y6:real`,`y6:real`);(`y5:real`,`y5:real`);(`y4:real`,`y4:real`);(`y3:real`,`y3:real`);(`y2:real`,`y2:real`);(`y1:real`,`y1:real`)]);
POP_ASSUM MP_TAC;
]
;;

let ineq6_of_ineq5 = prove_by_refinement(
  `!a1 a2 a3 a4 a5 y1 y2 y3 y4 y5 b1 b2 b3 b4 b5 P. 
((!x1 x2 x3 x4 x5 x6. ineq[(a1,x1,b1);(a2,x2,b2);(a3,x3,b3);(a4,x4,b4);(a5,x5,b5);(&1,x6,&1)] 
   (P x1 x2 x3 x4 x5)) ==> 
    ineq[(a1,y1,b1);(a2,y2,b2);(a3,y3,b3);(a4,y4,b4);(a5,y5,b5)]
   (P y1 y2 y3 y4 y5))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ineq];
  MESON_TAC[REAL_ARITH `&1 <= &1`];
  ]);;
  (* }}} *)

let ineq6_of_ineq1 = prove_by_refinement(
  `!a1 y1 b1 P. 
((!x1 x2 x3 x4 x5 x6. ineq[(a1,x1,b1);(&1,x2,&1);(&1,x3,&1);(&1,x4,&1);(&1,x5,&1);(&1,x6,&1)] 
   (P x1)) ==> ineq[(a1,y1,b1)]  (P y1))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ineq];
  MESON_TAC[REAL_ARITH `&1 <= &1`];
  ]);;
  (* }}} *)

let SERIES3Q1H_5D_TAC = 
  let instjx = INST_TYPE [(`:real`,`:A`);(`:real`,`:B`);(`:real`,`:C`);
			  (`:real`,`:D`);(`:real`,`:E`);(`:real`,`:F`)] in
  let PROJX = map instjx [ proj_x1;proj_x2;proj_x3;proj_x4;proj_x5;proj_x6] in
  let projx = list_mk_conj (map (concl o GSYM) PROJX ) in
 (REPEAT STRIP_TAC   THEN MATCH_MP_TAC ineq6_of_ineq5) THEN
 (REWRITE_TAC[Sphere.pathL;Sphere.pathR;Sphere.hplus;Sphere.h0]) THEN
 (REWRITE_TAC[ineq_expand6]) THEN
 (REPEAT GEN_TAC THEN REPEAT DISCH_TAC) THEN
 (SUBGOAL_THEN projx (fun t -> PURE_ONCE_REWRITE_TAC[t])) THENL
 [(REWRITE_TAC PROJX);ALL_TAC] THEN
 (REPEAT (POP_ASSUM MP_TAC)) THEN
 (REWRITE_TAC[GSYM ineq_expand6]);;

let get_macro_cpp_expand() = (
   [vol4f_palt;Parse_ineq.y_of_x_e;(* Parse_ineq.vol_y_e; *)
   Sphere.vol3f;Sphere.vol3r;Sphere.vol2f;Sphere.gamma4f;
   Sphere.gamma3f;Sphere.gamma23f;GSYM Parse_ineq.quadratic_root_plus_curry;
   REAL_MUL_LZERO;
   REAL_MUL_RZERO;FST;SND;Sphere.pathL;Sphere.pathR;
   Sphere.node2_y;Sphere.node3_y] @ (!Ineq.dart_classes));;

let xspec = SPECL [`x1:real`;`x2:real`;`x3:real`;`x4:real`;`x5:real`;`x6:real`];;

let X_OF_Y_DEF =  [REAL_ARITH `&2 = #2.0`;
 GSYM mardih_x;GSYM mardih2_x;GSYM mardih3_x;
 GSYM mardih4_x;GSYM mardih5_x;GSYM mardih6_x;beta_bump_force_x;
 GSYM Sphere.gchi1_x;GSYM Sphere.gchi2_x;GSYM Sphere.gchi3_x;GSYM Sphere.gchi4_x;GSYM Sphere.gchi5_x;GSYM Sphere.gchi6_x;
 GSYM Sphere.taum_x1_x2;GSYM Sphere.taum_x1;GSYM Sphere.taum_x2;
 GSYM Sphere.arclength_x1;GSYM Sphere.surf_x;
 GSYM Sphere.ldih_x;GSYM Sphere.ldih2_x;GSYM Sphere.ldih3_x;GSYM Sphere.ldih6_x;
 GSYM Sphere.surfR126d;];;

  let VAR_ORDER_TM = 
`norm2hh (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
     norm2hh_x x1 x2 x3 x4 x5 x6 /\ 
 rad2_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
     rad2_x x1 x2 x3 x4 x5 x6 /\ 
 dih2_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
     dih2_x x1 x2 x3 x4 x5 x6 /\         
 dih3_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
    dih3_x x1 x2 x3 x4 x5 x6 /\         
 dih_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
     dih_x x1 x2 x3 x4 x5 x6 /\  
 dih4_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
    dih4_x x1 x2 x3 x4 x5 x6 /\
 dih5_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
   dih5_x x1 x2 x3 x4 x5 x6 /\
 dih6_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
   dih6_x x1 x2 x3 x4 x5 x6 /\      
 delta_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
   delta_x x1 x2 x3 x4 x5 x6 /\ 
 vol_y (sqrt x1) (sqrt x2) (sqrt x3) (sqrt x4) (sqrt x5) (sqrt x6) = 
   vol_x x1 x2 x3 x4 x5 x6 /\ 
 eta_y (sqrt x1) (sqrt x2) (sqrt x6) pow 2 = eta2_126 x1 x2 x3 x4 x5 x6 /\ 
 eta_y (sqrt x1) (sqrt x3) (sqrt x5) pow 2 = eta2_135 x1 x2 x3 x4 x5 x6`;;

  let SQRT_SQRT_TAC = 
EVERY[
  REPEAT DISCH_TAC;
  SUBGOAL_THEN `sqrt x1 * sqrt x1 = x1 /\ sqrt x2 * sqrt x2 = x2 /\ sqrt x3 * sqrt x3 = x3 /\ sqrt x4 * sqrt x4 = x4 /\ sqrt x5 * sqrt x5 = x5 /\ sqrt x6 * sqrt x6 = x6` (fun t-> REWRITE_TAC[t]) THENL[ ASM_MESON_TAC[sq_pow2];ALL_TAC] THEN
  REPEAT (POP_ASSUM MP_TAC);
  DISCH_TAC;
];;

let X_OF_Y_TAC = 
  (
  (DISCH_TAC) THEN
  (REWRITE_TAC[GSYM Sphere.rad2_y]) THEN
  (REWRITE_TAC(get_macro_cpp_expand())) THEN
  (MATCH_MP_TAC ineq_square2) THEN
  (REWRITE_TAC basic_constants_nn) THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN
  (REPEAT (CONJ_TAC THENL[MP_TAC hminus_gt THEN REWRITE_TAC[Sphere.h0;Sphere.hplus] THEN REAL_ARITH_TAC;ALL_TAC])) THEN
  (REPEAT GEN_TAC) THEN
  (REWRITE_TAC [sol_y_123;taum_123]) THEN
  (REWRITE_TAC[ineq]) THEN
  (SQRT_SQRT_TAC) THEN
(*    SIMP_TAC[sq_pow2] THEN *)
  (REPEAT DISCH_TAC) THEN
  (SUBGOAL_THEN  VAR_ORDER_TM  (fun t-> REWRITE_TAC[t;(GSYM Sphere.rhazim_x); (GSYM Sphere.rhazim2_x);xspec (GSYM Sphere.rhazim3_x)]) THENL[ (ASM_MESON_TAC[Sphere.norm2hh_x;rad2_x_y;dih_x_y;dih2_x_y;delta_x_y;dih3_x_y;GSYM Sphere.dih4_x;GSYM Sphere.dih5_x;GSYM Sphere.dih6_x;vol_x_y;Sphere.eta2_126; Sphere.eta2_135;]);ALL_TAC]) THEN
  REWRITE_TAC X_OF_Y_DEF THEN
  (REPEAT (FIRST_X_ASSUM MP_TAC)) THEN
  (REWRITE_TAC[GSYM ineq_expand6]) THEN
  (REWRITE_TAC[REAL_ARITH `(&2 = #2.0) /\ (x pow 2 = x * x) /\ (#2.0 * #2.0 = #4.0) /\ (#2.18 * #2.18 = #4.7524 ) /\ (#2.52 * #2.52 = #6.3504)`;sqrt8_2;Sphere.h0;Sphere.hplus]) THEN
  ALL_TAC);;

let EXPAND_lfun = 
  (SUBGOAL_THEN `lfun x1 = (#1.26 - proj_x1  (x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real))/(#0.26)` (fun t-> REWRITE_TAC[t])) THENL [
  REWRITE_TAC[Sphere.lfun;proj_x1;Sphere.h0;REAL_ARITH `#1.26 - &1 = #0.26`];ALL_TAC] ;;

let REMOVE_dummy = SUBGOAL_THEN `!(f:bool). (!(dummy:real). ineq [&1,dummy,&1] f) = (!(x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real). ineq[(&1,x1,&1);(&1,x2,&1);(&1,x3,&1);(&1,x4,&1);(&1,x5,&1);(&1,x6,&1)] f)` (fun t-> REWRITE_TAC[t]) THENL[  REWRITE_TAC[ineq] THEN  MESON_TAC[REAL_ARITH `~(&2 <= &1)`]; ALL_TAC];;

let EXPAND_1var = SUBGOAL_THEN `!(f:real->bool) a b. (!(y:real). ineq [a,y,b] (f y)) = (!(x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real). ineq[(a,x1,b);(&1,x2,&1);(&1,x3,&1);(&1,x4,&1);(&1,x5,&1);(&1,x6,&1)] (f x1))` (fun t-> REWRITE_TAC[t]) THENL [REWRITE_TAC[ineq] THEN  MESON_TAC[REAL_ARITH `(&1 <= &1)`];ALL_TAC] ;;


let REAL_SIMPLIFY_EXPRESSION =  let
  arith = REAL_ARITH `!x y z. (&8 = #8) /\ (x - y = x + (-- #1.0) * y) /\ 
  (x * (y+z) = x * y + x * z) /\ (y+z) * x = y * x + z * x /\ 
  (x + y) + z = x + y + z /\ (-- x * -- y = x * y) /\ (x * -- y = -- x * y) /\ 
  (-- x * y = -- (x * y)) /\ (x * y) * z = x * y * z /\ -- #1.0 * x = -- x /\ 
  -- (x + y) = -- x + (--y) /\ -- (-- x) = x /\ (-- (-- x * y) = x * y) /\
   #0.0 = &0 /\ #0 = &0 /\ &0 * x = &0 /\ x * &0 = &0 /\ (&0 + x = x) /\ 
  -- &0 = &0 /\ (x + &0 = x) /\ (&0 + x = x) /\
  &1 * x = x /\ -- &1 * x = -- x /\ x * sqrt8 = sqrt8 * x    ` in
  (REWRITE_TAC[REAL_POW_MUL;real_div;REAL_MUL_LZERO; REAL_MUL_RZERO;arith]) ;;

let EXPAND_SQRT = 
  (SUBGOAL_THEN `sqrt x1 = sqrt_x1 x1 x2 x3 x4 x5 x6 /\ sqrt x2 = sqrt_x2 x1 x2 x3 x4 x5 x6 /\ sqrt x3 = sqrt_x3 x1 x2 x3 x4 x5 x6 /\ sqrt x4 = sqrt_x4 x1 x2 x3 x4 x5 x6 /\ sqrt x5 = sqrt_x5 x1 x2 x3 x4 x5 x6 /\ sqrt x6  = sqrt_x6 x1 x2 x3 x4 x5 x6` (fun t->REWRITE_TAC[t])  THENL [REWRITE_TAC[sqrt_x1;sqrt_x2; sqrt_x3;sqrt_x4;sqrt_x5;sqrt_x6];ALL_TAC]) ;;

(* for 1d inequality involving vol2f marchal *)

let EXPAND_vol2 = 
REWRITE_TAC[vol2f_marchal_pow_y;vol2r_y] THEN
  SUBGOAL_THEN `x1 pow 1 = promote pow1 x1 x2 x3 x4 x5 x6 /\ x1 pow 2 = promote_pow2 x1 x2 x3 x4 x5 x6 /\ x1 pow 3 = promote_pow3 (x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real) /\ x1 pow 4 = promote pow4 x1 x2 x3 x4 x5 x6` (fun t->REWRITE_TAC[t]) THENL[ REWRITE_TAC[promote;pow1;pow2;pow3;pow4;promote_pow2;promote_pow3];REWRITE_TAC[LET_DEF;LET_END_DEF]] ;;

let DEF_expand = [Sphere.a_spine5;Sphere.b_spine5;Sphere.mm1;
		  Sphere.flat_term;Sphere.beta_bump_lb;REAL_POW_2;
		  Sphere.h0;
   Sphere.mm2;GSYM Sphere.sqrt2;GSYM Sphere.sqrt3;GSYM Sphere.sqrt8;sol0_const1;sqrt2_sqrt8;
   Sphere.mm1;Sphere.mm2;Sphere.tau0;Sphere.hplus;tame_table_d_values;Sphere.vol2f;
   Sphere.lfun; (* added Oct 17, 2010 *)
   ];;

let STYLIZE_TAC = 
  REMOVE_dummy  THEN
  EXPAND_1var THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN
  EXPAND_vol2 THEN
 (* prev line added Sep 8 , 2010 *)
  REWRITE_TAC  DEF_expand THEN
 (* prev line moved down sep 8 *)
  EXPAND_lfun THEN
  REWRITE_TAC[ineq] THEN
  (REPEAT DISCH_TAC) THEN
  (ONCE_REWRITE_TAC[REAL_ARITH `(x < y <=> (x- y < &0)) /\ (x <= y <=> (x-y <= &0))`]) THEN
  (REWRITE_TAC[REAL_ARITH `(x > y <=> (y - x < &0) ) /\ (x >= y <=> (y-x <= &0))`]) THEN
  EXPAND_SQRT THEN
  REAL_SIMPLIFY_EXPRESSION THEN
    SUBGOAL_THEN `!a. x1:real * a = a * x1` (fun t->REWRITE_TAC[t]) THENL[REAL_ARITH_TAC;ALL_TAC] THEN (* added OCt 17, 2010 *)
  (SUBGOAL_THEN `!x. ((x < &0) <=> (unit0 * x < &0)) /\ ((x <= &0) <=> (unit0 * x <= &0))` (fun t -> ONCE_REWRITE_TAC[t])) THENL [REWRITE_TAC[unit0;REAL_ARITH `&1 * x = x`];ALL_TAC] THEN
  (REWRITE_TAC[REAL_ARITH `f x1 x2 x3 x4 x5 x6 * (y:real) = y * f x1 x2 x3 x4 x5 x6 /\ ((x * y) * z = x * y * z)`]) THEN
  (REWRITE_TAC[REAL_ARITH `unit0 * (x + y ) = unit0 * x + unit0 * y /\ unit0 * --x = --(unit0 * x) /\ (unit0 * x  = x  * unit0) /\ (x * y) * z = x * y * z`]) THEN
  (REWRITE_TAC[REAL_ARITH `unit0 * x = x * unit0`]) THEN
  (REWRITE_TAC[unit0f]) THEN
    (SUBGOAL_THEN `x2 * unit0 = proj_x2 (x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real) /\ x1 * unit0 = proj_x1 (x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real) ` (fun t-> REWRITE_TAC[t]) THENL[REWRITE_TAC[proj_x2;proj_x1;unit0;REAL_ARITH `x * &1 = x`];ALL_TAC]) THEN
  (SUBGOAL_THEN `unit0 = unit6 (x1:real) (x2:real) (x3:real) (x4:real) (x5:real) (x6:real)` (fun t-> REWRITE_TAC[t]) THENL [REWRITE_TAC[unit0;unit6];ALL_TAC]) THEN
  (REPEAT (FIRST_X_ASSUM MP_TAC)) THEN
  (REWRITE_TAC[GSYM ineq_expand6]) THEN DISCH_TAC;;

let WRAPUP_TAC = 
(REWRITE_TAC[REAL_ARITH `(x * y * (z:real)) = (x * y) * z`]) THEN
  (REWRITE_TAC[REAL_ARITH `(y:real) * f x1 x2 x3 x4 x5 x6 =  (f x1 x2 x3 x4 x5 x6) *  y `]) THEN
 (REWRITE_TAC[REAL_ARITH ` -- (x * y) = x * (-- y) `]) THEN
 (REWRITE_TAC[REAL_ARITH ` -- (f x1 x2 x3 x4 x5 x6) = f x1 x2 x3 x4 x5 x6 * -- &1`]) THEN
 (REWRITE_TAC[REAL_ARITH `(x * y) * (z:real) = x * y * z`]) THEN
  (REWRITE_TAC[REAL_ARITH `inv y = (&1/y)`]);;

(* SHARP CASES *)

let gamma4f_delta0 = prove_by_refinement(
  mk_imp (`NONLIN:bool`,all_forall `ineq [(sqrt8,y1,sqrt8);
		    (&2,y2,&2);
		    (&2,y3,&2);
		    (sqrt8,y4,sqrt8);
		    (&2,y5,&2);
		    (&2,y6,&2)]
 		    (gamma4f y1 y2 y3 y4 y5 y6 lmfun = &0)`),
  (* {{{ proof *)
  [
  BRANCH_TAC;
  X_OF_Y_TAC;
  REWRITE_TAC[Sphere.ineq];
  REPEAT STRIP_TAC;
  SUBGOAL_THEN `x1 = &8 /\ x2 = &4 /\ x3 = &4 /\ x4 = &8 /\ x5 = &4 /\ x6 = &4` (fun t -> REWRITE_TAC[t]);
  REPEAT (POP_ASSUM MP_TAC);
  REAL_ARITH_TAC;
  REPEAT (POP_ASSUM (fun t -> ALL_TAC));
  REWRITE_TAC[Sphere.vol_x;Sphere.gchi2_x;Sphere.gchi3_x;Sphere.gchi5_x;Sphere.gchi6_x;Sphere.dih_x;Sphere.dih2_x;Sphere.dih3_x;Sphere.dih4_x;Sphere.dih4_y;Sphere.dih5_x;Sphere.dih5_y;Sphere.dih6_x;Sphere.dih6_y;Sphere.dih_y];
  REWRITE_TAC[LET_DEF;LET_END_DEF];
  SUBGOAL_THEN `sqrt (&4) * sqrt(&4) = &4 /\ sqrt(&8) *sqrt (&8) = &8` (fun t-> REWRITE_TAC[t]);
  CONJ_TAC THEN MATCH_MP_TAC sq_pow2 THEN EXISTS_TAC `&0` THEN REAL_ARITH_TAC;
  REWRITE_TAC[delta_x_eq0;REAL_ARITH `x * &0 = &0 /\ -- -- x = x`;SQRT_0;delta_x4_eq64;atn2_0y];
  MP_TAC PI_POS;
  CONV_TAC  REAL_FIELD;    
  ]);;
  (* }}} *)



(* ========================================================================== *)
(*    VERIFYING INEQUALITIES                                                  *)
(* ========================================================================== *)


let get_testcase s = 
  let idq =  hd(Ineq.getexact s) in
(*  let b = mem Xconvert idq.tags in *)
  (idq,Parse_ineq.strip_let_tm idq.ineq);;

let is_xconvert (idq,_) = mem Xconvert idq.tags;;

let is_branch (idq,_) = mem Tprep idq.tags;;


let testfull ex s case = 
  let _ = g (mk_imp (`NONLIN`,snd case)) in
  let _ = if (is_branch case) then e(BRANCH_TAC) else e(ALL_TAC) in
  let _ = if (is_xconvert case) then e (X_OF_Y_TAC) else e(ALL_TAC) in
  let _ =   if (is_branch case && not(is_xconvert case)) then
    e(SERIES3Q1H_5D_TAC) else e(ALL_TAC) in
  let _ = e (STYLIZE_TAC) in
  let _ = e (WRAPUP_TAC) in
  let sharp = if  mem Sharp (fst case).tags then 1 else 0 in
  let checkderiv = if  mem Onlycheckderiv1negative (fst case).tags then 1 else 0 in
  let testineq = snd(top_goal()) in
    execute_interval ex (testineq,s,sharp,checkderiv);;

let test ex s = 
  let testid = s in
  let testcase = get_testcase  testid in 
    testfull ex testid testcase;;

let testsplit ex s = 
  let testcase = get_testcase s in
  let ls = get_split (fst testcase) in
    if (ls = []) then test ex s else
      let cases = split_all_h0  [(snd testcase, ls)] in
      let name_suffix i = Printf.sprintf " split(%d/%d)" i (List.length cases) in
	for i=0 to (List.length cases - 1) do 
	  try (testfull ex (s^name_suffix i) (fst testcase,(List.nth cases i)))
	  with Failure s -> failwith (s ^ " case fail: " ^(string_of_int i))
	done;;

(* let hassplit = filter (fun t -> List.length (get_split t) > 0) (!Ineq.ineqs);; *)

let testids = [ "1965189142 34";"3137600529"];;

let nightrun = [  "6938212390"; "9627800748 a";"9627800748 b";"9627800748 c";"9627800748 d";
  ];;

let malt =  [ "FHBVYXZ b"; ];;

(* ["9563139965"; "7676202716"; "3862621143"; "4240815464"; "6944699408"; 
   "7043724150";];; *)

(* moved "TSKAJXY-RIBCYXU" into early spot *)
let testid = hd malt;;
let testid = hd nightrun;;

failwith "stop here";;

testsplit true testid;;
map (testsplit true) nightrun;;


(* Parse_ineq.execute_cfsqp (hd(Ineq.getexact testid));; *)

let testcase = get_testcase  testid;;

let cases =
  let ls = get_split (fst testcase) in
     map (fun t -> (fst testcase,t)) (split_all_h0  [(snd testcase, ls)]);;
List.length cases;;
g (mk_imp (`NONLIN`,(fun (_,c) -> c) (List.nth cases 0)));;

(* Parse_ineq.execute_cfsqp (List.nth testids 0);; *)

(* goal *)

g (mk_imp (`NONLIN`,(fun (_,c) -> c) (get_testcase testid)));;
if (is_branch testcase ) then e(BRANCH_TAC) else e(ALL_TAC);; 
if (is_xconvert testcase) then e (X_OF_Y_TAC) else e(ALL_TAC);;
if (is_branch testcase && not(is_xconvert testcase)) then e(SERIES3Q1H_5D_TAC) else e(ALL_TAC);;
e (STYLIZE_TAC);;
e (WRAPUP_TAC);;

(* FIRST PASS OVER FULL LIST OF INEQS, SCAFFOLDING *)

let preprocess = REWRITE_RULE (DEF_expand @ Parse_ineq.get_macro_expand());; 

  let constants_of_id t = map fst (nub(Print_types.get_const_types 
   (concl(preprocess
   (ASSUME ((fun (_,c) -> c) (get_testcase t)))))));;

let get_const t = 
  let r = constants_of_id t in
  let knowns = 
    ["ineq";"real_neg";"lfun";
     "taum";"dih_y";"dih2_y";"dih3_y";"sqrt3";
     "beta_bump_force_y";"rad2_x";"vol_x";"delta_y";"delta_x4";"sol_y";
     "rhazim";"rhazim2";"rhazim3";
    (* constants *)
     "h0"; "hplus"; "sol0"; "mm1"; "mm2"; "hminus";  "beta_bump_lb"; 
    "a_spine5";"b_spine5";"sqrt8";"sqrt2";"pi";"const1";
    ] in
  let f = filter (fun s -> not (mem s knowns)) in
    f r;;

(*
let allids  =map (fun t-> t.id) (!Ineq.ineqs);;

let has_const c t = mem c (get_const t);;

let ineq_of_ids ids = map (fun (a,b) -> b) (map (get_testcase) ids);;

Parse_ineq.get_macro_expand();;


(*

let constant_list = nub (List.flatten (map get_const allids));;

  ["tauq"; "enclosed"; "edge_flat"; 
     "vol2r"; 

  (* polynomials *)

  (* case split *)
    "lmfun"; 
   
  (* implemented *)
   "arclength"; "eta_y"; "marchal_quartic"; "acs"; "norm2hh";
    "asn"; "cos"; "sin"; "sqrt";
  (* define away *)
  "flat_term";
  ]
*)

let has_edge_flat = filter (has_const "edge_flat") allids;;
let has_vol2r = filter (has_const "vol2r") allids;;
map concl (map preprocess (map ASSUME (ineq_of_ids has_edge_flat)));;

let mk_goodid() = filter (fun t -> List.length(get_const t) = 0) allids;;
map get_const testids;;
*)

(*
let goodid = mk_goodid();;
*)
searcht 5 [`edge_flat`];;

(* NEXT *)
Sphere.vol2r;;
Sphere.flat_term;;
(* next: filter out those that have run and pick a new one to do. *)

let non_test = [
 "9563139965" (* tauq, enclosed *);
  "GYQVFXJ hexD 1" (* edge_flat;  *);
  "2986512815" (* 9 variable polynomial *);
];;


(* some benchmarks 
(id, hales's nitpick time "H:MM:SS", zumkeller's sergei time "H:MM:SS");

*)

[("7394240696","0:01:32","0:29:26");
 ("7726998381","0:01:03","0:06:16");
 ("4047599236","0:01:04","0:00:59");
("5735387903","0:00:13","0:00:03");
("1550635295","0:00:01","0:00:46");
("1395142356","0:05:13","1:57:15");
 ];;

(*
Parse_ineq.execute_cfsqp (hd (Ineq.getexact "1395142356"));;
constrained min: 0.000999588577191658
*)

(*
process_to_string "cat qed_log.txt | sed  's/^.*ineq./\"/' | sed 's/., secs.*$/\";/'  "

cat qed_log.txt | sed  's/^.*ineq./"/' | sed 's/., secs.*$/";/' | sort -u | wc  

(*
let _ = Sys.command("cat "^flyspeck_dir^"/../interval_code/qed_log.txt");;
*)
*)


