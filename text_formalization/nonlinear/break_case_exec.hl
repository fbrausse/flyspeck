(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Nonlinear                                                  *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2014-06-05                                                           *)
(* ========================================================================== *)

(*
This uses a C++ program to partition each nonlinear inequality into subdomains.
On each subdomain the verification takes a small number of milliseconds to run in C++,
set by the parameter MSEC_INC.

The output appears in break_case_log.hl.
*)

(*
rflyspeck_needs "nonlinear/break_case_log.hl";;
*)

flyspeck_needs "nonlinear/prep.hl";;
flyspeck_needs "nonlinear/scripts.hl";;
flyspeck_needs "nonlinear/break_case_type.hl";;
flyspeck_needs "nonlinear/break_case_log.hl";;

module Break_case_exec = struct

  open Hales_tactic;;

(* PRELIMINARIES *)

  let assert_test p s = p or failwith s;;

let random_elt ls = 
  let i = Random.int (List.length ls) in
    List.nth ls i;;

let ( MSEC_INC ) = 1000;; (* global parameter for msec target size *)
let ERROR_TOLERANCE = 0.3;;  (* try for times within MSEC_INC * (1 +/- ERROR_TOLERANCE ). *)
let verbose = true;;

let get_idq s = 
  find (fun idq -> idq.idv = s) !Prep.prep_ineqs;;

let get_ineq s = 
  (get_idq s).ineq;;


(*
let get_prep s = 
  let p1 = !Prep.prep_ineqs in
    (find (fun t -> (t.idv = s)) p1);;
*)



let delta_ineq = 
  let t1 = (hd(Ineq.getexact "7823243247")).ineq in
  let t2 = (hd(Ineq.getexact "5744538693")).ineq  in
  let t3 = (get_idq "prep-2327525027").ineq in
  let t4 = (get_idq "prep-4092227918").ineq in 
  let t = end_itlist (curry mk_conj) [t1;t2;t3;t4] in
    Sphere.new_definition' (mk_eq (`delta_ineq_v6:bool`,t));;


(*

The type iargs is used to record a partition of a nonlinear inequality domain into pieces.
The code in this file is used to make the pieces all take approximately MSEC_INC milliseconds
to run.  The field 'a records the interval arithmetic C++ runtime in milliseconds.

The partition is determined from the data and the original domain determined by (x,z), where
x and z are lists of real numbers giving the lower left and upper right hand corners of the domain.

Iarg_leaf represents a domain with no subpartition.  The domain is all of (x,z).

Iarg_bisect (i,left,right) is a cut exactly in the middle along the ith variable.
The fields left and right give the further partition of the left and right sides.
For example if i=1 and (x,z) = [1.0;1.0;1.0],[3.0;3.0;3.0] then the partition goes
into (xleft,zleft) = [1.0;1.0;1.0],[3.0;2.0;3.0] and (xright,zright)=[1.0;2.0;1.0],[3.0;3.0;3.0].

Iarg_facet ((i,side),frac,msec,residual) breaks the domain in two unequal parts along the ith coordinate 
specified by a fraction 0.0 <= frac <= 1.0.
The fraction is measured from the left if side=false, and from the right otherwise.

For example, if i,side=1,false frac=0.25 and (x,z)= [x0;x1;x2],[z0;z1;z2], then
(xleft,rleft)= x,[z0;0.75 * x1+0.25 *z1;z2] and (xright,zright)=[x0;0.75*x1+0.25*z1,z].
The number msec is the C++ runtime for (xleft,rleft), and residual is the recursively defined
partition on (xright,zright).

For example, if we change side=true and keep the rest of the data the same, then
(xleft,rleft)= x,[z0;0.25 * x1+0.75 *z1;z2] and (xright,zright)=[x0;0.25*x1+0.75*z1,z].
The number msec is now the C++ runtime for (xright,right), and residual is the recursively defined
partition on (xleft,zleft). So changing the side exchanges right and left all the way along.


*)


let rec string_of_iargs = function 
  | Iarg_leaf msec -> Printf.sprintf "\n Iarg_leaf %d" msec
  | Iarg_facet ((i,b),frac,msec,a) -> Printf.sprintf "\n Iarg_facet ((%d,%s),%3.4f,%d,%s)"
      i (string_of_bool b) frac msec (string_of_iargs a)
  | Iarg_bisect(idx,a,b) -> Printf.sprintf "\n Iarg_bisect (%d,%s,%s)" 
      idx (string_of_iargs a) (string_of_iargs b);;


(* ********************************************************************** *)
(* I/O *)
(* ********************************************************************** *)

let break_temp_file = Filename.temp_file "break_log" ".hl";; 

let touch_temp = process_to_string (Printf.sprintf "touch %s" break_temp_file);;

(*
let fullpath s = flyspeck_dir ^ s;;

let output_case s iargs = 
  let sfull = Printf.sprintf "\nadd_case (\"%s\",%s);;\n" s (string_of_iargs iargs) in
  let oc = open_out_gen [Open_append;Open_text] 436 (fullpath "nonlinear/break_case_log_more.hl") in
  (Pervasives.output_string oc (sfull); close_out oc);;
*)

let output_case s iargs = 
  let sfull = Printf.sprintf "\nadd_case (\"%s\",%s);;\n" s (string_of_iargs iargs) in
  let oc = open_out_gen [Open_append;Open_text] 436 (break_temp_file) in
  (Pervasives.output_string oc (sfull); close_out oc);;


let sprintf = Printf.sprintf;;

Random.init 0;;

let getprep s = hd(filter (fun t -> t.idv = s) (!Prep.prep_ineqs));;

(* omit the quad cases for now: *)

let idvlist = 
  let nonquad = filter (fun t -> not(Optimize.is_quad_cluster t.tags))  (!Prep.prep_ineqs) in
    map (fun t -> t.idv) nonquad;;

let nth = List.nth;;

let rec cart a b = 
  match a with
    | [] -> []
    | a::rest -> (map (fun x -> (a,x)) b) @ cart rest b;;

let maxlist xs = List.fold_right max xs (nth xs 0);;

let rec trim s = 
  let white c = mem c [' '; '\012'; '\n'; '\r'; '\t'] in
  let n = String.length s in
  let subs k = String.sub s k (n-1) in
    if (n > 0 && white (s.[0])) then trim (subs 1)
    else if (n > 1 && white (s.[n-1])) then trim (subs 0)
    else s;;

let msec_inc = float_of_int MSEC_INC;;

let float_cache = ref (fun() -> 0.0);;

let eval_float s = 
    let (b,r) = Flyspeck_lib.eval_command ~silent:false 
      ("float_cache := (fun () -> ("^s^"));;") in
    let _ = b or (print_string (r^"\n"^s^"\n"); failwith "bad input string") in
    let t= (!float_cache)() in
      t;;

(* ********************************************************************** *)
(* C++ CODE GENERATION. *)
(* ********************************************************************** *)

let cpp_template_arg = sprintf "
 const char svn[] = %s;
 const char ineq_id[] = %s;

 int testRun(double x1[6],double z1[6]) // autogenerated code
	{
        // Warning: not rigorous. The rounding is off by epsilon. Use this only for experiments.
	interval tx[6]={interval(x1[0],x1[0]),interval(x1[1],x1[1]),interval(x1[2],x1[2]),
                        interval(x1[3],x1[3]),interval(x1[4],x1[4]),interval(x1[5],x1[5])   };
	interval tz[6]={interval(z1[0],z1[0]),interval(z1[1],z1[1]),interval(z1[2],z1[2]),
                        interval(z1[3],z1[3]),interval(z1[4],z1[4]),interval(z1[5],z1[5])}; 
	domain x = domain::lowerD(tx);
	domain z = domain::upperD(tz);
        domain x0=x;
        domain z0=z;
        %s
        const Function* I[%d] = {%s}; // len ...
        cellOption opt;
        opt.allowSharp = %d; // sharp
        opt.onlyCheckDeriv1Negative = %d; // checkderiv
        %s // other options.
	return  prove::recursiveVerifier(0,x,z,x0,z0,I,%d,opt); // len
	}";;

let mk_cpp_arg_proc t s tags = 
  let sharp = if  mem Sharp tags then 1 else 0 in
  let checkderiv = if  mem Onlycheckderiv1negative tags then 1 else 0 in
  let ifd b s = if b then s else "" in
  let (b,f) = Optimize.widthCut tags in
  let sWidth = ifd b (sprintf "\topt.widthCutoff = %8.16f;\n" f) in 
  let c = map Optimize.cpp_string_of_term in
  let f (x,y,z) = (c x,c y,c z) in
  let (aas,bbs,iis) = f (Optimize.dest_nonlin t) in
  let len = length iis in
  let sq = Optimize.quoted s in
  let svn = (Optimize.quoted(Optimize.svn_version())) in
    cpp_template_arg svn sq (Optimize.cpp_template_t "" iis) 
      len (Optimize.cpp_template_Fc "" len) sharp  checkderiv sWidth len;;

let mkfile_arg =
  let cpp_tail = Optimize.join_lines (Optimize.load_file  (flyspeck_dir^"/../interval_code/arg_tail.txt")) in
  let cpp_header = Optimize.cpp_header() in
    fun t s tags  ->
	Flyspeck_lib.output_filestring Optimize.tmpfile
	  (Optimize.join_lines [cpp_header;Auto_lib.interval_code;(mk_cpp_arg_proc t s tags);cpp_tail]);;

let execute_args ex tags s testineq xlist zlist =  
   let x = List.nth xlist in
   let z = List.nth zlist in
   let args = sprintf " %f %f %f %f %f %f   %f %f %f %f %f %f"
      (x 0) (x 1) (x 2) (x 3) (x 4) (x 5)     (z 0) (z 1) (z 2) (z 3) (z 4) (z 5) in
  let interval_dir = flyspeck_dir^"/../interval_code" in
  let _ = mkfile_arg testineq s tags in
  let _ = Optimize.compile_cpp() in 
  let _ = (not ex) or (0=  Sys.command(interval_dir^"/test_auto"^args)) or failwith "interval execution error" in
    ();;

let process_and_prep_args ex (s,tags,case) = 
  let _ = report ("process and prep args: "^s) in
  let (s,tags,testineq) = (* preprocess debug *) (s,tags,case) in
  let (x,y,_) = Optimize.dest_nonlin testineq in
    (execute_args ex tags s testineq , x, y);;

let rerun_timer =
  let run_out = Filename.temp_file "run" ".out" in
    fun xlist zlist timer ->
      let x = List.nth xlist in
      let z = List.nth zlist in
      let args = sprintf " %f %f %f %f %f %f   %f %f %f %f %f %f %f"
	(x 0) (x 1) (x 2) (x 3) (x 4) (x 5)     (z 0) (z 1) (z 2) (z 3) (z 4) (z 5) (float_of_int timer) in
      let interval_dir = flyspeck_dir^"/../interval_code" in
      let _ = (0=  Sys.command(interval_dir^"/test_auto"^args^" | tee "^run_out)) or 
	failwith "interval execution error" in
      let outs = trim (process_to_string ("grep msecs "^run_out^" | sed 's/^.*msecs=//' | sed 's/;.*$//' ")) in
	(*  let _ = report (":"^outs^":") in *)
      let msecs = try (int_of_string (outs)) with _ -> timer in
	(msecs);;

(* ********************************************************************** *)
(* Recursive parition of the domain *)
(* ********************************************************************** *)

(* DOMAIN CONSTANTS *)

let scrub_c t = 
  let th = REWRITE_CONV [Sphere.h0;
        GSYM Nonlinear_lemma.sol0_over_pi_EQ_const1;
	ASSUME `hminus = #1.2317544220903216`;
        ASSUME `pi = #3.1415926535897932385`;
        ASSUME `sol0 = #0.55128559843253080794`] t in
    rhs(concl th);;

let get_constants_xy s = 
  let (s,tags,case) = Optimize.idq_fields (getprep s) in
  let (x,y,_) = Optimize.dest_nonlin case in
    (map scrub_c x,map scrub_c y);;

let get_constants s = 
  let (x,y) = get_constants_xy s in x @ y;;

let get_float_domain s = 
  let m = map (eval_float o Parse_ineq.ocaml_string_of_term) in
  let (x,y) = get_constants_xy s in
    (m x,m y);;

(* they all check out on 2013/7/31
find (fun s -> not(can get_float_domain s)) (snd (chop_list 650 idvlist));;
*)


(* interpolate along edge *)

let index_max_width (x ,z) avoid = 
  let w = map (fun (xi,zi) -> zi -. xi) (zip x z) in
  let avoid_filter = map (fun i -> (mem i avoid)) (0--(List.length x - 1)) in
  let w' = map (fun (t,b) -> if b then 0.0 else t) (zip w avoid_filter) in
  let wm = maxlist w' in
    index wm w';;

let facet_opp (i,side)= (i,not side);;

let invert_side (_,side) (x,z) = 
  if side then (z,x) else (x,z);;

let invert_interpolate (i,side) frac (x,z) =
  let _ = (0.0 <= frac && frac <= 1.0) or failwith "invert_interpolate: frac out of range " in
  let _ = List.length x = List.length z or failwith "invert_interpolate: length mismatch" in
  let n = List.length x in
  let rg = (0--(n-1)) in
  let (x,z) = invert_side (i,side) (x,z) in
  let c = nth x i *. (1.0-. frac) +. nth z i *. frac in
  let modi (xi,j) = if (i=j) then c else xi in
  let xm = map modi (zip x rg) in
  let zm = map modi (zip z rg) in
    (* partition will be x--zm,  xm--z *)
    invert_side(i,side) (xm,zm);;

let interpolate_frac (f1,t1) (f2,t2) = 
  let _ = (0.0 <= f1 && f1 < f2 && f2 <= 1.0 && t1 <= msec_inc && msec_inc <= t2) 
    or failwith "interpolate: out of range" in
    (msec_inc -. t1) *. (f2 -. f1) /. (t2 -. t1) +. f1;;

let run_frac frac facet (x1,z1) timeout = 
  let (xm,zm) = invert_interpolate facet frac (x1,z1) in
  let m3 = if (not(snd facet)) then rerun_timer x1 zm timeout else rerun_timer xm z1 timeout in
    ((xm,zm),m3);;

let rec recursive_find_frac facet x1 z1  (f1,t1) (f2,t2) = 
  (* last case in a batch may have a small t2, so dont use abs_float in the following line *)
  if (t2/. msec_inc -. 1.0) < ERROR_TOLERANCE then (f2,int_of_float t2)
  else if abs_float(t1/. msec_inc -. 1.0) < ERROR_TOLERANCE then (f1,int_of_float t1)
  else       

    let minwidth = 0.001 in
      if (f2 <= f1 +. minwidth && t2 < 1.99 *. msec_inc) then (f2,int_of_float t2)
      else if (f2 <= f1 +. minwidth && t1 > 0.25 *. msec_inc) then (f1,int_of_float t1)
      else 
	let _ = f1+. minwidth <= f2 or failwith "find_frac width underflow" in

	let f3 = interpolate_frac (f1,t1) (f2,t2) in
	let f3 = if (Random.int 4 = 0 && t2 > 1.9*. msec_inc) then 
	  (f1+.f2)/. 2.0 +. Random.float (f2 -. f1) /. 2.0 else f3 in
	let f3 = if (Random.int 3 = 0 && t1 < 0.5*. msec_inc) then
	  f1 +. Random.float (f2 -. f1)/. 2.0 else f3 in
	let _ = (f1 <= f3 && f3 <= f2) or failwith "recursive_find_frac: out of range" in
	let ((xm,zm),m3) = run_frac f3 facet (x1,z1) (2 * MSEC_INC) in
	let _ = if verbose then report (sprintf "recursing fracs %3.3f,%3.3f,%3.3f msecs %d,%d,%d" f1 f3 f2 (int_of_float t1) m3 (int_of_float t2)) in

	let t3 = float_of_int m3 in
	  if abs_float(t3/. msec_inc -. 1.0) < ERROR_TOLERANCE then (f3,m3)
	  else 
	    let ((f1',t1'),(f2',t2')) = if (t3 <= msec_inc) then ((f3,t3),(f2,t2)) else ((f1,t1),(f3,t3)) in
	      recursive_find_frac facet x1 z1 (f1',t1') (f2',t2');;

(* ********************************************************************** *)
(* DEBUG *)
(* ********************************************************************** *)

let rec pass_time = function
    Iarg_bisect (_,a,b) -> pass_time a + pass_time b
  | Iarg_leaf msec -> msec
  | Iarg_facet (_,_,msec,c) -> msec + pass_time c;;

let rec recheck_pass  timeout domain iarg = match iarg with
  | Iarg_leaf msec -> 
      let (x,z) = domain in
      let msec' = rerun_timer x z timeout in
	Iarg_leaf (msec,msec')
  | Iarg_facet(facet,frac,msec,b) ->
      let (x,z) = domain in
      let (xm,zm) = invert_interpolate facet frac domain in
      let residual = if (not(snd facet)) then (xm,z) else (x,zm) in
      let (_,msec') = run_frac frac facet domain timeout in
	Iarg_facet(facet,frac,(msec,msec'),  recheck_pass timeout residual b)
  | Iarg_bisect(idx,a,b) ->
      let (x,z) = domain in 
      let facet = (idx,false) in
      let (xm,zm) = invert_interpolate facet 0.5 domain in
      let partA,partB = ((x,zm),(xm,z)) in 
	Iarg_bisect(idx,recheck_pass timeout partA a,recheck_pass timeout partB b);;


(* ********************************************************************** *)
(* Generate file break_case_log.hl *)
(* ********************************************************************** *)

let initial_msec = 
  let ft_sec = Scripts.finalize Scripts.finished_times in
  let ft_msec = Scripts.finalize Scripts.finished_times_msecs in
  let get s =       try assoc s ft_msec       with _ -> 1000 * (assoc s ft_sec ) in
  let starts_prep s = Str.string_match (Str.regexp "prep-*") s 0 in
  let cut_prep s = String.sub s 5 (String.length s - 5) in
    fun s ->
      try get s 
      with _ -> 
	if starts_prep s then get (cut_prep s) else failwith ("initial_msec "^ s);;

let initialize s = 
  let msec = initial_msec s in
  let (x1,z1)=get_float_domain s in
  let stc = Optimize.idq_fields (getprep s) in
  let (compile,_,_) = process_and_prep_args false stc in
  let _ = compile x1 z1 in
    (x1,z1,msec);;

let rec pass_revised avoid ((x,z),msec) =
  let left = false in
  let idx = index_max_width (x,z) avoid in
  let fi = float_of_int in
  let timeout = 2 * MSEC_INC in
  let (s0,s1,s2) = (0,1,2) in
  let facet = (idx,left) in
  let sz m = 
    let t = fi m /. fi MSEC_INC in
      if t < 1.0 -. ERROR_TOLERANCE then s0 else if t < 1.999 then s1 else s2 in
    if msec < timeout  then 
      let _ = if verbose then report "FOUND leaf..." in
      (Iarg_leaf msec)
    else 
      let (_,m3A) = run_frac 0.5 facet (x,z) timeout in
      let (_,m3B) = run_frac 0.5 (facet_opp facet) (x,z) timeout in
      let (m3min,facet,swap) = if m3A<=m3B then (m3A,facet,false) else (m3B,facet_opp facet,true) in
      let smin = sz m3min in
	if (smin=s2) then 
	  let (xm,zm) = invert_interpolate (idx,left) 0.5 (x,z) in
	  let partA,partB = ((x,zm),(xm,z)) in
	  let _ = if verbose then report "FOUND bisection..." in
	    Iarg_bisect (idx,pass_revised [] (partA,m3A),pass_revised [] (partB,m3B))
	else if (smin = s1) then 
	  let (xm,zm) = invert_interpolate facet 0.5 (x,z) in
	  let residual= if (snd facet=left) then (xm,z) else (x,zm) in
	  let m3max = if swap then m3A else m3B in
	  let _ = if verbose then report "FOUND 0.5 facet..." in
	    Iarg_facet(facet,0.5,m3min,pass_revised [] (residual,m3max))
	else (* smin=s0 *) 
	  try (
	    let (fracC,mC) = recursive_find_frac facet x z (0.5,fi m3min) (1.0,fi msec) in
	    let (xm,zm) = invert_interpolate facet fracC (x,z) in
	    let residual= if (snd facet=left) then (xm,z) else (x,zm) in
	    let mD = rerun_timer (fst residual) (snd residual) timeout in
	    let _ = if verbose then report (sprintf "FOUND %3.3f,%d facet..." fracC mC) in
	      Iarg_facet (facet,fracC,mC,pass_revised [] (residual,mD)))
          with Failure fail ->
	    let _ = report ("failure "^fail) in
	      pass_revised (idx::avoid) ((x,z),msec);;

let run_one save s = 
  let (x1,z1,msec1) = initialize s in
  let iarg = (pass_revised [] ((x1,z1),msec1)) in
  let _  = if (save) then output_case s iarg in
    iarg;;

let run_all_over2sec save = 
  let preptimes = map (fun s -> try s,initial_msec s with _ -> failwith s) (idvlist) in
  let over2sec =  (sort (fun (_,s) (_,t) -> s < t) (filter (fun (s,t) -> t > 2000) preptimes)) in
  let over2 = map fst over2sec in
  let alldata = map (fun s -> try s,run_one save s with Failure msg -> report s; failwith msg) over2 in
    alldata;;

(* steps to add more to the break_case_log.hl:

  let preptimes = map (fun s -> try s,(* Break_case_exec. *) initial_msec s with _ -> failwith s) 
   ((* Break_case_exec. *) idvlist);;
  let over2sec =  (sort (fun (_,s) (_,t) -> s < t) (filter (fun (s,t) -> t > 2200) preptimes));;
  let over2 = map fst over2sec;;
  let has_iarg = map fst !Break_case_log.break_data;;
  let redoable = subtract over2 has_iarg;;
  let redotimes = map (fun s -> try s,(* Break_case_exec. *) initial_msec s with _ -> failwith s) redoable;;
  let redodata = map (fun s -> 
			try (run_one true s;s) 
			with Failure msg -> report s; failwith msg) redoable;;
*)



(* ********************************************************************** *)
(* A few lemmas. *)
(* ********************************************************************** *)


let delta_ineq_eulerA = prove_by_refinement(
  `!x1 x2 x3 x4 x5 x6.
    delta_ineq_v6 /\
    &4 <= x1 /\ x1 <= #6.3504 /\
    &4 <= x2 /\ x2 <= #6.3504 /\
    &4 <= x3 /\ x3 <= #6.3504 /\
    #9.0 <= x4 /\ x4 <= #15.328 /\
    #9.0 <= x5 /\ x5 <= #15.328 /\
    #9.0 <= x6 /\ x6 <= #15.328 ==>
    (eulerA_x x1 x2 x3 x4 x5 x6 < &0 \/
   &0 < delta_x x1 x2 x3 x4 x5 x6 )
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[delta_ineq;Sphere.ineq];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let delta_ineq_delta4_x_squared = prove_by_refinement(
  `!x1 x2 x3 x4 x5 x6.
    delta_ineq_v6 /\
              &4 <= x1 /\ x1 <= &8 /\
            &4 <= x2 /\ x2 <= &7 /\
            &4 <= x3 /\ x3 <= &7 /\
            &8 <= x4 /\ x4 <= &28 /\
            &4 <= x5 /\ x5 <= &7 /\
            &4 <= x6 /\ x6 <= &7 ==>
    (&0 < delta4_squared_x x1 x2 x3 x4 x5 x6 \/
   &0 < delta_x x1 x2 x3 x4 x5 x6 )
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[delta_ineq;Sphere.ineq];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let delta_ineq_delta4_x_squared_wide = prove_by_refinement(
  `!x1 x2 x3 x4 x5 x6.
    delta_ineq_v6 /\
              &4 <= x1 /\ x1 <= &7 /\
            &4 <= x2 /\ x2 <= &7 /\
            &4 <= x3 /\ x3 <= &7 /\
            &4 <= x4 /\ x4 <= &7 /\
            &8 <= x5 /\ x5 <= &28 /\
            &4 <= x6 /\ x6 <= &7 ==>
    (&0 < delta4_squared_x x1 x2 x3 x4 x5 x6 \/
   &0 < delta_x x1 x2 x3 x4 x5 x6 )
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[delta_ineq;Sphere.ineq];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `28` (C INTRO_TAC [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`]);
  ASM_REWRITE_TAC[];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let delta_ineq_delta4_x_squared2 = prove_by_refinement(
  `!c x1 x2 x3 x4 x5 x6.
     ~(x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
      delta4_squared_x x1 x2 x3 x4 x5 x6 * c <
      &0) ==>
    (delta_ineq_v6 /\
    c < &0 /\
              &4 <= x1 /\ x1 <= &8 /\
            &4 <= x2 /\ x2 <= &7 /\
            &4 <= x3 /\ x3 <= &7 /\
            &8 <= x4 /\ x4 <= &28 /\
            &4 <= x5 /\ x5 <= &7 /\
            &4 <= x6 /\ x6 <= &7 )
	     ==>
    (
   &0 < delta_x x1 x2 x3 x4 x5 x6 )
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +      delta4_squared_x x1 x2 x3 x4 x5 x6 * c <      &0 \/ &0 < delta_x x1 x2 x3 x4 x5 x6` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `delta4_squared_x` kill;
  TYPIFY `&0 < delta_x x1 x2 x3 x4 x5 x6` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC delta_ineq_delta4_x_squared [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Sphere.x1_delta_x];
  DISCH_TAC;
  MATCH_MP_TAC (arith `&0 <= -- a /\ &0 < -- b  ==> a + b < &0`);
  CONJ2_TAC;
    REWRITE_TAC[arith `-- (a * b ) = a * (-- b)`];
    GMATCH_SIMP_TAC REAL_LT_MUL_EQ;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  REWRITE_TAC[arith `-- ((a * b) * &4) = &4 * a * (-- b)`];
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL;
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let delta_ineq_delta4_x_squared2_wide = prove_by_refinement(
  `!c x1 x2 x3 x4 x5 x6.
     ~(x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
      delta4_squared_x x1 x2 x3 x4 x5 x6 * c <
      &0) ==>
    (delta_ineq_v6 /\
    c < &0 /\
              &4 <= x1 /\ x1 <= &7 /\
            &4 <= x2 /\ x2 <= &7 /\
            &4 <= x3 /\ x3 <= &7 /\
            &4 <= x4 /\ x4 <= &7 /\
            &8 <= x5 /\ x5 <= &28 /\
            &4 <= x6 /\ x6 <= &7 )
	     ==>
    (
   &0 < delta_x x1 x2 x3 x4 x5 x6 )
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +      delta4_squared_x x1 x2 x3 x4 x5 x6 * c <      &0 \/ &0 < delta_x x1 x2 x3 x4 x5 x6` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `delta4_squared_x` kill;
  TYPIFY `&0 < delta_x x1 x2 x3 x4 x5 x6` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC delta_ineq_delta4_x_squared_wide [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Sphere.x1_delta_x];
  DISCH_TAC;
  MATCH_MP_TAC (arith `&0 <= -- a /\ &0 < -- b  ==> a + b < &0`);
  CONJ2_TAC;
    REWRITE_TAC[arith `-- (a * b ) = a * (-- b)`];
    GMATCH_SIMP_TAC REAL_LT_MUL_EQ;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  REWRITE_TAC[arith `-- ((a * b) * &4) = &4 * a * (-- b)`];
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL;
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let delta_ineq_delta_234_x = prove_by_refinement(
  `delta_ineq_v6 ==> (!x1 x2 x3 x4 x5 x6 r.
	~(delta_234_x r (&4) (&4) x1 x2 x3 x4 x5 x6 +
 unit6 x1 x2 x3 x4 x5 x6 * -- &98  <
 &0 ) ==> ( r = ((#2.0 * #1.26) * #2.0 * #1.26) /\
	    &4 <= x1 /\ x1 <= &4 * #1.26 pow 2 /\
	&4 <= x2 /\ x2 <= &4 * #1.26 pow 2 /\
	&4 <= x3 /\ x3 <= &4 * #1.26 pow 2 /\
	#3.01 pow 2 <= x4 /\ x4 <= #3.36 pow 2 /\
	&4 <= x5 /\ x5 <= &4 * #1.26 pow 2 /\
	&4 <= x6 /\ x6 <= &4 * #1.26 pow 2
==> &0 < delta_x x1 x2 x3 x4 x5 x6))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[delta_ineq];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `&98` (C INTRO_TAC [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`]);
  ASM_REWRITE_TAC[Sphere.ineq;IMP_IMP_THM];
  ANTS_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  FIRST_X_ASSUM_ST `delta_234_x` MP_TAC THEN ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[arith `(a * b * a * b) = (a * b) * (a*b)`];
  BY(REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let subat_rules = prove_by_refinement(
  `(!i (y:A). subat i y [] = []) /\
    (!x xs (y:A). subat 0 y (x::xs) = y :: xs) /\
    (!i x xs (y:A). subat (SUC i) y (x::xs) = x :: (subat i) y xs)`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[Sphere.subat];
  BY(REWRITE_TAC[arith `~(SUC i = 0)`;arith `SUC i - 1 = i`])
  ]);;
  (* }}} *)

let subat_nil = prove_by_refinement(
  `(!i (y:A). subat i y [] = [])`,
  (* {{{ proof *)
  [
  MESON_TAC[subat_rules]
  ]);;
  (* }}} *)

let subat_explicit = prove_by_refinement(
  `(!i x xs (y:A).
      subat 9 y (x::xs) = x :: (subat 8 y xs) /\
      subat 8 y (x::xs) = x :: (subat 7 y xs) /\
      subat 7 y (x::xs) = x :: (subat 6 y xs) /\
      subat 6 y (x::xs) = x :: (subat 5 y xs) /\
      subat 5 y (x::xs) = x :: (subat 4 y xs) /\
      subat 4 y (x::xs) = x :: (subat 3 y xs) /\
      subat 3 y (x::xs) = x :: (subat 2 y xs) /\
      subat 2 y (x::xs) = x :: (subat 1 y xs) /\
      subat 1 y (x::xs) = x :: (subat 0 y xs) /\
      subat 0 y (x::xs) = y :: xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[arith `9 = SUC 8 /\ 8 = SUC 7 /\ 7 = SUC 6 /\ 6 = SUC 5 /\ 5 = SUC 4 /\ 4 = SUC 3 /\ 3 = SUC 2 /\ 2 = SUC 1 /\ 1 = SUC 0`;subat_rules])
  ]);;
  (* }}} *)

let bisect_left_frac = prove_by_refinement(
  `!d i. bisect_left i d = frac_left i (#0.5) d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.bisect_left;Sphere.frac_left;LET_THM];
  LIST_INDUCT_TAC THEN REWRITE_TAC[Sphere.subat;LAMBDA_PAIR];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[EL;HD;TL;Sphere.pathL;CONS_11];
    INTRO_TAC PAIR_SURJECTIVE [`h`] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Sphere.pathL;PAIR_EQ];
    BY(ARITH_TAC);
  INTRO_TAC num_CASES [`i`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[EL;TL];
  BY(ASM_REWRITE_TAC[EL;TL;arith `SUC n - 1 = n`;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let bisect_right_frac = prove_by_refinement(
  `!d i. bisect_right i d = frac_right i (#0.5) d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.bisect_right;Sphere.frac_right;LET_THM];
  LIST_INDUCT_TAC THEN REWRITE_TAC[Sphere.subat;LAMBDA_PAIR];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[EL;HD;TL;Sphere.pathR;CONS_11];
    INTRO_TAC PAIR_SURJECTIVE [`h`] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Sphere.pathR;PAIR_EQ];
    BY(ARITH_TAC);
  INTRO_TAC num_CASES [`i`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[EL;TL];
  BY(ASM_REWRITE_TAC[EL;TL;arith `SUC n - 1 = n`;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let ineq6m = prove_by_refinement(
  `!x1 x2 x3 x4 x5 x6 a1 a2 a3 a4 a5 a6 b1 b2 b3 b4 b5 b6 f.
    ineqm [x1;x2;x3;x4;x5;x6] [(a1,b1);(a2,b2);(a3,b3);(a4,b4);(a5,b5);(a6,b6)] f = 
    ineq [(a1,x1,b1);(a2,x2,b2);(a3,x3,b3);(a4,x4,b4);(a5,x5,b5);(a6,x6,b6)] f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.ineqm];
  BY(REWRITE_TAC[MAP2])
  ]);;
  (* }}} *)

let ineq9m = prove_by_refinement(
  `!x1 x2 x3 x4 x5 x6 x7 x8 x9 a1 a2 a3 a4 a5 a6 a7 a8 a9 b1 b2 b3 b4 b5 b6 b7 b8 b9 f.
    ineqm [x1;x2;x3;x4;x5;x6;x7;x8;x9] [(a1,b1);(a2,b2);(a3,b3);(a4,b4);(a5,b5);(a6,b6);
			      (a7,b7);(a8,b8);(a9,b9)] f = 
    ineq [(a1,x1,b1);(a2,x2,b2);(a3,x3,b3);(a4,x4,b4);(a5,x5,b5);(a6,x6,b6);
	 (a7,x7,b7);(a8,x8,b8);(a9,x9,b9)] f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Sphere.ineqm];
  BY(REWRITE_TAC[MAP2])
  ]);;
  (* }}} *)

let ineqm_mp_simple = prove_by_refinement(
  `!a a' b c. ineqm a a' (b ==> c) <=> (b ==> ineqm a a' c)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Sphere.ineqm;Merge_ineq.ineq_mp_simple])
  ]);;
  (* }}} *)

let hminus_pow_2_le = prove_by_refinement(
  `!c d.  &0 <= c /\ c <= &2 /\ #6.3504 <= d ==> (c * hminus) * (c * hminus) <= d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(c * hminus ) * (c * hminus) <= #6.3504` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  TYPIFY `#6.3504 = (&2 * #1.26) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  TYPIFY `(c * hminus) * (c * hminus) = (c * hminus) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  GMATCH_SIMP_TAC (GSYM Trigonometry2.POW2_COND);
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL2;
  MP_TAC Nonlinear_lemma.hminus_lt_h0;
  MP_TAC Nonlinear_lemma.hminus_prop;
  REWRITE_TAC[Sphere.h0];
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let hminus4_pow_2_le = prove_by_refinement(
  `!c d.  &0 <= c /\ c <= &2 /\ #25.4016 <= d ==> (&2 * c * hminus) * (&2 * c * hminus) <= d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(&2 * c * hminus ) * (&2 * c * hminus) <= #25.4016` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  TYPIFY `#25.4016 = (&4 * #1.26) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  TYPIFY `(&2 * c * hminus) * (&2 * c * hminus) = (&2 * c * hminus) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  GMATCH_SIMP_TAC (GSYM Trigonometry2.POW2_COND);
  REWRITE_TAC[REAL_MUL_ASSOC];
  REWRITE_TAC[arith `&0 <= &4 * #1.26`];
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL2;
  MP_TAC Nonlinear_lemma.hminus_lt_h0;
  MP_TAC Nonlinear_lemma.hminus_prop;
  REWRITE_TAC[Sphere.h0];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let hminus_pow_2_ge = prove_by_refinement(
  `!c d.  &2 <= c /\ d <= #5.76 ==> d <= (c * hminus) * (c * hminus)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `#5.76 <= (c * hminus ) * (c * hminus)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  TYPIFY `#5.76 = (&2 * #1.2) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  TYPIFY `(c * hminus) * (c * hminus) = (c * hminus) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  GMATCH_SIMP_TAC (GSYM Trigonometry2.POW2_COND);
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL2;
  MP_TAC Nonlinear_lemma.hminus_prop;
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)

let hminus_pow_2_gt = prove_by_refinement(
  `!c d.  &2 <= c /\ d < #5.76 ==> d < (c * hminus) * (c * hminus)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `#5.76 <= (c * hminus ) * (c * hminus)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  TYPIFY `#5.76 = (&2 * #1.2) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  TYPIFY `(c * hminus) * (c * hminus) = (c * hminus) pow 2` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REAL_ARITH_TAC);
  GMATCH_SIMP_TAC (GSYM Trigonometry2.POW2_COND);
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL;
  GMATCH_SIMP_TAC REAL_LE_MUL2;
  MP_TAC Nonlinear_lemma.hminus_prop;
  BY(ASM_TAC THEN REAL_ARITH_TAC)
  ]);;
  (* }}} *)


let h_series = map MATCH_MP_TAC [hminus4_pow_2_le;hminus_pow_2_le;hminus_pow_2_ge;hminus_pow_2_gt];;

let x_lb = prove_by_refinement(
  `!x a b. a <= x ==> b <= a ==> b <= x`,
  (* {{{ proof *)
  [
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let x_ub = prove_by_refinement(
  `!x a b. x <= a ==> a <= b ==> x <= b`,
  (* {{{ proof *)
  [
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let x_pos = prove_by_refinement(
  `!x a b. a <= x ==> &0 < a ==> &0 < x`,
  (* {{{ proof *)
  [
  REAL_ARITH_TAC;
  ]);;
  (* }}} *)

let bisect_left_rules = prove_by_refinement(
  `!i h t. bisect_left i [] = [] /\
      bisect_left 0 (h::t) = (pathL h)::t /\
      bisect_left (SUC i) (h::t) = h :: bisect_left i t`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Sphere.bisect_left;subat_rules;EL;HD;TL])
  ]);;
  (* }}} *)

let bisect_right_rules = prove_by_refinement(
  `!i h t. bisect_right i [] = [] /\
      bisect_right 0 (h::t) = (pathR h)::t /\
      bisect_right (SUC i) (h::t) = h :: bisect_right i t`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Sphere.bisect_right;subat_rules;EL;HD;TL])
  ]);;
  (* }}} *)

let frac_left_rules = prove_by_refinement(
  `!i h t r. frac_left i r [] = [] /\
      frac_left 0 r (h::t) = (FST h,FST h * (&1 - r) + SND h * r)::t /\
      frac_left (SUC i) r (h::t) = h :: frac_left i r t`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Sphere.frac_left;subat_rules;EL;HD;TL;LET_THM;LAMBDA_PAIR;CONS_11])
  ]);;
  (* }}} *)

let frac_right_rules = prove_by_refinement(
  `!i h t r. frac_right i r [] = [] /\
      frac_right 0 r (h::t) = (FST h * (&1 - r) + SND h * r,SND h)::t /\
      frac_right (SUC i) r (h::t) = h :: frac_right i r t`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Sphere.frac_right;subat_rules;EL;HD;TL;LET_THM;LAMBDA_PAIR;CONS_11])
  ]);;
  (* }}} *)

let ineqm_rules = prove_by_refinement(
  `ineqm [] [] f = f /\
    ineqm (h::t) (h'::t') f = (FST h' <= h /\ h <= SND h' ==> ineqm t t' f)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Sphere.ineqm;MAP2;Sphere.ineq])
  ]);;
  (* }}} *)

let LENGTH_subat = prove_by_refinement(
  `!xs i y. LENGTH (subat i y xs) = LENGTH xs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[ subat_rules;LENGTH];
  BY(INDUCT_TAC THEN ASM_REWRITE_TAC[ subat_rules;LENGTH])
  ]);;
  (* }}} *)

let LENGTH_frac_left = prove_by_refinement(
  `!xs i r. LENGTH(frac_left i r xs) = LENGTH xs`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Sphere.frac_left;LENGTH_subat;LET_THM;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let LENGTH_frac_right = prove_by_refinement(
  `!xs i r. LENGTH(frac_right i r xs) = LENGTH xs`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Sphere.frac_right;LENGTH_subat;LET_THM;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let LENGTH_bisect_left = prove_by_refinement(
  `!xs i. LENGTH(bisect_left i xs) = LENGTH xs`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Sphere.bisect_left;LENGTH_subat;LET_THM;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let LENGTH_bisect_right = prove_by_refinement(
  `!xs i. LENGTH(bisect_right i xs) = LENGTH xs`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Sphere.bisect_right;LENGTH_subat;LET_THM;LAMBDA_PAIR])
  ]);;
  (* }}} *)

let bisect_thm = prove_by_refinement(
  `!d i x f. LENGTH x = LENGTH d ==>
    ineqm x (bisect_left i d) f ==> ineqm x (bisect_right i d) f ==> ineqm x d f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(SIMP_TAC[bisect_left_rules]);
  INDUCT_TAC;
    SIMP_TAC[bisect_left_rules;bisect_right_rules];
    LIST_INDUCT_TAC;
      BY(REWRITE_TAC[LENGTH;arith `~(0 = SUC i)`]);
    REWRITE_TAC[LENGTH;arith `SUC i = SUC j <=> i = j`];
    TYPIFY `h` SPEC1_TAC;
    REWRITE_TAC[FORALL_PAIR_THM];
    REWRITE_TAC[ineqm_rules;Sphere.pathL;Sphere.pathR];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `h' <= (p1+p2)/ &2` ASM_CASES_TAC;
      FIRST_X_ASSUM_ST `ineqm` kill;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  REWRITE_TAC[bisect_left_rules;bisect_right_rules];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[LENGTH;arith `~(0 = SUC i)`]);
  REWRITE_TAC[LENGTH;arith `SUC i = SUC j <=> i = j`];
  REWRITE_TAC[ineqm_rules];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let ineqm_frac_thm = prove_by_refinement(
  `!d i x f r. LENGTH x = LENGTH d ==>
    ineqm x (frac_left i r d) f ==> ineqm x (frac_right i r d) f ==> ineqm x d f`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(SIMP_TAC[frac_left_rules]);
  INDUCT_TAC;
    SIMP_TAC[frac_left_rules;frac_right_rules];
    LIST_INDUCT_TAC;
      BY(REWRITE_TAC[LENGTH;arith `~(0 = SUC i)`]);
    REWRITE_TAC[LENGTH;arith `SUC i = SUC j <=> i = j`];
    REWRITE_TAC[ineqm_rules];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `h' <= FST h * (&1 - r) + SND h * r` ASM_CASES_TAC;
      FIRST_X_ASSUM_ST `ineqm` kill;
      FIRST_X_ASSUM MATCH_MP_TAC;
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_TAC THEN REAL_ARITH_TAC);
  REWRITE_TAC[frac_left_rules;frac_right_rules];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[LENGTH;arith `~(0 = SUC i)`]);
  REWRITE_TAC[LENGTH;arith `SUC i = SUC j <=> i = j`];
  REWRITE_TAC[ineqm_rules];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)


(* ********************************************************************** *)
(* Generate terms to be fed to nonlinear optimization. *)
(* ********************************************************************** *)


let strip_term = snd o strip_forall;;

let simple_dest_ineq ineq = 
  let t = strip_term ineq in
  let (vs,i) = dest_comb t in
  let (_,vs) = dest_comb vs in
  let vs = dest_list vs in
  let vs = map (fun t -> let (a,b) = dest_pair t in (a,dest_pair b)) vs in
  let vs = map (fun (a,(b,c)) -> (a, b, c)) vs in
    (t,vs,i);;

(* example
simple_dest_ineq (hd (Ineq.getexact "1965189142 34")).ineq;;
*)

let mk_bisect_left =
  let bl = `bisect_left` in
    fun i domain ->
      let i' = mk_small_numeral i in
	mk_comb (mk_comb (bl,i'),domain);;

let mk_bisect_right =
  let br = `bisect_right` in
    fun i domain ->
      let i' = mk_small_numeral i in
	mk_comb (mk_comb (br,i'),domain);;

let mk_decimal10000  = 
  let d = mk_small_numeral 10000 in
  let dec = `DECIMAL` in
    fun r ->
      let r' = mk_small_numeral (truncate(10000.0 *. r)) in
	mk_comb (mk_comb (dec,r'),d);;

let mk_frac_left =  
  let bl = `frac_left` in
    fun i r d ->
      let i' = mk_small_numeral i in
      let r' = mk_decimal10000 r in
	mk_comb (mk_comb (mk_comb (bl,i'),r'),d);;

let mk_frac_right =  
  let bl = `frac_right` in
    fun i r d ->
      let i' = mk_small_numeral i in
      let r' = mk_decimal10000 r in
	mk_comb (mk_comb (mk_comb (bl,i'),r'),d);;

let rec mk_rec acc domain = function
  | Iarg_bisect (i,u,v) -> 
      let usL = mk_rec acc (mk_bisect_left i domain) u in
	mk_rec usL (mk_bisect_right i domain) v 
  | Iarg_leaf _ -> domain :: acc
  | Iarg_facet ((i,false),r,_,v) ->
      let usL = mk_frac_left i r   domain in
	usL :: (mk_rec  acc (mk_frac_right i r  domain) v)
  | Iarg_facet ((i,true),r,_,v) ->
      let r' = 1.0 -. r in
      let usR = mk_frac_right i r'  domain in
	usR :: (mk_rec acc (mk_frac_left i r'  domain) v);;

let mk_ineq  = 
  let ineq_const = `ineq` in
    fun xs f ->
      mk_comb(mk_comb (ineq_const, xs),f);;

let mk_ineqm  = 
  let ineq_const = `ineqm` in
    fun xs ab f ->
      mk_comb(mk_comb(mk_comb (ineq_const, xs),ab),f);;

(* TESTS:

mk_ineq `[a:real,x:real,b:real]` `x > &0`;;
mk_ineqm `[x:real]` `[a:real,b:real]` `x > &0`;;
*)

(* arguments changed June 13, 2014 *)

let mk_case_list inq iarg = 
  let (inq,axbs,f) = simple_dest_ineq inq in
  let xs = mk_flist (map (fun (_,x,_) -> x) axbs) in
  let abs = mk_flist (map (fun (a,_,b) -> mk_pair (a,b)) axbs) in
  let doms = mk_rec [] abs iarg in
    map (fun ab -> mk_ineqm xs ab f) doms;;

let count_case_list iarg =
  let varmax = 10 in
  let a = `a:real` in
  let a9 = mk_flist (map (fun t -> mk_pair (a,a)) (0--varmax)) in
  let m =  mk_rec [] a9 iarg in
    List.length m;;

let count_iargs m = 
  try count_case_list (snd(find (fun s -> fst s = m) !Break_case_log.break_data))
  with Failure _ -> 1;;

let get_iarg s = assocd s (!Break_case_log.break_data) (Iarg_leaf 1000);;

let ineq_conv = 
  (REWRITE_CONV [Sphere.frac_left;Sphere.frac_right;bisect_left_frac;bisect_right_frac;
		 subat_explicit;LET_THM;LAMBDA_PAIR;Basics.EL_EXPLICIT] 
     THENC REAL_RAT_REDUCE_CONV THENC REWRITE_CONV[ineq6m;ineq9m]) ;;

let get_one_iarg app (s,i) = 
  let t = app s in
  let iarg =  get_iarg s in 
  let cl = mk_case_list t iarg in
    List.nth cl i;;

let idv_parameters s = 
  let count = count_iargs s in
    map (fun i -> (s,i)) (0-- (count - 1));;

let run_generic get_tactic needs_delta_ineq s = 
  let t = get_ineq s in
  let di = `delta_ineq_v6:bool` in
  let b = needs_delta_ineq s in
  let gt = if b then mk_imp(di,t) else t in
  let _ = g gt in
  let TAC = get_tactic s in
  let _ = try e(TAC) with Failure m -> failwith (m^" "^s) in
  let a,w = top_goal() in
  let _ = (b && a = [di]) or (a =[]) or failwith ("unexpected assumption: "^s) in
    w;;




(* string,int *)

(* ********************************************************************** *)
(* TEST CASE: "OXLZLEZ 6346351218 %d %d" *)
(* ********************************************************************** *)

let all_oxl_idv = 
  let ij = List.flatten (map (fun i -> [(1,i);(2,i);(3,i);(4,i)]) (0--45)) in
  let p (i,j) = Printf.sprintf "prep-OXLZLEZ 6346351218 %d %d" i j in
    map p ij;;

(* generating OXL inequality series *)

let POSTPREP_OXL_634_TAC = 
  EVERY [
  REPEAT GEN_TAC;
  REWRITE_TAC[arith `a * b * a * b = (a * b) * (a * b)`];
  REWRITE_TAC[Sphere.ineq] THEN REPEAT DISCH_TAC;
  INTRO_TAC Merge_ineq.delta_pos_4_784 [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ANTS_TAC THENL [EVERY [
    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
    REPEAT (FIRST_X_ASSUM (MP_TAC o MATCH_MP Merge_ineq.square_x_4));
    REPEAT (FIRST_X_ASSUM (MP_TAC o MATCH_MP Merge_ineq.square_x_784));
    REPEAT WEAKER_STRIP_TAC;
    REPEAT (FIRST_X_ASSUM_ST `==>` GMATCH_SIMP_TAC);
    MP_TAC Nonlinear_lemma.hminus_prop;
    BY(ASM_TAC THEN REAL_ARITH_TAC);];ALL_TAC];
  DISCH_TAC;
  FIRST_ASSUM (MP_TAC o MATCH_MP Functional_equation.gchi_all_atn);
  FIRST_ASSUM (MP_TAC o MATCH_MP Functional_equation.dih_all_atn);
  SIMP_TAC[];
  DISCH_THEN kill;
  DISCH_THEN kill;
  (* last lines changed 2014-06-13 *)
  POP_ASSUM kill;
  ASM_TAC;
  REWRITE_TAC[GSYM Nonlinear_lemma.ineq_expand6];
  REWRITE_TAC [GSYM Nonlinear_lemma.sol0_over_pi_EQ_const1];
  (*  (GSPECL_TAC (List.rev Optimize.x6list)); *)
  ];;

let all_oxl_parameters = List.flatten (map idv_parameters all_oxl_idv);;
 
List.length all_oxl_parameters = 7272;;

let get_oxl_nth j = 
  let get_tactic s = POSTPREP_OXL_634_TAC in
  let needs_delta_ineq s = false in
  let run = run_generic get_tactic needs_delta_ineq in
    get_one_iarg run (List.nth all_oxl_parameters j);;


(* ********************************************************************** *)
(* Classification of non oxl cases. *)
(* ********************************************************************** *)


let rec get_const_names tm = 
    match tm with       
        Var(s,t) -> []
      | Const(s,t) ->  [s] 
      | Comb (t1,t2) -> get_const_names t1 @ get_const_names t2 
      | Abs (t1,t2) -> get_const_names t1 @ get_const_names t2 ;;

let rec all_const_name P = 
    function
      | Abs(_,t) -> all_const_name P t
      | Comb(u,v) -> all_const_name P u && all_const_name P v
      | Var _ -> true
      | Const(s,_) -> P s;;

let some_const_name P t = not (all_const_name (not o P) t);;

let has_match pat = (can ((term_match []) pat));;

let has_eulerA dj = mem (`eulerA_x x1 x2 x3 x4 x5 x6 < &0`) dj;;

let has_delta4_squared_x dj = 
  can (find (has_match `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
         delta4_squared_x x1 x2 x3 x4 x5 x6 * -- c <
         &0`)) dj;;

let has_delta_234_x dj = 
  can (find (has_match `delta_234_x r (&4) (&4) x1 x2 x3 x4 x5
           x6 +
           unit6 x1 x2 x3 x4 x5 x6 * -- &98 <
           &0`)) dj;;

let ocaml_of_term = 
  let rec soh t = 
    let _ = not( is_var t) or failwith "no variables allowed" in
    let (f,xs) = strip_comb t in
    let _  = (is_const f) or failwith ("constant expected:" ^ string_of_term f) in
    let ifix i = let [a;b] = xs in ((i) (soh a) (soh b)) in
      match fst (dest_const f) with
	  | "real_add" -> ifix (+.)
	  | "real_mul" -> ifix ( *. )
	  | "real_div" -> ifix (/.)
	  | "real_neg" -> (let [a] = xs in  ( ~-. ) (  soh a))
	  | "real_of_num" -> let [a] = xs in (float_of_int (dest_small_numeral a))
	  | "NUMERAL" -> let [a] = xs in float_of_int (dest_small_numeral t)
	  | "DECIMAL" ->  let [a;b] = xs in float_of_int (dest_small_numeral a ) /. float_of_int (dest_small_numeral b) 
	  | "hminus" -> 1.2317544220903216 
	  | "pi" ->  3.1415926535897932385
	  | "const1" -> 0.55128559843253080794 /. 3.1415926535897932385
	      in
    fun t -> 
      try (soh t) 
      with Failure s -> failwith (s^" .......   "^string_of_term t);;

let ocaml_domain inq = 
  let (_,axb,_) = simple_dest_ineq (strip_term inq) in
  let ab = map (fun (a,_,b) -> (a,b)) axb in
  let a,b = unzip ab in
    let f = ocaml_of_term in
    map f a,map f b;;

let odom_table = 
  let odom0 = ([4.; 4.; 4.; 4.; 4.; 4.], [7.99; 8.0; 8.; 8.; 7.99; 7.99]) in
  let odom1 = ([4.01; 4.01; 4.; 4.; 4.; 4.], [8.0; 8.0; 8.; 8.; 8.0; 8.0]) in
  let odom2 = ([4.01; 4.; 4.01; 4.; 4.; 4.], [8.0; 8.0; 8.; 8.; 8.0; 8.0]) in
  let odom3 = ([4.01; 4.; 4.; 4.; 4.; 4.], [7.99; 8.0; 8.; 8.; 8.0; 8.0]) in
  let odom4 = ([4.;4.;4.;4.;4.;4.],[6.3504; 6.3504; 6.3504; 9.64; 9.64; 9.64]) in
  let odom5 = ([4.;4.;4.;4.;9.;9.],[6.3504; 6.3504; 6.3504; 6.3504; 13.48; 13.48]) in
  let odom6 = ([4.;4.;4.;9.;9.;4.],[6.3504; 6.3504; 6.3504; 13.48; 13.48; 6.3504]) in
  let odom7 = ([4.;4.;4.;6.3504;6.3504;4.],[6.3504; 6.3504; 6.3504; 11.7; 11.7; 6.3504]) in
  let odom8 = ([7.;4.;4.;4.;4.;4.],[8.; 8.; 8.; 7.99; 8.; 8.]) in
  let odom9 = ([4.; 4.; 4.; 4.; 4.; 4.], [7.99; 7.99; 7.99; 8.; 8.; 8.]) in
  let odom10 = ([4.; 4.; 4.; 4.; 4.; 4.], [7.99; 7.99; 8.; 8.; 8.; 7.99]) in
    [
      (odom0,Merge_ineq.delta_min_corner_0);
      (odom1,Merge_ineq.delta_min_corner_1);
      (odom2,Merge_ineq.delta_min_corner_2);
      (odom3,Merge_ineq.delta_min_corner_3);
      (odom4,Merge_ineq.delta_min_corner_4);
      (odom5,Merge_ineq.delta_min_corner_5);
      (odom6,Merge_ineq.delta_min_corner_6);
      (odom7,Merge_ineq.delta_min_corner_7);
      (odom8,Merge_ineq.delta_min_corner_8);
      (odom9,Merge_ineq.delta_min_corner_4_799_8);
      (odom10,Merge_ineq.delta_min_corner_4_799_8_alt);
    ];;

let check_odom = setify (map (fun ((a,b),t) -> 
       let rr = GSYM (REWRITE_RULE[IMP_IMP_THM;GSYM CONJ_ASSOC] Nonlinear_lemma.ineq_expand6) in
       let t' = REWRITE_RULE[rr] t in
       let diff x y = map2 (-.) x y in
       let (c,d) = ocaml_domain (concl t') in
	 setify(diff a c),setify(diff b d)) odom_table);;

check_odom = [([0.],[0.])];;

let include_domain (a1,b1) (a2,b2) = 
  let eps = 1.0e-10 in
    forall2 (fun x y -> x +. eps >= y) a1 a2 &&
      forall2 (fun x y -> x <= y +. eps) b1 b2;;

let exists_domain t = 
  let (a,b) = (ocaml_domain t) in
  let v (dom,_) = include_domain (a,b) dom in
    exists v odom_table;;

let find_domain t = 
  let (a,b) = (ocaml_domain t) in
  let v (dom,_) = include_domain (a,b) dom in
    snd (find v odom_table);;

let rec is_delta_inert  = 
  let delta_strings = ["dih_x";"dih2_x";"dih3_x";"dih4_x";"dih5_x";"dih6_x";
		       "ldih1_x";"ldih2_x";"ldih3_x";"ldih4_x";"ldih5_x";"ldih6_x";
		       "gchi1_x";"gchi2_x";"gchi3_x";"gchi4_x";"gchi5_x";"gchi6_x";
		       "rhazim_x";"rhazim2_x";"rhazim3_x";
		       ] in
    all_const_name (fun s -> not (mem s delta_strings));;

let is_delta_pos t = not(is_delta_inert t) && exists_domain t;;

let tough_names = 
  [
    "quad_cross_diag2_x";
    "arclength_x1";"arclength_x_123";
    "eta2_126";"eta2_135";"eta2_456";
    "taud_x";
    "mud_126_x_v1";"mud_135_x_v1";"mud_234_x_v1";
    "vol3f_x_lfun";"vol3f_x_sqrt2_lmplus";"vol3_x_sqrt";
    "gamma23_full8_x";
    "gamma23_keep135_x";
  ];;

let oxl_idv,alpha_idv,beta_idv,gamma_idv,delta_idv = 
  let has_tough = some_const_name (fun s -> mem s tough_names) in 
  let all_idv = map (fun idq -> idq.idv) !Prep.prep_ineqs in
  let oxl_idv,p2 = partition 
    (fun t -> (Str.string_match (Str.regexp "prep-OXLZLEZ 6346351218 [1234]") t 0)) all_idv in
  let reduced_prep_idv,tough_idv = partition (fun s -> not ( has_tough (get_ineq s) )) p2 in
  let delta_pos_idv = 
    filter (is_delta_pos o get_ineq) reduced_prep_idv in
  let delta_inert_idv =   filter (is_delta_inert o get_ineq) reduced_prep_idv in
  let delta_idv = setify (delta_pos_idv @ delta_inert_idv) in
  let delta_nok_idv = subtract (reduced_prep_idv) delta_idv in
  let beta_idv = delta_nok_idv @ ["prep-2314572187"; "prep-7550003505 0 0 2"; "prep-7550003505 0 1 2";
   "prep-7550003505 0 2 2"; "prep-7550003505 0 2 3"; "prep-7550003505 0 2 4";
   "prep-7550003505 1 1 2"; "prep-7550003505 1 2 2"; "prep-7550003505 1 2 3";
   "prep-7550003505 1 2 4"; "prep-7550003505 2 2 2"; "prep-7550003505 2 2 3";
   "prep-7550003505 2 2 4"; "prep-7550003505 2 3 3"; "prep-7550003505 2 3 4";
   "prep-7550003505 2 4 4"] in
  let gamma_idv = ["prep-TEWNSCJ split(1/2)"; "prep-TEWNSCJ split(0/2)";
   "prep-PEMKWKU split(1/2)"; "prep-PEMKWKU split(0/2)";
   "prep-QITNPEAv2 4003532128 split(1/2)";
   "prep-QITNPEAv2 4003532128 split(0/2)"; "prep-TXQTPVC split(1/2)";
   "prep-TXQTPVC split(0/2)"; "prep-IXPOTPA split(1/2)";
   "prep-IXPOTPA split(0/2)"] in
  let alpha_idv = subtract tough_idv (beta_idv @ gamma_idv) in
  let _ = assert_test 
    (setify all_idv = setify (oxl_idv @ alpha_idv @ beta_idv @ gamma_idv @ delta_idv)) 
    "idv partition" in
    (oxl_idv,alpha_idv,beta_idv,gamma_idv,delta_idv);;

assert_test (oxl_idv = all_oxl_idv) "oxl list check";;


(* test code for delta *)

let exists_delta_explicit t = 
  let (_,_,fs) = Optimize.dest_ineq t in
   exists (has_match `delta_x x1 x2 x3 x4 x5 x6 + unit6 x1 x2 x3 x4 x5 x6 * -- y < &0`) fs;;

let exists_delta4_explicit t = 
  let odom = ([6.;4.;4.;8.;4.;4.],[8.; 7.; 7.; 25.; 7.;7.]) in
  let odom2 = ([4.;4.;4.;4.;8.;4.],[7.; 7.; 7.; 7.; 25.;7.]) in
  let (a,b) = ocaml_domain t in
  let (_,_,fs) = Optimize.dest_ineq t in
    (include_domain (a,b) odom or include_domain (a,b) odom2) && 
   exists (has_match `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
     delta4_squared_x x1 x2 x3 x4 x5 x6 * -- y <
     &0`) fs;;

let exists_eulerA_explicit t  = 
  let odom = ([4.;4.;4.;9.;9.;9.],[6.3504; 6.3504; 6.3504; 15.328;15.328;15.328]) in
  let (a,b) = ocaml_domain t in
  let (_,_,fs) = Optimize.dest_ineq t in
    include_domain (a,b) odom && 
      exists (has_match `eulerA_x x1 x2 x3 x4 x5 x6 < &0`) fs;;

let exists_delta_234_x t = 
  let (_,_,dj) = Optimize.dest_ineq t in
    has_delta_234_x dj;;

let test_delta_cases = 
  let f = filter (fun t -> 
		    let t = strip_term (get_ineq t) in
		      not (exists_domain t) && not (is_delta_inert t) && 
			not (exists_delta_explicit t) && not (exists_delta4_explicit t) && 
			not (exists_eulerA_explicit t) &&
		 not (exists_delta_234_x t)) (delta_idv @ beta_idv) in
    f;;

assert_test (test_delta_cases = [])  "delta_cases";;

(* ********************************************************************** *)
(* timing tests *)
(* ********************************************************************** *)


(* timing information *)

let times idvs  = 
  let preptime = map (fun (s,t) -> ("prep-"^s, t)) Scripts.times in
    filter (fun (s,_) -> mem s idvs) preptime;;

let total_nonquad_times = filter (fun (s,_) -> not (mem s Scripts.quad_enclosed)) Scripts.times;;

let cohort_times,total_time = 
  let a::b = map (fun (x1,x2)-> x1, (Scripts.hour o Scripts.total) x2 ) 
    [("all",total_nonquad_times);("oxl",times oxl_idv);
     ("alpha",times alpha_idv);
     ("beta",times beta_idv);
     ("gamma",times gamma_idv);
     ("delta",times delta_idv);
    ] 
  in (b,a);;

assert_test (forall (fun (s,_) ->  (mem ("prep-"^s) (oxl_idv @ alpha_idv @ beta_idv @ gamma_idv @ delta_idv))) total_nonquad_times) "missing timing information";;


(* ********************************************************************** *)
(* TEST CASE: DELTA SERIES.  
   In these inequalities, if delta_x1 x2 x3 x4 x5 x6 appears in 
   a square root, denominator, or atn function, it is positive over the
   entire domain of the inequality.
 *)
(* ********************************************************************** *)


  let rational_expansions = 
    [("delta_x",Sphere.delta_x);
     ("delta_x4",Sphere.delta_x4);
     ("delta_x1",Nonlin_def.delta_x1);
     ("ups_x",Sphere.ups_x);
     ("rho_x",Sphere.rho_x);
     ("lfun",Sphere.lfun);
     ("num1",Sphere.num1);
     ("gchi",Sphere.gchi);
     ("delta4_squared_x",Sphere.delta4_squared_x);
     ("x1_delta_x",Sphere.x1_delta_x);
     ("lfun_y1",Sphere.lfun_y1);
     ("norm2hh_x",Sphere.norm2hh_x);
     ("norm2hh",Sphere.norm2hh);
     ("bump",Sphere.bump);
     ("pow2",Nonlin_def.pow2);
     ("rad2_x",Sphere.rad2_x);
     ("proj_x1",Nonlin_def.proj_x1);
     ("proj_x2",Nonlin_def.proj_x2);
     ("proj_x3",Nonlin_def.proj_x3);
     ("proj_x4",Nonlin_def.proj_x4);
     ("proj_x5",Nonlin_def.proj_x5);
     ("proj_x6",Nonlin_def.proj_x6);
     ("unit6",Nonlin_def.unit6);
     ("dnum1",Nonlin_def.dnum1);
     ("rho",Nonlinear_lemma.rho_alt);
     ("delta_126_x",Sphere.delta_126_x);
     ("delta_135_x",Sphere.delta_135_x);
     ("delta_234_x",Sphere.delta_234_x);
     ("mu_y",Nonlin_def.mu_y);
     ("cayleyR6u",Nonlin_def.cayleyR6u);
     ("cayleytr6u",Nonlin_def.cayleytr6u);
     ("deltaL_x",Nonlin_def.deltaL_x);
     ("deltaL_x4",Nonlin_def.deltaL_x4);
     ("ups234_x",Nonlin_def.ups234_x);
    ];;

  let sqrt_expansions = 
    [("eulerA_x",Sphere.eulerA_x);
     ("proj_y1", Nonlin_def.proj_y1);
     ("proj_y2",Nonlin_def.proj_y2);
     ("proj_y3",Nonlin_def.proj_y3);
     ("proj_y4",Nonlin_def.proj_y4);
     ("proj_y5",Nonlin_def.proj_y5);
     ("proj_y6",Nonlin_def.proj_y6);
     ("sqrt_x1",Nonlin_def.sqrt_x1);
     ("sqrt_x2",Nonlin_def.sqrt_x2);
     ("sqrt_x3",Nonlin_def.sqrt_x3);
     ("sqrt_x4",Nonlin_def.sqrt_x4);
     ("sqrt_x5",Nonlin_def.sqrt_x5);
     ("sqrt_x6",Nonlin_def.sqrt_x6);
     ("halfbump_x",Nonlin_def.halfbump_x);
     ("halfbump_x1",Nonlin_def.halfbump_x1);
     ("halfbump_x4",Nonlin_def.halfbump_x4);
     ("taud_D2_num_x",Functional_equation.nonfunctional_taud_D2);
     ("mu6_x",Functional_equation.nonfunctional_mu6_x);
     ("vol_x",Sphere.vol_x);
     ("eta_x",Sphere.eta_x);
     ("taud_D1_num_x",Functional_equation.nonfunctional_taud_D1);
     ("gamma2_x_div_azim_v2",Nonlin_def.gamma2_x_div_azim_v2);
     ("gamma2_x1_div_a_v2",Functional_equation.nonf_gamma2_x1_div_a_v2);
     ("edge2_flatD_x1",Merge_ineq.nonf_edge2_flatD_x1);
     ("edge2_126_x",Merge_ineq.nonf_edge2_126_x);
     ("flat_term_x",    REWRITE_RULE[Sphere.flat_term] Sphere.flat_term_x);
     ("flat_term2_126_x",Merge_ineq.nonf_flat_term2_126_x);
     ("edge2_135_x",Merge_ineq.nonf_edge2_135_x);
     ("edge2_234_x",Merge_ineq.nonf_edge2_234_x);
     ("flat_term2_135_x",Merge_ineq.nonf_flat_term2_135_x);
     ("flat_term2_234_x",Merge_ineq.nonf_flat_term2_234_x);
     ("mudLs_135_x",Merge_ineq.nonf_mudLs_135_x);
     ("mudLs_126_x",Merge_ineq.nonf_mudLs_126_x);
     ("mudLs_234_x",Merge_ineq.nonf_mudLs_234_x);
     ("taud_x'",Merge_ineq.nonf_taud_x');
    ];;

  let trig_expansions1 = 
   [
     ("dihatn_x",Sphere.dihatn_x);
     ("dih2atn_x",Sphere.dih2atn_x);
     ("dih3atn_x",Sphere.dih3atn_x);
     ("dih4atn_x",Sphere.dih4atn_x);
     ("dih5atn_x",Sphere.dih5atn_x);
     ("dih6atn_x",Sphere.dih6atn_x);
     ("rhazimatn_x",Sphere.rhazimatn_x);
     ("rhazim2atn_x",Sphere.rhazim2atn_x);
     ("rhazim3atn_x",Sphere.rhazim3atn_x);
     ("ldihatn_x",Sphere.ldihatn_x);
     ("ldih2atn_x",Sphere.ldih2atn_x);
     ("ldih3atn_x",Sphere.ldih3atn_x);
     ("ldih4atn_x",Sphere.ldih4atn_x);
     ("ldih5atn_x",Sphere.ldih5atn_x);
     ("ldih6atn_x",Sphere.ldih6atn_x);
   ];;

  let trig_expansions = 
    [
      ("asn797k",Sphere.asn797k);
      ("asnFnhk",Sphere.asnFnhk);
      ("arclength_x1'",Merge_ineq.nonf_arclength_x1');
      ("arclength_x_123'", Merge_ineq.nonf_arclength_x_123');
      ("sol_euler_x_div_sqrtdelta",Nonlin_def.sol_euler_x_div_sqrtdelta);
      ("sol_euler156_x_div_sqrtdelta",Merge_ineq.nonf_sol_euler156_x_div_sqrtdelta);
      ("sol_euler246_x_div_sqrtdelta",Merge_ineq.nonf_sol_euler246_x_div_sqrtdelta);
      ("sol_euler345_x_div_sqrtdelta",Merge_ineq.nonf_sol_euler345_x_div_sqrtdelta);
      ("acs_sqrt_x1_d4",Sphere.acs_sqrt_x1_d4);
      ("tau_residual_x",Nonlin_def.tau_residual_x);
      ("rhazim_x_div_sqrtdelta_posbranch",Nonlin_def.rhazim_x_div_sqrtdelta_posbranch);
      ("rhazim2_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_rhazim2_x_div_sqrtdelta_posbranch);
      ("rhazim3_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_rhazim3_x_div_sqrtdelta_posbranch);
      ("dih_x_div_sqrtdelta_posbranch",Nonlin_def.dih_x_div_sqrtdelta_posbranch);
      ("dih4_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_dih4_x_div_sqrtdelta_posbranch);
      ("ldih_x_div_sqrtdelta_posbranch",Nonlin_def.ldih_x_div_sqrtdelta_posbranch);
      ("ldih2_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_ldih2_x_div_sqrtdelta_posbranch);
      ("ldih3_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_ldih3_x_div_sqrtdelta_posbranch);
      ("ldih5_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_ldih5_x_div_sqrtdelta_posbranch);
      ("ldih6_x_div_sqrtdelta_posbranch",Merge_ineq.nonf_ldih6_x_div_sqrtdelta_posbranch);
      ("gamma3f_x_div_sqrt_delta",Functional_equation.nonf_gamma3f_x_div_sqrt_delta);
      ("gamma3atn_x",Nonlin_def.gamma3atn_x);
    ];;

  let nonlin_rewrites = map snd (rational_expansions @ sqrt_expansions @ trig_expansions);;

  let good_names = 
    let ignores = 
      ["==>";"?";"!";"/\\";"\\/";",";"~";"APPEND";"CONS";"HD";"LAST";
       "NIL";"=";"real_lt";"real_gt";"real_le";"real_ge";"BIT0";"BIT1";"NUMERAL";
       "DECIMAL";"real_sub";"real_add";"real_neg";
       "real_of_num";"_0";"_1";"real_div";"real_mul";"real_pow";"COND";"LET";"LET_END";] in
    let real_constants = 
      ["sol0";"tau0";"mm1";"mm2";"const1";"h0";"rho";"pi";"sqrt8";
       "hminus";"hplus";"rh0";"arc_hhn";"sqrt3";"cos797";] in
    let specials = 
      ["ineq";"ineqm";"delta_ineq_v6";
       "bisect_left";"bisect_right";"frac_left";"frac_right";] in
    let primitive_univariate = 
      ["sqrt";"atn";"sin";"cos";"acs";"asn";"matan";] in
    let trig_primitive = map fst trig_expansions1 in
      ignores @ real_constants @ specials @ primitive_univariate @ trig_primitive;;


(* const_names *)

(*
let bad_names t = 
  let t' = concl (REWRITE_RULE nonlin_rewrites (ASSUME t)) in
  filter (fun c -> not(mem c good_names)) (setify ( (get_const_names t')));;
*)


let DOMAIN_X_MATCH_TAC x thm = 
  let t = SPEC x thm in
  let TAC2 = DISCH_THEN (fun t -> FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP t)) in
    MP_TAC t THEN TAC2;;

let x_ubs = map (C DOMAIN_X_MATCH_TAC x_ub)  Optimize.x6list;;
let x_lbs = map (C DOMAIN_X_MATCH_TAC x_lb) Optimize.x6list;;
let x_poss = map (C DOMAIN_X_MATCH_TAC x_pos) Optimize.x6list;;

let POSITIVE_DOMAIN_TAC =  (* proves a subgoal of the form `&0 < xi /\ &0 < xj /\ ... ` *)
  EVERY 
    [
      ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;    
      EVERY x_poss;    
      BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST h_series THEN REAL_ARITH_TAC))
    ];;

let DELTA_TAC delta_thm = EVERY [
  REPEAT GEN_TAC;
  REWRITE_TAC[arith `a * b * a * b = (a * b) * (a * b)`];
  REWRITE_TAC[Sphere.ineq] THEN REPEAT DISCH_TAC;
  COMMENT "delta_pos";
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [      ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY x_lbs;      EVERY x_ubs;      BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST h_series THEN REAL_ARITH_TAC))];
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC) THENL [POSITIVE_DOMAIN_TAC;ALL_TAC];
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC  [    BY(ASM_REWRITE_TAC[]) ];
  SIMP_TAC[];
  DISCH_THEN kill;
  REPLICATE_TAC 2 (POP_ASSUM kill);
  ASM_TAC THEN REWRITE_TAC[GSYM Nonlinear_lemma.ineq_expand6];
  ];;

let get_delta_tactic s = 
  let t = get_ineq s in
  let inert = is_delta_inert t in 
  let pos = is_delta_pos t in
  let _ = inert or pos or failwith ("delta series expected: "^s) in
  let TAC = if pos then DELTA_TAC (find_domain t) else REPEAT GEN_TAC 
    (* changed July 8, 2014 ALL_TAC *) in
    TAC;;

let all_delta_parameters = List.flatten (map idv_parameters delta_idv);;

List.length all_delta_parameters = 6200;;
 
let get_nth_delta j = 
  let needs_delta_ineq s = false in
  let run = run_generic get_delta_tactic needs_delta_ineq in
    get_one_iarg run (List.nth all_delta_parameters j);;


(* ********************************************************************** *)
(* run_alpha  *)
(* ********************************************************************** *)

let POS_TAC t =     TYPIFY t  (C SUBGOAL_THEN MP_TAC) THENL [(* Break_case_exec. *) POSITIVE_DOMAIN_TAC;ALL_TAC];;

let PREP_TAC =   EVERY[REPEAT DISCH_TAC;
		       REPEAT GEN_TAC;
  REWRITE_TAC[arith `a * b * a * b = (a * b) * (a * b)`];
  REWRITE_TAC[Sphere.ineq] THEN REPEAT DISCH_TAC;];;

let DELTA1_TAC delta_thm = EVERY [
  COMMENT "delta_pos";
  INTRO_TAC delta_thm [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [      ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;      EVERY (* Break_case_exec. *) x_lbs;      EVERY (* Break_case_exec. *) x_ubs;      BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST (* Break_case_exec. *) h_series THEN REAL_ARITH_TAC))];
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC) THENL [(* Break_case_exec. *) POSITIVE_DOMAIN_TAC;ALL_TAC];
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [    BY(ASM_REWRITE_TAC[]) ];
  SIMP_TAC[];
  DISCH_THEN kill;
  REPLICATE_TAC 2 (POP_ASSUM kill);
  ];;

let vol3f_x_sqrt2_lmplus_TAC = 
  EVERY [
  INTRO_TAC Merge_ineq.eta2_delta_cases [`#1.34 * #1.34`;`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST 
    ANTS_TAC 
    [
    ONFIRST
      CONJ_TAC
      [
	BY(REAL_ARITH_TAC);
      ];
    REPEAT (GMATCH_SIMP_TAC (arith `x <= &15 ==> x < &16`));
    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
    EVERY x_ubs;
    EVERY x_lbs;
    BY((REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST (* Break_case_exec. *) h_series THEN REAL_ARITH_TAC)));
    ];
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC Nonlinear_lemma.vol3f_x_sqrt2_lmplus_alt [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST 
    ANTS_TAC 
    [
      REWRITE_TAC[Sphere.h0];
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    ];
  SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`&2`;`&2`;`&2`;`x6`];
  ONFIRST 
    ANTS_TAC
    [
      ASM_REWRITE_TAC[];
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    ];
  SIMP_TAC[];
  (DISCH_THEN kill)];;

let vol3f_x_lfun_TAC = 
  EVERY [
  INTRO_TAC Merge_ineq.eta2_delta_cases [`#1.34 * #1.34`;`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST 
    ANTS_TAC 
    [
    ONFIRST
      CONJ_TAC
      [
	BY(REAL_ARITH_TAC);
      ];
    REPEAT (GMATCH_SIMP_TAC (arith `x <= &15 ==> x < &16`));
    ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
    EVERY x_ubs;
    EVERY x_lbs;
    BY((REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST (* Break_case_exec. *) h_series THEN REAL_ARITH_TAC)));
    ];
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC Nonlinear_lemma.vol3f_x_lfun_alt [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST 
    ANTS_TAC 
    [
      REWRITE_TAC[Sphere.h0];
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    ];
  SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`&2`;`&2`;`&2`;`x6`];
  ONFIRST 
    ANTS_TAC
    [
      ASM_REWRITE_TAC[];
      BY(ASM_TAC THEN REAL_ARITH_TAC);
    ];
  SIMP_TAC[];
  POP_ASSUM kill;
  (DISCH_THEN kill)];;

let PRE_DELTA_TAC gl = 
  let (asm,w) = dest_goal gl in
  let has s = some_const_name ((=) s) w in
  let contac b tac = if b then tac else ALL_TAC in
    EVERY [
      contac (has "vol3f_x_sqrt2_lmplus") vol3f_x_sqrt2_lmplus_TAC;
      contac (has "vol3f_x_lfun") vol3f_x_lfun_TAC;
    ] gl;;

let POS_SIMP_TAC gl = 
  let (asm,w) = dest_goal gl in
  let has s = some_const_name ((=) s) w in
  let contac b tac = if b then tac else ALL_TAC in
  let has_eta126 = has "eta2_126" in
  let has_eta135 = has "eta2_135" in
  let has_eta456 = has "eta2_456" in
  let has_taudx = has "taud_x" in
  let has_vol3x = has "vol3_x_sqrt" in
  let TAC126 = contac has_eta126  (POS_TAC `&0 < x1 /\ &0 < x2 /\ &0 < x6`) in
  let TAC_VOL3 = contac has_vol3x  (POS_TAC `&0 < x1 /\ &0 < x2 /\ &0 < x6`) in
  let TAC_ARC = contac (has "arclength_x1") (EVERY [
    REPEAT (GMATCH_SIMP_TAC Merge_ineq.arclength_x1x1');
    REWRITE_TAC[CONJ_ASSOC];
    ONFIRST CONJ_TAC [ASM_TAC THEN REAL_ARITH_TAC]  ]) in
  let TAC_ARC123 = contac (has "arclength_x_123") (EVERY [
    REPEAT (GMATCH_SIMP_TAC Merge_ineq.nonf_arclength_x_123);
    REWRITE_TAC[CONJ_ASSOC];
    ONFIRST CONJ_TAC [ASM_TAC THEN REAL_ARITH_TAC]  ]) in
  let MUD_TAC = contac (some_const_name (fun s -> mem s ["mud_126_x_v1";"mud_135_x_v1";"mud_234_x_v1"]) w) (EVERY [
  REPEAT (FIRST (map GMATCH_SIMP_TAC [Merge_ineq.nonf_mud_126_x_v1;Merge_ineq.nonf_mud_135_x_v1;Merge_ineq.nonf_mud_234_x_v1]));
  REWRITE_TAC[CONJ_ASSOC];
  ONFIRST CONJ_TAC [ASM_TAC THEN REAL_ARITH_TAC];
]) in
  let TAC135 = contac has_eta135 (POS_TAC `&0 < x1 /\ &0 < x3 /\ &0 < x5`) in
  let TAC456 = contac has_eta456 (POS_TAC `&0 < x4 /\ &0 < x5 /\ &0 < x6`) in
  let TAC123 = contac has_taudx (POS_TAC `&0 < x1 /\ &0 < x2 /\ &0 < x3`) in
  let INTRO_0 = contac (has_eta126 or has_eta135 or has_eta456)
      (INTRO_TAC Merge_ineq.eta_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`] ) in
  let INTRO_1 = contac has_taudx 
    (INTRO_TAC Functional_equation.taud_x' [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`]) in
  let INTRO_VOL3 = contac has_vol3x
    (INTRO_TAC Nonlinear_lemma.vol3_vol_x [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`]) in
    EVERY [
      TAC_ARC;
      TAC_ARC123;
      MUD_TAC;
      INTRO_0;
      INTRO_1;
      INTRO_VOL3;
      TAC126;
      TAC_VOL3;
      TAC135;
      TAC456;
      TAC123;
      ASM_SIMP_TAC[REAL_LT_IMP_LE];
      REPEAT(DISCH_THEN kill);
    ] gl;;

let POST_TAC =   ASM_TAC THEN REWRITE_TAC[GSYM Nonlinear_lemma.ineq_expand6];;

let bad_names t = 
  let t' = concl (REWRITE_RULE nonlin_rewrites (ASSUME t)) in
  filter (fun c -> not(mem c good_names)) (setify ( (get_const_names t')));;

let data_of_run f s = 
  let w = f s in
    (s,bad_names w);;

let get_alpha_tactic s = 
  let t = get_ineq s in
  let pos = (* Break_case_exec. *) is_delta_pos t in
  let TAC = if pos then DELTA1_TAC (find_domain t) else ALL_TAC in
    PREP_TAC THEN PRE_DELTA_TAC THEN TAC THEN POS_SIMP_TAC THEN POST_TAC;;

let run_alpha s = 
  let needs_delta_ineq s = false in
    run_generic get_alpha_tactic needs_delta_ineq s;;

let all_alpha_parameters = List.flatten (map idv_parameters alpha_idv);;

List.length all_alpha_parameters = 2010;;
 
let get_nth_alpha j = 
    get_one_iarg run_alpha (List.nth all_alpha_parameters j);;  

(* ********************************************************************** *)
(* run_beta for beta_idv *)
(* ********************************************************************** *)

let needs_delta_ineq1 t = 
  let (_,_,dj)= Optimize.dest_ineq (snd (strip_forall t)) in
    not(is_delta_inert t) && not(exists_domain t) &&  has_eulerA dj

let needs_delta_ineq2 t = 
  let (_,_,dj)= Optimize.dest_ineq (snd (strip_forall t)) in
    not(exists_domain t) &&  has_delta4_squared_x dj;;

let needs_delta_ineq3 t = 
  let (_,_,dj)= Optimize.dest_ineq (snd (strip_forall t)) in
    not(exists_domain t) &&  has_delta_234_x dj;;

let POST_DTAC = EVERY [
  DISCH_TAC;
  TYPIFY `&0 < x1 /\ &0 < x2 /\ &0 < x3 /\ &0 < x4 /\ &0 < x5 /\ &0 < x6` (C SUBGOAL_THEN ASSUME_TAC) THENL [(* Break_case_exec. *) POSITIVE_DOMAIN_TAC;ALL_TAC];
  INTRO_TAC Functional_equation.delta_all_atn [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [ BY(ASM_REWRITE_TAC[]) ];
  SIMP_TAC[];
  DISCH_THEN kill;
];;

let DELTA_TAC_PREP d = EVERY [
  ASM_CASES_TAC d THENL [ASM_REWRITE_TAC[];ALL_TAC];
  FIRST_X_ASSUM (MP_TAC o MATCH_MP Merge_ineq.delta_ineq_delta_bd);
  ONFIRST ANTS_TAC [REAL_ARITH_TAC];
  POST_DTAC;
  REPLICATE_TAC 2 (POP_ASSUM kill)
  ];;

let EULERA_TAC_PREP = EVERY [
  INTRO_TAC delta_ineq_eulerA [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
  ONFIRST ANTS_TAC [ ASM_REWRITE_TAC[] THEN ASM_TAC THEN REPEAT WEAKER_STRIP_TAC; EVERY (* Break_case_exec. *) x_lbs; EVERY (* Break_case_exec. *) x_ubs; BY(REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN TRY (REAL_ARITH_TAC) THEN REPEAT ( FIRST (* Break_case_exec. *) h_series THEN REAL_ARITH_TAC))];
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  POST_DTAC;
  REPLICATE_TAC 2 (POP_ASSUM kill);
  ];;

let get_matching_disjunct tm w = 
  let d = disjuncts w in
    find  (has_match tm) d;;

let DELTA_234_TAC gl = 
  let (_,w) = dest_goal gl in
  let hdd = get_matching_disjunct `delta_234_x r (&4) (&4) x1 x2 x3 x4 x5 x6 +	unit6 x1 x2 x3 x4 x5 x6 * -- c < &0` w in
    EVERY [
      ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];
      FIRST_X_ASSUM (MP_TAC o MATCH_MP (UNDISCH_ALL delta_ineq_delta_234_x));
      ONFIRST ANTS_TAC [ASM_TAC THEN REAL_ARITH_TAC];
      POST_DTAC;
      REPLICATE_TAC 2 (POP_ASSUM kill);
    ] gl;;
  
let PROVE_INEQ_TAC = 
  EVERY [ ASM_REWRITE_TAC[] THEN ASM_TAC THEN REPEAT WEAKER_STRIP_TAC; 
	  EVERY (* Break_case_exec. *) x_lbs; 
	  EVERY (* Break_case_exec. *) x_ubs; 
	  RULE_ASSUM_TAC (REWRITE_RULE[arith `&4 * hminus = &2 * (&2 * hminus)`]); 
	  REPEAT STRIP_TAC;
	  TRY (MATCH_MP_TAC (arith `x <= n - &1 ==> x < n`));
	  TRY (FIRST_X_ASSUM MATCH_MP_TAC);  
	  TRY (REAL_ARITH_TAC); 
	  REPEAT ( FIRST (* Break_case_exec. *) h_series THEN TRY REAL_ARITH_TAC)
	];;

let DELTA_X1_TAC gl = 
  let (_,w) = dest_goal gl in
    try 
      let hdd = get_matching_disjunct `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
	delta4_squared_x x1 x2 x3 x4 x5 x6 * -- c <    &0` w in
	EVERY [
	  ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];
	  FIRST_X_ASSUM (MP_TAC o MATCH_MP delta_ineq_delta4_x_squared2);
	  ONFIRST ANTS_TAC [PROVE_INEQ_TAC];
	] gl
    with Failure _ -> MP_TAC TRUTH gl;;

let DELTA_X1_TAC_WIDE gl = 
  let (_,w) = dest_goal gl in
  let hdd = get_matching_disjunct `x1_delta_x x1 x2 x3 x4 x5 x6 * &4 +
    delta4_squared_x x1 x2 x3 x4 x5 x6 * -- c <    &0` w in
    EVERY [
      ASM_CASES_TAC (hdd) THENL [ASM_REWRITE_TAC[];ALL_TAC];
      FIRST_X_ASSUM (MP_TAC o MATCH_MP delta_ineq_delta4_x_squared2_wide);
      ONFIRST ANTS_TAC [ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[Sphere.h0] THEN REAL_ARITH_TAC];
    ] gl;;

let Z_TAC gl =
  let (_,w) = dest_goal gl in
  let d = disjuncts w in
    if has_eulerA d then EULERA_TAC_PREP gl else 
      if has_delta_234_x d then DELTA_234_TAC gl else
	if  has_delta4_squared_x d then 
	  EVERY [DELTA_X1_TAC_WIDE;POST_DTAC;REPLICATE_TAC 2 (POP_ASSUM kill)] gl else
	  let fl = filter  (has_match 
			      `delta_x x1 x2 x3 x4 x5 x6 + unit6 x1 x2 x3 x4 x5 x6 * -- y < &0`) d in
	    if fl=[] then ALL_TAC gl else DELTA_TAC_PREP (hd fl) gl;;

let get_beta_tactic s = 
  PREP_TAC THEN Z_TAC THEN POS_SIMP_TAC THEN POST_TAC THEN TRY DISCH_TAC;;

let needs_beta s = 
    let t = get_ineq s in
      needs_delta_ineq1 t or needs_delta_ineq2 t or needs_delta_ineq3 t;;

let run_beta s = 
    run_generic get_beta_tactic needs_beta s;;

let test_beta () = 
  let beta_data = map (data_of_run run_beta) beta_idv in
    forall (fun (_,ls) -> (ls = [])) beta_data;;

let all_beta_parameters = List.flatten (map idv_parameters beta_idv);;

List.length all_beta_parameters = 6928;;
 
let get_nth_beta j = 
    get_one_iarg run_beta (List.nth all_beta_parameters j);;  

(* ********************************************************************** *)
(* run_gamma for gamma_data *)
(* ********************************************************************** *)

let has_full8 t = some_const_name ((=) "gamma23_full8_x") t;;

let has_keep135 t = some_const_name ((=) "gamma23_keep135_x") t;;


let DTAC t = 
    if exists_domain t 
    then 
      EVERY [
        INTRO_TAC (find_domain t) [`x1`;`x2`;`x3`;`x4`;`x5`;`x6`];
	ONFIRST ANTS_TAC [ PROVE_INEQ_TAC ];
      ]
    else DELTA_X1_TAC ;;

let ETA126_TAC gl = 
  let (_,w) = dest_goal gl in
    try
      let hdd = get_matching_disjunct  
	`unit6 x1 x2 x3 x4 x5 x6 * c + eta_x x1 x2 x6 pow 2 * -- &1 < &0` w in
	EVERY [
	  ASM_CASES_TAC (hdd) THENL [ ASM_REWRITE_TAC[];ALL_TAC];
	  FIRST_X_ASSUM (MP_TAC o MATCH_MP Merge_ineq.eta126_x_bd);
	  ONFIRST ANTS_TAC [  ARITH_TAC ];
	  DISCH_TAC;
	] gl
    with Failure _ -> ASSUME_TAC TRUTH gl;;

let ETA135_TAC gl = 
  let (_,w) = dest_goal gl in
    try
      let hdd = get_matching_disjunct  
	`unit6 x1 x2 x3 x4 x5 x6 * c + eta_x x1 x3 x5 pow 2 * -- &1 < &0` w in 
	EVERY [
	  ASM_CASES_TAC (hdd) THENL [ ASM_REWRITE_TAC[];ALL_TAC];
	  FIRST_X_ASSUM (MP_TAC o MATCH_MP Merge_ineq.eta135_x_bd);
	  ONFIRST ANTS_TAC [  ARITH_TAC ];
	  DISCH_TAC;
	] gl
    with Failure _ -> ASSUME_TAC TRUTH gl;;

let FULL8_TAC  = EVERY[
  GMATCH_SIMP_TAC Merge_ineq.nonf_gamma23f_full8_x;
  ONFIRST CONJ_TAC [PROVE_INEQ_TAC];
];;

let KEEP135_TAC  = EVERY[
  GMATCH_SIMP_TAC Merge_ineq.nonf_gamma23_keep135_x;
  ONFIRST CONJ_TAC [PROVE_INEQ_TAC];
];;

let get_gamma_tactic s =
  let t = get_ineq s in
    PREP_TAC THEN DTAC t THEN POST_DTAC THEN 
	    ETA126_TAC THEN ETA135_TAC THEN 
	    TRY FULL8_TAC THEN TRY KEEP135_TAC THEN 
	    REPLICATE_TAC 4 (POP_ASSUM kill) THEN POST_TAC THEN REPEAT DISCH_TAC;;

let needs_gamma s = 
  let t = get_ineq s in
    needs_delta_ineq2 t;;

let run_gamma s = 
  run_generic get_gamma_tactic needs_gamma s;;

let test_gamma() = 
  let data = map (data_of_run run_gamma) gamma_idv in
    forall (fun (_,ls) -> (ls = [])) data;;

let all_gamma_parameters = List.flatten (map idv_parameters gamma_idv);;

List.length all_gamma_parameters;;
 
let get_nth_gamma j = 
    get_one_iarg run_gamma (List.nth all_gamma_parameters j);;  

(* ********************************************************************** *)
(* Combine all cases *)
(* ********************************************************************** *)

let all_idv =     (oxl_idv @ delta_idv @ alpha_idv @ beta_idv @ gamma_idv);;

let all_parameters = List.flatten (map idv_parameters all_idv);;

List.length all_parameters = 23242;;

let check_tac s gl = 
  let (_,w) = dest_goal gl in
  let _ = (bad_names w = []) or failwith ("bad names: "^s) in
    ALL_TAC gl;;

let noarg f x = f;;

let cases = 
  [(oxl_idv,noarg POSTPREP_OXL_634_TAC,noarg false);
   (alpha_idv,get_alpha_tactic,noarg false);
   (beta_idv,get_beta_tactic,needs_beta);
   (gamma_idv,get_gamma_tactic,needs_gamma);
   (delta_idv,get_delta_tactic,noarg false)];;

let get_case s = find (fun (ls,_,_)-> mem s ls) cases;;

let get_nth = 
  fun j->
  let (s,i) = List.nth all_parameters j in
  let (_,tac,need) = get_case s in
  let run = run_generic (fun s -> tac s THEN check_tac s) need in
    get_one_iarg run (s,i);;

(* old OXL material *)

(*
let mk_i i = 
  try 
    let _ = Serialization.mk_ser_thm ( get_nth i) in
      (true,i)
  with Failure _ ->  (false,i);;
*)

(*
let prove_oxl_serialize_processed_idv s =
  let get_tactic s = POSTPREP_OXL_634_TAC in
  let needs_delta_ineq s = false in
  let run = run_generic get_tactic needs_delta_ineq in
  let t =  run (* mk_post_prep_oxl *) s in
  let iarg  = get_iarg s in 
    prove_serialize_processed_idq t iarg;;

let SERIAL_OXL_TAC s gl = 
  let t = goal_concl gl in
  let iarg = get_iarg s in 
  let thm = prove_oxl_serialize_processed_idq t iarg in
    ACCEPT_TAC thm gl;;

(* This generates theorems for all the prop-OXLZLEZ series inequalities in prep.hl *)

let exec_prove_all_prep_oxl () = 
  map prove_prep_oxl  all_oxl_idv;;

*)




(* ********************************************************************** *)
(* reconstruct inequality on full domain from subdomains *)
(* ********************************************************************** *)

let rec prove_iargs tm = 
  let (_,[x;d;f]) = strip_comb tm in
    function
      | Iarg_bisect (i,u,v) ->
	  let thm_u = prove_iargs (mk_ineqm x (mk_bisect_left i d) f) u in
	  let thm_v = prove_iargs (mk_ineqm x (mk_bisect_right i d) f) v in
	  let i' = mk_small_numeral i in
	  let thm =   UNDISCH_ALL (SPECL [d;i';x;f] bisect_thm) in
	    PROVE_HYP thm_v (PROVE_HYP thm_u thm)
      | Iarg_leaf _ -> ASSUME tm
      | Iarg_facet ((i,false),r,_,v) ->
	  let thm_v = prove_iargs (mk_ineqm x (mk_frac_right i r d) f) v in
	  let i' = mk_small_numeral i in
	  let r' = mk_decimal10000 r in
	  let thm = UNDISCH_ALL (SPECL [d;i';x;f;r'] ineqm_frac_thm) in
	    PROVE_HYP thm_v thm
      | Iarg_facet ((i,true),r,_,v) ->
	  let r' = 1.0 -. r in
	  let thm_v = prove_iargs (mk_ineqm x (mk_frac_left i r' d) f) v in
	  let i' = mk_small_numeral i in
	  let r'' = mk_decimal10000 r' in
	  let thm = UNDISCH_ALL (SPECL [d;i';x;f;r''] ineqm_frac_thm) in
	    PROVE_HYP thm_v thm;;
	    
let prove_iargs_cases tm iarg = 
  let spec_all tm = concl (SPEC_ALL (ASSUME tm)) in
  let eq1 = REWRITE_CONV [GSYM  ineq6m] (spec_all tm) in
  let rhs1 = rhs (concl eq1) in
  let pthm = prove_iargs (rhs1) iarg in
    EQ_MP (SYM eq1) pthm;;

let prove_serialize_processed_idq t iarg = 
  let cl =  mk_case_list t iarg in
  let cthms = map Serialization.mk_ser_thm cl in
  let athm =  prove_iargs_cases t iarg in
  let rthm = itlist (PROVE_HYP) cthms athm in
  let vthm = REWRITE_RULE 
    [LENGTH;LENGTH_bisect_left;LENGTH_bisect_right;LENGTH_frac_left;LENGTH_frac_right] 
    (DISCH_ALL rthm) in
    vthm;;

let SERIAL_TAC s gl = 
  let t = goal_concl gl in
  let iarg = get_iarg s in 
  let thm = prove_serialize_processed_idq t iarg in
    ACCEPT_TAC thm gl;;

(*
let prove_serialized_idv s = 
  let w =  get_ineq s in
  let (_,PREP_TAC,nd) = get_case s in
    if (nd s) then failwith "needs delta: " else
    prove(w, PREP_TAC s THEN SERIAL_TAC s);;
*)

let prove_serialized_idv s = 
  let t = get_ineq s in
  let di = `delta_ineq_v6:bool` in
  let (_,PREP_TAC,nd) = get_case s in
  let gt = if (nd s) then mk_imp(di,t) else t in
  let _ = g gt in
      (prove(gt, PREP_TAC s THEN SERIAL_TAC s));;

let prove_prep s =
  let _ = report s in
    try
      (s,prove_serialized_idv s)
    with Failure m -> (report "FAIL"; (m^s,TRUTH));;
	
let test_prep s = 
    try 
      (prove_prep s; true)
    with Failure _ -> (report ("fail "^s); false);;

let all_idv = setify (oxl_idv @ alpha_idv @ beta_idv @ gamma_idv @ delta_idv);;

end;;
