(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Linear Programming Inequalities                                          *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2010-08-01                                                           *)
(* ========================================================================== *)


(* Generate new linear inequalities that are needed for linear programs. *)

(*
Mathematica and Cfsqp both need to be installed before this code
can be executed.
*)

(*

Steps to create an inequality and rerun linear programs.
This file automates these steps.

0/- Analyze output to find a triangle that is bad with
  sorted_azim_weighted_diff darts_of_std_tri amx;; 
1/- Mathematica.  holineq[Dihedral,{2,2,2,2,2,2},{2.52,2.25,2.52,2.52,2.52,2.52}].
2/- save, strip "\ " at the end of lines.
3/- run Parse_ineq.execute_cfsqp new_ineq to check if it seems to be true.
     If not, edit until it is correct.
4/- change the domain info to something that is recognized by glpk model.
5/- add new_ineq to put in archive.
6/- Parse_ineq.lp_string()  to generate model body.mod.
7/- Save body.mod in directory: glpk/tame_archive.
8/- Lpproc.make_model() to make the new model.
9/- Rerun the linear programs.

*)

(* Interaction with inequality generation. Mathematica is needed for
    the next bit.  *)

flyspeck_needs "nonlinear/ineq.hl";;

module Temp_ineq = struct

  let all_forall = Sphere.all_forall;;

let junkval =  { 
 id = "junk";
 doc="junk";
 tags=[];
 ineq = 
 all_forall `ineq [(&1,y,&2)] (y > &0)`;
 };;

let mathfile = "/Applications/Mathematica\ 5.2.app/Contents/MacOS/MathKernel";;
let math_initf= "/Users/thomashales/Desktop/googlecode/flyspeck/mathematica/auto_mkineq.m";;
let mathtemp = "/tmp/mathtemp4.hl";; (* hardwired into mathematica code *)

let command_string fn lb ub = 
(mathfile^" -run \"<< "^math_initf^ ";\n runQuit["^fn^","^lb^","^ub^"];\"");;

let command_string_p fn p lb ub = 
(mathfile^" -run \"<< "^math_initf^ ";\n runQuitp["^fn^","^p^","^lb^","^ub^"];\"");;

 let cfsqp_margin idq = 
  let cfsqp_dir = flyspeck_dir^"/../cfsqp" in
  let _ =  Parse_ineq.mk_cc (cfsqp_dir ^ "/tmp/t.cc") idq in
  let _ = Parse_ineq.compile() in 
  let _ = (0=  Sys.command(cfsqp_dir^"/tmp/t.o > /tmp/cfsqp_out.txt")) or failwith "execution error" in
  let s2 =  process_to_string("grep 'constrained min:' /tmp/cfsqp_out.txt | sed 's/^constrained min://g' | tr -d '\n'") in  float_of_string s2;;

let padded_decimal_of_cfsqp idq = (* add padding to make nonlinear verifications easier *)
   let r =  cfsqp_margin idq in
     let a = if r < 0.001 then 0.001 -. r else 0.0 in
     let b = int_of_float (Pervasives.ceil (10000.0 *. a)) in
     mk_binop `DECIMAL` (mk_numeral (Int b)) (mk_numeral (Int 10000));;

let add_decimal ineq a =
  let (quant,raw) = strip_forall ineq in
  let (dom,gt) = dest_binop `ineq` raw in
  let (lhs,rhs) = dest_binop `real_gt` gt in
  let lhs' = mk_binop `real_add` lhs a in
  let gt' = mk_binop `real_gt` lhs' rhs in
  let raw' = mk_binop `ineq` dom gt' in
  let ineq' = list_mk_forall (quant,raw') in
   ineq';;

let sqrt8_sqrt2 = prove_by_refinement(
  `sqrt (&8) = &2 * sqrt2`,
  (* {{{ proof *)
  [
  SIMP_TAC[Sphere.sqrt2;SQRT_MUL;
     REAL_ARITH `&8 = &4 * &2 /\ &0 <= &2 /\ &0 <= &4`;];
  REWRITE_TAC[REAL_ARITH `&4 = &2 pow 2 /\ abs(&2) = &2`;POW_2_SQRT_ABS];
  ]);;
  (* }}} *)

let constant_fix = [sqrt8_sqrt2;Sphere.h0;Sphere.sqrt2;Sphere.sqrt8;
  REAL_ARITH `#2.0 = &2 /\ &2 * #1.26 = #2.52 /\ #2.00 = &2 `];;

(*
problem: dart_std3 and dart_std3_big have the same "domain".
*)

let reduced_dart_classes() = search_thml (term_match [])  [omit `dart_std3_big`] (map (fun t-> ("",t)) (!Ineq.dart_classes));;

let dart_class_rew() = map (REWRITE_RULE constant_fix)  (map (GSYM o snd ) (reduced_dart_classes()));;

let convert_domain ineq = snd (dest_eq (concl 
  (REWRITE_CONV ( constant_fix @ (dart_class_rew()) ) ineq)));;

let adjust = 
  let zero = `&0` in
  fun s idq ->
    let a = padded_decimal_of_cfsqp idq in
      if (a = zero) then idq else
     {
     id = idq.id;
     doc = idq.doc ^ s^ "\n  The inequality has been fitted to cfsqp margins.";
     tags = idq.tags;
     ineq = convert_domain(add_decimal idq.ineq a);
     };;

(* By loading the file mathtemp, the value of the reference tempval is
    changed to the output of the mathematica run *)

  let tempval = ref junkval;;

let generate_ineq_datum = 
  fun  fname slb sub ->
  let example = command_string fname slb sub in 
  let _ = Sys.command(example) in
  let _ = loadt mathtemp in
    adjust 
  ("\n Generated by generate_ineq_datum with input "^
   fname ^" "^slb^" "^sub^".") (!tempval);;

let generate_ineq_datum_p =
  fun fname sp slb sub ->
  let example = command_string_p fname sp slb sub in 
  let _ = Sys.command(example) in
  let _ = loadt mathtemp in
    adjust  ("\n Generated by generate_ineq_datum_p with input "^
   fname ^" "^sp^" "^slb^" "^sub^".") (!tempval);;


(*
This is a quick hack that converts a dihedral inequality into a function
that gives the difference between the right and left hand sides of an
ineq  LHS > RHS for given values y1..y6.

It assumes that the inequality has this particular form.
*)

let ocaml_funstring_of_ineq iqd = 
  let t = snd(strip_forall (Parse_ineq.prep_term (iqd.ineq))) in
  let (_,tm) = dest_comb t in
let (lhs,rhs) = dest_binop `real_gt` tm in
let olhs = Parse_ineq.ocaml_string_of_term lhs in
let orhs = Parse_ineq.ocaml_string_of_term rhs in
  "(fun y1 y2 y3 y4 y5 y6 -> " ^ olhs ^ " -. " ^ orhs ^ ");;";;

let tempfn = ref (fun (y1:float) (y2:float) (y3:float) (y4:float) (y5:float) (y6:float) -> 0.0);;

let ocaml_eval =
  let tempfile = Filename.temp_file "ocaml_eval_" ".ml" in
  fun iqd ->
  let _ = Parse_ineq.output_string tempfile 
    ("tempfn := " ^ ocaml_funstring_of_ineq iqd) in
  let _ = loadt tempfile in
    !tempfn;;

(* NOW DATA SECTION OF NEW DART CLASSES THAT HAVE BEEN FOUND *)


let dart_std3_lw = Ineq.define_dart `dart_std3_lw y1 y2 y3 y4 y5 y6 =
  [
  (#2.00,y1,#2.18);
  (&2,y2,#2.52);
  (&2,y3,#2.52);
  (#2.25,y4,#2.52);
  (&2,y5,#2.52);
  (&2,y6,#2.52)
  ]` ;;

(* NOW DATA SECTION OF NEW INEQUALITIES THAT HAVE BEEN FOUND *)

(*
generate_ineq_datum "mDihedral2" 
 "{2,2,2,2.52,2,2}" "{2.52,2.52,2.52,sqrt8,2.52,2.52}";;

Annoyance: have to manually edit `--#X.XX` -> `-- #X.XX`
*)

let i4750199435 = 
  {ineq =
    `!y1 y2 y3 y4 y5 y6.
         ineq (apex_flat y1 y2 y3 y4 y5 y6)
         (--dih2_y y1 y2 y3 y4 y5 y6 + #0.0031 >
          --  #1.08346 +
          #0.288794 * (-- &2 + y1) +
          -- #0.292829 * (-- &2 + y2) +
          #0.036457 * (-- &2 + y3) +
          #0.348796 * (-- #2.52 + y4) +
          -- #0.762602 * (-- &2 + y5) +
          -- #0.112679 * (-- &2 + y6))`;
   id = "4750199435";
   doc =
    "date{2010, 8, 1, 7, 59, 42.645902}           
     ineq generated by Mathematica holineq 
     The inequality has been fitted to cfsqp margins.";
   tags = [Cfsqp; Lp; Lpsymmetry]};;

Ineq.add  i4750199435;;

(* 8384511215;;
generate_ineq_datum_p "Dihedral2" "{2,2,2.52,sqrt8,2,2}"
 "{2,2,2,2.52,2,2}" "{2.52,2.52,2.52,sqrt8,2.52,2.52}";;
*)

let i8384511215 =  {ineq =
    `!y1 y2 y3 y4 y5 y6.
         ineq (apex_flat y1 y2 y3 y4 y5 y6)
         (dih2_y y1 y2 y3 y4 y5 y6 + #0.0015 >
          #0.913186 +
          -- #0.390288 * (-- &2 + y1) +
          #0.115895 * (-- &2 + y2) +
          #0.164805 * (-- #2.52 + y3) +
          -- #0.271329 * (-- #2.82843 + y4) +
          #0.584817 * (-- &2 + y5) +
          -- #0.170218 * (-- &2 + y6))`;
   id = "8384511215";
   doc =
    "date{2010, 8, 1, 12, 24, 31.880776}\n              ineq generated by Mathematica holineq\n  The inequality has been fitted to cfsqp margins.";
   tags = [Cfsqp; Lp; Lpsymmetry]};;

Ineq.add i8384511215;;

(*
7819193535;
generate_ineq_datum "Dihedral2" 
 "{2,2,2,2.25,2,2}" "{2.18,2.52,2.52,2.52,2.52,2.52}";;
*)

let i7819193535 =  {ineq =
    `!y1 y2 y3 y4 y5 y6.
         ineq (dart_std3_lw y1 y2 y3 y4 y5 y6)
         (dih2_y y1 y2 y3 y4 y5 y6 + #0.0011 >
          #1.16613 +
          -- #0.296776 * (-- &2 + y1) +
          #0.208935 * (-- &2 + y2) +
          -- #0.243302 * (-- &2 + y3) +
          -- #0.360575 * (-- #2.25 + y4) +
          #0.636205 * (-- &2 + y5) +
          -- #0.295156 * (-- &2 + y6))`;
   id = "7819193535";
   doc =
    "date{2010, 8, 1, 14, 6, 32.558867}\n              ineq generated by Mathematica holineq\n  The inequality has been fitted to cfsqp margins.";
   tags = [Cfsqp; Lp; Lpsymmetry]};;

Ineq.add  i7819193535;;

(* remove "2621779878";; *)

(*
let ii = generate_ineq_datum_p "Dihedral2" "{2.36,2,2,2.52,2,2.25}"
 "{2.18,2,2,2.25,2,2}" "{2.36,2.18,2.18,2.52,2.52,2.52}";;
*)

let i6987934000 =  {ineq =
    `!y1 y2 y3 y4 y5 y6.
         ineq (dart_mll_w y1 y2 y3 y4 y5 y6)
         (dih2_y y1 y2 y3 y4 y5 y6 + #0.0042 >
          #0.952682 +
          -- #0.268837 * (-- #2.36 + y1) +
          #0.130607 * (-- &2 + y2) +
          -- #0.168729 * (-- &2 + y3) +
          -- #0.0831764 * (-- #2.52 + y4) +
          #0.580152 * (-- &2 + y5) +
          #0.0656612 * (-- #2.25 + y6))`;
   id = "6987934000";
   doc =
    "date{2010, 8, 1, 17, 50, 0.245131}\n              ineq generated by Mathematica holineq\n  The inequality has been fitted to cfsqp margins.";
   tags = [Cfsqp; Lp; Lpsymmetry]};;

Ineq.add  i6987934000;;




end;;
