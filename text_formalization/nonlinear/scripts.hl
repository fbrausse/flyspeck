(* ========================================================================== *)
(* FLYSPECK - CODE INFORMAL                                                   *)
(*                                                                            *)
(* Chapter: Nonlinear                                                         *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2012-04-15                                                           *)
(* ========================================================================== *)


(* Interactive scripts for the running of interval arithmetic code from 
    ineq.hl, 
*)


(* START NONLINEAR INEQS *)
(* reneeds "nonlinear/ineqdata3q1h.hl";;  *)
(* reneeds "nonlinear/strongdodec_ineq.hl";; *)

flyspeck_needs "leg/enclosed_def.hl";;
flyspeck_needs "general/sphere.hl";;
flyspeck_needs "nonlinear/ineq.hl";;
flyspeck_needs "nonlinear/mdtau.hl";;
flyspeck_needs "nonlinear/main_estimate_ineq.hl";;
flyspeck_needs "nonlinear/strongdodec_ineq.hl";;

flyspeck_needs "nonlinear/lemma.hl";;
flyspeck_needs  "nonlinear/parse_ineq.hl";;
flyspeck_needs "nonlinear/optimize.hl";;
flyspeck_needs "nonlinear/bcc_lattice.hl";;

let all_cases = 
  Parse_ineq.nub (map (fun t -> t.idv) (!Ineq.ineqs));;

List.length  all_cases;;

let finished_cases = 
  let split_sp=  Str.split (Str.regexp "\n") in
  let p = process_to_string ("cat "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			     ^"| sed 's!^//.*$!!'"
			     ^"| sed  's/^.*ineq(/\"/' " 
                             ^"| sed 's/., secs.*$/\";/'   "
			     ^"| sed 's/ split(.*$//g' " 
                             ^"| sed 's/\"//g' "
			     ^" | sed 's/;//g' ") in
    Parse_ineq.nub (split_sp p);;
List.length finished_cases;;

let unfinished_cases = subtract all_cases finished_cases;;
List.length unfinished_cases;;


(*
let finished_splits = 
  let split_sp = Str.split(Str.regexp "\n") in
  let p = process_to_string("grep split "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			     ^"| sed  's/^.*ineq./\"/' " 
                             ^"| sed 's/., secs.*$/\";/'   "
			     ^"| sed 's/ split.*$//g' " 
                             ^"| sed 's/\"//g' "
			     ^" | sed 's/;//g' ") in
    Parse_ineq.nub (split_sp p);;


let hassplit =  
  let a = filter (fun t -> List.length (get_split_tags t) > 0)  !Ineq.ineqs in 
  let a' = filter (fun t -> mem t.id  unfinished_cases) a in
    map (fun t-> t.id) a';;
List.length hassplit;;

*)

(* lists of inequality ids *)

let disregard = 
   [
"9563139965D"; (* derived lp, disregard it *)
  ] ;;

let testids = ref[];;
testids:= subtract (List.rev unfinished_cases) disregard;;
testids := ["OXLZLEZ 6346351218 0 22"];;
testids := ["5556646409"; "4322269127";];;  (* mdtau_y_LC not defined *) 

List.length !testids;;

(*
let view nth = hd (Ineq.getexact (List.nth !testids nth));;
idq_fields(view 0);;
view 1;;
*)

let expand_string = map (fun t->t.idv) o Ineq.getprefix;;

let special_concerns = [
  "2065952723 A1"; (* requires special code, FAILS ON THACKMAC. *)
   ] @ (expand_string  "ZTGIJCF23" (* slow *));;

let nocompile = disregard;;


(* running one id *)

(*
let testid =   "FXZXPNS";;
Optimize.testsplit false testid;;
map (Optimize.testsplit true) !testids;;
*)

let execute_interval() = 
  map (Optimize.testsplit true) (subtract all_cases disregard);;

(* goal *)

(* open Optimize;; *)

let process_cases_testid testid = 
  let idq =  (hd(Ineq.getexact testid)) in
  let (s,tags,ineq) = Optimize.idq_fields idq in
  let ls = Optimize.get_split_tags idq in
   if (ls=[]) then (s,tags,ineq) else
     let cases = Optimize.split_all_h0 [(ineq,ls)] in 
       (s^" case-",tags,List.nth cases 1);;

let interactive_debug_stuff testid = 
  let (id,tags,case) = process_cases_testid testid in
  let ife b t = e(if b then t else ALL_TAC) in
  let is_xconvert = mem Xconvert tags in
  let is_branch = mem Branching tags in
  let _ = g (mk_imp (`NONLIN`,case)) in
  let _ = e(Optimize.PRELIM_REWRITE_TAC) in
  let _ = ife (is_branch) Optimize.BRANCH_TAC in
  let _ = ife (is_xconvert) Optimize.X_OF_Y_TAC in
  let _ = ife (is_branch && not(is_xconvert))
    (Optimize.SERIES3Q1H_5D_TAC) in
  let _ = e (Optimize.STYLIZE_TAC) in
    e (Optimize.WRAPUP_TAC);;

(* TESTING CFSQP *)


let one_cfsqp t = 
  Parse_ineq.execute_cfsqp (hd(Ineq.getexact t));;

let cfsqp ts = 
  let us = map (hd o Ineq.getexact) ts in
  !(Parse_ineq.execute_cfsqp_list us);;

let execute_cfsqp() = cfsqp all_cases;;

(* Timing *)

let rec finalize = function (* use time from most recent verification *)
  | [] -> []
  | (x,t)::vs -> if (exists (fun (x',_) -> (x'=x)) vs) then finalize vs
    else  (x,t)::(finalize vs);;

let total r = 
  let rr = map snd r in
    end_itlist (+) rr;;

let hour r = float_of_int r /. (60.0 *. 60.0);;

let finished_times,finished_rejects = 
  let split_sp = Str.split (Str.regexp "\n") in
  let split_semi = Str.split (Str.regexp ";") in
  let int_s [x;y] = (x,int_of_string y) in
  let p = process_to_string ("cat "^flyspeck_dir
			      ^"/../interval_code/qed_log.txt   "
			      ^"| sed 's!^//.*$!!'"
			     ^"| sed  's/^.*ineq(//' " 
                             ^"| sed 's/., svn.*$//'   "
			      ^"| sed 's/., secs./;/' "
                             ) in
  let (accept,rejects) = partition (fun t -> List.length t =2)  
		 (map split_semi (split_sp p)) in
     (map int_s accept,Parse_ineq.nub rejects);;

let times =   
  let ft = finalize finished_times in
  let split = Str.split(Str.regexp " +split") in
  let fti = filter (fun (x,_) -> mem (hd (split x)) all_cases) ft in
    sort (fun (_,y) (_,y') -> (y>y')) fti;;

hour (total times);;

filter (fun (_,t) -> t>200) times;;


(* splits, test for missing cases, -- none found! may 27, 2011 *)

let case_splits ls = 
  let split = Str.split(Str.regexp " +split") in
  let ss = map split ls in
  let ss2 = filter (fun t-> List.length t  = 2) ss in
  let pair bs = (List.nth bs 0,List.nth bs 1) in
  let nodigit = Str.split(Str.regexp "[^0-9]") in
  let digitize s =  map int_of_string (nodigit s) in
  let f  = function      | b::bs  -> 	(b,pair (unions (map digitize bs)))
    | _ -> failwith "case_splits" in
    map f ss2;;

let rec unify_splits = function
  | [] -> []
  | (s,(_,t)):: _ as ys -> let (st,xs') = partition (fun (s',(_,t')) -> (s'=s & t'=t)) ys in
       (s,Parse_ineq.nub (map (fun (_,(r',_ )) -> r') st),t) ::unify_splits xs';;

let case_splits_execute =   
      let vv = unify_splits (case_splits (map fst finished_times)) in
	filter (fun (_,ls,r) -> not ((0--(r-1)) = sort (<) ls)) vv;;

(* generating ocaml code of the the functions that appear in nonlinear ineqs *)


flyspeck_needs  "../development/thales/nonlinear/functional_equation.hl";;
flyspeck_needs  "nonlinear/parse_ineq.hl";;


let functions() = 
  [
    (* constants *)
   Sphere.h0;
    Sphere.sqrt3;
    Sphere.sol0;
    Sphere.tau0;
    Sphere.mm1;
    Sphere.mm2;
    SYM Nonlinear_lemma.sol0_over_pi_EQ_const1;
    (* single variable *)
    Sphere.gchi;
    Sphere.matan;
    Sphere.lfun;
    Sphere.flat_term;
    Nonlinear_lemma.rho_alt;
    Sphere.sqn;
    REWRITE_RULE[Sphere.flat_term] Sphere.flat_term_x;
  (* 3 vars *)
    Nonlinear_lemma.quad_root_plus_curry;
   Sphere.ups_x;
   Sphere.eta_x;
    (* general 6 *)
   Functional_equation.promote1_to_6;
   Functional_equation.promote3_to_6;
   Nonlinear_lemma.unit6;
   Nonlinear_lemma.proj_x1;
   Nonlinear_lemma.proj_x2;
   Nonlinear_lemma.proj_x3;
   Nonlinear_lemma.proj_x4;
   Nonlinear_lemma.proj_x5;
   Nonlinear_lemma.proj_x6;
   Functional_equation.proj_y1;
   Functional_equation.proj_y2;
   Functional_equation.proj_y3;
   Functional_equation.proj_y4;
   Functional_equation.proj_y5;
   Functional_equation.proj_y6;
   Sphere.delta_x;
   Sphere.delta_x4;
   Sphere.dih_x;
   Sphere.sol_x;
   Sphere.rho_x;
   Sphere.rad2_x;
   Functional_equation.compose6;
   Functional_equation.uni;
   Functional_equation.constant6;
   Functional_equation.two6;
   Functional_equation.zero6;
   Functional_equation.four6;
   Functional_equation.add6;
   Functional_equation.sub6;
   Functional_equation.mul6;
   Functional_equation.div6;
   Functional_equation.mk_126;
   Functional_equation.mk_135;
 (* by hand:  Functional_equation.domain6; *)
   Functional_equation.rotate234;
   Functional_equation.rotate126;
   Functional_equation.rotate345;
   Sphere.rotate2;
   Sphere.rotate3;
   Sphere.rotate4;
   Sphere.rotate5;
   Sphere.rotate6;
Functional_equation.functional_eta2_126;
Functional_equation.functional_x1_delta_x;
Functional_equation.functional_delta4_squared_x;
Functional_equation.functional_vol_x;
Functional_equation.functional_dih2_x;
Functional_equation.functional_dih3_x;
Functional_equation.functional_dih4_x;
Functional_equation.functional_dih5_x;
Functional_equation.functional_dih6_x;
Functional_equation.functional_lfun_y1;
Functional_equation.functional_ldih_x;
Functional_equation.functional_ldih2_x;
Functional_equation.functional_ldih3_x;
Functional_equation.functional_ldih6_x;
Functional_equation.functional_eulerA_x;
Functional_equation.functional_gchi1_x;
Functional_equation.functional_gchi2_x;
Functional_equation.functional_gchi3_x;
Functional_equation.functional_gchi4_x;
Functional_equation.functional_gchi5_x;
Functional_equation.functional_gchi6_x;
Functional_equation.functional_eta2_135;
Functional_equation.functional_vol3_x_sqrt;
Functional_equation.functional_vol3f_x_lfun;
Functional_equation.functional_vol3f_x_sqrt2_lmplus;
Functional_equation.functional_asn797k;
Functional_equation.functional_asnFnhk;
Functional_equation.functional_acs_sqrt_x1_d4;
Functional_equation.functional_acs_sqrt_x2_d4;
Functional_equation.functional_arclength_x_123;
Functional_equation.functional_arclength_234;
Functional_equation.functional_arclength_126;
Functional_equation.functional_sol_euler_x_divsqrtdelta;
Functional_equation.functional_sol246_euler_x_div_sqrtdelta;
Functional_equation.functional_sol345_euler_x_div_sqrtdelta;
Functional_equation.functional_sol156_euler_x_div_sqrtdelta;
Functional_equation.functional_dih_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih3_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih5_x_div_sqrtdelta_posbranch;
Functional_equation.functional_dih_x_126_s2;
Functional_equation.functional_dih2_x_126_s2;
Functional_equation.functional_dih3_x_126_s2;
Functional_equation.functional_dih4_x_126_s2;
Functional_equation.functional_dih5_x_126_s2;
Functional_equation.functional_dih6_x_126_s2;
Functional_equation.functional_dih_x_135_s2;
Functional_equation.functional_dih2_x_135_s2;
Functional_equation.functional_dih3_x_135_s2;
Functional_equation.functional_dih4_x_135_s2;
Functional_equation.functional_dih5_x_135_s2;
Functional_equation.functional_dih6_x_135_s2;
Functional_equation.functional_ldih_x_126_s2;
Functional_equation.functional_ldih2_x_126_s2;
Functional_equation.functional_ldih6_x_126_s2;
Functional_equation.functional_ldih_x_135_s2;
Functional_equation.functional_ldih3_x_135_s2;
Functional_equation.functional_ldih5_x_135_s2;
Functional_equation.functional_edge_flat2_x;
Functional_equation.functional_euler_3flat_x;
Functional_equation.functional_euler_2flat_x;
Functional_equation.functional_euler_1flat_x;
Functional_equation.functional_rhazim_x;
Functional_equation.functional_rhazim2_x;
Functional_equation.functional_rhazim3_x;
Functional_equation.functional_taum_x;
Functional_equation.functional_taum_3flat_x;
Functional_equation.functional_taum_2flat_x;
Functional_equation.functional_taum_1flat_x;
Functional_equation.functional_delta_x_126_s2;
Functional_equation.functional_delta_x_135_s2;
Functional_equation.functional_delta_pent_x;
Functional_equation.functional_vol3_x_135_s2;
Functional_equation.functional_ldih_x_div_sqrtdelta_posbranch;
Functional_equation.functional_ldih2_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih3_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih5_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih6_x_div_sqrtdelta_posbranch; 
Functional_equation.functional_ldih_x_n;
Functional_equation.functional_ldih_x_126_n;
Functional_equation.functional_ldih2_x_126_n;
Functional_equation.functional_ldih6_x_126_n;
Functional_equation.functional_ldih_x_135_n;
Functional_equation.functional_ldih3_x_135_n;
Functional_equation.functional_ldih5_x_135_n;
   ];;



let ocaml_code() = 
  let strip_all b = snd(strip_forall (concl (Nonlinear_lemma.strip_let b))) in
  let ocam f = Parse_ineq.ocaml_function (strip_all f) in
  let header = 
  "(* code automatically generated from Parse_ineq.ocaml_code *)\n\n"^
   "module Sphere2 = struct\n\n"^
   "let sqrt = Pervasives.sqrt\n\n" ^
   "let cos = Pervasives.cos\n\n" ^
   "let sin = Pervasives.sin\n\n" ^
   "let log = Pervasives.log\n\n" ^
   "let asn = Pervasives.asin\n\n" ^
   "let atn = Pervasives.atan\n\n" ^
   "let pi = 4.0 *. atn(1.0);;\n\n" ^
    "let pow2 x = x ** (2.0);;\n\n" in
  let tailer =    "end;;\n" in
    header ^
   (Flyspeck_lib.join_lines (map ocam (functions()))) ^ tailer;;

Flyspeck_lib.output_filestring "/tmp/sphere2.ml" (ocaml_code());;
loadt "/tmp/sphere2.ml";;

