
(*
let flast = new_definition 
 `flast H s <=> (next_el s (LAST s) = face_map H (LAST s))`;;

let conloop_list = new_definition
  `contour_list H s <=>
    (!x. MEM x s ==> (one_step_contour H x (next_el s x) /\ x IN dart H))`;;


let normal_list = new_definition
  `normal_list H L <=>
     (uniq (flatten L) /\
      all (\s. ~(s = [])) L /\ 
      all (flast H) L /\
      all (conloop_list H) L /\
      (!d. MEM d (flatten L) ==> node H d SUBSET set_of_list (flatten L)))`;;

*)

let lower_case = end_itlist CONJ
 [GSYM Seq.map_MAP;GSYM Seq.size;GSYM filter_FILTER;
  REVERSE_rev;GSYM last_LAST;APPEND_cat];;

let upper_case  = GSYM lower_case;;

let f_last = new_definition 
 `f_last L s <=> (next_el s (LAST s) = f_list L (LAST s))`;;

let one_step_list = new_definition `one_step_list L x y = 
  (y = f_list L x \/ y = (f_list L (e_list x)))`;;

let loop_list = new_definition
  `loop_list L s <=>
    (all (\x. MEM x (list_of_darts L) /\ one_step_list L x (next_el s x)) s)`;;

let norm_list = new_definition
  `norm_list L N <=>
    (uniq (flatten N) /\
     all (\s. ~(s = [])) N /\
     all (f_last L) N /\
     all (loop_list L) N /\
     (!d. MEM d (flatten N) ==> 
	(node (hypermap_of_list L) d SUBSET set_of_list (flatten N))))`;;

let list_of_face = new_definition `list_of_face H ff = 
  map (\i. node H ((face_map H POWER i) (CHOICE ff))) (upt 0 (CARD ff))`;;

let list_of_hypermap = new_definition `list_of_hypermap H = 
  map (list_of_face H) (list_of_set (face_set H))`;;

let core_list = new_definition `core_list PN = 
  map (\f. map (\x. FST (HD x)) f) PN`;;


(* need to reload first.
let split_list_face_n = new_definition' 
   `split_list_face_n (f:(A) list) (ram1) ram2 newVs = 
      (let f1 =  [ram1] #@#  (betwn f ram1 ram2) #@# [ram2] in
       let f2 =  [ram2] #@# (betwn f ram2 ram1) #@# [ram1] in
	 ( (REVERSE newVs #@# f1)),  (f2 #@# newVs))`;;


let split_list_face_n_split_face = prove_by_refinement(
  `!f ram1 ram2 newVs.
    split_face f ram1 ram2 newVs = 
    (let f1 = FST f in
     let sln = split_list_face_n f1 ram1 ram2 newVs
     in (FST sln,F),(SND sln,F))`,
  (* {{{ proof *)
  [
  rt[Import_tame_classification.split_list_face_n;Import_tame_classification.split_face]
  #
  ]);;
  (* }}} *)
*)

let next_el1 = prove_by_refinement(
  `!h. next_el [h] h = h`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INTRO_TAC Seq2.next_el_last [`h`;`[h]`];
  REWRITE_TAC[Seq.size;LENGTH;HD;Seq.uniq;MEM];
  NUM_REDUCE_TAC;
  TYPIFY `last h [h] = h` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  BY(REWRITE_TAC[Seq.last])
  ]);;
  (* }}} *)

let last_LAST = prove_by_refinement(
  `!s x0. ~(s = []) ==> last x0 s = LAST s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REWRITE_TAC[NOT_CONS_NIL;Seq.last;LAST];
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[Seq.last]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_LAST = prove_by_refinement(
  `!s. ~(s = []) ==> MEM (LAST s) s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.mem_last [`h`;`t`];
  REWRITE_TAC[LAST];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  BY(ASM_MESON_TAC[last_LAST])
  ]);;
  (* }}} *)

let uniq_last = prove_by_refinement(
  `!h s. ~(MEM h s) /\ ~(s = []) ==> ~(LAST (h::s) = h)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL];
  FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[MEM;LAST;NOT_CONS_NIL];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rev0 = prove_by_refinement(
  `rev [] = []`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[REVERSE;REVERSE_rev])
  ]);;
  (* }}} *)

let partition_into_atom0 = new_recursive_definition list_RECURSION
  `partition_into_atom0 (n:A->A) acc [] = acc /\
   partition_into_atom0 n acc (r::rs) = 
     if (acc = []) then partition_into_atom0 n [[r]] rs
     else (if (n r = HD(HD acc)) 
           then partition_into_atom0 n ((r:: HD acc)::TL acc) rs
	   else partition_into_atom0 n ([r]::acc) rs)`;;
     
let partition_into_atom = new_definition `partition_into_atom n r =
  partition_into_atom0 n [] (rev r)`;;

let subquotient = new_definition `subquotient L N = 
  (let H = hypermap_of_list L in
     hypermap_of_list (map (partition_into_atom (inverse (node_map H))) N))`;;

let flatten_partition0 = prove_by_refinement(
  `!n r a. flatten(partition_into_atom0 n a r) = cat (rev r) (flatten a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[partition_into_atom0];
    BY(REWRITE_TAC[rev0;Seq.flatten0;Seq.cat0s]);
  GEN_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    BY(REWRITE_TAC[Seq.rev_cons;Seq.cats1]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.flatten_cons;Seq.rev_cons;GSYM Seq.cats1];
    REWRITE_TAC[GSYM Seq.catA];
    AP_TERM_TAC;
    REWRITE_TAC[Seq.cat1s];
    REWRITE_TAC[Seq.cat1s];
    ONCE_REWRITE_TAC[GSYM Seq.cat1s];
    REWRITE_TAC[GSYM Seq.catA];
    AP_TERM_TAC;
    REWRITE_TAC[Seq.flatten_cons];
    REWRITE_TAC[GSYM Seq.flatten_cons];
    BY(ASM_MESON_TAC[CONS_HD_TL]);
  REWRITE_TAC[GSYM Seq.flatten_cons];
  REWRITE_TAC[Seq.rev_cons;GSYM Seq.cats1];
  ONCE_REWRITE_TAC[Seq.flatten_cons];
  ONCE_REWRITE_TAC[GSYM Seq.catA];
  AP_TERM_TAC;
  BY(REWRITE_TAC[Seq.flatten_cons])
  ]);;
  (* }}} *)

let flatten_partition = prove_by_refinement(
  `!n r. flatten (partition_into_atom n r) = r`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[partition_into_atom;flatten_partition0;Seq.flatten0;Seq.cats0;Seq.revK])
  ]);;
  (* }}} *)

(* was uniq_partition0 *)

let nonnil_partition0 = prove_by_refinement(
  `!n r a. all (\c. ~(c = [])) a ==>
    all (\c. ~(c = [])) (partition_into_atom0 n a r)`,
  (* {{{ proof *)
  [
 GEN_TAC THEN LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[partition_into_atom0];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[Seq.all;NOT_CONS_NIL]);
  COND_CASES_TAC THEN (FIRST_X_ASSUM MATCH_MP_TAC) THEN ASM_REWRITE_TAC[Seq.all;NOT_CONS_NIL];
  BY(ASM_MESON_TAC[CONS_HD_TL;Seq.all])
  ]);;
  (* }}} *)

let nonnil_partition = prove_by_refinement(
  `!n r. all (\c. ~(c = [])) (partition_into_atom n r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[partition_into_atom];
  REPEAT WEAKER_STRIP_TAC THEN MATCH_MP_TAC nonnil_partition0;
  BY(REWRITE_TAC[Seq.all])
  ]);;
  (* }}} *)


1;;
(*
let exists_atomize = prove_by_refinement(
  `!ni (s:(A)list). (all (\d. ~(ni d = d)) s) /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])
...
fxast `LAST` mp
rt[GSYM Seq.all_cons]
amt[Seq.all_cons]
  ]);;
  (* }}} *)
*)

let exists_atomize = prove_by_refinement(
  `!ni f (s:(A)list).  (all (\d. ~(ni d = d)) s) /\ 
    (all (\d. ~(ni d = f d)) s) /\ 
    next_el s (LAST s) = f (LAST s) /\
    all (\d. next_el s d = f d \/ next_el s d = ni d) s /\ uniq s ==>
   (?a. flatten a = s /\ all (\c. ~(c = [])) a /\
      all (\c. (all (\d. (next_el c d = ni d) <=> (~(d = LAST c))) c)) a)`,
  (* {{{ proof *)
  [
  GEN_TAC then g
  LIST_INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `[]:((A)list)list` EXISTS_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.all_nil]);
  REWRITE_TAC[Seq.all];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `t = []` ASM_CASES_TAC;
    TYPIFY `[[h]]` EXISTS_TAC;
    ASM_REWRITE_TAC[Seq.all];
    REWRITE_TAC[NOT_CONS_NIL;Seq.flatten_cons;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[LAST];
    BY(ASM_REWRITE_TAC[next_el1]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  ANTS_TAC;
    nconj 2
    BY(ASM_MESON_TAC[Seq.cons_uniq]);
    
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(a = [])` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `flatten` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0]);
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPED_ABBREV_TAC `c = HD a`;
  TYPIFY `if next_el (h::c) h = ni h then ((h::c)::TL a) else [h]::a` EXISTS_TAC;
  COND_CASES_TAC;
    REWRITE_TAC[Seq.all;Seq.flatten_cons];
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      ONCE_REWRITE_TAC[GSYM Seq.cat1s];
      REWRITE_TAC[GSYM Seq.catA];
      ONCE_REWRITE_TAC[GSYM Seq.flatten_cons];
      FIRST_X_ASSUM_ST `TL` (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[NOT_CONS_NIL];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.all]);
    nCONJ_TAC 0;
      ONCE_REWRITE_TAC[EQ_SYM_EQ];
      MATCH_MP_TAC uniq_last;
      CONJ2_TAC;
        BY(ASM_MESON_TAC[Seq.all]);
      FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cons_uniq];
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "t";
      FULL_EXPAND_TAC "c";
      FIRST_X_ASSUM_ST `MEM h (flatten a)` MP_TAC;
      REWRITE_TAC[Seq2.mem_flatten];
      TYPIFY `HD a` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC Wmlnymd.MEM_HD;
      BY(ASM_MESON_TAC[Seq.flatten0]);
    ASM_REWRITE_TAC[];
    TYPIFY `all (\c. all (\d. next_el c d = ni d <=> ~(d = LAST c)) c) (c:: TL a)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.all_cons];
    SIMP_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    REWRITE_TAC[LAST];
    COND_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.all_cons])




fxast `LAST` mp
rt[GSYM Seq.all_cons]

amt[Seq.all_cons]
  ]);;
  (* }}} *)


GSYM Seq.flatten_cons;;
Seq.flatten_cons;;


