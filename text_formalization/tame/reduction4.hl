(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: July 12, 2014                                                 *)
(* ========================================================================== *)


(* Bauer-Nipkow Isabelle tame graph compatibility checks *)

module Reduction4 = struct

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;

(*    *)


(* ............... NEW DEFS *)


let ftrans = new_definition'
  `!L N r (x:A#A) i. ftrans L N r x i = if i = 0 then SND x else FST (ztrans L N r x (PRE i))`;;

let ifbetwn = new_definition'
  `!s (x:A) y. ifbetwn s x y = if MEM x s /\ MEM y s /\ ~(x=y) then rcons (betwn s x y) y else []`;;


let assumption_setK10 = new_definition'
  `assumption_setK10 <=> (!L N r x k uvns vs vs' fx v.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      element_pre L N /\  // added July 13 2014
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      core_triple_v4 L N r x = uvns /\
      dest_triple_full (core L r) v uvns = vs /\
      MAP the (filter isSome vs) = vs' /\
       transform_count L N r x = k /\
        find_face L x = fx /\
      prev_el (core L r) v,v = x 
      ==> 
      //  added for reduction_D: July 10 2014
     uniq (core L (rtrans L N r x k)) /\
     MEM (FST x) (core L (rtrans L N r x k)) /\
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k)) /\
(~(FST(ztrans L N r x (PRE k)) = FST x) ==>  // added July 17 2014
	(betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))) /\
//     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
//	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\

	// added for induction July 11, 2014
	  (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
	     (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) = 
	       MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i))) /\
      (!i. i < k ==> prev_el (core L (rtrans L N r x i)) v,v = x ) /\

	  uniq (core L r) /\
	  ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	      FST (ztrans L N r x 0) /\
		sizel (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)) = 0) /\
	  (!i. i < transform_count L N r x
	   ==> MEM (FST (ytrans L N r x i)) (core L r)) /\
	  (!i. i < transform_count L N r x
	   ==> MEM (FST (ztrans L N r x i)) (core L r)) /\

	  (!i. 0 < i /\ i < transform_count L N r x ==>
	  uniq (core L (rtrans L N r x i)) /\
	  ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i) /\
		sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i)) = 0) /\
	  	  // corrected July 19 2014
	  // corrected July 19 2014
	  (~((FST (ztrans L N r x (PRE i))) =  (FST (ytrans L N r x i))) ==>
	     betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
	       betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
	    (FST (ytrans L N r x i))) /\

//	  betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
//	  betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
//	    (FST (ytrans L N r x i)) /\
	    (next_el (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i))) =
		FST (ytrans L N r x i) <=>
		  next_el (core L r) (FST (ztrans L N r x (PRE i))) = FST (ytrans L N r x i)) /\
	    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (core L r)) /\
	    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (core L r)) /\
	    (!i'. i' < transform_count L N r x
	     ==> MEM (FST (ytrans L N r x i')) (core L (rtrans L N r x i))) /\
	    (!i'. i' < transform_count L N r x
	     ==> MEM (FST (ztrans L N r x i')) (core L (rtrans L N r x i)))) /\


      //
      (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)))) /\
      (!i. MEM i (MAP FST (flatten N)) ==> 
	 ~(MEM i (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0))))) /\
      (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0))) /\
      (let (f1,f2) = split_normal_list L r fx (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N)) /\
      ~(transform_count L N r x = 0) /\
      0 < transform_count L N r x /\
      (FST x = prev_el (core L r) v) /\
      MEM x fx /\
      uniq fx /\
      1 <= sizel fx /\
      1 < sizel (core L r) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) fx <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) fx) /\
      (indexf (next_el fx x) (ztrans L N r x (PRE k)) fx <=
	 indexf (next_el fx x) x fx) /\
      (indexf (next_el fx x) (ytrans L N r x 0) fx <=
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx) /\


      MEM (next_el fx x) r /\
      (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\
      (!i. i < k ==> MEM (ztrans L N r x i) r) /\
      (!i. i < k ==> MEM (ytrans L N r x i) r) /\
      MEM (next_el fx x) fx /\
      (!i. i < k ==> MEM (ytrans L N r x i) fx) /\
      (!i. i < k ==> MEM (ztrans L N r x i) fx) /\
      uniq (core L r) /\

      (FST (next_el fx x) = v) /\

      (!u. MEM u r ==> MEM (FST u) (core L r)) /\

      indexf v (FST (ytrans L N r x 0)) (core L r) =
          indexf (next_el fx x) (ytrans L N r x 0) fx /\

         indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x fx /\

         (!i. SUC i < k
              ==> indexf (FST (ztrans L N r x i))
                  (FST (ytrans L N r x (SUC i)))
                  (core L r) =
                  indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) fx) /\

// uvns

	   (!i. SUC i < sizel vs'
            ==> indexf v (EL i vs') (core L r) <
           indexf v (EL (SUC i) vs') (core L r)) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (quotient_list L N))
             ==> MEM d (list_pairs (core L r))))

  )`;;


(* ............... LEMMAS *)

let final_assumption_mem_uniq = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
    MEM x (list_of_darts L) /\
    MEM x (find_face L x) /\
    MEM (next_el (find_face L x) x) (find_face L x) /\
    MEM (next_el (find_face L x) x) r /\
    (!i. i < k ==> MEM (ztrans L N r x i) r) /\
    (!i. i < k ==> MEM (ytrans L N r x i) r) /\
    (!i. i < k ==> MEM (ytrans L N r x i) (find_face L x)) /\
    (!i. i < k ==> MEM (ztrans L N r x i) (find_face L x)) /\
    (!i. i <= k ==> uniq (core L (rtrans L N r x i))) /\
    uniq (find_face L x) /\
    ~(k=0)
     `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC transform_count_non0 [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  (DISCH_THEN kill);
  TYPIFY `MEM x r /\ MEM r N /\ normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[GSYM List_hypermap.dart_in_face]);
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC Hojodcm.f_eq_next_el_x_v0 [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM (GEN_ALL Pwssrat.next_el_rotate_to_eq)) [`x`;`r`];
  TYPIFY `uniq r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  ASM_SIMP_TAC[List_hypermap.f_list];
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Kbwpbhq.transform_count_not;Pnxvwfs.PNXVWFS2]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Kbwpbhq.transform_count_not;Pnxvwfs.PNXVWFS1]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.ytran_me_f]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.ztran_me_f;Kbwpbhq.transform_count_not]);
  DISCH_TAC;
  CONJ2_TAC;
    MATCH_MP_TAC List_hypermap.uniq_find_face;
    BY(ASM_MESON_TAC[good_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `marked_list L (ntrans L N r x i) (rtrans L N r x i) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[AQIUNPP]);
  FIRST_X_ASSUM_ST `marked_list` MP_TAC THEN REWRITE_TAC[marked_list;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all uniq` MP_TAC;
  REWRITE_TAC[quotient_list_core;GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let reduction_K1 = prove_by_refinement(
  `(!L N r x k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\  // added July 13 2014
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>

     // END ASSUMPTIONS


     // (V)
     (!v. 
	     (prev_el (core L r) v,v = x)  ==>
	     (!i. i < k ==> prev_el (core L (rtrans L N r x i)) v,v = x ) /\
	     (FST (next_el (find_face L x) x) = v)) /\

     // (INDEX)
     (indexf (FST (next_el (find_face L x) x)) (FST (ytrans L N r x 0)) (core L r) =
         indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x)) /\
     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
     (!i. SUC i < k
      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\
     (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <=
	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=
         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
      (!i. 0 < i /\ i < k ==>
	 (next_el (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i))) =
		FST (ytrans L N r x i) <=>
		  next_el (core L r) (FST (ztrans L N r x (PRE i))) = FST (ytrans L N r x i)) ) /\

     // (BETWN) 
(~(FST(ztrans L N r x (PRE k)) = FST x) ==>  // added July 17 2014
	(betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))) /\
//     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
//	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
//      (!i. MEM i (MAP FST (flatten N)) ==> 
//	 ~(MEM i (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0))))) /\
     ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	 FST (ztrans L N r x 0) /\
	   sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)) = 0) /\
      (!i. 0 < i /\ i < k ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i) /\
		sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)) = 0) /\

	  // corrected July 19 2014
	  (~((FST (ztrans L N r x (PRE i))) =  (FST (ytrans L N r x i))) ==>
	     betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
	       betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
	    (FST (ytrans L N r x i)))) /\

	 // old19
	 // (betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
	   //  betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
	    //   (FST (ytrans L N r x i))) /\
     
     // (MEM)
     MEM (FST x) (core L (rtrans L N r x k)) /\ // final_assumption_mem_x_core
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k)) /\ // final_assumption_zpre_core_k
      (!u. MEM u r ==> MEM (FST u) (core L r)) /\ // final_assumption_mem_fst_core
     (!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r)) /\ // final_assumption_fsty_core
     (!i. i < k ==> MEM (FST (ztrans L N r x i)) (core L r)) /\ // final_assumption_fstz_core
     (!i j. 0 < i /\ i < k /\ j < k ==>
	(MEM (FST (ytrans L N r x j)) (core L (rtrans L N r x i))) /\
	MEM (FST (ztrans L N r x j)) (core L (rtrans L N r x i))) /\ 

     // (SIZE AND MISC)
     (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)) /\ // final_assumption_fst_z
     (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0))) /\ // final_assumption_fst_y_neq_fst_z
     (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\ // final_assumption_y_ne_z
     1 <= sizel (find_face L x) /\ // final_assumption_size_find_face
     1 < sizel (core L r) /\ // final_assumption_size_core 

     // (PREPPED)
      (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
	 (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) = 
	   MAP FST (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) /\

     // (split_normal_list)
      (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N)) /\

     // (UVNS)
      (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)) /\
		       
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 

   ) ==> assumption_setK10`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  REWRITE_TAC[assumption_setK10];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `is_restricted` (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`]);
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_uniq [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[CONJ_ASSOC];
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `list_pairs` (C INTRO_TAC [`v`]) THEN ASM_REWRITE_TAC[LET_THM];
    BY(MESON_TAC[]);
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `list_pairs` (C INTRO_TAC [`v`]) THEN ASM_REWRITE_TAC[LET_THM];
    BY(MESON_TAC[]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `quotient_list` kill);
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `prev_el (core L r) v,v = x` (C INTRO_TAC [`v`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    BY(POP_ASSUM (SUBST1_TAC o GSYM) THEN ASM_REWRITE_TAC[]);
  nCONJ_TAC 3;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `DIFF` MP_TAC;
    REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;IN_DIFF;NOT_FORALL_THM];
    TYPIFY `i` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 3;
    FIRST_X_ASSUM_ST `prev_el (core L r) v,v = x` (C INTRO_TAC [`v`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `uniq` MP_TAC);
  TYPIFY `core L r = core L (rtrans L N r x 0)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  BY(MESON_TAC[arith `0 <= k /\ (i < k ==> i <= k) /\ (k <= k)`])
  ]);;
  (* }}} *)

(* moved to tame_list.hl:
let uniq_flatten_all_uniq = prove_by_refinement(
  `!s. uniq (flatten s) ==> all uniq s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.all]);
  REWRITE_TAC[Seq.flatten_cons;Seq.cat_uniq;Seq.all_cons];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let final_assumption_y_ne_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)  ==>
    (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Diowaas.DIOWAAS) [`next_el (find_face L x) x`;`L`;`N`;`r`;`x`;`i`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_size_find_face = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)  ==>
    1 <= sizel (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC sizel_3_concl [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_mem_fst_core = prove_by_refinement(
  `!L N r x. 
     good_list L /\
     good_list_nodes L /\
     marked_list L N r x ==>
    (!u. MEM u r ==> MEM (FST u) (core L r))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.parts_flatten [`L`;`r`];
  SUBANTS_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM u (flatten (parts L r))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.parts_fst [`L`;`N`;`r`;`l`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  SIMP_TAC[];
  TYPIFY `FST (HD l) = (FST o HD) l` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[o_THM]);
  DISCH_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mem_fst_core = prove_by_refinement(
  `!L N r x u. 
     good_list L /\
     good_list_nodes L /\
     marked_list L N r x /\
     MEM u r ==>
    (MEM (FST u) (core L r))`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[final_assumption_mem_fst_core])
  ]);;
  (* }}} *)

let final_assumption_mem_x_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    MEM (FST x) (core L (rtrans L N r x k))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`(ntrans L N r x k)`;`(rtrans L N r x k)`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let final_assumption_zpre_core_k = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`(ntrans L N r x k)`;`(rtrans L N r x k)`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MATCH_MP_TAC;
  TYPIFY `PRE k = 0 + PRE k` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[final_assumption_mem_uniq]);
  TYPIFY `rtrans L N r x k = rtrans L N r x (SUC 0 + PRE k)` (C SUBGOAL_THEN SUBST1_TAC);
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[trans_add];
  MATCH_MP_TAC (GEN_ALL Pbflhet.ztrans_in_suc);
  GEXISTL_TAC [`find_face L x`];
  GEXISTL_TAC [`next_el (find_face L x) x`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  CONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_fsty_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let final_assumption_fstz_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (!i. i < k ==> MEM (FST (ztrans L N r x i)) (core L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let final_assumption_fst_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq1.FST_EQ_PREV_ZTRANS_v0) [`prev_el r (ztrans L N r x 0)`;`ztrans L N r x 0`;`L`;`N`;`r`;`x`];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[Reduction2.trans0])
  ]);;
  (* }}} *)

let final_assumption_fst_y_neq_fst_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC is_restricted_all_uniq [`L`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `(ytrans L N r x 0) =  (ztrans L N r x 0)` ENOUGH_TO_SHOW_TAC;
    INTRO_TAC final_assumption_y_ne_z [`L`;`N`;`r`;`x`;`k`];
    ASM_REWRITE_TAC[];
    DISCH_THEN MATCH_MP_TAC;
    REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  MATCH_MP_TAC Tame_list.list_pairs_unique;
  TYPIFY `find_pair_list L x` EXISTS_TAC;
  ASM_REWRITE_TAC[GSYM List_hypermap.find_face_alt];
  CONJ_TAC;
    TYPIFY `MEM (find_pair_list L x) L` ENOUGH_TO_SHOW_TAC;
      POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
      BY(MESON_TAC[]);
    MATCH_MP_TAC List_hypermap.mem_find_pair_list;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  BY(ASM_MESON_TAC[Hojodcm.ztran_me_f_v0;Pplhulj.ytran_me_f])
  ]);;
  (* }}} *)

let final_assumption_size_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    1 < sizel (core L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC LTE_TRANS;
  TYPIFY `CARD (set_of_list (core L r))` EXISTS_TAC;
  REWRITE_TAC[Tame_list.card_le_size];
  INTRO_TAC Hypermap.CARD_TWO_ELEMENTS [`FST (ytrans L N r x 0)`;`FST (ztrans L N r x 0)`];
  ASM_REWRITE_TAC[];
  TYPIFY `FINITE (set_of_list (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[FINITE_SET_OF_LIST]);
  INTRO_TAC CARD_SUBSET [`{FST (ytrans L N r x 0), FST (ztrans L N r x 0)}`;`set_of_list (core L r)`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;IN_INSERT;NOT_IN_EMPTY];
    BY(ASM_MESON_TAC[Hojodcm.ytrans_mem_rtrans_v0;Hojodcm.mem_ztrans_rtrans_v0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_yz_in_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) /\
     (!N' r' i'. i' < transform_count L N' r' x /\ marked_list L N' r' x /\
	newvertex_prepped L N' r' x /\ ~final_list L r' /\ element_pre L N' 
     ==> MEM (ztrans L N' r' x 0) (rtrans L N' r' x i'))
  ==>
     (!i j. 0 < i /\ i < k /\ j < k ==>
	(MEM (FST (ytrans L N r x j)) (core L (rtrans L N r x i))) /\
	MEM (FST (ztrans L N r x j)) (core L (rtrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM ( (ytrans L N r x j)) ( (rtrans L N r x i)) /\ MEM ((ztrans L N r x j)) ((rtrans L N r x i))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `i <= j:num` ASM_CASES_TAC;
    TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ARITH_TAC);
    TYPIFY `j = (j - i:num) + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    REWRITE_TAC[trans_add];
    REWRITE_TAC[Reduction2.trans0];
    TYPIFY `~(final_list L (rtrans L (ntrans L N r x i) (rtrans L N r x i) x (j-i)))` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[GSYM trans_add];
      MATCH_MP_TAC Kbwpbhq.transform_count_not;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Pnxvwfs.PNXVWFS2;Pnxvwfs.PNXVWFS1;Reduction2.transform_assumption_v2_lemma]);
  TYPIFY `j = 0 + j` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  TYPIFY `i = (i - j) + (j:num)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[trans_add];
  TYPIFY `~(final_list L (rtrans L (ntrans L N r x j) (rtrans L N r x j) x (i - j)))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM trans_add];
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `marked_list L (ntrans L N r x j) (rtrans L N r x j) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[ Pbflhet.properties_of_ytrans0;Reduction2.transform_assumption_v2_lemma]);
  (DISCH_TAC);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  INTRO_TAC lnrx_induction [`j`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[core_split_normal_list_assumption_lemma;r_trans_eq_assumption_lemma];
  DISCH_THEN kill;
  nCONJ_TAC 2;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let l_expand = prove_by_refinement(
  `!L N r x i. l'y L (rtrans L N r x i) x = ytrans L N r x i /\
    l'z L (ntrans L N r x i) (rtrans L N r x i) x = ztrans L N r x i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY_GOAL_THEN `ytrans L N r x i = ytrans L N r x (0+i) /\ ztrans L N r x i = ztrans L N r x (0+i)` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[arith `0+i=i`]);
  BY(REWRITE_TAC[trans_add;Reduction2.trans0])
  ]);;
  (* }}} *)

let final_assumption_newvertex_prepped = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
    element_pre L N /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)
  ==>
    (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
       (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) = 
	 MAP FST (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `iota1 = iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) `;
  INTRO_TAC Reduction2.rtrans_diff_r [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_REWRITE_TAC[trans_add;l_expand];
  REWRITE_TAC[GSYM trans_add];
  SUBANTS_TAC;
    CONJ_TAC;
      MATCH_MP_TAC AQIUNPP;
      BY(ASM_REWRITE_TAC[]);
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (ASSUME_TAC o GSYM) THEN ASM_REWRITE_TAC[];
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x`;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  INTRO_TAC Reduction2.face_diff_r [`L`;`fw`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`w`];
  ASM_REWRITE_TAC[GSYM trans_add];
  INTRO_TAC r_trans_eq_assumption [`L`];
  REWRITE_TAC[r_trans_eq_assumption_lemma];
  DISCH_THEN (C INTRO_TAC [`ntrans L N r x i`;`rtrans L N r x i`;`x`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i))) <= sizel (filter (\d. ~MEM d (rtrans L N r x i)) fw)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_cat;arith `i + j = k ==> i <= k:num`]);
  INTRO_TAC Seq.take_size_cat [`sizel (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))`;`(filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))`;`(filter (\d. ~MEM d (rtrans L N r x (1 + i))) fw)`];
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `cat` (SUBST1_TAC o GSYM);
  INTRO_TAC lnrx_induction [`i`;`L`;`N`;`r`;`x`];
  (ASM_REWRITE_TAC[]);
  REWRITE_TAC[r_trans_eq_assumption_lemma];
  REWRITE_TAC[core_split_normal_list_assumption_lemma];
  ASM_REWRITE_TAC[newvertex_prepped;LET_THM;Reduction2.newvertex_alt];
  INTRO_TAC Reduction2.newvertex_alt [`rtrans L N r x i`;`L`;`x`];
  ASM_SIMP_TAC[LET_THM];
  ANTS_TAC;
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[marked_list]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[final_assumption_mem_uniq]);
  SIMP_TAC[];
  DISCH_THEN kill;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP FST (take      (sizel      (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i))))      (filter (\d. ~MEM d (rtrans L N r x i)) fw)) = MAP FST (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[lower_case;Seq.map_take];
  ASM_REWRITE_TAC[Seq.map_MAP];
  DISCH_THEN (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `MAP` (SUBST1_TAC);
  GMATCH_SIMP_TAC Reduction2.take_iota;
  ASM_REWRITE_TAC[lower_case;Seq.size_map];
  BY(ASM_MESON_TAC[lower_case])
  ]);;
  (* }}} *)

(* ********************************************************************** *)
(* // SPLIT_NORMAL_LIST *)
(* ********************************************************************** *)

let size_replace1 = prove_by_refinement(
  `!s x y. sizel (replace x [y] s) = sizel s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;lower_case;Seq.size_cons];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC;
    REWRITE_TAC[Seq.size_cat;Seq.size_cons;Seq.size_nil];
    BY(ARITH_TAC);
  BY(ASM_REWRITE_TAC[Seq.size_cons;Seq.size_cat])
  ]);;
  (* }}} *)

let split_normal_list_index1_lemma = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	   (MEM (core L f1) (quotient_list L N) ==> (core L f1 = core L r)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  DISCH_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `find_face L (l'y L r x) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `~(quotient_list L (ntrans L N r x 1) = []) /\ ~(ntrans L N r x 1 = []) /\ LAST (quotient_list L (ntrans L N r x 1)) = (core L f1) /\ sizel (quotient_list L (ntrans L N r x 1)) = SUC (sizel (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[quotient_list_core;MAP_EQ_NIL];
    GMATCH_SIMP_TAC Tame_list.LAST_MAP;
    REWRITE_TAC[ntrans;Hypermap.POWER_1;transform_list];
    ASM_REWRITE_TAC[LET_THM;APPEND_EQ_NIL;NOT_CONS_NIL];
    BY(REWRITE_TAC[lower_case;Seq.cats1;LAST_rcons;Seq.size_map;Seq.size_rcons;size_replace1]);
  TYPED_ABBREV_TAC `n = sizel (quotient_list L N)`;
  TYPIFY `EL (n) (quotient_list L (ntrans L N r x 1)) = core L f1` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC LAST_EL [`(quotient_list L (ntrans L N r x 1))`];
    BY(ASM_SIMP_TAC[lower_case;arith `SUC n - 1 = n`]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (quotient_list L (ntrans L N r x 1))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  TYPIFY `uniq (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[quotient_list_core;MEM_MAP;NOT_EXISTS_THM];
  X_GENv_TAC "r'";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r=r')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`r'`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq9.element_in_ntrans_suc;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`f1`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r' = f1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REWRITE_TAC[normal_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC);
  POP_ASSUM MP_TAC;
  ASM_REWRITE_TAC[ntrans;transform_list;Hypermap.POWER_1;lower_case;LET_THM;Seq.cat_uniq];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ2_TAC THEN DISJ1_TAC;
  REWRITE_TAC[GSYM Seq.hasP];
  TYPIFY `r'` EXISTS_TAC;
  ASM_REWRITE_TAC[MEM];
  MATCH_MP_TAC Tame_list.MEM3_replace;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_normal_list_index2_lemma = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	   (MEM (core L f2) (quotient_list L N) ==> (core L f2 = core L r)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  DISCH_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `find_face L (l'y L r x) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (quotient_list L (ntrans L N r x 1))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  TYPIFY `uniq (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[quotient_list_core;MEM_MAP;NOT_EXISTS_THM];
  X_GENv_TAC "r'";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r=r')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`r'`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq9.element_in_ntrans_suc;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`f2`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC Aq8.snd_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY((ASM_SIMP_TAC[]));
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r' = f2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REWRITE_TAC[normal_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC);
  POP_ASSUM MP_TAC;
  REWRITE_TAC[];
  ASM_REWRITE_TAC[ntrans;transform_list;Hypermap.POWER_1;lower_case;LET_THM;Seq.cat_uniq];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ1_TAC;
  FULL_EXPAND_TAC "f2";
  MATCH_MP_TAC not_uniq_replace;
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let next_core_ne_FST = prove_by_refinement(
  `!L N r u v.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM u r /\
    uniq (core L r) /\
    ~(FST u = FST v) /\
    next_el r u = v 
    ==> next_el (core L r) (FST u) = (FST v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL More_lemma2.next_core_FST_SYM) [`L`;`N`;`r`;`u`];
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  INTRO_TAC Tame_list.loop_list_f_or_ni [`L`;`r`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[normal_list;Seq.allP]);
  FULL_EXPAND_TAC "v";
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `next_el r u` FULL_LEFT_EXPAND_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `FST` MP_TAC THEN REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM Tame_list.inverse_node_map_list);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`N`];
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  DISCH_TAC;
  INTRO_TAC (GSYM List_hypermap.fst_node_hypermap_of_list) [`L`;`u`];
  ASM_REWRITE_TAC[] THEN DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Hypermap.lemma_inverse_in_node;
  BY(REWRITE_TAC[Hypermap.node_refl])
  ]);;
  (* }}} *)

let final_assumption_split_normal_list = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) /\
    (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [] ==>
	 ~(next_el (core L (rtrans L N r x 0)) (FST (ytrans L N r x 0)) =
	      FST (ztrans L N r x 0))) /\
    (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [] ==> // new assumption
	 ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
	      FST (ytrans L N r x 0))) /\
    (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0))))
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `bet = betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)`;
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` ((C SUBGOAL_THEN ASSUME_TAC));
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `find_face L (ytrans L N r x 0) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `~(bet = [])` ASM_CASES_TAC;
    TYPIFY `?b. MEM b (MAP FST bet)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[List_hypermap.mem_not_nil;MAP_EQ_NIL]);
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC quotient_list_elements [`L`;`N`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    REWRITE_TAC[List_hypermap.elements_of_list;EXTENSION;IN_SET_OF_LIST;List_hypermap.list_of_elements;Seq2.mem_flatten;Seq.mem_undup];
    DISCH_THEN (C INTRO_TAC [`b`]);
    TYPIFY ` ~(MEM b (MAP FST (flatten N))) /\ MEM b (core L f1) /\ MEM b (core L f2)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    CONJ_TAC;
      FIRST_X_ASSUM_ST `DIFF` MP_TAC;
      REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;IN_DIFF];
      BY(ASM_MESON_TAC[]);
    INTRO_TAC core_split_normal_list_assumption_lemma [`L`];
    REWRITE_TAC[core_split_normal_list_assumption];
    DISCH_THEN (C INTRO_TAC [`N`;`r`;`x`]);
    ASM_REWRITE_TAC[core_split_normal_list];
    ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;l_expand];
    BY(ASM_SIMP_TAC[Seq.mem_cat;Seq.mem_rev]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
 
  COMMENT "bet = []";
  FIRST_X_ASSUM_ST `~` MP_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM f2 (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Aq8.snd_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  TYPIFY `MEM f1 (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  TYPIFY `uniq f2 /\ ~(f2 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq f1 /\ ~(f1 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  PROOF_BY_CONTR_TAC;
  INTRO_TAC split_normal_list [`L`;`r`;`(find_face L x)`;`ytrans L N r x 0`;`prev_el r (ztrans L N r x 0)`];
  ASM_REWRITE_TAC[LET_THM;lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `MEM r N /\ uniq r /\ ~(r  = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0;Seq.map;rev0;Seq.cat0s];
  ONCE_REWRITE_TAC[PAIR_EQ2];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM (core L f)` MP_TAC;
  REWRITE_TAC[];
  COMMENT "MEM z r";
  TYPIFY `MEM (ztrans L N r x 0) (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `1 = SUC 0`] THEN MATCH_MP_TAC (GEN_ALL Pbflhet.ztrans_in_suc);
    GEXISTL_TAC [`find_face L x`;`next_el (find_face L x) x`];
    ASM_SIMP_TAC[Reduction2.transform_assumption_v2_lemma];
    REWRITE_TAC[Reduction2.trans0];
    BY(ASM_REWRITE_TAC[]);
  COMMENT "F2 CASE";
  SUBCONJ2_TAC;
    DISCH_TAC;
    INTRO_TAC split_normal_list_index2_lemma [`L`;`N`;`r`;`x`;`k`];
    ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `next_el (core L r)` kill;
    FIRST_X_ASSUM_ST `next_el (core L r)` MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Reduction2.trans0];
    ASM_REWRITE_TAC[];
    TYPIFY `core L r` FULL_RIGHT_EXPAND_TAC;
    MATCH_MP_TAC next_core_ne_FST;
    TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC Reduction3.rtrans1 [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
    DISCH_TAC;
    SUBCONJ_TAC;
      FULL_EXPAND_TAC "f2";
      BY(ASM_MESON_TAC[Aq12.y_mem_split_snd]);
    DISCH_TAC;
    SUBCONJ_TAC;
      FULL_EXPAND_TAC "f2";
      INTRO_TAC Aq8.uniq_snd_split_normal_parts [`L`;`N`;`r`;`x`];
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    CONJ_TAC;
      INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
      BY(ASM_REWRITE_TAC[]);
    SIMP_TAC[];
    TYPIFY_GOAL_THEN `ytrans L N r x 0 = LAST f2  /\ ztrans L N r x 0 = HD f2` (unlist REWRITE_TAC);
      FIRST_ASSUM_ST `betwn` (SUBST1_TAC o GSYM);
      REWRITE_TAC[Seq.cat1s;HD];
      REWRITE_TAC[GSYM Seq.cat_cons];
      BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
    MATCH_MP_TAC Aq4.next_el_last_hd;
    FULL_EXPAND_TAC "f2";
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  DISCH_TAC;
  COMMENT "F1 CASE";
  INTRO_TAC split_normal_list_index1_lemma [`L`;`N`;`r`;`x`;`k`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `next_el (core L r)` MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Reduction2.trans0];
  ASM_REWRITE_TAC[];
  TYPIFY `core L r` FULL_RIGHT_EXPAND_TAC;
  COMMENT "new material";
  TYPIFY `FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq1.FST_EQ_PREV_ZTRANS_v0]);
  TYPIFY `FST (next_el r (ytrans L N r x 0)) = FST (ytrans L N r x 0)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC (GEN_ALL Hojodcm.FST_EQ_NEXT_YTRANS) [`ytrans L N r x 0`;`L`;`N`;`r`;`x`];
    DISCH_THEN GMATCH_SIMP_TAC;
    BY(ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  ASM_REWRITE_TAC[];
  TYPIFY `next_el (core L f1) (FST (prev_el r (ztrans L N r x 0))) = FST (next_el r (ytrans L N r x 0))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "old material";
  MATCH_MP_TAC next_core_ne_FST;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    INTRO_TAC Aq8.uniq_fst_split_normal_parts [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  nCONJ_TAC 2;
    INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FULL_EXPAND_TAC "f1";
    BY(REWRITE_TAC[Seq.mem_cat;MEM]);
  DISCH_TAC;
  TYPIFY_GOAL_THEN `prev_el r (ztrans L N r x 0) = LAST f1 /\ next_el r (ytrans L N r x 0) = HD f1` (unlist REWRITE_TAC);
    FULL_EXPAND_TAC "f1";
    REWRITE_TAC[Seq.cat1s;HD];
    REWRITE_TAC[GSYM Seq.cat_cons];
    BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
  MATCH_MP_TAC Aq4.next_el_last_hd;
  MATCH_MP_TAC normal_list_uniq_nonnil;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let reduction_K2 = prove_by_refinement(
  `(!L N r x k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\  // added July 13 2014
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     // END ASSUMPTIONS

     // (INDEX)
     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
     (!i. SUC i < k
      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\
     (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <=
	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=
         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
      (!i. SUC i < k ==>
	 (next_el (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x i)) =
		FST (ytrans L N r x (SUC i)) <=>
		  next_el (core L r) (FST (ztrans L N r x i)) = FST (ytrans L N r x (SUC i))) ) /\

     // (MISC) // new Jul 13 2014
    (!i. i < k     ==> MEM (ztrans L N r x 0) (rtrans L N r x i)) /\

     // (BETWN)
(~(FST(ztrans L N r x (PRE k)) = FST x) ==>  // added July 17 2014
	(betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))) /\
//     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
//	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
     (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i))) /\
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
	 ==> ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
             FST (ytrans L N r x 0))) /\

     // July 19 2014 corrected.
     (!i. SUC i < k /\  ~(FST (ztrans L N r x i) = FST (ytrans L N r x (SUC i))) ==>
	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
	    betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
	      (FST (ytrans L N r x (SUC i))))) /\

     // old19
//     (!i. SUC i < k ==> 
//	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
//	     betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
//	       (FST (ytrans L N r x (SUC i))))) /\

     // (UVNS)
      (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)) /\
		       
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 

   ) ==> assumption_setK10`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_K1;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`L`]) THEN ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `(!N' r' i'.              i' < transform_count L N' r' x /\              marked_list L N' r' x /\              newvertex_prepped L N' r' x /\              ~final_list L r' /\              element_pre L N'              ==> MEM (ztrans L N' r' x 0) (rtrans L N' r' x i'))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`N`;`r`;`x`;`k`]);
  ASM_SIMP_TAC[Seq.size_eq0];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `(0 < k)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  COMMENT "cases start here";
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.v_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf1_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC num_CASES [`i`];
    ASM_SIMP_TAC[arith `0 < i ==> ~(i=0)`];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[arith `PRE (SUC n) = n`];
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "i";
    BY(ASM_MESON_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  CONJ_TAC;  (*19*)
    REPEAT WEAKER_STRIP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    INTRO_TAC num_CASES [`i`];
    ASM_SIMP_TAC[arith `0 < i ==> ~(i=0)`];
    REPEAT WEAKER_STRIP_TAC;
    POP_ASSUM MP_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[arith `PRE (SUC n) = n`];
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "i";
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[CONJ_ASSOC];
  CONJ2_TAC;
    MATCH_MP_TAC final_assumption_split_normal_list;
    TYPIFY `k` EXISTS_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM CONJ_ASSOC];
  FIRST_X_ASSUM_ST `core_triple_v4` kill;
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_mem_x_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_zpre_core_k]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_mem_fst_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fsty_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fstz_core]);
  CONJ_TAC;
    MATCH_MP_TAC final_assumption_yz_in_core;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_z]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_y_neq_fst_z]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_y_ne_z;]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_size_find_face;]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_size_core]);
  MATCH_MP_TAC final_assumption_newvertex_prepped;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

(* ********************************************************************* *)
(* UVNS  *)
(* ********************************************************************* *)

let el_cat = prove_by_refinement(
  `!i a b. i < sizel (cat a b) ==> 
    EL i (cat a b) = if i < sizel a then EL i a else EL (i - sizel a) b`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.nth_cat [`HD a`;`a`;`b`;`i`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[GSYM Seq2.EL_nth]);
  TYPIFY `i - sizel a < sizel b` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat] THEN ARITH_TAC);
  BY(ASM_SIMP_TAC[GSYM Seq2.EL_nth])
  ]);;
  (* }}} *)

let el_cat_suc = prove_by_refinement(
  `!i a b. SUC i < sizel (cat a b)  ==>
    (?j. SUC j < sizel a /\ EL i (cat a b) = EL j a /\ EL (SUC i) (cat a b) = EL (SUC j) a) \/
    (?j. SUC j < sizel b /\ EL i (cat a b) = EL j b /\ EL (SUC i) (cat a b) = EL (SUC j) b) \/
    (~(a=[]) /\ ~(b=[]) /\ EL i (cat a b) = LAST a /\ EL (SUC i) (cat a b) = HD b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC i < sizel a` ASM_CASES_TAC;
    DISJ1_TAC;
    TYPIFY `i` EXISTS_TAC;
    BY(ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`]);
  DISJ2_TAC;
  TYPIFY `i < sizel ( a)` ASM_CASES_TAC;
    DISJ2_TAC;
    SUBCONJ_TAC;
      REWRITE_TAC[GSYM Seq.size_eq0];
      BY(ASM_TAC THEN ARITH_TAC);
    DISCH_TAC;
    SUBCONJ_TAC;
      BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat;GSYM Seq.size_eq0] THEN ARITH_TAC);
    DISCH_TAC;
    ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`];
    TYPIFY `SUC i - sizel a = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    ASM_SIMP_TAC[LAST_EL];
    ASM_SIMP_TAC[LAST_EL;GSYM Seq.size];
    TYPIFY `sizel a - 1 = i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(REWRITE_TAC[EL]);
  DISJ1_TAC;
  TYPIFY `i - sizel a` EXISTS_TAC;
  SUBCONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[Seq.size_cat] THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `i < sizel (cat a b)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_SIMP_TAC[ el_cat];
  TYPIFY_GOAL_THEN `SUC (i - sizel a) = SUC i - sizel a` (unlist REWRITE_TAC);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let EL_SUC_CONS = prove_by_refinement(
  `!i h t. EL (SUC i) (h::t) = EL i t`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[EL;TL]);
  ]);;
  (* }}} *)

let HD_flatten = prove_by_refinement(
  `!s. ~(s = []) /\ ~(HD s = []) ==> HD (flatten s ) = HD (HD s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.flatten_cons;HD;NOT_CONS_NIL];
  BY(SIMP_TAC[Tame_list.hd_cat])
  ]);;
  (* }}} *)

let el_flatten = prove_by_refinement(
  `!R i. SUC i < sizel (flatten R) /\ all (\r. ~(r = [])) R ==>
    (?r j. MEM r R /\ SUC j < sizel r /\ (EL i (flatten R) = EL j r) /\ 
       EL (SUC i) (flatten R) = EL (SUC j) r)  \/ 
    (?j. SUC j < sizel R /\ EL i (flatten R) = LAST (EL j R) /\ 
	EL (SUC i) (flatten R) = HD (EL (SUC j) R))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.size_nil;Seq.flatten0;MEM;arith `~(SUC i < 0)`];
  REWRITE_TAC[Seq.flatten_cons;Seq.all_cons;Seq.size_cons;TL];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC i < sizel h` ASM_CASES_TAC;
    DISJ1_TAC;
    GEXISTL_TAC [`h`;`i`];
    ASM_SIMP_TAC[];
    BY(ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`]);
  TYPIFY `i < sizel h` ASM_CASES_TAC;
    DISJ2_TAC;
    TYPIFY `0` EXISTS_TAC;
    REWRITE_TAC[arith `SUC i < SUC j <=> i < j`];
    SUBCONJ_TAC;
      REWRITE_TAC[arith `0 < n <=> ~(n=0)`;Seq.size_eq0];
      DISCH_TAC;
      BY(FIRST_X_ASSUM_ST `cat` MP_TAC THEN ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0] THEN ASM_TAC);
    DISCH_TAC;
    CONJ_TAC;
      ASM_SIMP_TAC[EL;el_cat;HD;arith `SUC i < n ==> i < n`];
      ASM_SIMP_TAC[ LAST_EL];
      REWRITE_TAC[lower_case];
      TYPIFY_GOAL_THEN `sizel h - 1 = i` (unlist REWRITE_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[EL_SUC_CONS];
    ASM_SIMP_TAC[el_cat];
    TYPIFY `SUC i - sizel h = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    REWRITE_TAC[EL];
    GMATCH_SIMP_TAC HD_flatten;
    CONJ_TAC;
      DISCH_TAC;
      BY(FIRST_X_ASSUM_ST `cat` MP_TAC THEN ASM_REWRITE_TAC[Seq.flatten0;Seq.cats0]);
    FIRST_X_ASSUM_ST `all` MP_TAC;
    REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    MATCH_MP_TAC MEM_HD;
    BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n ==> ~(n=0)`]);
  TYPIFY `?i'.  sizel h + i' = i` (C SUBGOAL_THEN MP_TAC);
    TYPIFY `i - sizel h` EXISTS_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "i";
  ASM_SIMP_TAC[el_cat;arith `SUC i < n ==> i < n`];
  REPLICATE_TAC 3 (POP_ASSUM kill);
  TYPIFY `(sizel h + i' ) - sizel h = i'` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  REWRITE_TAC[arith `SUC (sizel h + i') - sizel h = SUC i'`];
  REWRITE_TAC[EL_SUC_CONS];
  FIRST_X_ASSUM_ST `cat` MP_TAC THEN REWRITE_TAC[Seq.size_cat;arith `SUC (h + i') < h + t <=> SUC i' < t`];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`i'`]);
  ASM_REWRITE_TAC[];
  REPEAT STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  DISJ2_TAC;
  TYPIFY `SUC j` EXISTS_TAC THEN ASM_REWRITE_TAC[EL_SUC_CONS];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let scroll_flatten_map = prove_by_refinement(
  `!k i u (a:num->A).   
     ((a i) ::  flatten (MAP (\i. rcons (u i) (a (SUC i))) (iota (i) k))) = 
      rcons (flatten (MAP (\i. (a i) :: (u i)) (iota i k)))  (a (i+k))`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0;Seq.iota;MAP;Seq.rcons;arith `i+0=i`]);
  REWRITE_TAC[arith `SUC k = k + 1`;Seq.iota_add;Seq.map_cat;lower_case];
  TYPIFY_GOAL_THEN `!x. iota (x) 1 = [x]` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[Seq.iota;arith `1 = SUC 0`]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.cats1;Seq.flatten_cat;lower_case];
  ASM_SIMP_TAC[GSYM Seq.cat_cons;arith `i + 1 = SUC i`];
  DISCH_THEN kill;
  REWRITE_TAC[GSYM Seq.catA];
  AP_TERM_TAC;
  REWRITE_TAC[upper_case;MAP;Aq1.flatten_sing];
  BY(REWRITE_TAC[lower_case;CONS_11;Seq.catA;Seq.cat_cons;Seq.cat0s;arith `SUC (i+k) = SUC i + k /\ i + SUC k = SUC i + k `])
  ]);;
  (* }}} *)

let f_list_imp_last = prove_by_refinement(
  `!L r x.  
    good_list L /\
    MEM x (list_of_darts L) /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    uniq r /\ ~(r = []) /\
    MEM x r /\ next_el r x = f_list L x ==> MEM x (MAP LAST (parts L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "u");
  PROOF_BY_CONTR_TAC THEN RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM]);
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[NOT_FORALL_THM];
  INTRO_TAC parts_flatten [`L`;`r`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `MEM u (flatten (parts L r))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `l` EXISTS_TAC;
  ASM_REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `u` EXISTS_TAC;
  DISCH_THEN MP_TAC THEN ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`u`];
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.next_el_parts_unlast [`L`;`r`;`l`;`u`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let next_el_core_list_pairs = prove_by_refinement(
  `!L N r u1 v1.
    good_list L /\
    good_list_nodes L /\
    normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            MEM r N /\
            all uniq L /\
    uniq (core L r) /\
    MEM u1 (core L r) /\
    next_el (core L r) u1 = v1 ==>
    MEM (u1,v1) (list_pairs (core L r))
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC list_pairs_core;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  GMATCH_SIMP_TAC f_list_imp_last;
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.mem_core [`L`;`r`;`u1`] THEN ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `MEM u1 (MAP FST (flatten (parts L r)))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "u");
  TYPIFY `l` (RENAME_TAC "p");
  INTRO_TAC normal_list_parts_next_last [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  TYPIFY `FST u = FST (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (LAST p) r /\ MEM (LAST p) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_flatten;parts_flatten]);
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  TYPIFY `v1 = SND (LAST p)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[GSYM PAIR];
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC f_list_fst_snd [`L`;`LAST p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  INTRO_TAC More_lemma2.next_core_FST_SYM [`L`;`N`;`r`;`LAST p`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let flatten_filter = prove_by_refinement(
  `!s f. flatten (MAP (filter f) s) = filter f (flatten s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MAP_EQ_NIL;Seq.flatten0;Seq.filter;MAP];
  BY(ASM_REWRITE_TAC[Seq.flatten_cons;Seq.filter_cat])
  ]);;
  (* }}} *)

let filter_prebatch_batch = prove_by_refinement(
  `!f0 L N r x i. flatten(MAP (filter isSome) (prebatch f0 L N r x i)) = 
    filter (isSome) (batch0 f0 L N r x i)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM prebatch_batch;flatten_filter])
  ]);;
  (* }}} *)

let filter_nseq = prove_by_refinement(
  `!n f x. filter f (nseq n x) = if (f x) then nseq n x else []`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_REWRITE_TAC[nseq0;nseq_suc;Seq.filter_nil;Seq.filter_cons];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple0_prebatch = prove_by_refinement(
  `!L N r (x:A#A) i.
    dest_triple0 (core L r) [] (take i (core_triple_v4 L N r x)) = 
    flatten (prebatch (core L r) L N r x i)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[prebatch];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM Reduction3.dest_triple0_foldl_steps);
  BY(REWRITE_TAC[Seq.flatten0])
  ]);;
  (* }}} *)

let marked_list_uniq_core = prove_by_refinement(
  `!L N r x. 
    marked_list L N r x ==>
    uniq (core L r)`,
  (* {{{ proof *)
  [
    REWRITE_TAC[marked_list;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all uniq` MP_TAC;
  REWRITE_TAC[quotient_list_core;GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let initial_prebatch_explicit = prove_by_refinement(
  `!i L N r (x:A#A).
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\ 
     i < transform_count L N r x ==>    
     (let initial_seg =
         (if ftrans L N r x 0 = FST (ytrans L N r x 0)
          then []
          else SOME (SND x) ::
               MAP SOME (betwn (core L r) (ftrans L N r x 0) (FST (ytrans L N r x 0)))) in
     cat initial_seg (flatten (prebatch (core L r) L N r x (SUC i))) =  SOME (SND x) ::
     (flatten
     (MAP
      (\i. cat
           (if ftrans L N r x i = FST (ytrans L N r x i)
            then []
            else cat
                 (MAP SOME
                 (betwn (core L r) (ftrans L N r x i)
                 (FST (ytrans L N r x i))))
                 [SOME (FST (ytrans L N r x i))])
           (cat
            (nseq
             (sizel
             (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))
            NONE)
           [SOME (ftrans L N r x (SUC i))]))
     (iota 0 (SUC i)))))`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[prebatch1;Seq.flatten0;Seq.cats0];
    REWRITE_TAC[Seq.iota;MAP;Aq1.flatten_sing;ftrans;arith `~(SUC 0 = 0)`];
    REWRITE_TAC[arith `SUC 0 = 1`];
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC prebatch1;
    ASM_REWRITE_TAC[arith `0 < k <=> ~(k = 0)`];
    ASM_SIMP_TAC[Reduction3.transform_count_non0];
    REWRITE_TAC[LET_THM;arith `PRE 1 = 0`];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat0s;Seq.flatten_cat;Aq1.flatten_sing;Seq.cat_cons;CONS_11];
    REWRITE_TAC[GSYM Seq.catA];
    AP_TERM_TAC;
    BY(REWRITE_TAC[Seq.cat1s]);
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  GMATCH_SIMP_TAC prebatch_suc_explicit;
  ASM_REWRITE_TAC[arith `0 < SUC i`];
  CONJ_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[marked_list_uniq_core]);
    CONJ_TAC;
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `MEM (ytrans L N r x i') r` ENOUGH_TO_SHOW_TAC;
        BY(ASM_MESON_TAC[ final_assumption_mem_fst_core]);
      MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
      ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
      MATCH_MP_TAC Kbwpbhq.transform_count_not;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM (ztrans L N r x i') r` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[ final_assumption_mem_fst_core]);
    MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
    ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
    BY(ASM_SIMP_TAC[ Kbwpbhq.transform_count_not]);
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`]);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[arith `SUC i < k ==> i < k`];
  REWRITE_TAC[LET_THM];
  SIMP_TAC[Seq.flatten_cat;Seq.catA];
  DISCH_THEN kill;
  REWRITE_TAC[arith `SUC (SUC i) = SUC i +1`;Seq.iota_add];
  TYPIFY `iota (0 + SUC i) 1 = [SUC i]` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[arith `1 = SUC 0 `;Seq.iota;CONS_11];
    BY(ARITH_TAC);
  REWRITE_TAC[lower_case;Seq.map_cat;Seq.map_cons;Seq.map];
  REWRITE_TAC[Aq1.flatten_sing;Seq.cat_cons;CONS_11;Seq.flatten_cat;ftrans;arith `PRE(SUC n) = n`];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[arith `~(SUC (SUC i) = 0)`];
  BY(REWRITE_TAC[arith `~(SUC (SUC i) = 0)`;arith `~(SUC i = 0)`])
  ]);;
  (* }}} *)

let initial_prebatch_explicit_scroll = prove_by_refinement(
  `!i L N r (x:A#A). 
       good_list L /\
     good_list_nodes L /\
     marked_list L N r x /\
     ~final_list L r /\
     is_restricted (hypermap_of_list L) /\
     i < transform_count L N r x
     ==> (SOME (SND x) ::
          flatten
          (MAP
           (\i. cat
                (if ftrans L N r x i = FST (ytrans L N r x i)
                 then []
                 else cat
                      (MAP SOME
                      (betwn (core L r) (ftrans L N r x i)
                      (FST (ytrans L N r x i))))
                      [SOME (FST (ytrans L N r x i))])
                (cat
                 (nseq
                  (sizel
                  (betwn (find_face L x) (ytrans L N r x i)
                  (ztrans L N r x i)))
                 NONE)
                [SOME (ftrans L N r x (SUC i))]))
          (iota 0 (SUC i)))) =
         rcons
         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (SUC i))))
         (SOME (ftrans L N r x (SUC i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC scroll_flatten_map [`SUC i`;`0`;`\i. cat               (if ftrans L N r x i = FST (ytrans L N r (x:A#A) i)                then []                else cat                     (MAP SOME                     (betwn (core L r) (ftrans L N r x i)                     (FST (ytrans L N r x i))))                     [SOME (FST (ytrans L N r x i))])               (                (nseq                 (sizel                 (betwn (find_face L x) (ytrans L N r x i)                 (ztrans L N r x i)))                NONE)               )`;`\i. SOME (ftrans L N r (x:A#A) i)`];
  ASM_REWRITE_TAC[arith `0 + i = i`];
  DISCH_THEN (SUBST1_TAC o GSYM);
  REWRITE_TAC[ftrans;CONS_11];
  AP_TERM_TAC;
  REWRITE_TAC[Tame_list.map_id_eq];
  REWRITE_TAC[GSYM Seq.allP];
  BY(REWRITE_TAC[GSYM Seq.cats1;Seq.catA])
  ]);;
  (* }}} *)

let initial_prebatch_explicit2 = prove_by_refinement(
  `!i L N r (x:A#A).
     good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         is_restricted (hypermap_of_list L) /\ 
     i < transform_count L N r x ==>    
     (let initial_seg =
         (if ftrans L N r x 0 = FST (ytrans L N r x 0)
          then []
          else SOME (SND x) ::
               MAP SOME (betwn (core L r) (ftrans L N r x 0) (FST (ytrans L N r x 0)))) in
     cat initial_seg (flatten (prebatch (core L r) L N r x (SUC i))) =  
         rcons
         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (SUC i))))
         (SOME (ftrans L N r x (SUC i))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN LET_TAC;
  INTRO_TAC initial_prebatch_explicit [`i`;`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[LET_THM];
  SIMP_TAC[LET_THM];
  DISCH_THEN kill;
  MATCH_MP_TAC initial_prebatch_explicit_scroll;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let dest_triple_full_explicit = prove_by_refinement(
  `!L N r (x:A#A) k. 
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    transform_count L N r x = k /\
    (?w. prev_el (core L r) w,w = x) /\
    is_restricted (hypermap_of_list L)  ==>
      dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x) =
         cat (         (flatten
         (MAP
          (\i. SOME (ftrans L N r x i) ::
               cat
               (if ftrans L N r x i = FST (ytrans L N r x i)
                then []
                else cat
                     (MAP SOME
                     (betwn (core L r) (ftrans L N r x i)
                     (FST (ytrans L N r x i))))
                     [SOME (FST (ytrans L N r x i))])
               (
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               ))
         (iota 0 (k)))))  ((SOME (FST (ztrans L N r x (PRE k)))):: 
	   if FST (ztrans L N r x (PRE k)) = FST x then [] else
				 rcons (MAP SOME (betwn (core L r) (FST (ztrans L N r x (PRE k)) ) (FST x))) (SOME (FST x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[dest_triple_full;dest_triple0_prebatch];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  INTRO_TAC dest_triple0_prebatch [`L`;`N`;`r`;`x`;`k`];
  TYPIFY `take k (core_triple_v4 L N r x) = core_triple_v4 L N r x` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC Seq.take_oversize;
    BY(ASM_REWRITE_TAC[size_core_triple;arith `k <= k:num`]);
  SIMP_TAC[] THEN DISCH_THEN kill;
  TYPIFY `flatten [initial_seg; flatten (prebatch (core L r) L N r x k); final_seg] = cat (cat (initial_seg) (flatten (prebatch (core L r) L N r x (SUC (PRE k))))) final_seg` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[Seq.flatten_cons;Seq.catA;Seq.flatten0;Seq.cats0];
    BY(ASM_SIMP_TAC[arith `~(k=0) ==> SUC (PRE k) = k`]);
  INTRO_TAC initial_prebatch_explicit2 [`PRE k`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[arith `~(k=0) ==> PRE k < k`];
  LET_TAC;
  INTRO_TAC Reduction3.el_core_triple [`L`;`N`;`r`;`x`;`0`];
  ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`;EL;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `u` (FULL_LEFT_EXPAND_TAC);
  TYPIFY `initial_seg = initial_seg'` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "initial_seg";
    FULL_EXPAND_TAC "initial_seg'";
    BY(REWRITE_TAC[ftrans]);
  FULL_EXPAND_TAC "initial_seg'";
  FIRST_X_ASSUM_ST `rcons` SUBST1_TAC;
  ASM_SIMP_TAC[arith `~(k=0) ==> SUC (PRE k) = k`];
  REWRITE_TAC[GSYM Seq.cats1;GSYM Seq.catA];
  AP_TERM_TAC;
  REWRITE_TAC[Seq.cat1s;CONS_11];
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[ftrans]);
  FULL_EXPAND_TAC "final_seg";
  TYPIFY `v' = FST (ztrans L N r x (PRE k)) /\ u0 = FST x` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    BY(REWRITE_TAC[Seq.cats1]);
  (FULL_EXPAND_TAC "u0");
  CONJ2_TAC;
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[]);
  INTRO_TAC  last_core_triple [`L`;`N`;`r`;`x`;`PRE k`];
  BY(ASM_SIMP_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let COND_RAND2 = prove_by_refinement(
  `!f b x y. f (if b then x else y) = (if b then f x else f y)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let filter_isSome_map = prove_by_refinement(
  `!xs. filter isSome (MAP SOME xs) = (MAP SOME xs)`,
  (* {{{ proof *)
  [
      REWRITE_TAC[Seq.all_filterP;GSYM Seq.allP;Ssrbool.isSome;MEM_MAP];
  BY(MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

let filter_issome_dest_triple_full = prove_by_refinement(
  `!L N r (x:A#A) k.
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
         (?w. prev_el (core L r) w,w = x) /\
         is_restricted (hypermap_of_list L)
         ==> MAP the (filter isSome (dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x))) =
             cat
             (flatten
             (MAP
              (\i.  (ftrans L N r x i) ::
                   (if ftrans L N r x i = FST (ytrans L N r x i)
                    then []
                    else cat
                         (
                         (betwn (core L r) (ftrans L N r x i)
                         (FST (ytrans L N r x i))))
                         [ (FST (ytrans L N r x i))])
                   )
             (iota 0 k)))
             ( (FST (ztrans L N r x (PRE k))) ::
              (if FST (ztrans L N r x (PRE k)) = FST x
               then []
               else rcons
                    (
                    (betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))
                    ( (FST x))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dest_triple_full_explicit [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC COND_RAND2 [`filter (isSome: (A)option -> bool)`];
  SIMP_TAC[filter_isSome_map;Seq.filter_cat;Seq.filter_cons;Ssrbool.isSome;GSYM Seq.cats1;Seq.filter_nil;GSYM flatten_filter;GSYM MAP_o];
  DISCH_TAC;
  REWRITE_TAC[Seq.map_cat;lower_case;the_some;Seq.map];
  REWRITE_TAC[Seq.map_MAP;Tame_list.MAP_flatten];
  MATCH_MP_TAC Reduction2.cat_eq;
  REWRITE_TAC[CONS_11];
  INTRO_TAC COND_RAND2 [`(MAP the): ((A)option)list -> (A)list`];
  SIMP_TAC[MAP];
  DISCH_TAC;
  CONJ2_TAC;
    AP_TERM_TAC;
    REWRITE_TAC[lower_case;Seq.map_cat;Seq.map;the_some];
    REWRITE_TAC[Seq.map_MAP;GSYM MAP_o];
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    MATCH_MP_TAC MAP_EQ_DEGEN;
    REWRITE_TAC[the_some;o_THM];
    BY(REWRITE_TAC[lower_case;GSYM Seq.allP]);
  AP_TERM_TAC;
  REWRITE_TAC[GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[o_THM;Seq.filter_cat;Seq.filter_cons;Ssrbool.isSome;MAP;the_some;CONS_11;Seq.filter_nil];
  ASM_SIMP_TAC[lower_case;Seq.map_cat];
  ASM_SIMP_TAC[Seq.map_MAP;MAP;ftrans];
  REWRITE_TAC[filter_nseq;Ssrbool.isSome;MAP;Seq.cats0];
  AP_TERM_TAC;
  REWRITE_TAC[lower_case;Seq.map_cat];
  REWRITE_TAC[lower_case;Seq.map_cat;Seq.map;the_some];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  TYPED_ABBREV_TAC `b = (betwn (core L r) (if x' = 0 then SND x else FST (ztrans L N r x (PRE x'))) (FST (ytrans L N r x x')))`;
  REWRITE_TAC[filter_isSome_map;Seq.map_MAP;GSYM MAP_o];
  MATCH_MP_TAC MAP_EQ_DEGEN;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP];
  BY(REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP;o_THM;the_some])
  ]);;
  (* }}} *)

let uniq_el = prove_by_refinement(
  `!i j s. uniq s /\ i < sizel s /\ j < sizel s /\ ~(i = j) ==> ~(EL i s = EL j s)`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.nth_uniq;Seq2.EL_nth])
  ]);;
  (* }}} *)

let indexf_subseg = prove_by_refinement(
  `!v s t a b i.  s = cat (cat a t) b /\  (MEM v t ==> v = EL 0 t) /\ 
    uniq s /\ MEM v s /\
    SUC i < sizel t ==> SUC (indexf v (EL i t) s) = indexf v (EL (SUC i) t) s
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexf v (EL i t) s + indexf (EL i t) (EL (SUC i) t) s = indexf v (EL (SUC i) t) s /\ indexf (EL i t) (EL (SUC i) t) s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  TYPIFY `i < sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM (EL i t) t /\ MEM (EL (SUC i) t) t` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT (GMATCH_SIMP_TAC mem_el_index);
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ2_TAC;
    MATCH_MP_TAC Tame_list.next_el_indexf;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 3;
      REWRITE_TAC[Seq.size_cat];
      BY(ASM_TAC THEN ARITH_TAC);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC next_el_cat1;
    GMATCH_SIMP_TAC next_el_cat2;
    GMATCH_SIMP_TAC next_el_el;
    GMATCH_SIMP_TAC last_cat;
    GMATCH_SIMP_TAC LAST_EL THEN REWRITE_TAC[lower_case;GSYM Seq.size_eq0];
    ASM_REWRITE_TAC[Seq.mem_cat];
    GMATCH_SIMP_TAC uniq_el;
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN ASM_REWRITE_TAC[Seq.cat_uniq];
    ASM_SIMP_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  MATCH_MP_TAC Tame_list.indexf_add_right;
  ASM_SIMP_TAC[arith `1 <= n <=> ~(n=0)`];
  INTRO_TAC Tame_list.indexf0 [`v`;`EL (SUC i) t`;`s`];
  ASM_SIMP_TAC[Seq.mem_cat];
  REPEAT (GMATCH_SIMP_TAC mem_el_index);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  BY(ASM_MESON_TAC[arith `~(0 = SUC i)`;uniq_el;arith `i < n ==> 0 < n`])
  ]);;
  (* }}} *)

let indexf_subseg_rot = prove_by_refinement(
  `!v s n t a b i.  rot n s = cat (cat a t) b /\  (MEM v t ==> v = EL 0 t) /\ 
    uniq s /\ MEM v s /\
    SUC i < sizel t ==> SUC (indexf v (EL i t) s) = indexf v (EL (SUC i) t) s
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_subseg [`v`;`rot n s`;`t`;`a`;`b`;`i`];
  REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT (GMATCH_SIMP_TAC (GSYM Reduction2.indexf_rotn_alt));
  ASM_SIMP_TAC[];
  TYPIFY `?n'. s = rot n' (cat (cat a t) b)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[ Tame_list.rot_sym]);
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[Seq.mem_cat;Seq.mem_rot];
  REPEAT (GMATCH_SIMP_TAC mem_el_index);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let uniq_tl = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> uniq (TL s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC CONS_HD_TL [`s`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  TYPIFY `uniq (cat [HD s] (TL s))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.cat1s]);
  BY(MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let post_betwn = prove_by_refinement(
  `!x y s. HD s = x /\ MEM y s /\ ~(x = y) /\ uniq s ==>
    (?post. s = x:: cat (rcons (betwn s x y) y) post)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn];
  REPEAT WEAKER_STRIP_TAC THEN REPEAT LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  ASM_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(s=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  TYPIFY `MEM x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_HD]);
  INTRO_TAC (GEN_ALL Pwssrat.take_index_fst_split) [`x`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `indexl x s = 0` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[Pplhulj.indexl_hd]);
  ASM_REWRITE_TAC[Seq.take];
  DISCH_TAC THEN FULL_EXPAND_TAC "pre1";
  INTRO_TAC (GEN_ALL Pwssrat.dropl_index_snd_split) [`x`;`s`];
  ASM_REWRITE_TAC[Seq.drop];
  DISCH_TAC THEN FULL_EXPAND_TAC "post1";
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  INTRO_TAC tl_drop [`s`] THEN ASM_SIMP_TAC[];
  DISCH_TAC THEN TYPIFY `dropl 1 s` FULL_RIGHT_EXPAND_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC (GEN_ALL Pwssrat.take_index_fst_split) [`y`;`TL s`];
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[uniq_tl];
    DISCH_THEN (SUBST1_TAC o GSYM);
    TYPIFY `dropl (1+indexl y (TL s)) ((TL s))` EXISTS_TAC;
    REWRITE_TAC[GSYM Seq.cats1;GSYM Seq.catA];
    TYPIFY `TL s = cat (take (indexl y (TL s)) (TL s))  (cat [y] (dropl (1 + indexl y (TL s)) (TL s)))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[CONS_HD_TL]);
    REWRITE_TAC[Seq.catA];
    TYPIFY `(cat (take (indexl y (TL s)) (TL s)) [y]) = take (1 + indexl y (TL s)) (TL s)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[Seq.cat_take_drop]);
    REWRITE_TAC[arith `1 + n = SUC n`];
    GMATCH_SIMP_TAC Reduction3.take_el;
    REWRITE_TAC[GSYM Seq.cats1];
    SUBCONJ_TAC;
      REWRITE_TAC[Seq.index_mem];
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    AP_TERM_TAC;
    REWRITE_TAC[CONS_11];
    BY(ASM_SIMP_TAC[Seq2.EL_index]);
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[];
  BY(ASM_MESON_TAC[CONS_HD_TL;MEM])
  ]);;
  (* }}} *)

let indexf_ifbetwn = prove_by_refinement(
  `!s v (x:A) y i. MEM v s /\ MEM x s /\ MEM y s /\ uniq s /\ ~(MEM v (ifbetwn s x y)) /\
    SUC i < sizel (x:: ifbetwn s x y) ==>
    SUC (indexf v (EL i (x :: ifbetwn s x y)) s) = indexf v (EL (SUC i) (x::ifbetwn s x y)) s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexf_subseg_rot;
  TYPIFY `indexl x s` EXISTS_TAC;
  INTRO_TAC (GSYM Pwssrat.rotate_rot_indexl) [`x`;`s`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    ASM_REWRITE_TAC[ifbetwn;MEM;EL;HD];
    GEXISTL_TAC [`[]:(A)list`;`TL (rotate_to s y)`];
    REWRITE_TAC[Seq.cat0s;Seq.cat1s];
    TYPIFY `~(rotate_to s y = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[rot_eq_nil;List_hypermap.mem_not_nil]);
    BY(ASM_MESON_TAC[CONS_HD_TL;Tame_list.hd_rotate_to]);
  INTRO_TAC post_betwn [`x`;`y`;`rotate_to s x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[Tame_list.hd_rotate_to];
    BY(ASM_MESON_TAC[Seq.mem_rot;Seq.rot_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[MEM;EL;HD];
  ASM_REWRITE_TAC[ifbetwn];
  TYPIFY `[]:(A)list` EXISTS_TAC;
  REWRITE_TAC[Seq.cat0s];
  REWRITE_TAC[Seq.cat0s;Seq.cat_cons];
  TYPIFY `betwn (rotate_to s x) x y = betwn s x y` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Seq.index_size;Reduction2.betwn_rot])
  ]);;
  (* }}} *)

let mem_ftrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i <= transform_count L N r x ==>
    MEM ( (ftrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[ftrans];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC (GSYM More_lemma2.FST_next_face_eq_SND);
    TYPIFY `L` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC mem_fst_core;
    GEXISTL_TAC [`N`;`x`];
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Aq1.next_mark_mem_r_trans_v0]);
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_snd_x_core = prove_by_refinement(
  `!L N r x.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r  ==>
    MEM (SND x) (core L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC mem_ftrans_core [`L`;`N`;`r`;`x`;`0`];
  REWRITE_TAC[ftrans;arith `0 < k <=> ~(k=0)`];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_fst_x_core = prove_by_refinement(
  `!L N r x.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r  ==>
    MEM ( (FST x )) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let mem_fst_ytrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i < transform_count L N r x ==>
    MEM (FST (ytrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_fst_ztrans_core = prove_by_refinement(
  `!L N r x i.
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
     i < transform_count L N r x ==>
    MEM (FST (ztrans L N r x i)) (core L r)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC mem_fst_core;
  GEXISTL_TAC [`N`;`x`];
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let marked_x_exists = prove_by_refinement(
  `!L N r (x:A#A).   
    good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r ==>
  (?w. prev_el (core L r) w,w = x)
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SND x` EXISTS_TAC;
  REWRITE_TAC[PAIR_EQ2];
  GMATCH_SIMP_TAC (GSYM More_lemma2.FST_next_face_eq_SND);
  BY(ASM_MESON_TAC[More_lemma2.prev_core_x])
  ]);;
  (* }}} *)

let filter_issome_dest_triple_full_alt = prove_by_refinement(
  `!L N r (x:A#A) k.
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
         is_restricted (hypermap_of_list L)
         ==> MAP the (filter isSome (dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x))) =
             cat
             (flatten
             (MAP
              (\i.  (ftrans L N r x i) :: ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))
             (iota 0 k)))
             ( (FST (ztrans L N r x (PRE k))) :: ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC filter_issome_dest_triple_full [`L`;`N`;`r`;`x`;`k`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_x_exists]);
  SIMP_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC Reduction2.cat_eq;
  INTRO_TAC mem_ftrans_core [`L`;`N`;`r`;`x`];
  INTRO_TAC mem_fst_ytrans_core [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!i. i < k ==> MEM (ftrans L N r x i) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `i < k ==> i <= k:num`]);
  CONJ_TAC;
    AP_TERM_TAC;
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[Seq2.ALL_all];
    REWRITE_TAC[GSYM Seq.allP] THEN REWRITE_TAC[Seq.mem_iota;CONS_11;arith `0 + k = k`] THEN REPEAT WEAKER_STRIP_TAC;
    ASM_SIMP_TAC[];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cats1]);
  REWRITE_TAC[CONS_11];
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `MEM (FST (ztrans L N r x (PRE k))) (core L r) /\     MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC) THEN ASM_REWRITE_TAC[];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[mem_fst_x_core]);
    BY(ASM_MESON_TAC[mem_fst_ztrans_core;arith `~(k=0) ==> PRE k < k`]);
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let last_ifbetwn = prove_by_refinement(
  `!s x y. MEM y s /\ MEM x s ==> LAST (x:: ifbetwn s x y) = y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[ifbetwn];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[LAST;rcons_nonnil;LAST_rcons]);
  REWRITE_TAC[LAST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_assumption_uvns_vs'  = prove_by_refinement(
  `!L N r x k v.
     is_restricted (hypermap_of_list L) /\
         good_list L /\
         good_list_nodes L /\
         marked_list L N r x /\
         ~final_list L r /\
         transform_count L N r x = k /\
    ~(MEM (SND x) ((ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))) /\
// test July 22 2014
    (!i. i < k /\ 1 < sizel (ftrans L N r x i :: ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))) ==> // new
       ~MEM (SND x) (ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))) /\
    (!i. i < k ==>  // new
       indexf (SND x) (FST (ytrans L N r x i)) (core L r) < 
       indexf (SND x) (FST (ztrans L N r x i)) (core L r)) /\
	  (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r))
		`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  TYPED_ABBREV_TAC `mtf = (MAP the     (filter isSome (dest_triple_full (core L r) v (core_triple_v4 L N r x))))`;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM filter_issome_dest_triple_full_alt) [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  TYPIFY `SND x = v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[ marked_x_exists ;PAIR;FST;SND]);
  ASM_SIMP_TAC[];
  FIRST_X_ASSUM_ST `dest_triple_full` kill;
  DISCH_TAC;
  COMMENT "mem";
  TYPIFY `MEM v (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_snd_x_core]);
  TYPIFY `(!i. i <= k ==> MEM (ftrans L N r x i) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_ftrans_core]);
  TYPIFY `(!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_ytrans_core]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_x_core]);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `PRE k < k` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  INTRO_TAC el_cat_suc [`i`;`(flatten      (MAP       (\i. ftrans L N r x i ::            ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))      (iota 0 k)))`;`(FST (ztrans L N r x (PRE k)) ::       ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))`];
  ASM_SIMP_TAC[NOT_CONS_NIL];
  DISCH_THEN DISJ_CASES_TAC;
    POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    INTRO_TAC el_flatten [`(MAP  (\i. ftrans L N r x i ::       ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))) (iota 0 k))`;`j`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      REWRITE_TAC[GSYM Seq.allP;MEM_MAP];
      REPEAT WEAKER_STRIP_TAC;
      BY(FIRST_X_ASSUM_ST `ftrans` (MP_TAC o GSYM) THEN ASM_REWRITE_TAC[NOT_CONS_NIL]);
    DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
      MATCH_MP_TAC (arith `SUC i = j ==> i < j`);
      FIRST_X_ASSUM_ST `MEM` (MP_TAC o REWRITE_RULE[Seq.mem_iota;MEM_MAP;arith `0 + k = k`;arith `0 <= i`]);
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `r'` FULL_LEFT_EXPAND_TAC;
      MATCH_MP_TAC indexf_ifbetwn;
      ASM_SIMP_TAC[];
      CONJ_TAC;
        BY(ASM_MESON_TAC[arith `i < j ==> i <= j:num`]);
      BY(ASM_MESON_TAC[arith `SUC j < n ==> 1 < n`]);
    REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_REWRITE_TAC[lower_case;Seq.size_iota];
    REPEAT (GMATCH_SIMP_TAC Tame_list.el_iota);
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC last_ifbetwn;
    REWRITE_TAC[arith `0 + j = j`];
    TYPIFY `SUC j' < k /\ j' < k` (C SUBGOAL_THEN ASSUME_TAC);
      FIRST_X_ASSUM_ST `SUC j' < l` MP_TAC THEN REWRITE_TAC[Seq.size_map;Seq.size_iota;lower_case];
      BY(ARITH_TAC);
    ASM_SIMP_TAC[arith `SUC j' < k ==> j' <= k`];
    ASM_SIMP_TAC[ftrans;arith `~(SUC j = 0) /\ PRE (SUC j) = j`];
    BY(ASM_MESON_TAC[]);
  COMMENT "next case";
  POP_ASSUM (DISJ_CASES_TAC) THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    MATCH_MP_TAC (arith `SUC i = j ==> i < j`);
    MATCH_MP_TAC indexf_ifbetwn;
    ASM_SIMP_TAC[];
    CONJ2_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM_ST `ftrans` (C INTRO_TAC [`k`]) THEN REWRITE_TAC[ftrans];
    BY(ASM_SIMP_TAC[arith `k <= k:num`]);
  COMMENT "last case";
  GMATCH_SIMP_TAC Aq23.LAST_FLATTEN_2;
  REWRITE_TAC[MAP_EQ_NIL;HD];
  GMATCH_SIMP_TAC LAST_EL;
  REWRITE_TAC[MAP_EQ_NIL;GSYM Seq.size;REWRITE_RULE[Seq.map_MAP] Seq.size_map;Seq.size_iota];
  REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN REWRITE_TAC[GSYM Seq.size;Seq.size_iota];
  GMATCH_SIMP_TAC last_ifbetwn;
  REWRITE_TAC[NOT_CONS_NIL];
  REPEAT (GMATCH_SIMP_TAC el_iota);
  REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota];
  ASM_SIMP_TAC[arith `~(k=0) ==> k - 1 < k`;arith `~(k=0) ==> 0 + k - 1 = PRE k`;arith `PRE k <= k`];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let dest_triple_full_ifbetwn = prove_by_refinement(
  `!L N r (x:A#A) k. 
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    transform_count L N r x = k /\
    (?w. prev_el (core L r) w,w = x) /\
    is_restricted (hypermap_of_list L)  ==>
      dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x) =
         cat (         (flatten
         (MAP
          (\i. cat (MAP SOME ( (ftrans L N r x i) ::
	ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))))
                (nseq
                 (sizel
                 (betwn (find_face L x) (ytrans L N r x i)
                 (ztrans L N r x i)))
                NONE)
               )
         (iota 0 (k))))) (MAP SOME ( (ftrans L N r x k):: 
	 (ifbetwn (core L r) (ftrans L N r x k) (FST x))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dest_triple_full_explicit [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  MATCH_MP_TAC Reduction2.cat_eq;
  TYPIFY `(!i. i <= k ==> MEM (ftrans L N r x i) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_ftrans_core]);
  TYPIFY `(!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_ytrans_core]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_x_core]);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  CONJ2_TAC;
    REWRITE_TAC[MAP;CONS_11];
    ASM_SIMP_TAC[ifbetwn;arith `k<=k:num`];
    TYPIFY `FST (ztrans L N r x (PRE k)) = ftrans L N r x k` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[ftrans]);
    REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[MAP];
    BY(REWRITE_TAC[lower_case;GSYM Seq.cats1;Seq.map_cat;Seq.map]);
  AP_TERM_TAC;
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP;Seq.mem_iota;arith `0 <= x`;arith `0+k=k`;CONS_11;MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[ifbetwn;arith `i < k ==> i <= k`];
  REWRITE_TAC[CONS_11;Seq.cat_cons];
  MATCH_MP_TAC Reduction2.cat_eq THEN REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MAP];
  ASM_SIMP_TAC[arith `i < k ==> i <= k:num`];
  BY(REWRITE_TAC[GSYM Seq.cats1;lower_case;Seq.map_cat;Seq.map])
  ]);;
  (* }}} *)

let next_el_subseg = prove_by_refinement(
  `!s t (b:(A)list) i.  s = cat t b /\  
    uniq t /\ 
    SUC i < sizel t ==> next_el s (EL i t) = EL (SUC i) t
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `EL (SUC i) t = next_el t (EL i t) ` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC (GSYM Aq12.next_el_EL);
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC next_el_cat1;
  GMATCH_SIMP_TAC mem_el_index;
  GMATCH_SIMP_TAC LAST_EL THEN ASM_SIMP_TAC[GSYM Seq.size_eq0;lower_case];
  GMATCH_SIMP_TAC uniq_el;
  ASM_SIMP_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let next_el_suc = prove_by_refinement(
  ` !s n t b i.  rot n s = cat ( t) b /\ 
    uniq s /\ 
    SUC i < sizel t ==> next_el s (EL i t) = EL (SUC i) t
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_el_subseg [`rot n s`;`t`;`b`;`i`];
  REWRITE_TAC[Seq.rot_uniq;Seq.mem_rot];
  SUBANTS_TAC;
    BY(ASM_MESON_TAC[Seq.cat_uniq;Seq.rot_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (SUBST1_TAC o GSYM);
  BY(ASM_SIMP_TAC[Seq2.next_el_rot_eq])
  ]);;
  (* }}} *)

let next_el_ifbetwn = prove_by_refinement(
  `!s (x:A) y i.  MEM x s /\ MEM y s /\ uniq s /\ 
    SUC i < sizel (x:: ifbetwn s x y) ==>
    (next_el s  (EL i (x :: ifbetwn s x y)) = 
	(EL (SUC i) (x::ifbetwn s x y)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC next_el_suc;
  TYPIFY `indexl x s` EXISTS_TAC;
  INTRO_TAC (GSYM Pwssrat.rotate_rot_indexl) [`x`;`s`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    ASM_REWRITE_TAC[ifbetwn;MEM;EL;HD];
    GEXISTL_TAC [`TL (rotate_to s y)`];
    REWRITE_TAC[Seq.cat0s;Seq.cat1s];
    TYPIFY `~(rotate_to s y = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[rot_eq_nil;List_hypermap.mem_not_nil]);
    BY(ASM_MESON_TAC[CONS_HD_TL;Tame_list.hd_rotate_to]);
  INTRO_TAC post_betwn [`x`;`y`;`rotate_to s x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[Tame_list.hd_rotate_to];
    BY(ASM_MESON_TAC[Seq.mem_rot;Seq.rot_uniq]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[MEM;EL;HD];
  ASM_REWRITE_TAC[ifbetwn];
  TYPIFY `post` EXISTS_TAC;
  REWRITE_TAC[Seq.cat0s];
  POP_ASSUM (SUBST1_TAC);
  REWRITE_TAC[Seq.cat0s;Seq.cat_cons;CONS_11];
  TYPIFY `betwn (rotate_to s x) x y = betwn s x y` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[Seq.index_size;Reduction2.betwn_rot])
  ]);;
  (* }}} *)

let mem_ifbetwn = prove_by_refinement(
  `!x y s u. MEM u (ifbetwn s x y) ==> MEM u s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn];
  REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat;MEM];
    BY(ASM_MESON_TAC[betwn_mem]);
  BY(REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let uvns_mem_core = prove_by_refinement(
  `!L N r (x:num#num) k i. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)  ==>
    (let dtf = dest_triple_full (core L r) (SND x) (core_triple_v4 L N r x) in
        i < sizel dtf /\  isSome (EL i dtf) ==> 
	  MEM (the (EL i dtf)) (core L r) )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (the (EL i dtf)) (MAP the (filter isSome dtf))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC MEMf_MAP;
    REWRITE_TAC[Seq.mem_filter];
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[mem_el_index]);
  INTRO_TAC filter_issome_dest_triple_full_alt [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPED_ABBREV_TAC `u = the (EL i dtf)`;
  FIRST_X_ASSUM_ST `MEM` MP_TAC THEN ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `MAP` kill;
  TYPIFY `?v. (prev_el (core L r) v,v = x)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_x_exists]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC;
  TYPIFY `SND x = v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_x_exists ;PAIR;FST;SND]);
  COMMENT "mem";
  TYPIFY `MEM v (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_snd_x_core]);
  TYPIFY `(!i. i <= k ==> MEM (ftrans L N r x i) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_ftrans_core]);
  TYPIFY `(!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_ytrans_core]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_x_core]);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `PRE k < k` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.mem_cat];
  DISCH_THEN DISJ_CASES_TAC;
    POP_ASSUM MP_TAC THEN REWRITE_TAC[Seq2.mem_flatten];
    REWRITE_TAC[MEM_MAP;Seq.mem_iota;arith `0<= i /\ 0 + i = i`];
    REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[MEM];
    DISCH_THEN DISJ_CASES_TAC THEN ASM_SIMP_TAC[arith `i < k ==> i <= k:num`];
    MATCH_MP_TAC mem_ifbetwn;
    BY(ASM_MESON_TAC[]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[MEM];
  DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[];
    TYPIFY `FST (ztrans L N r x (PRE k)) = ftrans L N r x k` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_SIMP_TAC[ftrans;arith `k<=k:num`]);
    DISCH_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[mem_ifbetwn])
  ]);;
  (* }}} *)

let el_cat_nseq_none = prove_by_refinement(
  `!i (a:(A option)list) n. 
    SUC i < sizel (cat a (nseq n NONE)) /\ isSome (EL i (cat a (nseq n NONE))) /\
    isSome (EL (SUC i) (cat a (nseq n NONE)))
  ==> (?j. SUC j < sizel a /\
                  EL i (cat a (nseq n NONE)) = EL j a /\
                  EL (SUC i) (cat a (nseq n NONE)) = EL (SUC j) a)    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC el_cat_suc [`i`;`a`;`nseq n (NONE:(A)option)`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  PROOF_BY_CONTR_TAC;
  POP_ASSUM kill;
  POP_ASSUM MP_TAC THEN REWRITE_TAC[NOT_EXISTS_THM;DE_MORGAN_THM];
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    TYPIFY `SUC j < sizel (nseq n (NONE:(A)option))` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC Reduction3.el_nseq);
    BY(ASM_MESON_TAC[Ssrbool.isSome;Seq.size_nseq;arith `SUC j < n ==> j < n`]);
  TYPIFY `a = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `nseq n (NONE:(A)option) = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  DISJ2_TAC;
  REWRITE_TAC[GSYM EL];
  GMATCH_SIMP_TAC Reduction3.el_nseq;
  BY(ASM_MESON_TAC[arith `~(n=0) ==> 0 < n`;Ssrbool.isSome;Seq.size_eq0;Seq.size_nseq])
  ]);;
  (* }}} *)

let el_cat_nseq_the_none = prove_by_refinement(
  `!i (a:(A option)list) n. 
    SUC i < sizel (cat a (nseq n NONE)) /\ isSome (EL i (cat a (nseq n NONE))) /\
    isSome (EL (SUC i) (cat a (nseq n NONE)))
  ==> (?j. SUC j < sizel a /\
                  the (EL i (cat a (nseq n NONE))) = EL j (MAP the a) /\
                  the (EL (SUC i) (cat a (nseq n NONE))) = EL (SUC j) (MAP the a))    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC el_cat_nseq_none [`i`;`a`;`n`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `j` EXISTS_TAC THEN ASM_SIMP_TAC[];
  BY(REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_SIMP_TAC[GSYM Seq.size;arith `SUC j < n ==> j < n`])
  ]);;
  (* }}} *)

let nseq_eq_nil = prove_by_refinement(
  `!n x. nseq n x = [] <=> (n=0)`,
  (* {{{ proof *)
  [
    BY(INDUCT_TAC THEN REWRITE_TAC[nseq0;nseq_suc;NOT_CONS_NIL;arith `~(SUC n = 0)`])
  ]);;
  (* }}} *)

let last_nseq = prove_by_refinement(
  `!n x. ~(n=0) ==> LAST (nseq n x) = x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC LAST_EL;
  ASM_REWRITE_TAC[nseq_eq_nil;lower_case];
  GMATCH_SIMP_TAC el_nseq;
  REWRITE_TAC[Seq.size_nseq];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_uvns = prove_by_refinement(
  `!L N r (x:num#num) k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) /\
    (!i. i < k /\  (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) =[]) ==> ~(MEM ((FST (ytrans L N r x i)) ,(FST (ztrans L N r x i))) (list_of_darts (quotient_list L N)))) // new here
  ==>      
    (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  TYPED_ABBREV_TAC `dtf = (dest_triple_full (core L r) v (core_triple_v4 L N r x))`;
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC next_el_core_list_pairs;
  TYPIFY `N` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Tame_list.is_restricted_all_uniq]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  DISCH_TAC;
  TYPIFY `SND x = v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_x_exists ;PAIR;FST;SND]);
  INTRO_TAC uvns_mem_core [`L`;`N`;`r`;`x`;`k`;`i`];
  ASM_SIMP_TAC[LET_THM;arith `SUC i < n ==> i < n`];
  DISCH_TAC;
  PRINT_TAC "mem";
  TYPIFY `MEM v (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_snd_x_core]);
  TYPIFY `(!i. i <= k ==> MEM (ftrans L N r x i) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_ftrans_core]);
  TYPIFY `(!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_ytrans_core]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `MEM (FST x) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_x_core]);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `PRE k < k` (C SUBGOAL_THEN ASSUME_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  PRINT_TAC "intro";
  INTRO_TAC dest_triple_full_ifbetwn [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  PRINT_TAC "split into cases";
  INTRO_TAC el_cat_suc [`i`;`(flatten  (MAP  (\i. cat       (MAP SOME       (ftrans L N r x i ::        ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))))       (nseq        (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))       NONE)) (iota 0 k)))` ;`(MAP SOME (ftrans L N r x k :: ifbetwn (core L r) (ftrans L N r x k) (FST x))) `];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    INTRO_TAC el_flatten [` (MAP  (\i. cat       (MAP SOME       (ftrans L N r x i ::        ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))))       (nseq        (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))       NONE)) (iota 0 k)) `;`j`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      REWRITE_TAC[GSYM Seq.allP;MEM_MAP;Seq.mem_iota;arith `0 <= i /\ 0+i=i`];
      REPEAT WEAKER_STRIP_TAC;
      BY(POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[cat_eq_nil;MAP_EQ_NIL;NOT_CONS_NIL]);
    DISCH_THEN DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
      FIRST_X_ASSUM_ST `MEM r' (MAP f xs)` MP_TAC;
      REWRITE_TAC[MEM_MAP;Seq.mem_iota;arith `0 <= i /\ 0 +i=i`];
      DISCH_THEN (MP_TAC o GSYM);
      REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
      REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_SIMP_TAC[];
      REPEAT WEAKER_STRIP_TAC;
      PRINT_TAC "complete first case dest_triple0";
      INTRO_TAC el_cat_nseq_the_none [`j'`;`(MAP SOME      (ftrans L N r x x' ::       ifbetwn (core L r) (ftrans L N r x x') (FST (ytrans L N r x x'))))`;`(sizel (betwn (find_face L x) (ytrans L N r x x') (ztrans L N r x x')))`];
      ASM_SIMP_TAC[];
      REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[];
      DISCH_THEN kill THEN POP_ASSUM kill;
      REWRITE_TAC[GSYM MAP_o];
      TYPIFY `((the o SOME):(num) -> (num)) = I` (C SUBGOAL_THEN SUBST1_TAC);
        BY(REWRITE_TAC[FUN_EQ_THM;o_THM;the_some;I_THM]);
      REWRITE_TAC[MAP_I;I_THM];
      MATCH_MP_TAC next_el_ifbetwn;
      ASM_SIMP_TAC[arith ` i < n ==> i <= n:num`];
      BY(POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[lower_case;Seq.size_map]);
    (COMMENT "second case last+hd on dest_triple0");
    REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `SUC j' < n` MP_TAC THEN REWRITE_TAC[REWRITE_RULE[Seq.map_MAP] Seq.size_map;Seq.size_iota];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
    REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_SIMP_TAC[GSYM Seq.size;Seq.size_iota;arith `SUC j < k ==> j < k`];
    REPEAT (GMATCH_SIMP_TAC el_iota) THEN ASM_SIMP_TAC[arith `SUC j < k ==> j < k`;arith `0 + j = j`];
    REWRITE_TAC[MAP;Seq.cat_cons;HD;the_some];
    TYPIFY `ftrans L N r x (SUC j') = FST (ztrans L N r x j')` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REWRITE_TAC[ftrans;arith `~(SUC j = 0)`;arith `PRE (SUC j) = j`]);
    COMMENT "split again on nseq=[]";
    TYPIFY `(sizel (betwn (find_face L x) (ytrans L N r x j') (ztrans L N r x j'))) = 0` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
      REWRITE_TAC[Reduction3.nseq0;Seq.cats0];
      TYPIFY `the (LAST (SOME (ftrans L N r x j') ::    (MAP SOME  (ifbetwn (core L r) (ftrans L N r x j') (FST (ytrans L N r x j')))) )) = the (SOME (LAST (ftrans L N r x j' ::   (ifbetwn (core L r) (ftrans L N r x j') (FST (ytrans L N r x j')))) ))` (C SUBGOAL_THEN SUBST1_TAC);
        AP_TERM_TAC;
        BY(MESON_TAC[MAP;EL_MAP;LAST_MAP;NOT_CONS_NIL]);
      REWRITE_TAC[the_some];
      REPEAT (GMATCH_SIMP_TAC last_ifbetwn);
      ASM_SIMP_TAC[arith `SUC j < k ==> j <= k /\ j< k`];
      FIRST_X_ASSUM_ST `list_of_darts` (C INTRO_TAC [`j'`]);
      ASM_REWRITE_TAC[GSYM Seq.size_eq0];
      BY(ASM_SIMP_TAC[arith `SUC j' < k ==> j' < k`]);
    DISCH_THEN kill;
    PROOF_BY_CONTR_TAC THEN POP_ASSUM kill;
    FIRST_X_ASSUM_ST `HD` kill;
    FIRST_X_ASSUM_ST `LAST` MP_TAC;
    REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_SIMP_TAC[GSYM Seq.size;Seq.size_iota;arith `SUC j < k ==> j < k`];
    REPEAT (GMATCH_SIMP_TAC el_iota) THEN ASM_SIMP_TAC[arith `SUC j < k ==> j < k`;arith `0 + j = j`];
    GMATCH_SIMP_TAC last_cat;
    ASM_REWRITE_TAC[Seq.size_eq0;nseq_eq_nil];
    GMATCH_SIMP_TAC last_nseq;
    BY(ASM_REWRITE_TAC[Ssrbool.isSome]);
  COMMENT "back to 1";
  POP_ASSUM DISJ_CASES_TAC THEN POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_SIMP_TAC[];
    REPLICATE_TAC 2 (POP_ASSUM kill);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `sizel` MP_TAC THEN REWRITE_TAC[REWRITE_RULE[Seq.map_MAP] Seq.size_map];
    DISCH_TAC;
    REPEAT (GMATCH_SIMP_TAC EL_MAP) THEN ASM_SIMP_TAC[GSYM Seq.size;the_some;arith `SUC j < k ==> j < k`];
    MATCH_MP_TAC next_el_ifbetwn;
    BY(ASM_SIMP_TAC[arith `k <= k:num`]);
  COMMENT "last case";
  REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_SIMP_TAC[];
  REPLICATE_TAC 2 (POP_ASSUM kill);
  SIMP_TAC[MAP;HD;the_some;Ssrbool.isSome];
  REPEAT (GMATCH_SIMP_TAC Aq23.LAST_FLATTEN_2);
  REWRITE_TAC[MAP_EQ_NIL];
  REWRITE_TAC[GSYM CONJ_ASSOC];
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_iota]);
  DISCH_TAC;
  REPEAT (GMATCH_SIMP_TAC LAST_MAP) THEN ASM_REWRITE_TAC[GSYM Seq.size;cat_eq_nil;NOT_CONS_NIL];
  DISCH_TAC;
  TYPIFY `LAST (iota 0 k) = PRE k` (C SUBGOAL_THEN SUBST1_TAC);
    BY(GMATCH_SIMP_TAC LAST_EL THEN GMATCH_SIMP_TAC el_iota THEN ASM_SIMP_TAC[GSYM Seq.size_eq0;Seq.size_iota;arith `~(k=0) ==> k-1 = PRE k`;lower_case;arith `0 + j = j`]);
  TYPIFY `(sizel      (betwn (find_face L x) (ytrans L N r x (PRE k))      (ztrans L N r x (PRE k)))) = 0` ASM_CASES_TAC THEN ASM_REWRITE_TAC[nseq0;Seq.cats0];
    TYPIFY `(the  (LAST  (SOME (ftrans L N r x (PRE k)) ::   MAP SOME   (ifbetwn (core L r) (ftrans L N r x (PRE k))   (FST (ytrans L N r x (PRE k))))))) = (the (SOME (LAST ((ftrans L N r x (PRE k)) :: ifbetwn (core L r) (ftrans L N r x (PRE k))   (FST (ytrans L N r x (PRE k)))) )))` (C SUBGOAL_THEN SUBST1_TAC);
      AP_TERM_TAC;
      BY(MESON_TAC[MAP;LAST_EL;LAST_MAP;NOT_CONS_NIL]);
    REWRITE_TAC[the_some];
    REPEAT (GMATCH_SIMP_TAC last_ifbetwn);
    ASM_SIMP_TAC[arith `~(k=0) ==>  PRE k <= k /\ PRE k < k`];
    FIRST_X_ASSUM_ST `list_of_darts` (C INTRO_TAC [`PRE k`]);
    ASM_REWRITE_TAC[GSYM Seq.size_eq0];
    BY(ASM_SIMP_TAC[GSYM Seq.size_eq0;ftrans]);
  DISCH_THEN kill;
  DISCH_TAC;
  PROOF_BY_CONTR_TAC THEN POP_ASSUM kill;
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  REWRITE_TAC[];
  BY(GMATCH_SIMP_TAC last_cat THEN GMATCH_SIMP_TAC last_nseq THEN ASM_REWRITE_TAC[Ssrbool.isSome;nseq_eq_nil])
  ]);;
  (* }}} *)

let final_assumption_uvns_combined = prove_by_refinement(
  `!L N r (x:num#num) k.
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     transform_count L N r x = k /\
     (!i. i < k /\
          betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
          ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))
               (list_of_darts (quotient_list L N))) /\
     // 22x
     (!i. i < k /\
              1 <
              sizel
              (ftrans L N r x i ::
               ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))
              ==> ~MEM (SND x)
                   (ifbetwn (core L r) (ftrans L N r x i)
                   (FST (ytrans L N r x i)))) /\

     ~MEM (SND x) (ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
//     (!i. i < k // replaced with Jul 22
//          ==> ~MEM (SND x)
//               (ifbetwn (core L r) (ftrans L N r x i)
//               (FST (ytrans L N r x i)))) /\
     (!i. i < k
          ==> indexf (SND x) (FST (ytrans L N r x i)) (core L r) <
              indexf (SND x) (FST (ztrans L N r x i)) (core L r))
     ==> (!v. prev_el (core L r) v,v = x
              ==> (let uvns = core_triple_v4 L N r x in
                  ( let vs = dest_triple_full (core L r) v uvns in
                  ( let vs' = MAP the (filter isSome vs) in
                   (!i. SUC i < sizel vs'
                        ==> indexf v (EL i vs') (core L r) <
                            indexf v (EL (SUC i) vs') (core L r)) /\
                   (!i. let d = the (EL i vs),the (EL (SUC i) vs) in
                        isSome (EL i vs) /\
                        isSome (EL (SUC i) vs) /\
                        SUC i < sizel vs /\
                        MEM d (list_of_darts (quotient_list L N))
                        ==> MEM d (list_pairs (core L r)))))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  CONJ2_TAC;
    INTRO_TAC final_assumption_uvns [`L`;`N`;`r`;`x`;`k`];
    ASM_REWRITE_TAC[LET_THM];
    BY(ASM_MESON_TAC[]);
  INTRO_TAC final_assumption_uvns_vs' [`L`;`N`;`r`;`x`;`k`;`v`];
  (ASM_REWRITE_TAC[LET_THM])
  ]);;
  (* }}} *)

let reduction_K3 = prove_by_refinement(
  `(!L N r (x:num#num) k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     element_pre L N /\  // added July 13 2014
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     // END ASSUMPTIONS

     // (INDEX)
//     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) = // More_lemma2.indexf2_final_lemmas
//         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
//     (!i. SUC i < k  // f3
//      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
//          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\

//     (!i. SUC i < k  // f4
//       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
//       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
//      (!i. SUC i < k  // f5
//       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
//       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
//      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <= // f6
//	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
//      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=  // f7
//         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
//      (!i. SUC i < k ==>  // f8
//	 (next_el (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x i)) =
//		FST (ytrans L N r x (SUC i)) <=>
//		  next_el (core L r) (FST (ztrans L N r x i)) = FST (ytrans L N r x (SUC i))) ) /\

     // (MISC) 
    (!i. i < k     ==> MEM (ztrans L N r x 0) (rtrans L N r x i)) /\

     // (BETWN)
(~(FST(ztrans L N r x (PRE k)) = FST x) ==>  // added July 17 2014
	(betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))) /\
//     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
//	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
     (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i))) /\
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
	 ==> ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
             FST (ytrans L N r x 0))) /\

     // July 19 2014 corrected.
     (!i. SUC i < k /\  ~(FST (ztrans L N r x i) = FST (ytrans L N r x (SUC i))) ==>
	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
	    betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
	      (FST (ytrans L N r x (SUC i))))) /\

//     (!i. SUC i < k ==> 
//	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
//	     betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
//	       (FST (ytrans L N r x (SUC i))))) /\

     // (NEW)
    ~(MEM (SND x) ((ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))) /\

     // July 22 2014 replaced
   (!i. i < k /\
              1 <
              sizel
              (ftrans L N r x i ::
               ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))
              ==> ~MEM (SND x)
                   (ifbetwn (core L r) (ftrans L N r x i)
                   (FST (ytrans L N r x i)))) /\
//    (!i. i < k ==> // old 
 //      ~MEM (SND x) (ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))) /\


    (!i. i < k ==>  // new
       indexf (SND x) (FST (ytrans L N r x i)) (core L r) < 
       indexf (SND x) (FST (ztrans L N r x i)) (core L r)) /\ 
   (!i. i < k /\
              betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) =
              []
              ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))
                   (list_of_darts (quotient_list L N)))


   ) ==> assumption_setK10`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_K2;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`]);
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `(!i. i < k /\              1 <              sizel              (ftrans L N r x i ::               ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))              ==> ~MEM (SND x)                   (ifbetwn (core L r) (ftrans L N r x i)                   (FST (ytrans L N r x i)))) /\ (~MEM (SND x) (ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\    (!i. i < k       ==> indexf (SND x) (FST (ytrans L N r x i)) (core L r) <           indexf (SND x) (FST (ztrans L N r x i)) (core L r))) /\ (!i. i < k /\               betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) =               []               ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))                    (list_of_darts (quotient_list L N)))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  COMMENT "pick off last conjunct";
  REWRITE_TAC[CONJ_ASSOC];
  ONCE_REWRITE_TAC[GSYM IMP_IMP_THM];
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    REPEAT LET_TAC;
    INTRO_TAC final_assumption_uvns_combined [`L`;`N`;`r`;`x`;`k`];
    ASM_SIMP_TAC[LET_THM];
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(k = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  COMMENT "cases here";
  REWRITE_TAC[GSYM CONJ_ASSOC];
  FIRST_X_ASSUM_ST `SND` kill;
  FIRST_X_ASSUM_ST `SND` kill;
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf2_final_lemmas;
    BY(ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf3_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf4_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf5_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf6_final_lemmas;
    BY(ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma2.indexf7_final_lemmas;
    BY(ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC More_lemma2.indexf8_final_lemmas [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(DISCH_THEN (C INTRO_TAC [`SUC i`]) THEN ASM_SIMP_TAC[arith `0 < SUC i /\ (PRE (SUC i)=i)`])
  ]);;
  (* }}} *)

let corei_reduction = prove_by_refinement(
  `
(!L N r (x:num#num). 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []) ==>
	 ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	     FST (ztrans L N r x 0)))
    ==>
 (!L N r (x:num#num) k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>   (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	     FST (ztrans L N r x i))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REWRITE_TAC[];
  TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  REWRITE_TAC[trans_add];
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`]);
  ASM_SIMP_TAC[];
  TYPIFY `(rtrans L (ntrans L N r x i) (rtrans L N r x i) x 0) = rtrans L N r x i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[GSYM trans_add;arith `0 + i = i`]);
  DISCH_THEN MATCH_MP_TAC;
  (ASM_REWRITE_TAC[GSYM trans_add;arith `0 + i = i`]);
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not];
  MATCH_MP_TAC AQIUNPP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let n1_diff_n0 = prove_by_refinement(
  `!L N r (x:A#A).
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    ~final_list L r ==>
    (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	 set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC SUBSET_ANTISYM;
  CONJ2_TAC;
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;IN_DIFF];
    X_GENv_TAC "d";
    DISCH_THEN (MP_TAC o GSYM o REWRITE_RULE[MEM_MAP] );
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "d";
    INTRO_TAC (GEN_ALL Aq1.betwn_not_in_fst_faltten) [`find_face L x`;`x'`;`L`;`N`;`r`;`x`];
    ASM_SIMP_TAC[];
    SIMP_TAC[upper_case];
    DISCH_TAC;
    MATCH_MP_TAC MEMf_MAP;
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `rtrans L N r x 1` EXISTS_TAC;
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `betwn` MP_TAC;
    INTRO_TAC (GSYM Reduction2.rtrans_diff_r) [`L`;`N`;`r`;`x`];
    BY(ASM_MESON_TAC[Reduction2.trans0;Seq.mem_filter]);
  REWRITE_TAC[SUBSET;IN_DIFF;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq9.CASES_CORE) [`x'`;`find_face L x`;`ytrans L N r x 0`;`ztrans L N r x 0`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[Reduction2.trans0];
  REWRITE_TAC[GSYM quotient_list_core];
  TYPIFY `x' IN elements_of_list (quotient_list L (ntrans L N r x 1)) /\ ~(x' IN elements_of_list(quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[quotient_list_elements;marked_list;IN_SET_OF_LIST]);
  BY(ASM_MESON_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements;IN_SET_OF_LIST;Seq.mem_undup])
  ]);;
  (* }}} *)

(*
let non_r_darts_trans = prove_by_refinement(
    `!L N r x u. 
    good_list L /\
    is_restricted(hypermap_of_list L) /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\ 
    MEM u (list_of_darts (quotient_list L N)) /\
    ~MEM u r ==>
    MEM u (list_of_darts (quotient_list L (ntrans L N r x 1))) /\
    ~MEM u (rtrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N /\ is_edge_nondegenerate (hypermap_of_list L) /\ all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[is_restricted_all_uniq]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[Hypermap.is_restricted]);
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ2_TAC;
    INTRO_TAC Aq1.has_snd_norm_list_fliter [`L`;`N`;`r`;`x`];
    ASM_SIMP_TAC[];
    INTRO_TAC (GSYM Reduction3.rtrans1) [`L`;`N`;`r`;`x`];
    ASM_SIMP_TAC[];
    DISCH_THEN kill;
    REWRITE_TAC[GSYM Seq.hasP;NOT_EXISTS_THM;TAUT `~(a /\ b) <=> (a ==> ~b )`];
    DISCH_THEN MATCH_MP_TAC;
    REWRITE_TAC[Seq.mem_filter];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
    GMATCH_SIMP_TAC Tame_list.mem_list_of_darts_quotient;
    ASM_SIMP_TAC[];
    REWRITE_TAC[Seq2.mem_flatten] THEN REPEAT WEAKER_STRIP_TAC;
    TYPIFY `r'` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
    TYPIFY `r' = flatten (parts L r')` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[parts_flatten]);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `p` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC MEM_LAST;
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
  REPEAT (GMATCH_SIMP_TAC list_of_darts_quotient);
  ASM_SIMP_TAC[];
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x ` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `u` FULL_LEFT_EXPAND_TAC;
  POP_ASSUM kill THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[Seq2.mem_flatten;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `l` FULL_LEFT_EXPAND_TAC;
  TYPIFY `x'` (RENAME_TAC "p");
  TYPIFY `x''` (RENAME_TAC "r'");
  TYPIFY `~(r = r')` ASM_CASES_TAC;
    TYPIFY `p` EXISTS_TAC THEN ASM_SIMP_TAC[];
    TYPIFY `parts L r'` EXISTS_TAC THEN ASM_SIMP_TAC[];
    TYPIFY `r'` EXISTS_TAC THEN ASM_SIMP_TAC[];
    MATCH_MP_TAC Aq9.element_in_ntrans_suc;
    BY(ASM_REWRITE_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  FULL_EXPAND_TAC "r'";
  PROOF_BY_CONTR_TAC;
  REPEAT (FIRST_X_ASSUM_ST `rtrans` kill);
  FIRST_X_ASSUM_ST `~MEM x r` MP_TAC;
  REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `p` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC MEM_LAST;
  BY(ASM_MESON_TAC[parts_uniq_nonnil])
  ]);;
  (* }}} *)

let non_r_darts_trans_i = prove_by_refinement(
  `!i L N r x u.
    good_list L /\
    is_restricted (hypermap_of_list L) /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    i <= transform_count L N r x /\
    MEM u (list_of_darts (quotient_list L N)) /\
    ~MEM u r
    ==> MEM u (list_of_darts (quotient_list L (ntrans L N r x i))) /\
             ~MEM u (rtrans L N r x i)`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_SIMP_TAC[];
    BY(ASM_SIMP_TAC[Reduction2.trans0]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[arith `SUC i = 1 + i`;trans_add];
  MATCH_MP_TAC non_r_darts_trans;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i < k`]);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`])
  ]);;
  (* }}} *)
*)

let mem_list_pairs_core = prove_by_refinement(
  `!L N r d.
    normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            MEM r N /\
            all uniq L /\
    MEM d (list_pairs (core L r)) ==> MEM d r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN GMATCH_SIMP_TAC list_pairs_core;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d` FULL_LEFT_EXPAND_TAC;
  TYPIFY `x` (RENAME_TAC "p");
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `uniq p /\ ~(p=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let list_of_darts_quotient_flatten = prove_by_refinement(
  `!L N u.
    normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            all uniq L /\
    MEM u (list_of_darts (quotient_list L N)) ==>
    MEM u (flatten N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
  REWRITE_TAC[quotient_list_core;Rxokskc.MEM_LIST_DARTS];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC THEN REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` FULL_LEFT_EXPAND_TAC;
  INTRO_TAC mem_list_pairs_core [`L`;`N`;`x'`;`u`];
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let mem_list_of_darts_quotient_core = prove_by_refinement(
  `!L N u.  normal_list L N /\
            is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            all uniq L /\
    MEM u (list_of_darts (quotient_list L N)) ==>
    (?r. MEM r N /\ MEM u (list_pairs (core L r)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
  REWRITE_TAC[quotient_list_core;Rxokskc.MEM_LIST_DARTS];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC THEN REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` FULL_LEFT_EXPAND_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let non_r_darts_trans = prove_by_refinement(
    `!L N r x u. 
    good_list L /\
    is_restricted(hypermap_of_list L) /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\ 
    MEM u (list_of_darts (quotient_list L N)) /\
    ~MEM u (list_pairs (core L r)) ==>
    MEM u (list_of_darts (quotient_list L (ntrans L N r x 1))) /\
    ~MEM u (list_pairs (core L (rtrans L N r x 1)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N /\ is_edge_nondegenerate (hypermap_of_list L) /\ all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[is_restricted_all_uniq]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[Hypermap.is_restricted]);
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x ` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `~MEM u (list_pairs (core L (rtrans L N r x 1)))` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `list_of_darts` MP_TAC;
    REPEAT (GMATCH_SIMP_TAC list_of_darts_quotient);
    ASM_SIMP_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    DISCH_TAC;
    REWRITE_TAC[MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `u` FULL_LEFT_EXPAND_TAC;
    POP_ASSUM kill THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[Seq2.mem_flatten;MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `l` FULL_LEFT_EXPAND_TAC;
    TYPIFY `x'` (RENAME_TAC "p");
    TYPIFY `x''` (RENAME_TAC "r'");
    TYPIFY `~(r = r')` ASM_CASES_TAC;
      TYPIFY `p` EXISTS_TAC THEN ASM_SIMP_TAC[];
      TYPIFY `parts L r'` EXISTS_TAC THEN ASM_SIMP_TAC[];
      TYPIFY `r'` EXISTS_TAC THEN ASM_SIMP_TAC[];
      MATCH_MP_TAC Aq9.element_in_ntrans_suc;
      BY(ASM_REWRITE_TAC[]);
    RULE_ASSUM_TAC(REWRITE_RULE[]);
    FULL_EXPAND_TAC "r'";
    PROOF_BY_CONTR_TAC;
    REPEAT (FIRST_X_ASSUM_ST `rtrans` kill);
    FIRST_X_ASSUM_ST `~MEM x r` MP_TAC;
    REWRITE_TAC[];
    TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
    INTRO_TAC list_pairs_core [`L`;`N`;`r`];
    ASM_SIMP_TAC[];
    DISCH_TAC;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "u not in core of r1";
  DISCH_TAC;
  TYPIFY `MEM u (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC mem_list_pairs_core [`L`;`ntrans L N r x 1`;`rtrans L N r x 1`;`u`];
    ASM_SIMP_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    BY(SIMP_TAC[]);
  INTRO_TAC Reduction3.rtrans1 [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (ASSUME_TAC o GSYM);
  TYPIFY `MEM u (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[list_of_darts_quotient_flatten]);
  INTRO_TAC Aq1.has_snd_norm_list_fliter [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[GSYM Seq.hasP];
  TYPIFY `u` EXISTS_TAC;
  ASM_SIMP_TAC[Seq.mem_filter];
  DISCH_TAC;
  INTRO_TAC mem_list_of_darts_quotient_core [`L`;`N`;`u`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = r')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[] THEN MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  GEXISTL_TAC [`N`;`u`];
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[normal_list]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  BY(ASM_MESON_TAC[mem_list_pairs_core])
  ]);;
  (* }}} *)

let non_r_darts_trans_i = prove_by_refinement(
  `!i L N r x u.
    good_list L /\
    is_restricted (hypermap_of_list L) /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    i <= transform_count L N r x /\
    MEM u (list_of_darts (quotient_list L N)) /\
    ~(MEM u (list_pairs (core L r)))
    ==> MEM u (list_of_darts (quotient_list L (ntrans L N r x i))) /\
           ~MEM u (list_pairs (core L (rtrans L N r x i)))`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN ASM_SIMP_TAC[];
    BY(ASM_SIMP_TAC[Reduction2.trans0]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[arith `SUC i = 1 + i`;trans_add];
  MATCH_MP_TAC non_r_darts_trans;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i < k`]);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[arith `SUC i <= k ==> i <= k`])
  ]);;
  (* }}} *)


(*
let list_of_darts_mem = prove_by_refinement(
  `(!L N r (x:num#num).
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          marked_list L N r x /\
          ~final_list L r /\
          ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0)) r /\
          (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
           ==> ~(next_el (core L r) (FST (ytrans L N r x 0)) =
                 FST (ztrans L N r x 0))) /\
          betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
          ==> ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0))
               (list_of_darts (quotient_list L N)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `==>` MP_TAC THEN ASM_REWRITE_TAC[] THEN PROOF_BY_CONTR_TAC;
  TYPED_ABBREV_TAC `d = (FST (ytrans L N r x 0),FST (ztrans L N r x 0))`;
  INTRO_TAC non_r_darts_trans [`L`;`N`;`r`;`x`;`d`];
  ASM_SIMP_TAC[];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ2_TAC;
  TYPIFY `normal_list L N /\            is_edge_nondegenerate (hypermap_of_list L) /\            all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[is_restricted_all_uniq]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[Hypermap.is_restricted]);
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM d (list_pairs (core L (rtrans L N r x 1)))` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    MATCH_MP_TAC mem_list_pairs_core;
    GEXISTL_TAC[ `L`;`ntrans L N r x 1` ];
    ASM_SIMP_TAC[];
    BY(ASM_MESON_TAC[marked_list]);
  FULL_EXPAND_TAC "d" THEN MATCH_MP_TAC next_el_core_list_pairs;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[marked_list]);
  nCONJ_TAC 1;
    MATCH_MP_TAC marked_list_uniq_core;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (ytrans L N r x 0) (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_SIMP_TAC[rtrans1];
    INTRO_TAC (GEN_ALL Aq12.y_mem_split_snd) [`l'z L N r x`;`find_face L (l'y L r x)`;`prev_el r (l'z L N r x)`;`l'y L r x`;`(SND     (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)	(prev_el r (l'z L N r x))))`;`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[Reduction2.trans0]);
  nCONJ_TAC 2;
    MATCH_MP_TAC mem_fst_core;
    GEXISTL_TAC [`ntrans L N r x 1`;`x`];
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  COMMENT "next_el core";
  MATCH_MP_TAC next_core_ne_FST;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_y_neq_fst_z]);
  DISCH_TAC;
  TYPIFY `uniq (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `all uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[uniq_flatten_all_uniq;marked_list;normal_list]);
    POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  POP_ASSUM MP_TAC;
  ASM_SIMP_TAC[rtrans1];
  ASM_SIMP_TAC[split_normal_list;LET_THM;LAMBDA_PAIR];
  REPEAT (GMATCH_SIMP_TAC Reduction2.find_face_x_eq_y);
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `(betwn (find_face L x) (l'y L r x) (l'z L N r x)) = []` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  REWRITE_TAC[Seq.cats0];
  TYPIFY_GOAL_THEN `l'z L N r x = ztrans L N r x 0 /\ l'y L r x = ytrans L N r x 0` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  TYPED_ABBREV_TAC `p = (cat [ztrans L N r x 0]  (cat (betwn r (ztrans L N r x 0) (ytrans L N r x 0)) [ytrans L N r x 0]))`;
  TYPIFY `~(p = []) /\ ytrans L N r x 0 = LAST p /\ ztrans L N r x 0 = HD p ` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "p";
    REWRITE_TAC[Seq.cat_cons;HD;NOT_CONS_NIL];
    REWRITE_TAC[GSYM Seq.cat_cons;Seq.catA];
    REWRITE_TAC[Seq.cats1];
    BY(REWRITE_TAC[LAST_rcons]);
  ASM_SIMP_TAC[];
  ASM_SIMP_TAC[Aq4.next_el_last_hd];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil;marked_list])
  ]);;
  (* }}} *)

let list_of_darts_reduction = prove_by_refinement(
  `(!L N r (x:num#num).
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      (betwn (find_face L x) (ytrans L N r x 0)
	 (ztrans L N r x 0) = [])  ==>
      ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	   FST (ztrans L N r x 0))) /\

  (!L N r (x:num#num) k.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      transform_count L N r x  = k ==>
      (!i. i < k /\
                   betwn (find_face L x) (ytrans L N r x i)
                   (ztrans L N r x i) =
                   []
                   ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i)) r))  

// /\  
//(!L N r (x:num#num).
//    good_list L /\
//    good_list_nodes L /\
//    is_restricted (hypermap_of_list L) /\
//    marked_list L N r x /\
//    ~final_list L r /\
//    ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0)) r /\
//    (  (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []) ==>
//       ~(next_el (core L r) (FST (ytrans L N r x 0)) =
//	   FST (ztrans L N r x 0))) /\
//   (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [])
//         ==> ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0))
//         (list_of_darts (quotient_list L N)))

 ==>

(!L N r (x:num#num) k.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    transform_count L N r x = k /\
    ~final_list L r 

    ==>
   (!i. i < k /\
        betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
         ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))
         (list_of_darts (quotient_list L N))))`,
  (* {{{ proof *)
  [
    ASSUME_TAC list_of_darts_mem;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC non_r_darts_trans_i [`i`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `~MEM ((FST (ytrans L N r x i),FST (ztrans L N r x i)) ) r /\ ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))     (list_of_darts (quotient_list L (ntrans L N r x i)))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[arith `i < k ==> i <= k:num`]);
  POP_ASSUM kill;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  (POP_ASSUM MP_TAC) THEN TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  REWRITE_TAC[trans_add];
  DISCH_TAC;
  TYPIFY `(ntrans L (ntrans L N r x i) (rtrans L N r x i) x 0) = ntrans L N r x i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[GSYM trans_add;arith `0+i = i`]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  DISCH_TAC;
  SIMP_TAC[];
  CONJ_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`transform_count L (ntrans L N r x i) (rtrans L N r x i) x`]);
    ASM_SIMP_TAC[];
    DISCH_THEN (C INTRO_TAC [`0`]);
    ASM_SIMP_TAC[GSYM trans_add;arith `0+i=i`];
    GMATCH_SIMP_TAC Reduction3.transform_count_add;
    BY(ASM_SIMP_TAC[arith `(i < k ==> i <= k) /\ (i < k ==> 0 < k - i)`]);
  CONJ2_TAC;
    BY(ASM_REWRITE_TAC[GSYM trans_add;arith `0+i =i`]);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)
*)

let list_of_darts_mem = prove_by_refinement(
  `(!L N r (x:num#num).
          good_list L /\
          good_list_nodes L /\
          is_restricted (hypermap_of_list L) /\
          marked_list L N r x /\
          ~final_list L r /\
          ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0)) (list_pairs (core L r)) /\
          (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
           ==> ~(next_el (core L r) (FST (ytrans L N r x 0)) =
                 FST (ztrans L N r x 0))) /\
          betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
          ==> ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0))
               (list_of_darts (quotient_list L N)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `==>` MP_TAC THEN ASM_REWRITE_TAC[] THEN PROOF_BY_CONTR_TAC;
  TYPED_ABBREV_TAC `d = (FST (ytrans L N r x 0),FST (ztrans L N r x 0))`;
  INTRO_TAC non_r_darts_trans [`L`;`N`;`r`;`x`;`d`];
  ASM_SIMP_TAC[];
  REWRITE_TAC[DE_MORGAN_THM];
  MATCH_MP_TAC (TAUT `(a ==> b) ==> (~a \/ b)`);
  DISCH_TAC;
  TYPIFY `normal_list L N /\            is_edge_nondegenerate (hypermap_of_list L) /\            all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[is_restricted_all_uniq]);
    nCONJ_TAC 1;
      BY(ASM_MESON_TAC[Hypermap.is_restricted]);
    nCONJ_TAC 0;
      BY(ASM_MESON_TAC[marked_list]);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "d" THEN MATCH_MP_TAC next_el_core_list_pairs;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[marked_list]);
  nCONJ_TAC 1;
    MATCH_MP_TAC marked_list_uniq_core;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (ytrans L N r x 0) (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_SIMP_TAC[rtrans1];
    INTRO_TAC (GEN_ALL Aq12.y_mem_split_snd) [`l'z L N r x`;`find_face L (l'y L r x)`;`prev_el r (l'z L N r x)`;`l'y L r x`;`(SND     (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)	(prev_el r (l'z L N r x))))`;`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[Reduction2.trans0]);
  nCONJ_TAC 2;
    MATCH_MP_TAC mem_fst_core;
    GEXISTL_TAC [`ntrans L N r x 1`;`x`];
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  COMMENT "next_el core";
  MATCH_MP_TAC next_core_ne_FST;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_y_neq_fst_z]);
  DISCH_TAC;
  TYPIFY `uniq (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `all uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[uniq_flatten_all_uniq;marked_list;normal_list]);
    POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  POP_ASSUM MP_TAC;
  ASM_SIMP_TAC[rtrans1];
  ASM_SIMP_TAC[split_normal_list;LET_THM;LAMBDA_PAIR];
  REPEAT (GMATCH_SIMP_TAC Reduction2.find_face_x_eq_y);
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `(betwn (find_face L x) (l'y L r x) (l'z L N r x)) = []` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  REWRITE_TAC[Seq.cats0];
  TYPIFY_GOAL_THEN `l'z L N r x = ztrans L N r x 0 /\ l'y L r x = ytrans L N r x 0` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  TYPED_ABBREV_TAC `p = (cat [ztrans L N r x 0]  (cat (betwn r (ztrans L N r x 0) (ytrans L N r x 0)) [ytrans L N r x 0]))`;
  TYPIFY `~(p = []) /\ ytrans L N r x 0 = LAST p /\ ztrans L N r x 0 = HD p ` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "p";
    REWRITE_TAC[Seq.cat_cons;HD;NOT_CONS_NIL];
    REWRITE_TAC[GSYM Seq.cat_cons;Seq.catA];
    REWRITE_TAC[Seq.cats1];
    BY(REWRITE_TAC[LAST_rcons]);
  ASM_SIMP_TAC[];
  ASM_SIMP_TAC[Aq4.next_el_last_hd];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil;marked_list])
  ]);;
  (* }}} *)

let list_of_darts_reduction = prove_by_refinement(
  `(!L N r (x:num#num).
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      (betwn (find_face L x) (ytrans L N r x 0)
	 (ztrans L N r x 0) = [])  ==>
      ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	   FST (ztrans L N r x 0))) /\
  (!L N r (x:num#num) k.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      marked_list L N r x /\
      ~final_list L r /\
      transform_count L N r x  = k ==>
      (!i. i < k /\
                   betwn (find_face L x) (ytrans L N r x i)
                   (ztrans L N r x i) =
                   []
                   ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i)) (list_pairs (core L r))))  
// /\  
//(!L N r (x:num#num).
//    good_list L /\
//    good_list_nodes L /\
//    is_restricted (hypermap_of_list L) /\
//    marked_list L N r x /\
//    ~final_list L r /\
//    ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0)) r /\
//    (  (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []) ==>
//       ~(next_el (core L r) (FST (ytrans L N r x 0)) =
//	   FST (ztrans L N r x 0))) /\
//   (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [])
//         ==> ~MEM (FST (ytrans L N r x 0),FST (ztrans L N r x 0))
//         (list_of_darts (quotient_list L N)))

 ==>

(!L N r (x:num#num) k.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    transform_count L N r x = k /\
    ~final_list L r 

    ==>
   (!i. i < k /\
        betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
         ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))
         (list_of_darts (quotient_list L N))))`,
  (* {{{ proof *)
  [

    ASSUME_TAC list_of_darts_mem;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC non_r_darts_trans_i [`i`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `~MEM ((FST (ytrans L N r x i),FST (ztrans L N r x i)) ) (list_pairs (core L r)) /\ ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))     (list_of_darts (quotient_list L (ntrans L N r x i)))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[arith `i < k ==> i <= k:num`]);
  POP_ASSUM kill;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  (POP_ASSUM MP_TAC) THEN TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  REWRITE_TAC[trans_add];
  DISCH_TAC;
  TYPIFY `(ntrans L (ntrans L N r x i) (rtrans L N r x i) x 0) = ntrans L N r x i` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[GSYM trans_add;arith `0+i = i`]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not]);
  DISCH_TAC;
  SIMP_TAC[];
  CONJ_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`transform_count L (ntrans L N r x i) (rtrans L N r x i) x`]);
    ASM_SIMP_TAC[];
    DISCH_THEN (C INTRO_TAC [`0`]);
    ASM_SIMP_TAC[GSYM trans_add;arith `0+i=i`];
    GMATCH_SIMP_TAC Reduction3.transform_count_add;
    BY(ASM_SIMP_TAC[arith `(i < k ==> i <= k) /\ (i < k ==> 0 < k - i)`]);
  CONJ2_TAC;
    BY(ASM_REWRITE_TAC[GSYM trans_add;arith `0+i =i`]);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let final_reduction_mem_z0_ri = prove_by_refinement(
  `!L i N r (x:num#num) k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     i < k /\
     (transform_count L N r x = k) ==>
      (MEM (ztrans L N r x 0) (rtrans L N r x i))
`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC Pwssrat.mem_ztrans_rtrans;
    BY(ASM_REWRITE_TAC[Reduction2.trans0]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Ncvibwu.NCVIBWU [`L`;`N`;`r`;`find_face L x`;`next_el (find_face L x) x`;`x`;`i`;`indexf (next_el (find_face L x) x) (ztrans L N r x 0) (find_face L x)` ];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    GMATCH_SIMP_TAC Kbwpbhq.transform_count_not;
    ASM_SIMP_TAC[arith `SUC i < k ==> i < k`];
    INTRO_TAC (GEN_ALL More_lemma2.indexf_ztrans_lt_find_face) [`next_el (find_face L x) x`;`find_face L x`;`L`;`N`;`r`;`x`];
    ASM_SIMP_TAC[];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_SIMP_TAC[arith `SUC i < k ==> i < k`]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `ztrans L N r x 0 = ((next_el (find_face L x) POWER        indexf (next_el (find_face L x) x) (ztrans L N r x 0) (find_face L x))      (next_el (find_face L x) x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC indexf_n;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_next_el;
    REWRITE_TAC[GSYM List_hypermap.dart_in_face];
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Hojodcm.ztran_me_f_v0]);
  MATCH_MP_TAC List_hypermap.uniq_find_face;
  BY(ASM_MESON_TAC[List_hypermap.good_list])
  ]);;
  (* }}} *)

(* ********************************************************************** *)
(* SND x CORE results *)
(* ********************************************************************** *)

let ifbetwn_disjoint = prove_by_refinement(
  `!x y w f.
    uniq f /\  MEM w (ifbetwn f x y)
            ==> ~MEM w (ifbetwn f y x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  REWRITE_TAC[MEM;GSYM Seq.cats1;Seq.mem_cat];
  BY(ASM_MESON_TAC[Tame_list.not_betwn1;Tame_list.not_betwn2;Reduction3.betwn_disjoint])
  ]);;
  (* }}} *)

let ifbetwn_cover = prove_by_refinement(
  `!x y w f.
    uniq f /\ MEM x f /\ MEM y f /\ MEM w f /\ ~(x=y) ==>
    (MEM w (ifbetwn f x y) <=> ~(MEM w (ifbetwn f y x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn];
  SIMP_TAC[MEM; GSYM Seq.cats1;Seq.mem_cat];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.betwn_cases [`f`;`x`;`w`;`y`];
  ASM_SIMP_TAC[];
  INTRO_TAC ifbetwn_disjoint [`x`;`y`;`w`;`f`];
  INTRO_TAC ifbetwn_disjoint [`y`;`x`;`w`;`f`];
  ASM_SIMP_TAC[ifbetwn;MEM;GSYM Seq.cats1;Seq.mem_cat];
  BY(ASM_MESON_TAC[ Tame_list.not_betwn1; Tame_list.not_betwn2])
  ]);;
  (* }}} *)

let core_nil = prove_by_refinement(
  `!L. core L [] = []`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[core;MAP_EQ_NIL;parts_nil])
  ]);;
  (* }}} *)

let core_cat = prove_by_refinement(
  `!L u v.
    uniq (cat u v) /\
    ~(u = []) /\
    ~(next_el (cat u v) (LAST u) = f_list L (e_list (LAST u))) ==>
    core L (cat u v) = cat (core L u) (core L v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v = []` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[core_nil;Seq.cats0]);
  REWRITE_TAC[core];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  BY(REWRITE_TAC[lower_case;Seq.map_cat])
  ]);;
  (* }}} *)

let take_eq_nil = prove_by_refinement(
  `!r k. take k r = [] <=> (k= 0 \/ r = [])`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.take];
  BY(INDUCT_TAC THEN REWRITE_TAC[Seq.take;NOT_CONS_NIL;arith `~(SUC k = 0)`])
  ]);;
  (* }}} *)

let rot_core = prove_by_refinement(
  `!L r r' k.
    uniq r /\ ~(r=[]) /\
    rot k r = r' /\
    ~(next_el r (LAST r) = f_list L (e_list (LAST r))) /\
    ~(next_el r' (LAST r') = f_list L (e_list (LAST r'))) ==>
    (?k'. rot k' (core L r) = (core L r'))
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k=0` ASM_CASES_TAC;
    TYPIFY `0` EXISTS_TAC;
    BY(FIRST_X_ASSUM_ST `rot` MP_TAC THEN ASM_SIMP_TAC[Seq.rot0]);
  INTRO_TAC Seq.rot [`k`;`r`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC core_cat [`L`;`dropl k r`;`take k r`];
  INTRO_TAC core_cat [`L`;`take k r`;`dropl k r`];
  SIMP_TAC[Seq.cat_take_drop;GSYM Seq.rot];
  ASM_REWRITE_TAC[Seq.rot_uniq;take_eq_nil];
  TYPIFY `LAST (take k r) = LAST r'` (C SUBGOAL_THEN SUBST1_TAC);
    POP_ASSUM SUBST1_TAC;
    GMATCH_SIMP_TAC LAST_cat;
    BY(ASM_REWRITE_TAC[take_eq_nil]);
  POP_ASSUM (ASSUME_TAC o GSYM);
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq;Seq.rot_uniq]);
  DISCH_TAC;
  TYPIFY `dropl k r = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `0` EXISTS_TAC;
    REWRITE_TAC[Seq.rot0;core_nil;Seq.cats0];
    BY(ASM_MESON_TAC[Seq.cat0s]);
  TYPIFY `LAST (dropl k r) = LAST r` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[LAST_cat;Seq.cat_take_drop]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq;Seq.rot_uniq]);
  DISCH_THEN SUBST1_TAC;
  BY(ASM_MESON_TAC[Seq.rot_size_cat])
  ]);;
  (* }}} *)

let ifbetwn_rot = prove_by_refinement(
  `!x y s n.
    uniq s ==>
    ifbetwn (rot n s) x y = ifbetwn s x y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[ifbetwn;Seq.mem_rot];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `n <= sizel s` ASM_CASES_TAC;
      BY(ASM_MESON_TAC[Seq.mem_rot;Reduction2.betwn_rot]);
    BY(ASM_MESON_TAC[Seq.rot_oversize;arith `~(n <= s) ==> (s <= n:num)`]);
  ]);;
  (* }}} *)

let indexf_inj = prove_by_refinement(
  `!s x y z. MEM x s /\ MEM y s /\ MEM z s ==>
    (indexf x y s = indexf x z s <=> (y = z))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `y = z` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[arith `a + b - c = (b-c) + a:num`];
  REPEAT (GMATCH_SIMP_TAC Ocbicby.MOD_EQ_MOD_SHIFT);
  REPEAT (GMATCH_SIMP_TAC MOD_LT);
  nCONJ_TAC 3;
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  ASM_REWRITE_TAC[Seq.index_mem;Seq.size_eq0];
  BY(ASM_MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let ifbetwn_indexf = prove_by_refinement(
  `!s x y z. MEM x s /\ MEM y s /\ MEM z s /\ uniq s ==>
    (MEM y (ifbetwn s x z) <=> 
       (0 < indexf x y s /\ indexf x y s <= indexf x z s))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[ifbetwn] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `x = z` ASM_CASES_TAC THEN ASM_SIMP_TAC[MEM;Tame_list.indexf_refl];
    BY(ARITH_TAC);
  REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat;MEM];
  TYPIFY `y = z` ASM_CASES_TAC THEN ASM_REWRITE_TAC[arith `n <= n:num`];
    BY(ASM_MESON_TAC[arith `0 < n <=> ~(n=0)`;indexf0]);
  TYPIFY `~(indexf x y s = indexf x z s)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC indexf_inj;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC indexf_betwn_eq [`s`;`x`;`y`;`z`];
  ASM_SIMP_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let flatten_rot1 = prove_by_refinement(
  `!ss. ~(ss = []) ==>
    flatten (rot 1 ss) = rot (sizel (HD ss)) (flatten ss)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.rot1_cons;NOT_CONS_NIL;HD];
  REWRITE_TAC[Seq.flatten_cons;Seq.rot_size_cat;GSYM Seq.cats1];
  BY(REWRITE_TAC[Seq.flatten_cat;Aq1.flatten_sing])
  ]);;
  (* }}} *)

let flatten_rot = prove_by_refinement(
  `!k ss. ?k'. 
    flatten (rot k ss) = (rot k' (flatten ss))`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    GEN_TAC;
    BY(TYPIFY `0` EXISTS_TAC THEN REWRITE_TAC[Seq.rot0]);
  GEN_TAC;
  TYPIFY `ss = []` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[Seq.rot;Seq.flatten0;Seq.drop;Seq.take;Seq.cat0s]);
  REWRITE_TAC[arith `SUC k = 1 + k`];
  TYPIFY `1 + k <= sizel ss` ASM_CASES_TAC;
    GMATCH_SIMP_TAC Seq.rot_addn;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC flatten_rot1;
    ASM_SIMP_TAC[rot_eq_nil];
    FIRST_X_ASSUM (C INTRO_TAC [`ss`]) THEN REPEAT WEAKER_STRIP_TAC THEN ASM_SIMP_TAC[];
    BY(MESON_TAC[Seq2.rot_rot_eq_rot]);
  TYPIFY `0` EXISTS_TAC;
  BY(ASM_MESON_TAC[Seq.rot_oversize;arith `~(n <= s) ==> (s <= n:num)`;Seq.rot0])
  ]);;
  (* }}} *)

let rot_parts = prove_by_refinement(
  `!L N r p.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) ==>    
    (?k. take (sizel p) (rot k r) = p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  TYPIFY `MEM (HD p) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP]);
  TYPIFY `uniq (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Tame_list.uniq_parts]);
  TYPIFY `?k. HD (rot k (parts L r)) = p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.uniq_parts;Pwssrat.rotate_rot_indexl;Tame_list.hd_rotate_to]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC flatten_rot [`k`;`parts L r`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN GMATCH_SIMP_TAC parts_flatten;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `~(flatten (rot k (parts L r)) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[rot_eq_nil]);
  TYPIFY `k'` EXISTS_TAC;
  FIRST_X_ASSUM_ST `x = rot k' r` (SUBST1_TAC o GSYM);
  INTRO_TAC CONS_HD_TL [`(rot k (parts L r))`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Tame_list.parts_nonnil;rot_eq_nil]);
  DISCH_THEN SUBST1_TAC;
  ASM_REWRITE_TAC[Seq.flatten_cons];
  BY(ASM_MESON_TAC[Seq.take_size_cat])
  ]);;
  (* }}} *)

let mem_ifbetwn_hd_extend = prove_by_refinement(
  `!L N r p (x:A#A) y z.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) /\
    MEM x p /\
    MEM z r /\
    MEM y r /\
    ~(FST x = FST y) /\ ~(FST x = FST z) ==>
    (MEM y (ifbetwn r x z) <=> MEM y (ifbetwn r (HD p) z))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC ifbetwn_indexf);
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD p) r /\ MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_HD]);
  ASM_SIMP_TAC[];
  REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
  TYPIFY `~(indexf x y r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  TYPIFY `FST x = FST (HD p)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Tame_list.parts_fst;
    BY(ASM_MESON_TAC[]);
  TYPIFY `~(indexf (HD p) y r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  ASM_REWRITE_TAC[];
  TYPIFY `!u. MEM u p ==> (FST u = FST (HD p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  TYPIFY `!u. MEM u r /\ ~(FST u = FST (HD p)) ==> indexf (HD p) u r = indexf (HD p) x r + indexf x u r` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_ASSUM (C INTRO_TAC [`y`]);
    FIRST_X_ASSUM (C INTRO_TAC [`z`]);
    DISCH_THEN GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_THEN GMATCH_SIMP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    BY(ARITH_TAC);
  COMMENT "u";
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC Tame_list.indexf_add_left;
  ASM_SIMP_TAC[];
  TYPIFY `~MEM u p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC rot_parts [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexf (HD p) x (rot k r) <= indexf (HD p) u (rot k r)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Reduction2.indexf_rotn_alt]);
  TYPIFY `HD p = HD (rot k r)` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC HD_take;
    BY(ASM_REWRITE_TAC[rot_eq_nil;Seq.size_eq0]);
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC indexf_hd);
  ASM_REWRITE_TAC[Seq.mem_rot];
  TYPIFY `rot k r = cat p  (dropl (sizel p) (rot k r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.cat_take_drop]);
  FIRST_ASSUM (SUBST1_TAC);
  REWRITE_TAC[Seq.index_cat];
  ASM_REWRITE_TAC[];
  TYPIFY `indexl x p <= sizel p` ENOUGH_TO_SHOW_TAC;
    BY(ARITH_TAC);
  BY(REWRITE_TAC[Seq.index_size])
  ]);;
  (* }}} *)

let mem_ifbetwn_tl_extend = prove_by_refinement(
  `!L N r p (x:A#A) y z.
    good_list L /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) /\
    MEM z p /\
    MEM x r /\
    MEM y r /\
    ~(FST y = FST z) /\ ~(FST x = FST z) ==>
    (MEM y (ifbetwn r x z) <=> MEM y (ifbetwn r x (LAST p)))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC ifbetwn_indexf);
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) p /\ MEM (LAST p) r /\ MEM z r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST]);
  ASM_SIMP_TAC[];
  REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
  TYPIFY `(indexf x y r = 0)` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[arith `0<=n`]);
  ASM_REWRITE_TAC[];
  TYPIFY `FST z = FST (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  TYPIFY `!u. MEM u p ==> (FST u = FST (LAST p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  TYPIFY `?k a b. HD(rot k r ) = x /\ (rot k r) = cat (cat a p) b` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `indexf x y (rot k r) <= indexf x z (rot k r) <=> indexf x y (rot k r) <= indexf x (LAST p) (rot k r)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Reduction2.indexf_rotn_alt]);
    FIRST_ASSUM_ST `HD` (SUBST1_TAC o GSYM);
    REPEAT (GMATCH_SIMP_TAC indexf_hd);
    REWRITE_TAC[Seq.mem_rot];
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[Seq.index_cat;Seq.mem_cat;Seq.size_cat];
    TYPIFY `~(MEM y p)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    TYPIFY `uniq (rot k r)` (C SUBGOAL_THEN MP_TAC);
      BY(REWRITE_TAC[Seq.rot_uniq] THEN ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[Seq.cat_uniq;GSYM Seq.hasP;Seq.mem_cat];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `~MEM z a /\ ~MEM (LAST p) a` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      ASM_SIMP_TAC[Tame_list.indexl_LAST];
      INTRO_TAC Seq.index_mem [`y`;`a`] THEN ASM_REWRITE_TAC[];
      BY(ARITH_TAC);
    INTRO_TAC Seq.index_mem [`z`;`p`] THEN ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[Tame_list.indexl_LAST];
    BY(ARITH_TAC);
  TYPIFY `?k. take (sizel p) (rot k r) = p` (C SUBGOAL_THEN MP_TAC);
    MATCH_MP_TAC rot_parts;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `r' = rot k r`;
  TYPED_ABBREV_TAC `a = dropl (indexl x r') r'`;
  TYPED_ABBREV_TAC `b = dropl (sizel p) (take (indexl x r') r')`;
  TYPIFY `sizel p <= indexl x r'` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `r' = cat (take (sizel p) r') (dropl (sizel p) r')` (C SUBGOAL_THEN MP_TAC);
      BY(REWRITE_TAC[Seq.cat_take_drop]);
    DISCH_THEN SUBST1_TAC;
    ASM_REWRITE_TAC[Seq.index_cat];
    TYPIFY `~(MEM x p)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  TYPIFY `r' = cat (cat p b) a` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `cat p b = take (indexl x r') r'` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(ASM_MESON_TAC[Seq.cat_take_drop]);
    TYPIFY `take (sizel p) (take (indexl x r') r') = take (sizel p) r'` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Seq.cat_take_drop]);
    MATCH_MP_TAC take_take;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `?k'. rot k' r' = cat a (cat p b)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.rot_size_cat]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq2.rot_rot_eq_rot [`r`;`k'`;`k`] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k''` EXISTS_TAC;
  POP_ASSUM (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[];
  GEXISTL_TAC [`a`;`b`] THEN POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[GSYM Seq.catA];
  DISCH_THEN kill;
  GMATCH_SIMP_TAC hd_cat;
  FULL_EXPAND_TAC "a";
  INTRO_TAC Seq2.index_drop_le [`r'`;`indexl x r'`;`x`];
  REWRITE_TAC[arith `n <= n:num`;arith `n - n = 0`];
  DISCH_TAC;
  INTRO_TAC Tame_list.mem_drop_index [`indexl x r'`;`x`;`r'`];
  ASM_SIMP_TAC[arith `n <= n:num`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.mem_rot;Seq.rot_uniq]);
  BY(ASM_MESON_TAC[Tame_list.index0;List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let flatten_indexl = prove_by_refinement(
  `!R px py x y.  
    all (\p. ~(p=[])) R /\
    uniq (flatten R) /\
    MEM px R /\ MEM py R /\ MEM x px /\ MEM y py /\ ~(px=py) ==>
    (indexl px R < indexl py R <=> 
       indexl x (flatten R) < indexl y (flatten R))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[MEM];
  REWRITE_TAC[Seq.flatten_cons;Seq2.index_cons;Seq.all_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(h=px /\ MEM py t) \/ (h=py /\ MEM px t) \/ (MEM px t /\ MEM py t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cat_uniq;GSYM Seq.hasP;Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(MEM x py) /\ ~(MEM y px)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique]);
  FIRST_X_ASSUM_ST `\/` DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[arith `0 < SUC i`;Seq.index_cat];
    BY(ASM_MESON_TAC[Seq.index_mem;arith `i < s ==> i < s + t:num`]);
  FIRST_X_ASSUM_ST `\/` DISJ_CASES_TAC THEN ASM_REWRITE_TAC[arith `~(SUC i < 0)`;Seq.index_cat];
    MATCH_MP_TAC (arith `i < j ==> ~(j + f < i:num)`);
    BY(ASM_MESON_TAC[Seq.index_mem]);
  TYPIFY `~(px = h) /\ ~(py = h)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `~(MEM x h) /\ ~(MEM y h)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[arith `SUC i < SUC j <=> i < j`;arith `i + u < i + v <=> u < v:num`];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let all_rot = prove_by_refinement(
  `!P k r. all P (rot k r) <=> all P r`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM Seq.allP;Seq.mem_rot])
  ]);;
  (* }}} *)

let flatten_indexf = prove_by_refinement(
  `!R px py pz (y:A) z.  
    all (\p. ~(p=[])) R /\
    uniq (flatten R) /\
    MEM px R /\ MEM py R /\ MEM y py /\ ~(px=py) /\
    MEM pz R /\ MEM z pz /\ ~(px=pz) /\ ~(py=pz) 
==>
    (indexf px py R < indexf px pz R <=> 
       indexf (HD px) y (flatten R) < indexf (HD px) z (flatten R))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq R` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[List_hypermap.uniq_flatten]);
  TYPIFY `?k. HD(rot k R) = px` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pwssrat.rotate_rot_indexl;Tame_list.hd_rotate_to]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!p. MEM p R ==> indexf px p R = indexl p (rot k R)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Ohcgkfu.indexf_indexl_hd;Reduction2.indexf_rotn_alt]);
  ASM_SIMP_TAC[] THEN DISCH_THEN kill;
  INTRO_TAC flatten_rot [`k`;`R`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(R= []) /\ ~(px = [])` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `all` MP_TAC THEN ASM_SIMP_TAC[GSYM Seq.allP];
    BY(ASM_MESON_TAC[MEM]);
  TYPIFY `HD (flatten(rot k R)) = HD (px)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC HD_flatten;
    BY(ASM_REWRITE_TAC[rot_eq_nil]);
  TYPIFY `MEM (HD (px)) px` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  TYPIFY `MEM (HD (px)) (flatten R)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  TYPIFY `!u. MEM u (flatten R) ==> indexf (HD px) u (flatten R) = indexl u (flatten (rot k R))` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[] THEN GMATCH_SIMP_TAC Reduction2.indexf_rotn_alt;
    TYPIFY `k'` EXISTS_TAC;
    ASM_SIMP_TAC[];
    BY(ASM_MESON_TAC[Ohcgkfu.indexf_indexl_hd]);
  TYPIFY `MEM y (flatten R) /\ MEM z (flatten R)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  ASM_SIMP_TAC[];
  INTRO_TAC flatten_indexl [`rot k R`;`py`;`pz`;`y`;`z`];
  BY(ASM_SIMP_TAC[Seq.rot_uniq;Seq.mem_rot;all_rot])
  ]);;
  (* }}} *)

let indexf_map_uniq = prove_by_refinement(
  `!ys d d' (f:A->B).
    MEM d ys /\ MEM d' ys /\ uniq (MAP f ys) ==> 
    indexf (f d') (f d) (MAP f ys) = indexf d' d ys`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Reduction2.indexf_rotate_to_indexl);
  REPEAT (GMATCH_SIMP_TAC Pwssrat.rotate_rot_indexl);
  ASM_SIMP_TAC[MEMf_MAP];
  TYPIFY `uniq ys` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.map_uniq;lower_case]);
  ASM_SIMP_TAC[lower_case;GSYM Seq.map_rot];
  REWRITE_TAC[upper_case];
  GMATCH_SIMP_TAC Reduction3.indexl_map_uniq;
  ASM_SIMP_TAC[Seq.mem_rot];
  SUBCONJ_TAC;
    REWRITE_TAC[lower_case];
    GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
    ASM_SIMP_TAC[Seq.rot_uniq];
    ASM_SIMP_TAC[Seq.rot_uniq;Seq.mem_rot];
    BY(ASM_MESON_TAC[Aq8.uniq_imp_inj;lower_case]);
  DISCH_TAC;
  REPEAT (GMATCH_SIMP_TAC Seq2.index_rot);
  ASM_SIMP_TAC[];
  TYPIFY `indexl (f d') (MAP f ys) = indexl d' ys` ENOUGH_TO_SHOW_TAC;
    SIMP_TAC[];
    BY(ASM_SIMP_TAC[Seq.index_mem]);
  GMATCH_SIMP_TAC Reduction3.indexl_map_uniq;
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let core_lt_indexf = prove_by_refinement(
  `!L N r p x u v .
    good_list L /\
    marked_list L N r x /\
    MEM u r /\ MEM v r /\
    ~(FST (HD p) = FST u) /\
    ~(FST (HD p) = FST v) /\
    ~(FST u = FST v) /\
    MEM p (parts L r) 
  ==>
    (indexf (HD p) u r < indexf (HD p) v r <=>
       indexf (FST (HD p)) (FST u) (core L r) < indexf (FST (HD p)) (FST v) (core L r))
    `,
  (* {{{ proof *)
  [
  REWRITE_TAC[core];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `?pu. MEM pu (parts L r) /\ MEM u pu` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Aq8.parts_mem_exists]);
  TYPIFY `?pv. MEM pv (parts L r) /\ MEM v pv` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Aq8.parts_mem_exists]);
  TYPIFY `uniq p /\ ~(p=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC flatten_indexf [`parts L r`;`p`;`pu`;`pv`;`u`;`v`];
  ASM_REWRITE_TAC[];
  SUBANTS_TAC;
    ASM_SIMP_TAC[Tame_list.parts_all_nonnil];
    ASM_SIMP_TAC[parts_flatten];
    BY(ASM_MESON_TAC[Tame_list.parts_fst]);
  ASM_SIMP_TAC[parts_flatten];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (SUBST1_TAC o GSYM);
  TYPIFY `FST u = (FST o HD) (pu)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[o_THM;parts_fst]);
  TYPIFY `FST v = (FST o HD) (pv)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[o_THM;parts_fst]);
  MATCH_MP_TAC (arith `(a' = a /\ b' = b) ==> (a < b <=> a' < b':num)`);
  REPEAT (GMATCH_SIMP_TAC indexf_map_uniq);
  TYPIFY `FST (HD p) = (FST o HD) p` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[o_THM]);
  REPEAT (GMATCH_SIMP_TAC indexf_map_uniq);
  ASM_REWRITE_TAC[GSYM core];
  BY(ASM_MESON_TAC[marked_list_uniq_core])
  ]);;
  (* }}} *)

let hd_core = prove_by_refinement(
  `!L N r.
    normal_list L N /\
    MEM r N ==>
    HD (core L r) = FST (HD r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Tame_list.HD_MAP;
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_SIMP_TAC[parts_nonnil;o_THM];
  GMATCH_SIMP_TAC (GSYM HD_flatten);
  GMATCH_SIMP_TAC parts_flatten;
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[parts_nonnil]);
  DISCH_TAC;
  BY(ASM_MESON_TAC[MEM_HD;parts_uniq_nonnil])
  ]);;
  (* }}} *)

let core_betwn = prove_by_refinement(
  `!L N r x u v w.
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x /\
    ~final_list L r /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    MEM u r /\ MEM v r /\ MEM w r /\
    ~(FST u = FST v) /\ ~(FST v = FST w) /\ ~(FST u = FST w) ==>
    (MEM v (ifbetwn r u w) <=> 
       MEM (FST v) (ifbetwn (core L r) (FST u) (FST w)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `normal_list L N /\ uniq r /\ ~(r = []) /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  TYPIFY `?pu. MEM pu (parts L r) /\ MEM u pu` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Aq8.parts_mem_exists]);
  TYPIFY `?pv. MEM pv (parts L r) /\ MEM v pv` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Aq8.parts_mem_exists]);
  TYPIFY `?pw. MEM pw (parts L r) /\ MEM w pw` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Aq8.parts_mem_exists]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(pu= pv) /\ ~(pv = pw) /\ ~(pu = pw)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  INTRO_TAC mem_ifbetwn_hd_extend [`L`;`N`;`r`;`pu`;`u`;`v`;`w`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC mem_ifbetwn_tl_extend [`L`;`N`;`r`;`pw`;`HD pu`;`v`;`w`];
  DISCH_THEN GMATCH_SIMP_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `uniq pu /\ ~(pu = []) /\ uniq pw /\ ~(pw = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (HD pu) pu /\ MEM (LAST pw) pw` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD;MEM_LAST]);
  TYPIFY `MEM (HD pu) r /\ MEM (LAST pw) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP]);
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[parts_fst]);
  DISCH_TAC;
  REPEAT (GMATCH_SIMP_TAC ifbetwn_indexf);
  ASM_SIMP_TAC[];
  SUBCONJ_TAC;
    nCONJ_TAC 3;
      BY(ASM_MESON_TAC[marked_list_uniq_core]);
    BY(ASM_MESON_TAC[mem_fst_core]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[arith `0 < n <=> ~(n=0)`];
  TYPIFY `~(indexf (FST u) (FST v) (core L r) = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[indexf0]);
  TYPIFY `~(HD pu = v)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique;parts_flatten]);
  TYPIFY `~(indexf (HD pu) v r = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[indexf0]);
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (flatten (parts L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  TYPIFY `~(LAST pw = v)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique]);
  TYPIFY `indexf (HD pu) v r = indexf (HD pu) (LAST pw) r` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[indexf_inj]);
  ASM_SIMP_TAC[arith `~(x = y) ==> (x <= y <=> x < y:num)`];
  TYPIFY `indexf (FST u) (FST v) (core L r) = indexf (FST u) (FST w) (core L r)` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[indexf_inj]);
  ASM_SIMP_TAC[arith `~(x = y) ==> (x <= y <=> x < y:num)`];
  GMATCH_SIMP_TAC core_lt_indexf;
  TYPIFY `L` EXISTS_TAC THEN ASM_SIMP_TAC[];
  TYPIFY `(FST (HD pu) = FST u ) /\ (FST (LAST pw) = FST w)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_fst]);
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let ifbetwn_refl = prove_by_refinement(
  `!x s. ifbetwn s x x = []`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[ifbetwn])
  ]);;
  (* }}} *)

let final_assumption_not_mem_snd_x_fy = prove_by_refinement(
  `!L N r x k.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    ~final_list L r  /\
    (transform_count L N r x = k)
  ==>
    (!i. i < k /\
                   1 <
                   sizel
                   (ftrans L N r x i ::
                    ifbetwn (core L r) (ftrans L N r x i)
                    (FST (ytrans L N r x i)))
                   ==> ~MEM (SND x)
                        (ifbetwn (core L r) (ftrans L N r x i)
                        (FST (ytrans L N r x i))))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `ftrans L N r x i = FST (ytrans L N r x i)` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `sizel` MP_TAC THEN ASM_REWRITE_TAC[Seq.size_cons;arith `1 < SUC i <=> ~(i=0)`;Seq.size_eq0;ifbetwn_refl]);
  FIRST_X_ASSUM_ST `sizel` kill;
  INTRO_TAC ifbetwn_disjoint [`(ftrans L N r x i)`;`(FST (ytrans L N r x i))`;`SND x`;`core L r`];
  ASM_SIMP_TAC[];
  REWRITE_TAC[ftrans];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REPEAT (FIRST_X_ASSUM_ST `ftrans` MP_TAC) THEN ASM_REWRITE_TAC[ftrans;ifbetwn];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
    BY(REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat;MEM]);
  INTRO_TAC (GSYM More_lemma2.FST_next_face_eq_SND) [`L`;`N`;`r`;`x`] THEN ASM_SIMP_TAC[];
  INTRO_TAC (GSYM core_betwn) [`L`;`N`;`r`;`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_SIMP_TAC[];
  TYPIFY `MEM (ytrans L N r x i) r /\  MEM (next_el (find_face L x) x) r /\  MEM (ztrans L N r x (PRE i)) r /\  MEM (ytrans L N r x i) (find_face L x) /\  MEM (ztrans L N r x (PRE i)) (find_face L x) /\ MEM (next_el (find_face L x) x) (find_face L x) ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[final_assumption_mem_uniq;arith `~(i=0) /\ i < k ==> PRE i < k`]);
  ASM_SIMP_TAC[];
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.is_restricted_all_uniq]);
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  INTRO_TAC (GEN_ALL Qcdvkea.QCDVKEA) [`L`;`N`;`r`;`find_face L x`;`next_el (find_face L x) x`;`x`;`PRE i`];
  INTRO_TAC (GEN_ALL Pplhulj.PPLHULJ3) [`next_el (find_face L x) x`;`find_face L x`;`L`;`N`;`r`;`x`;`0`;`PRE i`];
  ASM_SIMP_TAC[];
  (ASM_SIMP_TAC[arith `~(i=0) ==> SUC (PRE i)= i`]);
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not;arith `i < k ==> PRE i < k`];
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    TYPIFY `~(next_el (find_face L x) x = ytrans L N r x i) /\ ~(next_el (find_face L x) x = ztrans L N r x (PRE i)) /\ ~(ytrans L N r x i = ztrans L N r x (PRE i))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Reduction1.simple_list]);
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[ftrans]);
    ASM_REWRITE_TAC[];
    TYPIFY `~(indexf (next_el (find_face L x) x) (ztrans L N r x (PRE i))      (find_face L x) = 0) /\ ~(indexf (next_el (find_face L x) x) (ytrans L N r x (i))      (find_face L x) = 0)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Tame_list.indexf_refl]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "last subgoal";
  GMATCH_SIMP_TAC ifbetwn_cover;
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil;marked_list]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[ifbetwn];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[MEM;GSYM Seq.cats1;Seq.mem_cat;DE_MORGAN_THM];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexf_add_betwn [`(ztrans L N r x (PRE i))`;`(next_el (find_face L x) x)`;`(ytrans L N r x i)`;`r`];
  ASM_SIMP_TAC[DE_MORGAN_THM];
  INTRO_TAC indexf_antisym [`(ztrans L N r x (PRE i))`;`(next_el (find_face L x) x)`;`r`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexf_lt_sizel [`r`;`(ztrans L N r x (PRE i))`;`(ytrans L N r x i)`];
  ASM_SIMP_TAC[];
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x`;
  TYPED_ABBREV_TAC `z = ztrans L N r x (PRE i)`;
  TYPED_ABBREV_TAC `y = ytrans L N r x i`;
  INTRO_TAC (GEN_ALL Ryiuuvk.RYIUUVK) [`w`;`L`;`N`;`r`;`x`;`PRE i`];
  ASM_SIMP_TAC[arith `~(i=0) ==> SUC (PRE i) = i`;Kbwpbhq.transform_count_not];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_not_mem_snd_x_zx = prove_by_refinement(
  `!L N r x k.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    ~final_list L r  /\
    (transform_count L N r x = k)
  ==>
     ~(MEM (SND x) 
	 (ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  TYPIFY `FST (ztrans L N r x (PRE k)) = FST x` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `ifbetwn` MP_TAC THEN ASM_REWRITE_TAC[ifbetwn;MEM]);
  INTRO_TAC ifbetwn_disjoint [`FST (ztrans L N r x (PRE k))`;`FST x`;`SND x`;`core L r`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM More_lemma2.FST_next_face_eq_SND) [`L`;`N`;`r`;`x`] THEN ASM_SIMP_TAC[];
  INTRO_TAC (GSYM core_betwn) [`L`;`N`;`r`;`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_SIMP_TAC[];
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  TYPIFY `MEM x r /\ MEM (next_el (find_face L x) x) r /\  MEM (ztrans L N r x (PRE k)) r /\ MEM x (find_face L x) /\ MEM (next_el (find_face L x) x) (find_face L x) /\  MEM (ztrans L N r x (PRE k)) (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;final_assumption_mem_uniq;arith `~(k=0) ==> PRE k < k`]);
  ASM_SIMP_TAC[];
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.is_restricted_all_uniq]);
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  TYPIFY `uniq r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  INTRO_TAC next_el_refl [`x`;`find_face L x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC (GEN_ALL Pplhulj.PPLHULJ3) [`next_el (find_face L x) x`;`find_face L x`;`L`;`N`;`r`;`x`;`0`;`PRE k`];
  ASM_SIMP_TAC[];
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not;arith `~(k=0) ==> PRE k < k`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;List_hypermap.good_list]);
  TYPIFY `~(next_el (find_face L x) x = x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  SUBCONJ_TAC;
    TYPIFY ` ~( (ztrans L N r x (PRE k)) =  (next_el (find_face L x) x))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Reduction1.simple_list]);
    DISCH_TAC;
    BY(ASM_MESON_TAC[arith `i < j ==> ~(j=0)`;Tame_list.indexf_refl]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "last subgoal";
  GMATCH_SIMP_TAC ifbetwn_indexf;
  ASM_SIMP_TAC[arith `(0 < i) <=> ~(i=0)`];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  DISCH_TAC;
  MATCH_MP_TAC (arith `(i = 1 /\ ~(j=0) ==> i <= j)`);
  CONJ2_TAC;
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  MATCH_MP_TAC Tame_list.next_el_indexf;
  ASM_SIMP_TAC[];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[ Tame_list.sizel_gt_1]);
  TYPIFY `next_el r x = f_list L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  BY(ASM_MESON_TAC[List_hypermap.f_list])
  ]);;
  (* }}} *)

let final_assumption_index_snd_x = prove_by_refinement(
  `!L N r x k.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    marked_list L N r x /\
    ~final_list L r  /\
    (transform_count L N r x = k)
  ==>
   (!i. i < k ==>  
	indexf (SND x) (FST (ytrans L N r x i)) (core L r) < 
	indexf (SND x) (FST (ztrans L N r x i)) (core L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  TYPIFY `uniq (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list_uniq_core]);
  INTRO_TAC (GSYM More_lemma2.FST_next_face_eq_SND) [`L`;`N`;`r`;`x`] THEN ASM_SIMP_TAC[];
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `i < k ==> ~(k=0)`]);
  TYPIFY `MEM x r /\ MEM (next_el (find_face L x) x) r /\  MEM (ztrans L N r x i) r /\ MEM (ytrans L N r x i) r /\ MEM x (find_face L x) /\ MEM (next_el (find_face L x) x) (find_face L x) /\  MEM (ztrans L N r x i) (find_face L x) /\  MEM (ytrans L N r x i) (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;final_assumption_mem_uniq;arith `~(k=0) ==> PRE k < k`]);
  ASM_SIMP_TAC[];
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  TYPIFY `all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.is_restricted_all_uniq]);
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  TYPIFY `uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  TYPIFY `uniq (find_face L x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;List_hypermap.good_list]);
  DISCH_TAC;
  INTRO_TAC (GEN_ALL Aq8.parts_mem_exists) [`x`;`L`;`r`];
  ASM_SIMP_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_el_parts_last [`L`;`r`;`p`;`x`];
  ASM_SIMP_TAC[];
  TYPED_ABBREV_TAC `p' = next_el (parts L r) p`;
  TYPIFY `next_el r x = f_list L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (flatten (parts L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  TYPIFY `LAST p = x` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC f_list_imp_last [`L`;`r`;`x`];
    ASM_SIMP_TAC[];
    REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC;
    TYPIFY `uniq x' /\ ~(x' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[parts_uniq_nonnil;marked_list]);
    TYPIFY `MEM x x'` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_REWRITE_TAC[] THEN ASM_SIMP_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique;]);
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `next_el (find_face L x) x = HD p'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.f_list]);
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (FST (ytrans L N r x i)) (core L r) /\ MEM (FST (ztrans L N r x i)) (core L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_fst_core]);
  TYPIFY `~(FST (ytrans L N r x i) = (FST (ztrans L N r x i)))` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY ` ~( (ytrans L N r x i) =  ztrans L N r x i)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Reduction1.simple_list]);
    DISCH_TAC;
    BY(ASM_MESON_TAC[Pplhulj.PPLHULJ3;Kbwpbhq.transform_count_not;arith `~(i < i:num)`]);
  TYPIFY `FST (next_el (find_face L x) x) = FST (ytrans L N r x i)` ASM_CASES_TAC;
    POP_ASSUM MP_TAC THEN ASM_SIMP_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC indexf_refl;
    ASM_REWRITE_TAC[arith `0 < i <=> ~(i=0)`];
    BY(ASM_MESON_TAC[Tame_list.indexf0]);
  COMMENT "convert core";
  INTRO_TAC (GSYM core_lt_indexf) [`L`;`N`;`r`;`p'`;`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_SIMP_TAC[];
  nCONJ_TAC 2;
    FULL_EXPAND_TAC "p'";
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 2;
    TYPIFY `HD p'` FULL_RIGHT_EXPAND_TAC;
    INTRO_TAC (GEN_ALL Diowaas.DIOWAAS) [`next_el (find_face L x) x`;`L`;`N`;`r`;`x`;`i`];
    BY(ASM_SIMP_TAC[Kbwpbhq.transform_count_not;]);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `HD p'` FULL_RIGHT_EXPAND_TAC;
  TYPIFY `~( (ztrans L N r x i) =  (next_el (find_face L x) x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Reduction1.simple_list]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC indexf_refl;
  BY(ASM_REWRITE_TAC[arith `~(i < 0)`])
  ]);;
  (* }}} *)


let next_el_core_last = prove_by_refinement(
  `!L N r p.
    good_list L /\
    good_list_nodes L  /\
    all uniq L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    uniq (core L r) /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r) 
    ==>
    next_el (core L r) (FST (LAST p)) = SND (LAST p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC More_lemma2.next_core_FST_SYM [`L`;`N`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_SIMP_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST]);
  INTRO_TAC normal_list_parts_next_last [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC Tame_list.f_list_fst_snd;
  ASM_REWRITE_TAC[];
  INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`N`];
  ASM_SIMP_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let next_el_core_imp_eq_last = prove_by_refinement(
  `!L N N' r r' p p' y.
    good_list L /\
    good_list_nodes L  /\
    all uniq L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r)  /\
    uniq (core L r) /\
    normal_list L N' /\
    MEM r' N' /\
    MEM p' (parts L r')  /\
    uniq (core L r') /\
    MEM y p /\ MEM y p' /\
    next_el (core L r) (FST y) = next_el (core L r') (FST y) ==>
    (LAST p = LAST p')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[PAIR_EQ2];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `uniq p' /\ ~(p' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `MEM (LAST p) p /\ MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  TYPIFY `FST (LAST p) = FST y /\ FST (LAST p') = FST y` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.parts_fst]);
  ASM_REWRITE_TAC[];
  INTRO_TAC next_el_core_last [`L`;`N`;`r`;`p`];
  INTRO_TAC next_el_core_last [`L`;`N'`;`r'`;`p'`];
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let next_el_core_imp_next_f = prove_by_refinement(
  `!L N N' r r' p p' y.
    good_list L /\
    good_list_nodes L  /\
    all uniq L /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM p (parts L r)  /\
    uniq (core L r) /\
    normal_list L N' /\
    MEM r' N' /\
    MEM p' (parts L r')  /\
    uniq (core L r') /\
    MEM y p /\ MEM y p' /\
    next_el (core L r) (FST y) = next_el (core L r') (FST y) /\
    next_el r' y = f_list L y
    ==>
    next_el r y = f_list L y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_el_core_imp_eq_last [`L`;`N`;`N'`;`r`;`r'`;`p`;`p'`;`y`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `uniq r' /\ ~(r'=[]) /\ uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq (flatten (parts L r'))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  TYPIFY `MEM y r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq8.MEM_PARTS_IMP;MEM_LAST]);
  TYPIFY `MEM y (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`N'`];
    ASM_SIMP_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `LAST p' = y` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC f_list_imp_last [`L`;`r'`;`y`];
    ASM_SIMP_TAC[];
    REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC;
    TYPIFY `uniq x /\ ~(x = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[parts_uniq_nonnil;marked_list]);
    TYPIFY `MEM y x` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_REWRITE_TAC[] THEN ASM_SIMP_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique;]);
  INTRO_TAC normal_list_parts_next_last [`L`;`N`;`r`;`p`];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let bet_eq_nil_imp_next_y_z = prove_by_refinement(
  `!L N r (x:A#A) k i.
    good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
    transform_count L N r x = k /\
    i < k /\
    (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) =
               [])
               ==> 
    (next_el (rtrans L N r x (SUC i))
	( (ytrans L N r x i)) =
	( (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  INTRO_TAC Reduction3.rtrans1 [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_SIMP_TAC[GSYM trans_add;arith `1+i = SUC i`];
  GMATCH_SIMP_TAC Kbwpbhq.transform_count_not;
  ASM_REWRITE_TAC[];
  DISCH_THEN (ASSUME_TAC o GSYM);
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `marked_list L (ntrans L N r x (SUC i)) (rtrans L N r x (SUC i)) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x (SUC i))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (rtrans L N r x (SUC i)) (ntrans L N r x (SUC i))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (rtrans L N r x (SUC i)) /\ ~(rtrans L N r x (SUC i) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC split_normal_list [`L`;`rtrans L N r x i`;`(find_face L x)`;`ytrans L N r x i`;`prev_el (rtrans L N r x i) (ztrans L N r x i)`];
  ASM_REWRITE_TAC[LET_THM;lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `marked_list L (ntrans L N r x i) (rtrans L N r x i) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (rtrans L N r x i) (ntrans L N r x i) /\ uniq (rtrans L N r x i) /\ ~(rtrans L N r x i  = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0;Seq.map;rev0;Seq.cat0s];
  ONCE_REWRITE_TAC[PAIR_EQ2];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `FST` kill;
  TYPIFY `cat [ztrans L N r x i]      (cat (betwn (rtrans L N r x i) (ztrans L N r x i) (ytrans L N r x i))      [ytrans L N r x i]) = rtrans L N r x (SUC i)` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    TYPIFY `rtrans L N r x (SUC i)` FULL_RIGHT_EXPAND_TAC;
    COMMENT "L'Y";
    TYPIFY `l'y L (rtrans L N r x i) x = ytrans L N r x i /\ l'z L (ntrans L N r x i) (rtrans L N r x i) x = ztrans L N r x i /\ find_face L (ytrans L N r x i) = find_face L x` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    REWRITE_TAC[l_expand];
    INTRO_TAC Pplhulj.ytran_me_f [`L`;`N`;`r`;`x`;`find_face L x`;`i`];
    ASM_REWRITE_TAC[];
    INTRO_TAC List_hypermap.mem_find_face_imp_faces_eq [`ytrans L N r x i`;`x`;`L`];
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  TYPIFY `HD (rtrans L N r x (SUC i)) = ztrans L N r x i /\ LAST (rtrans L N r x (SUC i)) = ytrans L N r x i` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM (SUBST1_TAC o GSYM);
    REWRITE_TAC[HD;Seq.cat1s];
    REWRITE_TAC[LAST;cat_eq_nil;NOT_CONS_NIL];
    BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
  TYPIFY `next_el (rtrans L N r x (SUC i)) (LAST (rtrans L N r x (SUC i))) = (HD (rtrans L N r x (SUC i)))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Aq4.next_el_last_hd;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let bet_eq_nil_imp_next_z_y = prove_by_refinement(
  `!L N r (x:A#A) f1.
    good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
    (FST (split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) 
	 (prev_el r (ztrans L N r x 0))) = f1) /\
    (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) =
               [])
               ==> 
    (next_el f1
	(prev_el r (ztrans L N r x 0)) =
	(next_el r (ytrans L N r x 0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (rtrans L N r x 1) (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (rtrans L N r x 1) /\ ~(rtrans L N r x 1 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC split_normal_list [`L`;`r`;`(find_face L x)`;`ytrans L N r x 0`;`prev_el r (ztrans L N r x 0)`];
  ASM_REWRITE_TAC[LET_THM;lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `MEM r N /\ uniq r /\ ~(r=[])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0;Seq.map;rev0;Seq.cat0s];
  ONCE_REWRITE_TAC[PAIR_EQ2];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM kill;
  TYPIFY `next_el r (ytrans L N r x 0) = HD f1 /\ prev_el r (ztrans L N r x 0) = LAST f1 /\ ~(f1 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM (SUBST1_TAC o GSYM);
    REWRITE_TAC[HD;Seq.cat1s;NOT_CONS_NIL];
    REWRITE_TAC[LAST;cat_eq_nil;NOT_CONS_NIL];
    BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
  INTRO_TAC Aq1.uniq_fst_split_norm [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `(FST      (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x)      (prev_el r (l'z L N r x)))) = f1` (C SUBGOAL_THEN ASSUME_TAC);
    REPLICATE_TAC 3 (POP_ASSUM kill);
    FULL_EXPAND_TAC "f1";
    GMATCH_SIMP_TAC Reduction2.find_face_x_eq_y;
    REWRITE_TAC[Reduction2.trans0];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN ASM_REWRITE_TAC[] THEN DISCH_TAC;
  FIRST_X_ASSUM_ST `~(next_el f1 a = next_el r u)` MP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC Aq4.next_el_last_hd;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mem_y_rtrans1 = prove_by_refinement(
  `!L N r x.
    good_list L /\
            good_list_nodes L /\
    ~final_list L r /\
            marked_list L N r x ==>
    MEM (ytrans L N r x 0) (rtrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq12.y_mem_split_snd) [`l'z L N r x`;`find_face L (l'y L r x)`;`prev_el r (l'z L N r x)`;`l'y L r x`;`rtrans L N r x 1`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  ANTS_TAC;
    BY(ASM_SIMP_TAC[ rtrans1]);
  BY(MESON_TAC[Reduction2.trans0])
  ]);;
  (* }}} *)

let mem_ytrans_rtrans_suc = prove_by_refinement(
  `!L N r x i.
    good_list L /\
            good_list_nodes L /\
    ~final_list L r /\
            marked_list L N r x /\
    i < transform_count L N r x ==>
    MEM (ytrans L N r x i) (rtrans L N r x (SUC i))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[arith `i = 0 + i`];
  REWRITE_TAC[arith `0 + SUC i = 1 + i`];
  REWRITE_TAC[trans_add];
  MATCH_MP_TAC mem_y_rtrans1;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not];
  MATCH_MP_TAC AQIUNPP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let fst_yi_ne_fst_zi = prove_by_refinement(
  `!L N r x k i.
            good_list L /\
            good_list_nodes L /\
            is_restricted (hypermap_of_list L) /\
            marked_list L N r x /\
            ~final_list L r /\
            transform_count L N r x = k /\
            i < k
            ==> ~(FST (ytrans L N r x i) = FST (ztrans L N r x i))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MP_TAC THEN REWRITE_TAC[];
  ONCE_REWRITE_TAC[arith `i = 0 + i`] THEN REWRITE_TAC[trans_add];
  MATCH_MP_TAC final_assumption_fst_y_neq_fst_z;
  TYPIFY `k- (i:num)` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not];
  GMATCH_SIMP_TAC Reduction3.transform_count_add;
  ASM_SIMP_TAC[arith `i < k ==> i <= k:num`];
  MATCH_MP_TAC AQIUNPP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let ne_fst_imp_f_list = prove_by_refinement(
  `!L N r u v.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM u r /\
    uniq (core L r) /\
    ~(FST u = FST v) /\
    next_el r u = v 
    ==> f_list L u = v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.loop_list_f_or_ni [`L`;`r`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[normal_list;Seq.allP]);
  TYPIFY `f_list L u = v` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "v";
  DISCH_TAC;
  FIRST_X_ASSUM_ST `FST` MP_TAC THEN REWRITE_TAC[];
  POP_ASSUM MP_TAC;
  GMATCH_SIMP_TAC (GSYM Tame_list.inverse_node_map_list);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`N`];
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  DISCH_TAC;
  SIMP_TAC[] THEN DISCH_TAC;
  INTRO_TAC (GSYM List_hypermap.fst_node_hypermap_of_list) [`L`;`u`];
  ASM_REWRITE_TAC[] THEN DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Hypermap.lemma_inverse_in_node;
  BY(REWRITE_TAC[Hypermap.node_refl])
  ]);;
  (* }}} *)

let final_assumptions_not_next_core_0_i = prove_by_refinement(
  `!L N r (x:A#A) k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     (!i. i < k /\
            betwn (find_face L x) (ytrans L N r x i)
            (ztrans L N r x i) =
             []
             ==> ~(next_el (core L r) (FST (ytrans L N r x i)) = 
		 FST (ztrans L N r x i))) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC bet_eq_nil_imp_next_y_z [`L`;`N`;`r`;`x`;`k`;`i`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `all uniq L /\ is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted_all_uniq;Hypermap.is_restricted]);
  TYPIFY `normal_list L N /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `MEM (ytrans L N r x i) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[final_assumption_mem_uniq]);
  INTRO_TAC (GEN_ALL Aq8.parts_mem_exists) [`ytrans L N r x i`;`L`;`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_list_uniq_core [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `marked_list L (ntrans L N r x (SUC i)) (rtrans L N r x (SUC i)) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `marked_list L (ntrans L N r x ( i)) (rtrans L N r x ( i)) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x (SUC i))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (rtrans L N r x (SUC i)) (ntrans L N r x (SUC i))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (rtrans L N r x (SUC i)) /\ ~(rtrans L N r x (SUC i) = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (ytrans L N r x i) (rtrans L N r x (SUC i))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC mem_ytrans_rtrans_suc;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC (GEN_ALL Aq8.parts_mem_exists) [`ytrans L N r x i`;`L`;`(rtrans L N r x (SUC i))`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_list_uniq_core [`L`;`ntrans L N r x (SUC i)`;`rtrans L N r x (SUC i)`;`x`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  INTRO_TAC fst_yi_ne_fst_zi [`L`;`N`;`r`;`x`;`k`;`i`];
  ASM_REWRITE_TAC[];
  PROOF_BY_CONTR_TAC;
  TYPIFY `next_el (core L (rtrans L N r x (SUC i))) (FST (ytrans L N r x i)) = next_el (core L r) (FST (ytrans L N r x i))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC next_core_ne_FST;
    TYPIFY `ntrans L N r x (SUC i)` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC ne_fst_imp_f_list [`L`;`ntrans L N r x (SUC i)`;`rtrans L N r x (SUC i)`;`ytrans L N r x i`;`ztrans L N r x i`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC next_el_core_imp_next_f [`L`;`N`;`ntrans L N r x (SUC i)`;`r`;`rtrans L N r x (SUC i)`;`p`;`p'`;`ytrans L N r x i`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  INTRO_TAC Kbwpbhq.KBWPBHQ1 [`L`;`N`;`r`;`x`;`ytrans L N r x i`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  TYPIFY_GOAL_THEN `(?i'. ytrans L N r x i' = ytrans L N r x i /\ i' < k)` (unlist REWRITE_TAC);
    BY(TYPIFY `i` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `find_list N (ytrans L N r x i) = r` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Tame_list.find_list_uniq;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list]);
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[final_assumption_mem_uniq])
  ]);;
  (* }}} *)

let final_assumptions_not_next_core0_z_y = prove_by_refinement(
  `!L N r (x:A#A). 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r 
  ==>
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) =
               []
               ==> ~(next_el (core L (rtrans L N r x 0))
                     (FST (ztrans L N r x 0)) =
                     FST (ytrans L N r x 0)))
     `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `f1 = FST       (split_normal_list L r (find_face L x) (ytrans L N r x 0)       (prev_el r (ztrans L N r x 0)))`;
  INTRO_TAC bet_eq_nil_imp_next_z_y [`L`;`N`;`r`;`x`;`f1`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `all uniq L /\ is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted_all_uniq;Hypermap.is_restricted]);
  TYPIFY `normal_list L N /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPED_ABBREV_TAC `z' = prev_el r (ztrans L N r x 0)`;
  TYPIFY `MEM (ztrans L N r x 0) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Hojodcm.mem_ztrans_rtrans_v0]);
  TYPIFY `MEM z' r` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "z'";
    BY(ASM_SIMP_TAC[Seq2.mem_prev_el]);
  INTRO_TAC (GEN_ALL Aq8.parts_mem_exists) [`z'`;`L`;`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_list_uniq_core [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM (rtrans L N r x 1) (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `uniq (rtrans L N r x 1) /\ ~(rtrans L N r x 1 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `(FST (split_normal_list L r (find_face L (l'y L r x)) (l'y L r x) (prev_el r (l'z L N r x)))) = f1` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "f1";
    FULL_EXPAND_TAC "z'";
    GMATCH_SIMP_TAC Reduction2.find_face_x_eq_y;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    BY(REWRITE_TAC[GSYM Reduction2.trans0]);
  TYPIFY `MEM f1 (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  TYPIFY `MEM z' f1` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC (GEN_ALL Aq12.prev_z_mem_split_snd);
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  INTRO_TAC (GEN_ALL Aq8.parts_mem_exists) [`z'`;`L`;`f1`];
  TYPIFY `uniq f1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq1.uniq_fst_split_norm]);
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (core L f1)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `marked_list` MP_TAC;
    REWRITE_TAC[marked_list;LET_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `all uniq` MP_TAC;
    REWRITE_TAC[quotient_list_core;GSYM Seq.allP];
    DISCH_THEN MATCH_MP_TAC;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC fst_yi_ne_fst_zi [`L`;`N`;`r`;`x`;`transform_count L N r x`;`0`];
  ASM_REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
  ASM_SIMP_TAC[Reduction3.transform_count_non0];
  PROOF_BY_CONTR_TAC;
  TYPED_ABBREV_TAC `y' = next_el r (ytrans L N r x 0)`;
  TYPIFY `FST (ytrans L N r x 0) = FST y'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq1.FST_EQ_NEXT_YTRANS_v0;Reduction2.trans0]);
  TYPIFY `FST (ztrans L N r x 0) = FST z'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq1.FST_EQ_PREV_ZTRANS_v0;Reduction2.trans0]);
  TYPIFY `next_el (core L f1) (FST z') = next_el (core L r) (FST z')` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `rtrans L N r x 0` MP_TAC THEN ASM_SIMP_TAC[];
    SIMP_TAC[Reduction2.trans0];
    DISCH_TAC;
    MATCH_MP_TAC next_core_ne_FST;
    TYPIFY `ntrans L N r x 1` EXISTS_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC ne_fst_imp_f_list [`L`;`ntrans L N r x 1`;`f1`;`z'`;`y'`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC next_el_core_imp_next_f [`L`;`N`;`ntrans L N r x 1`;`r`;`f1`;`p`;`p'`;`z'`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  POP_ASSUM MP_TAC THEN FULL_EXPAND_TAC "z'";
  REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.next_prev_id;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let reduction_K4 = prove_by_refinement(
  `(!L N r (x:num#num) k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     // END ASSUMPTIONS

     // mem_z0_ri
     // (!i. i < k     ==> MEM (ztrans L N r x 0) (rtrans L N r x i)) /\

     // betwn_corek_z_x
     (~(FST(ztrans L N r x (PRE k)) = FST x) ==>  
	(betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	    betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x))) /\

     // betwn_core0_z_y
     // July 19 2014 corrected.
     (!i. SUC i < k /\  ~(FST (ztrans L N r x i) = FST (ytrans L N r x (SUC i))) ==>
	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
	    betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
	      (FST (ytrans L N r x (SUC i))))) /\

     // not_next_core0_z_y
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
	 ==> ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
             FST (ytrans L N r x 0))) /\

     // not_next_core0_y_z  // corei_reduction.
     // (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
//	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
//	     FST (ztrans L N r x i))) /\

     ((betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []) ==>
	 ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	     FST (ztrans L N r x 0))) /\

     // not_mem_yi_zi_list_of_darts_weak
//     (!i. i < k /\
//        betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
//         ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i)) r) 
     // edited Jul 23 2014
     (!i. i < k /\
        betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
         ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i)) (list_pairs (core L r))) 

// /\

     // not_mem_yi_zi_list_of_darts
//     (!i. i < k /\
//        betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = []
//         ==> ~MEM (FST (ytrans L N r x i),FST (ztrans L N r x i))
//         (list_of_darts (quotient_list L N))) /\

     // n1_diff_n0
//     (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
//	 set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) 
// /\

     // index_snd_x
//     (!i. i < k ==>  
//	indexf (SND x) (FST (ytrans L N r x i)) (core L r) < 
//	indexf (SND x) (FST (ztrans L N r x i)) (core L r))  
// /\ 

     // not_mem_snd_x_zx
//     ~(MEM (SND x) ((ifbetwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)))) /\

     // not_mem_snd_x_fy replaced Jul 22 2014.
//     (!i. i < k /\
//              1 <
//              sizel
//              (ftrans L N r x i ::
//               ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i)))
//              ==> ~MEM (SND x)
//                   (ifbetwn (core L r) (ftrans L N r x i)
//                   (FST (ytrans L N r x i)))) 
//     (!i. i < k ==> 
//	~MEM (SND x) (ifbetwn (core L r) (ftrans L N r x i) (FST (ytrans L N r x i))))

   ) ==> assumption_setK10`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC reduction_K3;
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 3;
    BY(ASM_MESON_TAC[corei_reduction]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 8;
    BY(ASM_MESON_TAC[list_of_darts_reduction]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`]);
  COMMENT "cases";
  (ASM_SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_reduction_mem_z0_ri]);
  CONJ_TAC;
    BY(ASM_SIMP_TAC[n1_diff_n0]);
  CONJ_TAC;
    MATCH_MP_TAC final_assumption_not_mem_snd_x_zx;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC final_assumption_not_mem_snd_x_fy;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC final_assumption_index_snd_x;
    BY(ASM_REWRITE_TAC[]);
  ]);;
  (* }}} *)



end;;
