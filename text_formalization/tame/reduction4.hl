(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: July 12, 2014                                                 *)
(* ========================================================================== *)


(* Bauer-Nipkow Isabelle tame graph compatibility checks *)

module Reduction4 = struct

open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Reduction3;;

(*    *)


(* ............... NEW DEFS *)


let ftrans = new_definition'
  `!L N r (x:A#A) i. ftrans L N r x i = if i = 0 then SND x else FST (ztrans L N r x (PRE i))`;;

let ifbetwn = new_definition'
  `!s (x:A) y. ifbetwn s x y = if MEM x s /\ MEM y s /\ ~(x=y) then rcons (betwn s x y) y else []`;;


let assumption_setK8 = new_definition'
  `assumption_setK8 <=> (!L N r x k uvns vs vs' fx v.
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      element_pre L N /\  // added July 13 2014
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      core_triple_v4 L N r x = uvns /\
      dest_triple_full (core L r) v uvns = vs /\
      MAP the (filter isSome vs) = vs' /\
       transform_count L N r x = k /\
        find_face L x = fx /\
      prev_el (core L r) v,v = x 
      ==> 
      //  added for reduction_D: July 10 2014
     uniq (core L (rtrans L N r x k)) /\
     MEM (FST x) (core L (rtrans L N r x k)) /\
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k)) /\
     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\

	// added for induction July 11, 2014
	  (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
	     (sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i))) = 
	       MAP FST (betwn fx (ytrans L N r x i) (ztrans L N r x i))) /\
      (!i. i < k ==> prev_el (core L (rtrans L N r x i)) v,v = x ) /\

	  uniq (core L r) /\
	  ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	      FST (ztrans L N r x 0) /\
		sizel (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)) = 0) /\
	  (!i. i < transform_count L N r x
	   ==> MEM (FST (ytrans L N r x i)) (core L r)) /\
	  (!i. i < transform_count L N r x
	   ==> MEM (FST (ztrans L N r x i)) (core L r)) /\

	  (!i. 0 < i /\ i < transform_count L N r x ==>
	  uniq (core L (rtrans L N r x i)) /\
	  ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i) /\
		sizel (betwn fx (ytrans L N r x i) (ztrans L N r x i)) = 0) /\
	  betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
	  betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
	    (FST (ytrans L N r x i)) /\
	    (next_el (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i))) =
		FST (ytrans L N r x i) <=>
		  next_el (core L r) (FST (ztrans L N r x (PRE i))) = FST (ytrans L N r x i)) /\
	    (!i. i < transform_count L N r x ==> MEM (FST (ytrans L N r x i)) (core L r)) /\
	    (!i. i < transform_count L N r x ==> MEM (FST (ztrans L N r x i)) (core L r)) /\
	    (!i'. i' < transform_count L N r x
	     ==> MEM (FST (ytrans L N r x i')) (core L (rtrans L N r x i))) /\
	    (!i'. i' < transform_count L N r x
	     ==> MEM (FST (ztrans L N r x i')) (core L (rtrans L N r x i)))) /\


      //
      (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0)))) /\
      (!i. MEM i (MAP FST (flatten N)) ==> 
	 ~(MEM i (MAP FST (betwn fx (ytrans L N r x 0) (ztrans L N r x 0))))) /\
      (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0))) /\
      (let (f1,f2) = split_normal_list L r fx (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N)) /\
      ~(transform_count L N r x = 0) /\
      0 < transform_count L N r x /\
      (FST x = prev_el (core L r) v) /\
      MEM x fx /\
      uniq fx /\
      1 <= sizel fx /\
      1 < sizel (core L r) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) fx <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) fx <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) fx) /\
      (indexf (next_el fx x) (ztrans L N r x (PRE k)) fx <=
	 indexf (next_el fx x) x fx) /\
      (indexf (next_el fx x) (ytrans L N r x 0) fx <=
         indexf (next_el fx x) (ztrans L N r x (PRE k)) fx) /\


      MEM (next_el fx x) r /\
      (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\
      (!i. i < k ==> MEM (ztrans L N r x i) r) /\
      (!i. i < k ==> MEM (ytrans L N r x i) r) /\
      MEM (next_el fx x) fx /\
      (!i. i < k ==> MEM (ytrans L N r x i) fx) /\
      (!i. i < k ==> MEM (ztrans L N r x i) fx) /\
      uniq (core L r) /\

      (FST (next_el fx x) = v) /\

      (!u. MEM u r ==> MEM (FST u) (core L r)) /\

      indexf v (FST (ytrans L N r x 0)) (core L r) =
          indexf (next_el fx x) (ytrans L N r x 0) fx /\

         indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x fx /\

         (!i. SUC i < k
              ==> indexf (FST (ztrans L N r x i))
                  (FST (ytrans L N r x (SUC i)))
                  (core L r) =
                  indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) fx) /\

// uvns

	   (!i. SUC i < sizel vs'
            ==> indexf v (EL i vs') (core L r) <
           indexf v (EL (SUC i) vs') (core L r)) /\
          (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
             isSome (EL i vs) /\
               isSome (EL (SUC i) vs) /\
               SUC i < sizel vs /\
               MEM d (list_of_darts (quotient_list L N))
             ==> MEM d (list_pairs (core L r))))

  )`;;


(* ............... LEMMAS *)

let final_assumption_mem_uniq = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
    MEM x (list_of_darts L) /\
    MEM x (find_face L x) /\
    MEM (next_el (find_face L x) x) (find_face L x) /\
    MEM (next_el (find_face L x) x) r /\
    (!i. i < k ==> MEM (ztrans L N r x i) r) /\
    (!i. i < k ==> MEM (ytrans L N r x i) r) /\
    (!i. i < k ==> MEM (ytrans L N r x i) (find_face L x)) /\
    (!i. i < k ==> MEM (ztrans L N r x i) (find_face L x)) /\
    (!i. i <= k ==> uniq (core L (rtrans L N r x i))) /\
    uniq (find_face L x) /\
    ~(k=0)
     `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC transform_count_non0 [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  (DISCH_THEN kill);
  TYPIFY `MEM x r /\ MEM r N /\ normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[GSYM List_hypermap.dart_in_face]);
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC Hojodcm.f_eq_next_el_x_v0 [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM (GEN_ALL Pwssrat.next_el_rotate_to_eq)) [`x`;`r`];
  TYPIFY `uniq r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  ASM_SIMP_TAC[List_hypermap.f_list];
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC Reduction2.transform_assumption_v2_lemma [`L`];
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Kbwpbhq.transform_count_not;Pnxvwfs.PNXVWFS2]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Kbwpbhq.transform_count_not;Pnxvwfs.PNXVWFS1]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.ytran_me_f]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Pplhulj.ztran_me_f;Kbwpbhq.transform_count_not]);
  DISCH_TAC;
  CONJ2_TAC;
    MATCH_MP_TAC List_hypermap.uniq_find_face;
    BY(ASM_MESON_TAC[good_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `marked_list L (ntrans L N r x i) (rtrans L N r x i) x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[AQIUNPP]);
  FIRST_X_ASSUM_ST `marked_list` MP_TAC THEN REWRITE_TAC[marked_list;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all uniq` MP_TAC;
  REWRITE_TAC[quotient_list_core;GSYM Seq.allP];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let reduction_K1 = prove_by_refinement(
  `(!L N r x k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\  // added July 13 2014
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>

     // END ASSUMPTIONS


     // (V)
     (!v. 
	     (prev_el (core L r) v,v = x)  ==>
	     (!i. i < k ==> prev_el (core L (rtrans L N r x i)) v,v = x ) /\
	     (FST (next_el (find_face L x) x) = v)) /\

     // (INDEX)
     (indexf (FST (next_el (find_face L x) x)) (FST (ytrans L N r x 0)) (core L r) =
         indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x)) /\
     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
     (!i. SUC i < k
      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\
     (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <=
	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=
         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
      (!i. 0 < i /\ i < k ==>
	 (next_el (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i))) =
		FST (ytrans L N r x i) <=>
		  next_el (core L r) (FST (ztrans L N r x (PRE i))) = FST (ytrans L N r x i)) ) /\

     // (BETWN) 
     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
//      (!i. MEM i (MAP FST (flatten N)) ==> 
//	 ~(MEM i (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0))))) /\
     ~(next_el (core L r) (FST (ytrans L N r x 0)) =
	 FST (ztrans L N r x 0) /\
	   sizel (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)) = 0) /\
      (!i. 0 < i /\ i < k ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i) /\
		sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)) = 0) /\
	 (betwn (core L r) (FST (ztrans L N r x (PRE i))) (FST (ytrans L N r x i)) =
	     betwn (core L (rtrans L N r x i)) (FST (ztrans L N r x (PRE i)))
	       (FST (ytrans L N r x i)))) /\
     
     // (MEM)
     MEM (FST x) (core L (rtrans L N r x k)) /\ // final_assumption_mem_x_core
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k)) /\ // final_assumption_zpre_core_k
      (!u. MEM u r ==> MEM (FST u) (core L r)) /\ // final_assumption_mem_fst_core
     (!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r)) /\ // final_assumption_fsty_core
     (!i. i < k ==> MEM (FST (ztrans L N r x i)) (core L r)) /\ // final_assumption_fstz_core
     (!i j. 0 < i /\ i < k /\ j < k ==>
	(MEM (FST (ytrans L N r x j)) (core L (rtrans L N r x i))) /\
	MEM (FST (ztrans L N r x j)) (core L (rtrans L N r x i))) /\ 

     // (SIZE AND MISC)
     (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)) /\ // final_assumption_fst_z
     (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0))) /\ // final_assumption_fst_y_neq_fst_z
     (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i)) /\ // final_assumption_y_ne_z
     1 <= sizel (find_face L x) /\ // final_assumption_size_find_face
     1 < sizel (core L r) /\ // final_assumption_size_core 

     // (PREPPED)
      (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
	 (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) = 
	   MAP FST (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) /\

     // (split_normal_list)
      (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N)) /\

     // (UVNS)
      (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)) /\
		       
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 

   ) ==> assumption_setK8`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  REWRITE_TAC[assumption_setK8];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `is_restricted` (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`]);
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_uniq [`L`;`N`;`r`;`x`;`k`];
  ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[CONJ_ASSOC];
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `list_pairs` (C INTRO_TAC [`v`]) THEN ASM_REWRITE_TAC[LET_THM];
    BY(MESON_TAC[]);
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `list_pairs` (C INTRO_TAC [`v`]) THEN ASM_REWRITE_TAC[LET_THM];
    BY(MESON_TAC[]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `quotient_list` kill);
  CONJ2_TAC;
    FIRST_X_ASSUM_ST `prev_el (core L r) v,v = x` (C INTRO_TAC [`v`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    BY(POP_ASSUM (SUBST1_TAC o GSYM) THEN ASM_REWRITE_TAC[]);
  nCONJ_TAC 3;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `DIFF` MP_TAC;
    REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;IN_DIFF;NOT_FORALL_THM];
    TYPIFY `i` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 3;
    FIRST_X_ASSUM_ST `prev_el (core L r) v,v = x` (C INTRO_TAC [`v`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "x";
    BY(REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `uniq` MP_TAC);
  TYPIFY `core L r = core L (rtrans L N r x 0)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  BY(MESON_TAC[arith `0 <= k /\ (i < k ==> i <= k) /\ (k <= k)`])
  ]);;
  (* }}} *)

let uniq_flatten_all_uniq = prove_by_refinement(
  `!s. uniq (flatten s) ==> all uniq s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.all]);
  REWRITE_TAC[Seq.flatten_cons;Seq.cat_uniq;Seq.all_cons];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_assumption_y_ne_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)  ==>
    (!i. i < k ==> ~(ytrans L N r x i = ztrans L N r x i))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Diowaas.DIOWAAS) [`next_el (find_face L x) x`;`L`;`N`;`r`;`x`;`i`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  ASM_SIMP_TAC[Kbwpbhq.transform_count_not];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_size_find_face = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)  ==>
    1 <= sizel (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC sizel_3_concl [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_mem_fst_core = prove_by_refinement(
  `!L N r x. 
     good_list L /\
     good_list_nodes L /\
     marked_list L N r x ==>
    (!u. MEM u r ==> MEM (FST u) (core L r))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[core];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.parts_flatten [`L`;`r`];
  SUBANTS_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[marked_list]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM u (flatten (parts L r))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Tame_list.parts_fst [`L`;`N`;`r`;`l`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_list]);
  SIMP_TAC[];
  TYPIFY `FST (HD l) = (FST o HD) l` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[o_THM]);
  DISCH_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let mem_fst_core = prove_by_refinement(
  `!L N r x u. 
     good_list L /\
     good_list_nodes L /\
     marked_list L N r x /\
     MEM u r ==>
    (MEM (FST u) (core L r))`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[final_assumption_mem_fst_core])
  ]);;
  (* }}} *)

let final_assumption_mem_x_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    MEM (FST x) (core L (rtrans L N r x k))`,

  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`(ntrans L N r x k)`;`(rtrans L N r x k)`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let final_assumption_zpre_core_k = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     MEM (FST (ztrans L N r x (PRE k))) (core L (rtrans L N r x k))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`(ntrans L N r x k)`;`(rtrans L N r x k)`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM MATCH_MP_TAC;
  TYPIFY `PRE k = 0 + PRE k` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  TYPIFY `~(k=0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[final_assumption_mem_uniq]);
  TYPIFY `rtrans L N r x k = rtrans L N r x (SUC 0 + PRE k)` (C SUBGOAL_THEN SUBST1_TAC);
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[trans_add];
  MATCH_MP_TAC (GEN_ALL Pbflhet.ztrans_in_suc);
  GEXISTL_TAC [`find_face L x`];
  GEXISTL_TAC [`next_el (find_face L x) x`];
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  CONJ_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_fsty_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (!i. i < k ==> MEM (FST (ytrans L N r x i)) (core L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Pnxvwfs.PNXVWFS1;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let final_assumption_fstz_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (!i. i < k ==> MEM (FST (ztrans L N r x i)) (core L r))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Pnxvwfs.PNXVWFS2;
  ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma];
  MATCH_MP_TAC Kbwpbhq.transform_count_not;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let final_assumption_fst_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
     (FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL Aq1.FST_EQ_PREV_ZTRANS_v0) [`prev_el r (ztrans L N r x 0)`;`ztrans L N r x 0`;`L`;`N`;`r`;`x`];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[Reduction2.trans0])
  ]);;
  (* }}} *)

let final_assumption_fst_y_neq_fst_z = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    (~(FST (ytrans L N r x 0) = FST (ztrans L N r x 0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC is_restricted_all_uniq [`L`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `(ytrans L N r x 0) =  (ztrans L N r x 0)` ENOUGH_TO_SHOW_TAC;
    INTRO_TAC final_assumption_y_ne_z [`L`;`N`;`r`;`x`;`k`];
    ASM_REWRITE_TAC[];
    DISCH_THEN MATCH_MP_TAC;
    REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  MATCH_MP_TAC Tame_list.list_pairs_unique;
  TYPIFY `find_pair_list L x` EXISTS_TAC;
  ASM_REWRITE_TAC[GSYM List_hypermap.find_face_alt];
  CONJ_TAC;
    TYPIFY `MEM (find_pair_list L x) L` ENOUGH_TO_SHOW_TAC;
      POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
      BY(MESON_TAC[]);
    MATCH_MP_TAC List_hypermap.mem_find_pair_list;
    BY(ASM_MESON_TAC[Pplhulj.marked_list_of_dart]);
  BY(ASM_MESON_TAC[Hojodcm.ztran_me_f_v0;Pplhulj.ytran_me_f])
  ]);;
  (* }}} *)

let final_assumption_size_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
    1 < sizel (core L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC LTE_TRANS;
  TYPIFY `CARD (set_of_list (core L r))` EXISTS_TAC;
  REWRITE_TAC[Tame_list.card_le_size];
  INTRO_TAC Hypermap.CARD_TWO_ELEMENTS [`FST (ytrans L N r x 0)`;`FST (ztrans L N r x 0)`];
  ASM_REWRITE_TAC[];
  TYPIFY `FINITE (set_of_list (core L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[FINITE_SET_OF_LIST]);
  INTRO_TAC CARD_SUBSET [`{FST (ytrans L N r x 0), FST (ztrans L N r x 0)}`;`set_of_list (core L r)`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;IN_INSERT;NOT_IN_EMPTY];
    BY(ASM_MESON_TAC[Hojodcm.ytrans_mem_rtrans_v0;Hojodcm.mem_ztrans_rtrans_v0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let final_assumption_yz_in_core = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) /\
     (!N' r' i'. i' < transform_count L N' r' x /\ marked_list L N' r' x /\
	newvertex_prepped L N' r' x /\ ~final_list L r' /\ element_pre L N' 
     ==> MEM (ztrans L N' r' x 0) (rtrans L N' r' x i'))
  ==>
     (!i j. 0 < i /\ i < k /\ j < k ==>
	(MEM (FST (ytrans L N r x j)) (core L (rtrans L N r x i))) /\
	MEM (FST (ztrans L N r x j)) (core L (rtrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC final_assumption_mem_fst_core [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_SIMP_TAC[];
  SUBANTS_TAC;
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM ( (ytrans L N r x j)) ( (rtrans L N r x i)) /\ MEM ((ztrans L N r x j)) ((rtrans L N r x i))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `i <= j:num` ASM_CASES_TAC;
    TYPIFY `i = 0 + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ARITH_TAC);
    TYPIFY `j = (j - i:num) + i` (C SUBGOAL_THEN SUBST1_TAC);
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    REWRITE_TAC[trans_add];
    REWRITE_TAC[Reduction2.trans0];
    TYPIFY `~(final_list L (rtrans L (ntrans L N r x i) (rtrans L N r x i) x (j-i)))` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[GSYM trans_add];
      MATCH_MP_TAC Kbwpbhq.transform_count_not;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Pnxvwfs.PNXVWFS2;Pnxvwfs.PNXVWFS1;Reduction2.transform_assumption_v2_lemma]);
  TYPIFY `j = 0 + j` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ARITH_TAC);
  TYPIFY `i = (i - j) + (j:num)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  REWRITE_TAC[trans_add];
  TYPIFY `~(final_list L (rtrans L (ntrans L N r x j) (rtrans L N r x j) x (i - j)))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM trans_add];
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `marked_list L (ntrans L N r x j) (rtrans L N r x j) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[ Pbflhet.properties_of_ytrans0;Reduction2.transform_assumption_v2_lemma]);
  (DISCH_TAC);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC transform_count_add;
  ASM_REWRITE_TAC[];
  INTRO_TAC lnrx_induction [`j`;`L`;`N`;`r`;`x`];
  ASM_SIMP_TAC[core_split_normal_list_assumption_lemma;r_trans_eq_assumption_lemma];
  DISCH_THEN kill;
  nCONJ_TAC 2;
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let l_expand = prove_by_refinement(
  `!L N r x i. l'y L (rtrans L N r x i) x = ytrans L N r x i /\
    l'z L (ntrans L N r x i) (rtrans L N r x i) x = ztrans L N r x i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY_GOAL_THEN `ytrans L N r x i = ytrans L N r x (0+i) /\ ztrans L N r x i = ztrans L N r x (0+i)` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[arith `0+i=i`]);
  BY(REWRITE_TAC[trans_add;Reduction2.trans0])
  ]);;
  (* }}} *)

let final_assumption_newvertex_prepped = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
    element_pre L N /\
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k)
  ==>
    (!i. i < k ==> iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) 
       (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) = 
	 MAP FST (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `iota1 = iota (sizel (undup (MAP FST (flatten (ntrans L N r x i))))) (sizel (betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i))) `;
  INTRO_TAC Reduction2.rtrans_diff_r [`L`;`ntrans L N r x i`;`rtrans L N r x i`;`x`];
  ASM_REWRITE_TAC[trans_add;l_expand];
  REWRITE_TAC[GSYM trans_add];
  SUBANTS_TAC;
    CONJ_TAC;
      MATCH_MP_TAC AQIUNPP;
      BY(ASM_REWRITE_TAC[]);
    MATCH_MP_TAC Kbwpbhq.transform_count_not;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  POP_ASSUM (ASSUME_TAC o GSYM) THEN ASM_REWRITE_TAC[];
  TYPED_ABBREV_TAC `w = next_el (find_face L x) x`;
  TYPED_ABBREV_TAC `fw = rotate_to (find_face L x) w`;
  INTRO_TAC Reduction2.face_diff_r [`L`;`fw`;`ntrans L N r x i`;`rtrans L N r x i`;`x`;`w`];
  ASM_REWRITE_TAC[GSYM trans_add];
  INTRO_TAC r_trans_eq_assumption [`L`];
  REWRITE_TAC[r_trans_eq_assumption_lemma];
  DISCH_THEN (C INTRO_TAC [`ntrans L N r x i`;`rtrans L N r x i`;`x`]);
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i))) <= sizel (filter (\d. ~MEM d (rtrans L N r x i)) fw)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_cat;arith `i + j = k ==> i <= k:num`]);
  INTRO_TAC Seq.take_size_cat [`sizel (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))`;`(filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))`;`(filter (\d. ~MEM d (rtrans L N r x (1 + i))) fw)`];
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `cat` (SUBST1_TAC o GSYM);
  INTRO_TAC lnrx_induction [`i`;`L`;`N`;`r`;`x`];
  (ASM_REWRITE_TAC[]);
  REWRITE_TAC[r_trans_eq_assumption_lemma];
  REWRITE_TAC[core_split_normal_list_assumption_lemma];
  ASM_REWRITE_TAC[newvertex_prepped;LET_THM;Reduction2.newvertex_alt];
  INTRO_TAC Reduction2.newvertex_alt [`rtrans L N r x i`;`L`;`x`;`w`];
  ASM_SIMP_TAC[LET_THM];
  ANTS_TAC;
    nCONJ_TAC 2;
      BY(ASM_MESON_TAC[marked_list]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[final_assumption_mem_uniq]);
  SIMP_TAC[];
  DISCH_THEN kill;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP FST (take      (sizel      (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i))))      (filter (\d. ~MEM d (rtrans L N r x i)) fw)) = MAP FST (filter (\d. ~MEM d (rtrans L N r x i)) (rtrans L N r x (1 + i)))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[lower_case;Seq.map_take];
  ASM_REWRITE_TAC[Seq.map_MAP];
  DISCH_THEN (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `MAP` (SUBST1_TAC);
  GMATCH_SIMP_TAC Reduction2.take_iota;
  ASM_REWRITE_TAC[lower_case;Seq.size_map];
  BY(ASM_MESON_TAC[lower_case])
  ]);;
  (* }}} *)

(* ********************************************************************** *)
(* // SPLIT_NORMAL_LIST *)
(* ********************************************************************** *)

let size_replace1 = prove_by_refinement(
  `!s x y. sizel (replace x [y] s) = sizel s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[replace;lower_case;Seq.size_cons];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC;
    REWRITE_TAC[Seq.size_cat;Seq.size_cons;Seq.size_nil];
    BY(ARITH_TAC);
  BY(ASM_REWRITE_TAC[Seq.size_cons;Seq.size_cat])
  ]);;
  (* }}} *)

let split_normal_list_index1_lemma = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	   (MEM (core L f1) (quotient_list L N) ==> (core L f1 = core L r)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  DISCH_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `find_face L (l'y L r x) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `~(quotient_list L (ntrans L N r x 1) = []) /\ ~(ntrans L N r x 1 = []) /\ LAST (quotient_list L (ntrans L N r x 1)) = (core L f1) /\ sizel (quotient_list L (ntrans L N r x 1)) = SUC (sizel (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[quotient_list_core;MAP_EQ_NIL];
    GMATCH_SIMP_TAC Tame_list.LAST_MAP;
    REWRITE_TAC[ntrans;Hypermap.POWER_1;transform_list];
    ASM_REWRITE_TAC[LET_THM;APPEND_EQ_NIL;NOT_CONS_NIL];
    BY(REWRITE_TAC[lower_case;Seq.cats1;LAST_rcons;Seq.size_map;Seq.size_rcons;size_replace1]);
  TYPED_ABBREV_TAC `n = sizel (quotient_list L N)`;
  TYPIFY `EL (n) (quotient_list L (ntrans L N r x 1)) = core L f1` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC LAST_EL [`(quotient_list L (ntrans L N r x 1))`];
    BY(ASM_SIMP_TAC[lower_case;arith `SUC n - 1 = n`]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (quotient_list L (ntrans L N r x 1))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  TYPIFY `uniq (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[quotient_list_core;MEM_MAP;NOT_EXISTS_THM];
  X_GENv_TAC "r'";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r=r')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`r'`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq9.element_in_ntrans_suc;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`f1`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r' = f1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REWRITE_TAC[normal_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC);
  POP_ASSUM MP_TAC;
  ASM_REWRITE_TAC[ntrans;transform_list;Hypermap.POWER_1;lower_case;LET_THM;Seq.cat_uniq];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ2_TAC THEN DISJ1_TAC;
  REWRITE_TAC[GSYM Seq.hasP];
  TYPIFY `r'` EXISTS_TAC;
  ASM_REWRITE_TAC[MEM];
  MATCH_MP_TAC Tame_list.MEM3_replace;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_normal_list_index2_lemma = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) 
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	   (MEM (core L f2) (quotient_list L N) ==> (core L f2 = core L r)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(REWRITE_RULE[]);
  DISCH_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `find_face L (l'y L r x) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq (quotient_list L (ntrans L N r x 1))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  TYPIFY `uniq (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.good_list_uniq;
    BY(ASM_MESON_TAC[marked_list_good_quotient]);
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[quotient_list_core;MEM_MAP;NOT_EXISTS_THM];
  X_GENv_TAC "r'";
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r=r')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`r'`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Aq9.element_in_ntrans_suc;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexl_core [`L`;`ntrans L N r x 1`;`f2`;`x`];
  SUBANTS_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC Aq8.snd_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY((ASM_SIMP_TAC[]));
  ASM_SIMP_TAC[];
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r' = f2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Tame_list.index_uniq]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  REWRITE_TAC[normal_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[GSYM Seq.allP] THEN REPEAT WEAKER_STRIP_TAC);
  POP_ASSUM MP_TAC;
  REWRITE_TAC[];
  ASM_REWRITE_TAC[ntrans;transform_list;Hypermap.POWER_1;lower_case;LET_THM;Seq.cat_uniq];
  REWRITE_TAC[DE_MORGAN_THM];
  DISJ1_TAC;
  FULL_EXPAND_TAC "f2";
  MATCH_MP_TAC not_uniq_replace;
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let next_core_ne_FST = prove_by_refinement(
  `!L N r u v.
    good_list L /\
    good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM u r /\
    uniq (core L r) /\
    ~(FST u = FST v) /\
    next_el r u = v 
    ==> next_el (core L r) (FST u) = (FST v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GEN_ALL More_lemma_e.next_core_FST_SYM) [`L`;`N`;`r`;`u`];
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Hypermap.is_restricted]);
  INTRO_TAC Tame_list.loop_list_f_or_ni [`L`;`r`;`u`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[normal_list;Seq.allP]);
  FULL_EXPAND_TAC "v";
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `next_el r u` FULL_LEFT_EXPAND_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `FST` MP_TAC THEN REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM Tame_list.inverse_node_map_list);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    INTRO_TAC Tame_list.normal_list_list_of_darts [`L`;`N`];
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  DISCH_TAC;
  INTRO_TAC (GSYM List_hypermap.fst_node_hypermap_of_list) [`L`;`u`];
  ASM_REWRITE_TAC[] THEN DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC Hypermap.lemma_inverse_in_node;
  BY(REWRITE_TAC[Hypermap.node_refl])
  ]);;
  (* }}} *)

let final_assumption_split_normal_list = prove_by_refinement(
  `!L N r x k. 
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) /\
    (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [] ==>
	 ~(next_el (core L (rtrans L N r x 0)) (FST (ytrans L N r x 0)) =
	      FST (ztrans L N r x 0))) /\
    (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = [] ==> // new assumption
	 ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
	      FST (ytrans L N r x 0))) /\
    (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0))))
  ==>
        (let (f1,f2) = split_normal_list L r 
	 (find_face L x) (ytrans L N r x 0) (prev_el r (ztrans L N r x 0)) in
	 ~MEM (core L f1) (quotient_list L N) /\
	 ~MEM (core L f2) (quotient_list L N))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  POP_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `bet = betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)`;
  TYPIFY `l'y L r x = ytrans L N r x 0 /\ l'z L N r x = ztrans L N r x 0` ((C SUBGOAL_THEN ASSUME_TAC));
    BY(REWRITE_TAC[Reduction2.trans0]);
  TYPIFY `find_face L (ytrans L N r x 0) = find_face L x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction2.find_face_x_eq_y]);
  TYPIFY `~(bet = [])` ASM_CASES_TAC;
    TYPIFY `?b. MEM b (MAP FST bet)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[List_hypermap.mem_not_nil;MAP_EQ_NIL]);
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC quotient_list_elements [`L`;`N`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[marked_list]);
    REWRITE_TAC[List_hypermap.elements_of_list;EXTENSION;IN_SET_OF_LIST;List_hypermap.list_of_elements;Seq2.mem_flatten;Seq.mem_undup];
    DISCH_THEN (C INTRO_TAC [`b`]);
    TYPIFY ` ~(MEM b (MAP FST (flatten N))) /\ MEM b (core L f1) /\ MEM b (core L f2)` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    CONJ_TAC;
      FIRST_X_ASSUM_ST `DIFF` MP_TAC;
      REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;IN_DIFF];
      BY(ASM_MESON_TAC[]);
    INTRO_TAC core_split_normal_list_assumption_lemma [`L`];
    REWRITE_TAC[core_split_normal_list_assumption];
    DISCH_THEN (C INTRO_TAC [`N`;`r`;`x`]);
    ASM_REWRITE_TAC[core_split_normal_list];
    ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR;l_expand];
    BY(ASM_SIMP_TAC[Seq.mem_cat;Seq.mem_rev]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  COMMENT "bet = []";
  FIRST_X_ASSUM_ST `~` MP_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC AQIUNPP;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `normal_list L (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `MEM f2 (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Aq8.snd_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  TYPIFY `MEM f1 (ntrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Aq8.fst_mem_rtran1 [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  TYPIFY `uniq f2 /\ ~(f2 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq f1 /\ ~(f1 = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  PROOF_BY_CONTR_TAC;
  INTRO_TAC split_normal_list [`L`;`r`;`(find_face L x)`;`ytrans L N r x 0`;`prev_el r (ztrans L N r x 0)`];
  ASM_REWRITE_TAC[LET_THM;lower_case];
  REPEAT (GMATCH_SIMP_TAC Seq2.next_prev_id);
  TYPIFY `MEM r N /\ uniq r /\ ~(r  = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list;normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[Seq.cats0;Seq.flatten0;Seq.map;rev0;Seq.cat0s];
  ONCE_REWRITE_TAC[PAIR_EQ2];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM (core L f)` MP_TAC;
  REWRITE_TAC[];
  COMMENT "MEM z r";
  TYPIFY `MEM (ztrans L N r x 0) (rtrans L N r x 1)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `1 = SUC 0`] THEN MATCH_MP_TAC (GEN_ALL Pbflhet.ztrans_in_suc);
    GEXISTL_TAC [`find_face L x`;`next_el (find_face L x) x`];
    ASM_SIMP_TAC[Reduction2.transform_assumption_v2_lemma];
    REWRITE_TAC[Reduction2.trans0];
    BY(ASM_REWRITE_TAC[]);
  COMMENT "F2 CASE";
  SUBCONJ2_TAC;
    DISCH_TAC;
    INTRO_TAC split_normal_list_index2_lemma [`L`;`N`;`r`;`x`;`k`];
    ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `next_el (core L r)` kill;
    FIRST_X_ASSUM_ST `next_el (core L r)` MP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Reduction2.trans0];
    ASM_REWRITE_TAC[];
    TYPIFY `core L r` FULL_RIGHT_EXPAND_TAC;
    MATCH_MP_TAC next_core_ne_FST;
    TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_REWRITE_TAC[];
    INTRO_TAC Reduction3.rtrans1 [`L`;`N`;`r`;`x`] THEN ASM_REWRITE_TAC[];
    DISCH_TAC;
    SUBCONJ_TAC;
      FULL_EXPAND_TAC "f2";
      BY(ASM_MESON_TAC[Aq12.y_mem_split_snd]);
    DISCH_TAC;
    SUBCONJ_TAC;
      FULL_EXPAND_TAC "f2";
      INTRO_TAC Aq8.uniq_snd_split_normal_parts [`L`;`N`;`r`;`x`];
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    CONJ_TAC;
      INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
      BY(ASM_REWRITE_TAC[]);
    SIMP_TAC[];
    TYPIFY_GOAL_THEN `ytrans L N r x 0 = LAST f2  /\ ztrans L N r x 0 = HD f2` (unlist REWRITE_TAC);
      FIRST_ASSUM_ST `betwn` (SUBST1_TAC o GSYM);
      REWRITE_TAC[Seq.cat1s;HD];
      REWRITE_TAC[GSYM Seq.cat_cons];
      BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
    MATCH_MP_TAC Aq4.next_el_last_hd;
    FULL_EXPAND_TAC "f2";
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[marked_list]);
  DISCH_TAC;
  DISCH_TAC;
  COMMENT "F1 CASE";
  INTRO_TAC split_normal_list_index1_lemma [`L`;`N`;`r`;`x`;`k`];
  ASM_REWRITE_TAC[LET_THM;LAMBDA_PAIR];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `next_el (core L r)` MP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Reduction2.trans0];
  ASM_REWRITE_TAC[];
  TYPIFY `core L r` FULL_RIGHT_EXPAND_TAC;
  COMMENT "new material";
  TYPIFY `FST (prev_el r (ztrans L N r x 0)) = FST (ztrans L N r x 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Aq1.FST_EQ_PREV_ZTRANS_v0]);
  TYPIFY `FST (next_el r (ytrans L N r x 0)) = FST (ytrans L N r x 0)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC (GEN_ALL Hojodcm.FST_EQ_NEXT_YTRANS) [`ytrans L N r x 0`;`L`;`N`;`r`;`x`];
    DISCH_THEN GMATCH_SIMP_TAC;
    BY(ASM_REWRITE_TAC[Reduction2.transform_assumption_v2_lemma]);
  ASM_REWRITE_TAC[];
  TYPIFY `next_el (core L f1) (FST (prev_el r (ztrans L N r x 0))) = FST (next_el r (ytrans L N r x 0))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "old material";
  MATCH_MP_TAC next_core_ne_FST;
  TYPIFY `ntrans L N r x 1` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    INTRO_TAC Aq8.uniq_fst_split_normal_parts [`L`;`N`;`r`;`x`];
    BY(ASM_SIMP_TAC[]);
  nCONJ_TAC 2;
    INTRO_TAC final_assumption_fst_y_neq_fst_z [`L`;`N`;`r`;`x`;`k`];
    BY(ASM_SIMP_TAC[]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FULL_EXPAND_TAC "f1";
    BY(REWRITE_TAC[Seq.mem_cat;MEM]);
  DISCH_TAC;
  TYPIFY_GOAL_THEN `prev_el r (ztrans L N r x 0) = LAST f1 /\ next_el r (ytrans L N r x 0) = HD f1` (unlist REWRITE_TAC);
    FULL_EXPAND_TAC "f1";
    REWRITE_TAC[Seq.cat1s;HD];
    REWRITE_TAC[GSYM Seq.cat_cons];
    BY(REWRITE_TAC[Seq.cats1;LAST_rcons]);
  MATCH_MP_TAC Aq4.next_el_last_hd;
  MATCH_MP_TAC normal_list_uniq_nonnil;
  BY(ASM_MESON_TAC[marked_list])
  ]);;
  (* }}} *)

let reduction_K2 = prove_by_refinement(
  `(!L N r x k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
     element_pre L N /\  // added July 13 2014
     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     // END ASSUMPTIONS

     // (INDEX)
     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) =
         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
     (!i. SUC i < k
      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\
     (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <=
	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=
         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
      (!i. SUC i < k ==>
	 (next_el (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x i)) =
		FST (ytrans L N r x (SUC i)) <=>
		  next_el (core L r) (FST (ztrans L N r x i)) = FST (ytrans L N r x (SUC i))) ) /\

     // (MISC) // new Jul 13 2014
    (!i. i < k     ==> MEM (ztrans L N r x 0) (rtrans L N r x i)) /\

     // (BETWN)
     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
     (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i))) /\
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
	 ==> ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
             FST (ytrans L N r x 0))) /\
     (!i. SUC i < k ==> 
	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
	     betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
	       (FST (ytrans L N r x (SUC i))))) /\

     // (UVNS)
      (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)) /\
		       
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 

   ) ==> assumption_setK8`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_K1;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`L`]) THEN ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `(!N' r' i'.              i' < transform_count L N' r' x /\              marked_list L N' r' x /\              newvertex_prepped L N' r' x /\              ~final_list L r' /\              element_pre L N'              ==> MEM (ztrans L N' r' x 0) (rtrans L N' r' x i'))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`N`;`r`;`x`;`k`]);
  ASM_SIMP_TAC[Seq.size_eq0];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `(0 < k)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[arith `0 < k <=> ~(k=0)`];
    BY(ASM_MESON_TAC[transform_count_non0]);
  COMMENT "cases start here";
  CONJ_TAC;
    MATCH_MP_TAC More_lemma_e.v_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    MATCH_MP_TAC More_lemma_e.indexf1_final_lemmas;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC num_CASES [`i`];
    ASM_SIMP_TAC[arith `0 < i ==> ~(i=0)`];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[arith `PRE (SUC n) = n`];
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "i";
    BY(ASM_MESON_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Reduction2.trans0]);
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    INTRO_TAC num_CASES [`i`];
    ASM_SIMP_TAC[arith `0 < i ==> ~(i=0)`];
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[arith `PRE (SUC n) = n`];
    POP_ASSUM (ASSUME_TAC o GSYM) THEN FULL_EXPAND_TAC "i";
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[CONJ_ASSOC];
  CONJ2_TAC;
    MATCH_MP_TAC final_assumption_split_normal_list;
    TYPIFY `k` EXISTS_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM CONJ_ASSOC];
  FIRST_X_ASSUM_ST `core_triple_v4` kill;
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_mem_x_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_zpre_core_k]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_mem_fst_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fsty_core]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fstz_core]);
  CONJ_TAC;
    MATCH_MP_TAC final_assumption_yz_in_core;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_z]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_fst_y_neq_fst_z]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_y_ne_z;]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_size_find_face;]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[final_assumption_size_core]);
  MATCH_MP_TAC final_assumption_newvertex_prepped;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let reduction_K3 = prove_by_refinement(
  `(!L N r x k. 

     // ASSUMPTIONS HERE
     good_list L /\
     good_list_nodes L /\
     is_restricted (hypermap_of_list L) /\
//     element_pre L N /\  // added July 13 2014
//     newvertex_prepped L N r x /\
     marked_list L N r x /\
     ~final_list L r /\
     (transform_count L N r x = k) ==>
     // END ASSUMPTIONS

     // (INDEX)
//     (indexf (FST (ztrans L N r x (PRE k))) (FST x) (core L r) = // More_lemma_e.indexf2_final_lemmas
//         indexf (ztrans L N r x (PRE k)) x (find_face L x)) /\
     (!i. SUC i < k
      ==> indexf (FST (ztrans L N r x i)) (FST (ytrans L N r x (SUC i))) (core L r) =
          indexf (ztrans L N r x i) (ytrans L N r x (SUC i)) (find_face L x)) /\
     (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ztrans L N r x i) (find_face L x) <=
       indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x)) /\
      (!i. SUC i < k
       ==> indexf (ytrans L N r x 0) (ytrans L N r x (SUC i)) (find_face L x) <=
       indexf (ytrans L N r x 0) (ztrans L N r x (SUC i)) (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x) <=
	 indexf (next_el (find_face L x) x) x (find_face L x)) /\
      (indexf (next_el (find_face L x) x) (ytrans L N r x 0) (find_face L x) <=
         indexf (next_el (find_face L x) x) (ztrans L N r x (PRE k)) (find_face L x)) /\
      (!i. SUC i < k ==>
	 (next_el (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x i)) =
		FST (ytrans L N r x (SUC i)) <=>
		  next_el (core L r) (FST (ztrans L N r x i)) = FST (ytrans L N r x (SUC i))) ) /\

     // (MISC) 
    (!i. i < k     ==> MEM (ztrans L N r x 0) (rtrans L N r x i)) /\

     // (BETWN)
     (betwn (core L (rtrans L N r x k)) (FST (ztrans L N r x (PRE k))) (FST x) =
	 betwn (core L r) (FST (ztrans L N r x (PRE k))) (FST x)) /\
      (set_of_list (MAP FST (flatten (ntrans L N r x 1))) DIFF set_of_list (MAP FST (flatten N)) = 
	  set_of_list (MAP FST (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0)))) /\
     (!i. i < k /\ betwn (find_face L x) (ytrans L N r x i) (ztrans L N r x i) = [] ==>
	 ~(next_el (core L (rtrans L N r x i)) (FST (ytrans L N r x i)) =
	      FST (ztrans L N r x i))) /\
     (betwn (find_face L x) (ytrans L N r x 0) (ztrans L N r x 0) = []
	 ==> ~(next_el (core L (rtrans L N r x 0)) (FST (ztrans L N r x 0)) =
             FST (ytrans L N r x 0))) /\
     (!i. SUC i < k ==> 
	(betwn (core L r) (FST (ztrans L N r x (i))) (FST (ytrans L N r x (SUC i))) =
	     betwn (core L (rtrans L N r x (SUC i))) (FST (ztrans L N r x (i)))
	       (FST (ytrans L N r x (SUC i))))) /\

     // (UVNS)
      (       
		(!v. (prev_el (core L r) v,v = x) ==>
		   let uvns = core_triple_v4 L N r x in
		   let vs = dest_triple_full (core L r) v uvns in
		   let vs' = MAP the (filter isSome vs) in
	   	     (!i. SUC i < sizel vs'
		      ==> indexf v (EL i vs') (core L r) <
		      indexf v (EL (SUC i) vs') (core L r)) /\
		       
		       (!i. (let d = the (EL i vs),the (EL (SUC i) vs) in
			       isSome (EL i vs) /\
				 isSome (EL (SUC i) vs) /\
				 SUC i < sizel vs /\
				 MEM d (list_of_darts (quotient_list L N))
			       ==> MEM d (list_pairs (core L r)))))
		) // uvns 

   ) ==> assumption_setK8`,
  (* {{{ proof *)
  [
  DISCH_TAC;
  MATCH_MP_TAC reduction_K2;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`L`;`N`;`r`;`x`;`k`]);
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  TYPIFY `~(k = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Reduction3.transform_count_non0]);
  MATCH_MP_TAC More_lemma_e.indexf2_final_lemmas;
  BY(ASM_SIMP_TAC[arith `~(k=0) ==> 0 < k`])
  ]);;
  (* }}} *)




end;;
