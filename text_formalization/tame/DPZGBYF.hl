(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Tame Hypermap                                           *)
(* Lemma:  DPZGBYF                                                            *)
(* Author:  Thomas Hales     *)
(* Date: Jan 24, 2014                                                *)
(* ========================================================================== *)

(* STRIP_TAC failure: *)
(*
g `(?p:num. A p) /\ C (p:num) ==> E`;;
e STRIP_TAC;;
*)

module Dpzgbyf = struct
end;;

  open Hales_tactic;;
open Hypermap;;
open Import_tame_classification;;
open Tame_defs;;
open Tame_concl;;
open More_tame_concl;;
open Oxaxucs;;
open Asfutbf;;
open Elllnyz;;
open Wmlnymd;;

let DPZGBYF_concl = `!g. planegraph g ==> planegraph_relaxed g`;;

let planegraph_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ (!g g' i. (B g /\ 3 <= i /\ i <= maxGon p /\ 
   (  (let fs = nonFinals g in
     if (fs = []) then F else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. planegraph g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[planegraph];
  REWRITE_TAC[IMAGE;UNIONS;IN_UNIV;IN_ELIM_THM];
  REWRITE_TAC[planegraphP;IN_ELIM_THM;RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`p`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane p x))`;`\ x y. (x = Seed p) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed p`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let planegraph_relaxed_induct = prove_by_refinement(
  `!B. ((!p. B (Seed p) /\ 
   (!g g' i. (B g /\ 3 <= i /\ 
		(  (let fs = nonFinals g in
		      if (fs = []) then F else
			(let f = minimalFace fs in
			 let v = minimalVertex g f in
			   (MEM g' (generatePolygon i v f g)))))) ==> B g'))) ==>
    (!g. planegraph_relaxed g ==> B g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[planegraph_relaxed];
  REWRITE_TAC[RTranCl;IN;UNCURRY_DEF];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`p`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC RTC_INDUCT_L [`(\x y. MEM y (next_plane q x))`;`\ x y. (x = Seed p) ==> B y`];
  REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    GEXISTL_TAC [`y`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `MEM` MP_TAC;
    REWRITE_TAC[next_plane];
    REWRITE_TAC[LET_THM];
    TYPIFY `nonFinals y = []` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[MEM]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;Import_tame_classification.upt;Seq.mem_iota];
    REPEAT WEAKER_STRIP_TAC;
    GEXISTL_TAC [`x'`];
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_SIMP_TAC [arith `3 <= x' ==> (x' < 3 + SUC (maxGon m) - 3 <=> x' <= maxGon m)`];
    BY(ASM_MESON_TAC[]);
  DISCH_THEN (C INTRO_TAC [`Seed p`]) THEN REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let RTranCl_REFL = prove_by_refinement(
  `!P x. (x,x) IN RTranCl P`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[RTranCl;IN;UNCURRY_DEF;RTC_REFL])
  ]);;
  (* }}} *)

let DPZGBYF = prove_by_refinement(
  `!g. planegraph g ==> planegraph_relaxed g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[planegraph;planegraph_relaxed];
  BY(MESON_TAC[])  
  ]);;
  (* }}} *)

let subdivFace0_induct = prove_by_refinement(
  `!B vs g f u n.  ((!f' g. B g ==> B(makeFaceFinal f' g)) /\ (!g u v f'' n .
        B g /\ (~(n=0) \/  ~(nextVertex f'' u = v)) ==> 
    (let ws = upt (countVertices g) (countVertices g + n) in
     let (f1,f2,g') = splitFace g u v f'' ws in B g'))) ==>
    (B g ==> (B(subdivFace0 g f u n vs)))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT LET_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `makeFaceFinal` (C INTRO_TAC [`g'`;`f2`;`v`;`0`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  LET_TAC;
  ASM_REWRITE_TAC[];
  LET_TAC;
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let nonFinals_subdivFace0_induct = prove_by_refinement(
  `!B vs g f u n.  ((!f' g. B g ==> B(makeFaceFinal f' g)) /\ (!g u v f'' n .
        B g /\ MEM f'' (nonFinals g) /\ (~(n=0) \/  ~(nextVertex f'' u = v)) ==> 
    (let ws = upt (countVertices g) (countVertices g + n) in
     let (f1,f2,g') = splitFace g u v f'' ws in B g'))) ==>
    (B g /\ MEM f (nonFinals g) ==> (B(subdivFace0 g f u n vs)))`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    ASM_REWRITE_TAC[subdivFace0];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[subdivFace0];
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT LET_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `makeFaceFinal` (C INTRO_TAC [`g'`;`f2`;`v`;`0`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`g`;`u`;`v`;`f`;`n`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  LET_TAC;
  ASM_REWRITE_TAC[];
  LET_TAC;
  (REWRITE_TAC[]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `splitFace` MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  FIRST_X_ASSUM_ST `REVERSE` MP_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  FIRST_X_ASSUM_ST `nonFinals` MP_TAC;
  REWRITE_TAC[nonFinals];
  REWRITE_TAC[MEM_FILTER];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC;
    EXPAND_TAC "f2";
    EXPAND_TAC "f2'";
    BY(REWRITE_TAC[type_face_SND]);
  REWRITE_TAC[faces_graph];
  FULL_EXPAND_TAC "f2";
  REWRITE_TAC[MEM_APPEND];
  DISJ1_TAC;
  FULL_EXPAND_TAC "fs";
  MATCH_MP_TAC MEM2_replace;
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let MEM_generatePolygon = prove_by_refinement(
  `!i v f g g'. MEM g' (generatePolygon i v f g) ==> (?e vs.
     MEM e (enumerator i (LENGTH (FST f))) /\
     ~containsDuplicateEdge g f v e /\
     vs = indexToVertexList f v e /\
     g' = subdivFace g f vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[generatePolygon;LET_THM;MEM_MAP;MEM_FILTER];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let fgraph_graph = prove_by_refinement(
  `!f n a b. fgraph (Graph f n a b) = MAP FST f`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[bn_Graph;fgraph;faces;vertices])
  ]);;
  (* }}} *)

let uniq_list_of_darts_seed = prove_by_refinement(
  `!p. uniq(list_of_darts(fgraph (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.cats0];
  REWRITE_TAC[Seq.cat_uniq];
  GEN_TAC;
  CONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[Import_tame_classification.upt];
    BY(REWRITE_TAC[Seq.iota_uniq]);
  CONJ2_TAC;
    MATCH_MP_TAC List_hypermap.uniq_list_pairs;
    REWRITE_TAC[REVERSE_rev];
    REWRITE_TAC[Seq.rev_uniq];
    REWRITE_TAC[Import_tame_classification.upt];
    BY(REWRITE_TAC[Seq.iota_uniq]);
  REWRITE_TAC[GSYM Seq.hasP];
  REWRITE_TAC[NOT_EXISTS_THM];
  GEN_TAC;
  REWRITE_TAC[TAUT `~(a /\ b) <=> (a ==> ~b)`];
  REWRITE_TAC[upt0;maxGon];
  TYPIFY `?i j. x = i,j` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[REVERSE_rev;Seq.mem_rev;list_pairs_iota];
  GMATCH_SIMP_TAC list_pairs_rev_iota;
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let all_nonempty_seed = prove_by_refinement(
  `!p. all (\l. ~(l = [])) (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.all];
  REWRITE_TAC[Import_tame_classification.upt;maxGon];
  REWRITE_TAC[GSYM Seq.size_eq0;REVERSE_rev;Seq.size_rev];
  REWRITE_TAC[Seq.size_iota];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_transpose_seed = prove_by_refinement(
  `!p d. MEM d (list_of_darts (fgraph (Seed p))) ==> MEM (SND d,FST d) (list_of_darts (fgraph (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;graphl;LET_THM;fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_darts_cons;List_hypermap.list_of_darts_nil];
  REWRITE_TAC[Seq.mem_cat];
  REWRITE_TAC[Import_tame_classification.upt;maxGon;REVERSE_rev];
  REPEAT GEN_TAC;
  TYPIFY_GOAL_THEN `(p+3)-0 = p+3` SUBST1_TAC;
    BY(ARITH_TAC);
  TYPIFY `?i j. d = (i,j)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[list_pairs_iota];
  REPEAT (GMATCH_SIMP_TAC list_pairs_rev_iota);
  REWRITE_TAC[MEM];
  REWRITE_TAC[arith `0 < p + 3 /\ (p+3)- 1 = p+2 /\ (i + 1 = p + 3 <=> i = p+ 2) /\ (i + 1 < p + 3 <=> i < p + 2)`];
  REPEAT STRIP_TAC;
        BY(ASM_TAC THEN ARITH_TAC);
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_REWRITE_TAC[]);
  DISJ1_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let good_list_seed = prove_by_refinement(
  `!p. good_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[List_hypermap.good_list;mem_transpose_seed;all_nonempty_seed;uniq_list_of_darts_seed])
  ]);;
  (* }}} *)

let FST_setFinal = prove_by_refinement(
  `!vs f. MAP FST (replace f [setFinal f] vs) = MAP FST vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[replace]);
  REWRITE_TAC[replace];
  GEN_TAC;
  REWRITE_TAC[APPEND_SING];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MAP];
    BY(REWRITE_TAC[setFinal_ALT;Import_tame_classification.vertices_face_FST]);
  BY(ASM_REWRITE_TAC[MAP])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!g f. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;fgraph;bn_Graph;faces;makeFaceFinalFaceList;setFinal];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

let planegraph_all_nonempty = prove_by_refinement(
 `!g. planegraph_relaxed g  ==> all (\(l:(num)list). ~(l = [])) (fgraph g)`,
  (* {{{ proof *)
  [
  MATCH_MP_TAC planegraph_relaxed_induct;
  REWRITE_TAC[all_nonempty_seed;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_generatePolygon));
  REWRITE_TAC[subdivFace];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM SUBST1_TAC;
  INTRO_TAC subdivFace0_induct [`(all (\ (l:(num)list). ~(l = []))) o fgraph`;`TL vs`;`g`;`(minimalFace (nonFinals g))`;`the (HD vs)`;`0`];
  REWRITE_TAC[o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  REWRITE_TAC[fgraph_makeFaceFinal];
  REPEAT (FIRST_X_ASSUM kill);
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace;split_face];
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  EXPAND_TAC "g'";
  REWRITE_TAC[fgraph];
  REWRITE_TAC[faces_graph];
  REWRITE_TAC[MAP_APPEND];
  REWRITE_TAC[APPEND_cat;Seq.all_cat];
  REWRITE_TAC[MAP];
  FIRST_X_ASSUM_ST `Face` MP_TAC;
  REPEAT LET_TAC;
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[Seq.all];
    ASM_REWRITE_TAC[];
    TYPIFY `~(FST (Face (APPEND (REVERSE ws) f1'') F) = [])` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[vertices_face_FST];
    REWRITE_TAC[APPEND_EQ_NIL];
    EXPAND_TAC "f1''";
    REWRITE_TAC[APPEND_EQ_NIL];
    BY(MESON_TAC[NOT_CONS_NIL]);
  COMMENT "last case";
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  FULL_EXPAND_TAC "fs";
  FULL_EXPAND_TAC "ws";
  FULL_EXPAND_TAC "f2''";
  REWRITE_TAC[GSYM Seq.map_MAP];
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[Seq.map_MAP;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  DISCH_THEN (MP_TAC o (MATCH_MP MEM_replace));
  REWRITE_TAC[MEM];
  DISCH_THEN DISJ_CASES_TAC;
    FIRST_X_ASSUM_ST `all` MP_TAC;
    REWRITE_TAC[fgraph];
    REWRITE_TAC[GSYM Seq.map_MAP;GSYM Seq.allP];
    REWRITE_TAC[Seq.map_MAP;MEM_MAP];
    BY(REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC) THEN MESON_TAC[]);
  FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o GSYM);
  FULL_EXPAND_TAC "x'";
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM_ST `upt` MP_TAC;
  REWRITE_TAC[vertices_face_FST];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[APPEND_EQ_NIL];
  BY(REWRITE_TAC[NOT_CONS_NIL])
]);;
  (* }}} *)

let mem_minimalFace_nonFinals = prove_by_refinement(
  `!g. ~(nonFinals g = []) ==> MEM (minimalFace (nonFinals g)) (nonFinals g)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  REWRITE_TAC[minimalFace];
  BY(MESON_TAC[mem_bn_minimal])
  ]);;
  (* }}} *)

let undup_cat = prove_by_refinement(
  `!s t. (!x. MEM x s ==> MEM x t) ==> undup (cat s t) = undup t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.undup;Seq.cat0s;MEM;Seq.cat];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM h t'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY_GOAL_THEN `MEM h (cat t t')` (unlist REWRITE_TAC);
    BY(ASM_REWRITE_TAC[Seq.mem_cat]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* was elements_of_list_seed *)

let list_of_elements_seed = prove_by_refinement(
  `!p. list_of_elements (fgraph (Seed p)) = REVERSE (upt 0 (p+3))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[bn_Seed;maxGon;graphl];
  GEN_TAC;
  REWRITE_TAC[LET_THM];
  REWRITE_TAC[fgraph_graph;MAP];
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.flatten_cons;Seq.cats0;Seq.flatten0];
  GMATCH_SIMP_TAC undup_cat;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.mem_rev;REVERSE_rev]);
  MATCH_MP_TAC Seq.undup_id;
  REWRITE_TAC[Seq.rev_uniq;REVERSE_rev];
  BY(REWRITE_TAC[Oxaxucs.upt0;Seq.iota_uniq])
  ]);;
  (* }}} *)

let good_vertices_set2_seed = prove_by_refinement(
  `!p. vertices_set2 (Seed p) = elements_of_list (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list;list_of_elements_seed];
  REWRITE_TAC[vertices_set2;bn_Seed;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
  BY(MESON_TAC[Seq.mem_rev;REVERSE_rev])
  ]);;
  (* }}} *)

let all_uniq_seed = prove_by_refinement(
  `!p. all uniq (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;bn_Seed;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[fgraph_graph];
  REWRITE_TAC[fgraph_graph;MAP;Seq.all];
  REWRITE_TAC[Seq.rev_uniq;REVERSE_rev];
  BY(REWRITE_TAC[Oxaxucs.upt0;Seq.iota_uniq])
  ]);;
  (* }}} *)

let EL_REPLICATE = prove_by_refinement(
  `!n i s. i < n ==> EL i (REPLICATE n s) = s`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[REPLICATE;EL_CONS];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let good_facesAt_seed = prove_by_refinement(
  `!p. (!v. v IN vertices_set2 (Seed p)
        ==> facesAt (Seed p) v = FILTER (\f. MEM v (FST f)) (faces (Seed p)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[good_vertices_set2_seed;List_hypermap.elements_of_list;IN_SET_OF_LIST;list_of_elements_seed];
  REWRITE_TAC[REVERSE_rev;Seq.mem_rev];
  REWRITE_TAC[vertices_set2;bn_Seed;graphl;maxGon;LET_THM;vertices_graph;countVertices];
  REWRITE_TAC[faces_graph];
  REWRITE_TAC[facesAt;bn_faceListAt];
  REWRITE_TAC[upt0];
  REWRITE_TAC[Seq.mem_iota] THEN REWRITE_TAC[arith `0 + n = n /\ 0 <= n`];
  SIMP_TAC[EL_REPLICATE];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[Seq.all_filterP;GSYM filter_FILTER];
  REWRITE_TAC[Seq.all;REVERSE_rev;Seq.mem_rev];
  BY(REWRITE_TAC[Seq.mem_iota] THEN REWRITE_TAC[arith `0 + n = n /\ 0 <= n`])
  ]);;
  (* }}} *)

let lemma_node_representation_eq = prove_by_refinement(
  `!H u. u IN node_set H <=> (?x. x IN dart H /\ u = node H x)`,
  (* {{{ proof *)
  [
BY(MESON_TAC[Hypermap.lemma_node_representation;Hypermap.lemma_in_hypermap_orbits])
  ]);;
  (* }}} *)

(*
let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) (HD n))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `HD x` ex
  asimp[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  intro List_hypermap.node_of_list_not_nil [`L`;`x`]
  art[]
  dthen (assume o mm Wmlnymd.MEM_HD)
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  abbrev `t = HD x`
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  mt[]
  dt
  abbrev `t = HD x`
  rt[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`t`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = t` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`t`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
...
  ]);;
  (* }}} *)

*)

let good_list_nodes_crit = prove_by_refinement(
  `!L. good_list L /\ 
     (!n. ?r. (MEM r n) /\ (!d. MEM n (list_of_nodes L) /\ MEM d n ==>
		        d IN node (hypermap_of_list L) r))
   ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes]
  st/r
  rt[EXTENSION;IN_SET_OF_LIST]
  rt[lemma_node_representation_eq]
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  gv "sn" then conj2
  rt[List_hypermap.nodes_of_list]
  rt[MEM_MAP]
  st/r
  fxa (C intro [`x`])
  st/r
  typ `r` ex
  subconj
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  fxa kill
  fxast `MEM` mp
  art[]
  rt[Seq.mem_filter]
  amt[Wmlnymd.dart_hypermap_of_list;IN_SET_OF_LIST]
  dt
  art[EXTENSION;Geomdetail.EQ_EXPAND]
  gv "e"
  conj then st/r
  fxa mmp
  art[]
  amt[IN_SET_OF_LIST]
  intro List_hypermap.fst_node_hypermap_of_list [`L`;`r`]
  ants
  art[]
  dthen (C intro [`e`])
  art[]
  dt
  rule(  rr[List_hypermap.list_of_nodes;MEM_MAP])
  repeat (fxa mp) then st/r
  art[IN_SET_OF_LIST]
  rt[Seq.mem_filter]
  conj
  rep 5 (fxa mp) then art[Seq.mem_filter]
  mt[]
  typ `e = r` asmcase
  art[]
  typ `e IN dart (hypermap_of_list L)` sat
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
amt[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
asimp[GSYM Wmlnymd.dart_hypermap_of_list;GSYM IN_SET_OF_LIST]
 contr then (fxa (assume o mm Hypermap.lemma_node_exception))
fxa (assume o mm Hypermap.lemma_node_identity)
intro Hypermap.node_refl [`hypermap_of_list L`;`r`]
rep 4 (fxa mp) then set[]
comment "second half"
st/r
fxa (sub1)
typ `MEM (FST x) (list_of_elements L) /\ node (hypermap_of_list L) x = set_of_list (filter (\d. FST d = FST x) (list_of_darts L))` ets
st/r
art[GSYM IN_SET_OF_LIST]
rt[IN_SET_OF_LIST;List_hypermap.nodes_of_list]
mmp MEMf_MAP
mmp Wmlnymd.node_of_element
art[]
xxd to here. Give lemma about node subset filter FST.
  ]);;
  (* }}} *)


REBIND_TAC;;
  Hypermap.lemma_node_representation;;

let good_list_nodes_seed = prove_by_refinement(
  `!p. good_list_nodes (fgraph (Seed p))`,
  (* {{{ proof *)
  [
  rt[List_hypermap.good_list_nodes;bn_Seed;graphl;maxGon;LET_THM;fgraph_graph]
  rt[MAP;List_hypermap.nodes_of_list;List_hypermap.list_of_nodes]

  ]);;
  (* }}} *)

good_graph;;


