(* Added May 2017, to restore compatibility with HOL Light *)


Lemma min_k_continuous k n f net: `!k n f net. (!i. i < n ==> f i real_continuous net) ==>
  (\x. min_k k (mkseq (\i. f i x) n)) real_continuous net`,
 str/r
 case `k < n:num`
 rt[min_k]
   1;;

reneeds "tame/ssreflect/sort-compiled.hl";;
search [`min_k`];;
1;;
   (*
	Proof.

	
case k_lt: `k < n:num` => /=; last first.
  rewrite min_k; set r := `\x. _ x`.
  suff ->: `r = \x. EL k (nseq n ((@)UNIV))` by rewrite REAL_CONTINUOUS_CONST.
  rewrite -r_def -eq_ext => m /=; apply ge_length_imp_EL_eq.
  by rewrite -size size_merge_sort size_mkseq size_nseq leqNgt.
rewrite !real_continuous !"GEN_ALL REALLIM".
case: `trivial_limit net` => /= f_cont e e_gt0.
suff: `?y. (?x. netord net x y) /\
        (!x. netord net x y ==> (!i:num. i < n ==> abs (f i x - f i (netlimit net)) < e))`.
  apply MONO_EXISTS => y [->] all_f; rewrite andTb => x net_x.
  rewrite !min_k.
  set s := `merge_sort (<=) _`; set s' := `merge_sort (<=) _`.
  rewrite !(EL_nth `&0`) -?s_def -?s'_def ?size_merge_sort ?size_mkseq //.
  rewrite s_def s'_def (sort_continuous `mkseq (\i. f i x) n` `mkseq (\i. f i (netlimit net)) n`).
  rewrite -{1}s_def -{1}s'_def !real_merge_sort !size_mkseq k_lt /= => i i_lt.
  by rewrite !nth_mkseq //= all_f.
have ord_xy: `?y x. netord net x y`.
  by move: (f_cont k_lt e_gt0) => [y] [] [x] h _; exists y x.
elim: n f_cont => [|m IH]; rewrite ?ltn0 /=.
  by move: ord_xy => [y] [x] ord_xy; exists y x.
move => f_cont; move: IH; "ANTS_TAC" => [i i_lt_m e' e'_gt0|].
  by rewrite f_cont e'_gt0; move: i_lt_m; arith.
move: (f_cont m e_gt0 (ltnSn m)).
rewr IMP_IMP => /NET_DILEMMA [y] [x_ord] h.
exists y; rewrite x_ord andTb "ARITH_RULE `i < SUC m <=> i = m \/ i < m`" => x ord_xy i.
case => [->|i_lt_m]; first by rewrite h.
by rewrite (h ord_xy).
Qed.

Lemma min_k_limit k s s' net:
        `(!n. LENGTH (s' n) = LENGTH s) /\
        (!i. i < LENGTH s ==> ((\n. EL i (s' n)) ---> EL i s) net) ==>
        ((\n. min_k k (s' n)) ---> min_k k s) net`.
Proof.
move => [len_eq s'_to].
case k_lt: `k < LENGTH s` => /=; last first.
  suff ->: `(\n. min_k k (s' n)) = (\n. min_k k s)` by rewrite REALLIM_CONST.
  rewrite !min_k -eq_ext => m /=; apply ge_length_imp_EL_eq.
  by rewrite -size !size_merge_sort size len_eq leqNgt.
move: s'_to; rewrite !"GEN_ALL REALLIM".
case: `trivial_limit net` => /= el_cont e e_gt0.
suff: `?y. (?x. netord net x y) /\
        (!x. netord net x y ==> (!i. i < LENGTH s ==> abs (EL i (s' x) - EL i s) < e))`.
  apply MONO_EXISTS => y [->] all_el; rewrite andTb => x net_x.
  rewrite !min_k.
  set l := `merge_sort (<=) _`; set l' := `merge_sort (<=) _`.
  rewrite !(EL_nth `&0`) -?l_def -?l'_def ?size_merge_sort ?size_mkseq ?size ?len_eq //.
  rewrite l_def l'_def (sort_continuous `s' x` s).
  rewrite -{1}l_def -{1}l'_def !real_merge_sort size len_eq k_lt /= => i i_lt.
  by rewrite -!EL_nth ?size ?len_eq // all_el.
have ord_xy: `?y x. netord net x y`.
  by move: (el_cont k_lt e_gt0) => [y] [] [x] h _; exists y x.
elim: s s' len_eq el_cont => [|h t IH]; rewrite !LENGTH ?ltn0 // => s' len_eq el_cont.
move: (IH `\n. TL (s' n)`); do !"ANTS_TAC".
  move => n; rewrite LENGTH_TL ?len_eq; last by arith.
  by apply: contraL (len_eq n) => ->; rewrite LENGTH; arith.
  move => i i_lt e' e'_gt0.
  by move: (el_cont `SUC i` e'_gt0); rewrite ltSS i_lt /= !EL TL.
move: (el_cont `0` e_gt0); rewrite gtS0 /=.
rewr IMP_IMP => /NET_DILEMMA [y] [x_ord] h.
exists y; rewrite x_ord andTb => x ord_xy [_|i]; first by rewrite h.
by rewrite ltSS => i_lt; rewrite !EL TL (h ord_xy).
Qed.
   *)
