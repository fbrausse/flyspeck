(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter: Hypermap, Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: 2011-04-29 -- 2013-08                                                *)
(* ========================================================================== *)

(* Port The Bauer-Nipkow completeness theorem from Isabelle,
    based on
   http://afp.sourceforge.net/browser_info/current/HOL/Flyspeck-Tame/outline.pdf

   This is a translation of the Isabelle results.  

   The tame_classification_theorem is the translation into HOL
   Light of the main result of Flyspeck I, Bauer-Nipkow.  

*)

needs "Library/rstc.ml";; (* for RTC reflexive transitive closure *)
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;

(*
flyspeck_needs "../tame_archive/tame_archive.hl";;
*)

module Import_tame_classification = struct

  open Hales_tactic;;

  let overrides,add_override = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map override_interface (!os) in
      (oo,ao);;
  
  let override_interface' (a,b) = 
    let _ = report ("override " ^ a ^ " " ^(string_of_term b)) in
    let _ = add_override (a,b) in
      override_interface (a,b);;

  let makeovers,add_makeover = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map (fun (a,b) -> make_overloadable a b) (!os) in
      (oo,ao);;
  
  let make_overloadable' a b = 
    let _ = report ("makeover " ^ a ^ " " ^(string_of_type b)) in
    let _ = add_makeover (a,b) in
      make_overloadable a b;;

  let overloads,add_overload = 
    let os = ref [] in
    let ao t = (os := t :: !os) in
    let oo() = map overload_interface (!os) in
      (oo,ao);;
  
  let overload_interface' (a,b) = 
    let _ = report ("overload " ^ a ^ " " ^(string_of_term b)) in
    let _ = add_overload (a,b) in
      overload_interface (a,b);;

  let parse_as_infixes,add_parse_as_infix =
    let pais = ref [] in
    let apai t = (pais := t :: !pais) in
    let pai () = map parse_as_infix (!pais) in
      (pai,apai);;

  let parse_as_infix' t = 
    let _ = add_parse_as_infix t in
      parse_as_infix t;;

  let notation() = 
    let _ = parse_as_infixes() in
    let _ = overrides() in
    let _ = makeovers() in
    let _ = overloads() in
      ();;

parse_as_infix' ("::", (12, "right"));;
override_interface' ("::", `CONS`);;
parse_as_infix' ("^^", (24, "right"));;
override_interface' ("^^", `POWER`);;

  let ISADIR = 
    let dir = (Sys.getenv "FLYSPECK_DIR") in
     Filename.concat dir "../isabelle_graph";;

  let HOLDIR = Filename.concat ISADIR "hol";;
  let TAMEDIR = Filename.concat ISADIR "tame";;

  let TESTDIR = "~/Desktop";;

  let tamefile  = Filename.concat TAMEDIR;;
  let holfile = Filename.concat HOLDIR;;
  let testfile = Filename.concat TESTDIR;;


(* ************************************************************************** *)
(* TYPES *)
(* ************************************************************************** *)

  let new_definition' t = 
    if has_stv t 
    then (Print_types.print_term_types t; failwith "new_definition has stv") 
    else new_definition t;;


(*
types: num, (A) list, (A ==> B), (A) Option, A#B, bool.
(* type (a,b) table is (a#b) list *)
*)


  type liz_ty = {
    liz_ty_loc : (string*int*int);
    liz_t : string;
    liz_h : string;
  };;

  let lizt = ref [];;

  let liz_ty recd = 
    let _ = lizt := (recd::!lizt) in ();;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "vertex";
    liz_h = "num";
  };;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "facetype";
    liz_h = "bool";
  };;

  liz_ty {
    liz_ty_loc = ("",0,0);
    liz_t = "face";
    liz_h = "(num list)#bool";
  };;

(*  datatype graph = Graph "(face list)" "nat" "face list list" "nat list" *)

  liz_ty {
    liz_ty_loc = (tamefile "Graph.thy",117,117);
    liz_t = "graph";
    liz_h = "((num list#bool) list) # num # (((num list#bool) list) list) # num list";
  };;

  liz_ty {
    liz_ty_loc = (tamefile "Vector.thy",10,10);
    liz_t = "vector";
    liz_h = "list";
  };;

(*
type_synonym 'a Fgraph = "'a list set"
type_synonym 'a fgraph = "'a list list"
*)

  liz_ty {
    liz_ty_loc = (tamefile "PlaneGraphIso.thy",43,43);
    liz_t = "(A) Fgraph";
    liz_h = "(A) list -> bool";
  };;

  liz_ty {
    liz_ty_loc = (tamefile "PlaneGraphIso.thy",44,44);
    liz_t = "(A) fgraph";
    liz_h = "((A) list) list";
  };;

(* ************************************************************************** *)
(* TERMS *)
(* ************************************************************************** *)

  let unsplit = Flyspeck_lib.unsplit;;

  let trim = Flyspeck_lib.trim;;

(* expand syntactic sugar *)

  let get_liz_def = 
    let p = Printf.sprintf in
    let tok = "[a-zA-Z0-9_]*" in
    let words = "[a-zA-Z0-9_ ]*" in
    let wordp = "[a-zA-Z0-9_)@^(=.\\ ]*" in
    let escape_quote = "'s/\"/ \\\" /g'" in
    let expand_angle1 = p "'s/\\\\<^\(%s\)>/ ___\1 /g'" tok in
    let expand_angle2 = p "'s/\\\<\([%s\)>/ __\1 /g'" tok in
    let expand_let = p "'s/ let *\([^;]*\) *; *\(.*\) in / let \1 in let \2 in /g'" in
    let expand_comment = p "'s/(\*[^*]*\*)//g'" in
      (* expand_Squnion : ListAux.thy 120,123 *)
    let expand_Squnion = p "'s/__Squnion *___bsub *\(%s\)  *__in  *\(.*\) *___esub *\([^()\"]*\)/(concat (map(\\\\ \1 . \3 )  (\2) ))/g'" tok in
    let expand_upt = p "'s/\[ *\(%s\) *\.\.< *\([^]]*\) *\]/(upt (\1) (\2))/g'" words  in
    let expand_map = p "'s/\[\([^.]*\)\. *\(%s\) *<- *\(%s\)\]/(map (\\\\ \2 . \1) (\3))/g'" tok words in
    let expand_map2 = p "'s/\[\([^.]*\)\. *\(%s\) *__leftarrow *\(%s\)\]/(map (\\\\ \2 . \1) (\3))/g'" tok wordp in
    let expand_filter = p "'s/\[\([^.]*\) *__leftarrow *\([^.]*\) *\. *\(%s\)\]/(filter (\\\\ \1 . \3) (\2))/g'" wordp in
      (* expand_update : List.thy 118,126 *)
    let expand_update = p "'s/\(%s\) *\[\(%s\) *:= *\([^]]*\)\]/(list_update (\1) (\2) (\3))/g'" tok tok in
    let expand_length = p "'s/| *\(%s\) *|/(length \1)/g'" tok in
    let expand_length2 = p "'s/|\(%s\)|/(length (\1))/g'" wordp in
    let expand_isub = p "'s/ *___isub *//g'" in
    let expand_forall_in = p "'s/__forall *\(%s\) *__in *\([^.]*\) *\./__forall \1 . (\1 __in \2) __longrightarrow/g'" tok in
    let expand_nextV = p "'s/\(%s\) *___bsup *\(%s\) *___esup *__bullet *\(%s\)/nextVertices \1 \2 \3/g'" tok tok tok in
    let expand_label1 = p "'s/where *[a-zA-Z0-9_]*:/where /g'" in
    let expand_label2 = p "'s/| *[a-zA-Z0-9_]*:/| /g'" in
    let case_num = p "'s!case *\(%s\) *of *0 *__Rightarrow * \([^|]*\) *| *Suc *\(%s\) *__Rightarrow *\([a-zA-Z0-9!#_ ]*\)!(if (\1 = 0) then (\2) else (let \3 = PRE (\1) in (\4)))!g'" tok tok in
    let case_facetype = p "'s!case *\(%s\) *of *Final *__Rightarrow * \([^|]*\) *| *Nonfinal *__Rightarrow *\([a-zA-Z0-9!#_ ]*\)!(if (\1 = Final) then (\2) else (\3))!g'" tok in
    let case_list = p "'s!case *\(%s\) *of *\[\] *__Rightarrow * \([^|]*\) *| *( *\(%s\) *# *\(%s\) *) *__Rightarrow *\([a-zA-Z0-9!#<_ ]*\)!(if (\1 = []) then (\2) else (let \3 = HD (\1) in (let \4 = TL (\1) in \5)))!g'" tok tok tok in
    let case_vector = p "'s!case *\(%s\) *of *(Vector \(%s\)) *__Rightarrow * \([^\"]*\) !(let \2 = \1 in (\3))!g'" tok tok in
    let case_option = p "'s!case *\(%s\) *of *None *__Rightarrow *\([^|]*\) *| *(Some \(%s\)) *__Rightarrow *\([a-zA-Z0-9_+=,() ]*\)!(if (\1 = None) then (\2) else (let \3 = the (\1) in (\4)))!g'" tok tok in
      (* Vector.thy 40 "\<lbrakk>f. x < m, y < n\<rbrakk>" == "CONST tabulate2 m n (\<lambda>x y. f)" *)
    let expand_tab = p "'s/__lbrakk *\([^.]*\) *\. *\(%s\) *< *\(%s\) *, *\(%s\) *< *\(%s\) *__rbrakk/ tabulate2 (\3) (\5) (\\\\ \2 \4 . \1) /g'" tok words tok words in
    let expand_RT = p "'s/\(%s\) *\[\(%s\)\] *__rightarrow *\* *\(%s\)/ ((\1),\3) __in RTranCl (\2) /g'" words words tok in (* was t w t *)
    let expand_in_set = p "'s/\(%s\) *\[\(%s\)\] *__rightarrow *\(%s\)/ (\3) __in set_of_list((\2) \1) /g'" tok tok tok in 
    let expand_set = p "'s/{\([^.}]*\)\.\([^}]*\)}/{\1 | \2}/g'" in
    let expand_sum2 = p "'s/ __Sum *___bsub *\(%s\)  *__in  *\(%s\) *___esub *\(%s(%s)\)/listsum (map (\\\\ \1 . \3) (\2)) /g'" tok wordp words words in
    let expand_sum = p "'s/ __Sum *___bsub *\(%s\)  *__in  *\(%s\) *___esub *\(%s\)/listsum (map (\\\\ \1 . \3) (\2)) /g'" tok wordp words in
    let expand_union = p "'s/ __Union *\(%s\)  *__in  *\(%s\) *\. *\(%s\)/UNIONS (IMAGE (\\\\ \1 . \3) (\2)) /g'" tok tok words in
    let expand_sub = p "'s/ ___bsub *\(%s\) *___esub/ \1 /g'" tok in
    let expand_cong = p "'s!//{ *__cong *}! //// (__cong) !g'" in
    let expand_pattern = p "'s!|! /\\\\ !g'" in
(*     let expand_quote = p "'s/\"/ /g'" in *)
    let e = unsplit " -e " (fun x -> x) 
      [escape_quote;expand_angle1;expand_angle2;
       expand_let;expand_let;       expand_let;expand_let;       expand_let;expand_let;       
       expand_let;expand_let;       expand_let;expand_let;       expand_let;expand_let;       
       expand_comment;
       expand_Squnion;expand_length2;expand_upt;expand_map;expand_map2;expand_filter;expand_update;
       expand_length;expand_length2;expand_isub;expand_forall_in;expand_nextV;
       expand_label1;expand_label2;case_num;case_facetype;case_list;case_vector;case_option;
       expand_tab;expand_RT;expand_in_set;expand_set;expand_sum2;expand_sum;
       expand_union;expand_sub;expand_cong;expand_pattern] in 

      fun file lines expand ->
	if (file="") then "" else
	  let e2 = unsplit " -e " (fun x -> x)       [escape_quote] in
	  let sed = p "sed -n %d,%dp %s | tr '\t\n\\047' '  _' | sed -e %s " (fst lines) (snd lines) file e in
	  let sed2 = p "sed -n %d,%dp %s | tr '\t\n\\047' '  _' | sed -e %s " (fst lines) (snd lines) file e2 in
	  let sed'  = if expand then sed else sed2 in
	    if Sys.file_exists file then (process_to_string sed') 
	    else ("def-file not found "^file);;

  let get_hol_def fil lines = 
    let file = Filename.concat HOLDIR fil in
      get_liz_def file lines true;;

  let get_tame_def fil lines = 
    let file = Filename.concat TAMEDIR fil in
      get_liz_def file lines true;;

  let report_def dir files name after = 
    let searchdir = Filename.concat dir files in
    let sp = Printf.sprintf in
    let grep = sp "grep -A%d -n '\(primrec\|definition\|abbreviation\|defs .overloaded.\)[ \"]*%s' %s" in
    let out = process_to_string(grep after name searchdir) in
      report(out);;

  let report_tame_def = report_def TAMEDIR "*";;

  let report_list_def = report_def HOLDIR "List.thy";;

  type liz_record = {
    liz_loc : (string*int*int);
    liz_name : string;
    liz_holl : term;
    liz_thm : thm;
  };;

  let print_liz t = 
    let (loc,a,b) = t.liz_loc in
      if (loc = "") then report ("NOT FOUND") else
	report (get_liz_def loc (a,b) true);;

  let lizl = ref [];;

(* Example: *)
report_tame_def "replace" 4;;
report (get_tame_def "ListAux.thy" (167,170));;

  let translate_precedence_to_holl n = if n < 66 then n / 4 else 16 + (n - 66);;

  let get_infixr   =
    let reg = Str.regexp ".*infixr* *\" *\([^\"]*\)\" *\([0-9]*\).*where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("",0) else
	    let sy = Str.matched_group 1 s in
	    let p0 =  (Str.matched_group 2 s) in
	    let p = try int_of_string p0 with _ -> failwith p0 in
	      (sy,p);;

  let get_infixl   =
    let reg = Str.regexp ".*infixl *\" *\([^\"]*\)\" *\([0-9]*\).*where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("",0) else
	    let sy = Str.matched_group 1 s in
	    let p0 =  (Str.matched_group 2 s) in
	    let p = try int_of_string p0 with _ -> failwith p0 in
	      (sy,p);;

  let get_interface = 
    let reg = Str.regexp ".*:: *\"[^\"]*\" *( *\" *\([A-Za-z0-9_]*\) *\" *) *where.*" in
      fun s ->
	let b = Str.string_match reg s 0 in
	  if not(b) then ("") else
	    let sy = Str.matched_group 1 s in
	      sy;;

  let get_name = 
    let reg1 = Str.regexp "\([A-Za-z0-9_]*\) *::" in
    let reg2 = Str.regexp "primrec *\([A-Za-z0-9_]*\) *where" in
    let reg3 = Str.regexp "defs *([A-Za-z]) *\([A-Za-z0-9_]*\) *:" in
    let get reg s = 
      let _ = Str.search_forward reg s 0 in
	    Str.matched_group 1 s in
      fun s ->
	try get reg1 s
	with Not_found -> 
	  try get reg2 s
	  with Not_found ->
	    try get reg3 s
	    with Not_found -> "";;

  let basic_dictionary = 
    [
    ("[]","[]");
    ("Suc","SUC");
    ("__in","IN");
    ("@","#@#");
    ("#","::");
    ("!","#!#");
    ("`","#?#");
    ];;

  let infixr (s, p) = 
    if (s,p) = ("",0) then "" else
      let s' = trim s in
      let ix = assocd s' basic_dictionary s' in
      let _ = report ("adding infixr "^ix) in
      let _ = parse_as_infix' (ix, (translate_precedence_to_holl p,"right")) in
	ix;;

  let infixl (s, p) = 
    if (s,p) = ("",0) then "" else
      let s' = trim s in
      let ix = assocd s' basic_dictionary s' in
      let _ = report ("adding infixl "^ix) in
      let _ = parse_as_infix' (ix, (translate_precedence_to_holl p,"left")) in
	ix;;

  let liz_add recd = 
    let _ = lizl := (recd:: !lizl) in
    let (loc,a,b) = recd.liz_loc in
    let s = get_liz_def loc (a,b) true in
    let ixr = infixr (get_infixr s) in
    let _ = (ixr="") or (override_interface'(ixr,recd.liz_holl); true) in
    let ixl = infixl (get_infixl s) in
    let _ = (ixl="") or (override_interface'(ixl,recd.liz_holl); true) in
    let ix = get_interface s in
    let _ = (ix="") or (override_interface'(ix,recd.liz_holl); true) in
    let _ = print_liz recd in
    let nm = get_name s in
    let _ = nm = recd.liz_name or (report ("liz_add name mismatch "^nm); true) in
      recd.liz_thm;;

  let get_liz s = 
    let u = filter (fun recd -> recd.liz_name = s) !lizl in
    let recd = hd u in
    let _ = print_liz recd in
      recd.liz_thm;;


(*
  let infix_table =
    [
    (* List.thy *) ("#","#",'r',65,`CONS`);
      ("append","@",'r',65);
      ("nth","!",'l',100);
      (* Nat.thy *)
      ("funpow","^^",'r',80); 
      (* PlaneGraphIso.thy *)
      ("congs","\<cong>",'x',60); (* no direction 'l' 'r' assigned. Overloaded. *)
    ];;

*)

(*  infixes: =~ (congs) is congruence modulo rotation on lists,  -~ unused on lists.
                  =~ is pr_isomorphism on graphs, -~ isomorphic of graphs.

     {=~} is Isabelle notation for {(f1,f2). f1 =~ f2}.

    type a Fgraph  a list -> bool
            a fgraph a list list
*)
(* overload append -> #@# *)

liz_add {
liz_name = "append";
liz_loc =  (holfile "List.thy",51,53);
liz_holl = `APPEND`;
liz_thm = APPEND;
};;

let nth_EL = prove_by_refinement(
  `!x xs n k.
    ((n = 0) ==> (\l n. EL n l) (x::xs) n = x) /\ 
     ((n = SUC k) ==> (\l n. EL n l) (x::xs) n = (\l n. EL n l) xs k)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL]
  ]);;
  (* }}} *)

(*
let case = new_definition' `case (n:A) (a1, b1:B) (a2,b2) = 
  if (n=a1) then b1 else if (n=a2) then b2 else b2`;;
*)

let nnnth = new_definition' `( #!# ) (l:(A) list) n = EL n l`;;

let bn_EL = prove_by_refinement(
  `(#!#) (x::xs) n = if (n = 0) then (x:A) else (let k = PRE n in (#!#) xs k)`,
  (* {{{ proof *)
  [
  COND_CASES_TAC THEN ASM_REWRITE_TAC[nnnth;EL;HD;TL];
  LET_TAC;
  TYPIFY `n = SUC k` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[EL;HD;TL])
  ]);;
  (* }}} *)

let not_equal = new_definition' `( ~= ) (x : A) y <=> ( ~(x = y))`;;

liz_add {
liz_name = "not_equal";
liz_loc =  (holfile "HOL.thy",86,90);
liz_holl = `( ~= ):A->A -> bool`;
liz_thm = not_equal;
};;

liz_add {
liz_name = "nth";
liz_loc =  (holfile "List.thy",106,107);
liz_holl = `(#!#):A list -> num -> A`;
liz_thm = bn_EL;
};;

(* XX use a lemma to justify length. such as length_append in List.thy *)
liz_add {
liz_name = "length";
liz_loc =  (holfile "List.thy",189,190); (* see note on lines 185--187, size is overloaded for all datatypes. *)
liz_holl = `(LENGTH:A list -> num)`;
liz_thm = LENGTH;
};;

liz_add {
liz_name = "rev";
liz_loc =  (holfile "List.thy",55,57); 
liz_holl = `REVERSE:A list -> A list`;
liz_thm = REVERSE;
};;


(* List operations in Isabelle-Main:
   op @, concat, filter, length, map, op !, remove1, rev, 
   rotate, rotate1, upto, upt, zip.

   Other things in main:
   the,
   See http://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/Isabelle2013/doc/main.pdf
*)

(*
(* HOL Light definition from hypermap. Use ITER instead. *)

parse_as_infix'("POWER",(24,"right"));;

let POWER = new_recursive_definition num_RECURSION 
  `(!(f:A->A). f POWER 0  = I) /\  
   (!(f:A->A) (n:num). f POWER (SUC n) = (f POWER n) o f)`;;
*)

let APPEND_cat = prove_by_refinement(
  `APPEND = cat`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[APPEND; Seq.cat0s]);
  BY(ASM_REWRITE_TAC[APPEND;Seq.cat_cons])
  ]);;
  (* }}} *)

(* import of 1.1 HOL *)

let the = new_definition' `the s = @(x:A). (s = SOME x)`;;

let the_some = prove_by_refinement(
  `!(x:A). the (SOME x) = x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[the];
  GEN_TAC;
  SELECT_TAC;
    INTRO_TAC option_RECURSION [`x`;`I:A->A`];
    REWRITE_TAC[I_THM];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

liz_add {
liz_name = "the";
liz_loc =  (holfile "Option.thy",39,40); 
liz_holl = `the`;
liz_thm = the_some;
};;

Seq.size;; (* sizel = LENGTH *)


(* 1.2 length xs, 1.2.2 filter P xs, 1.2.3 concat,  *)

let filter_liz = prove_by_refinement(
  `filter (f:A->bool) [] = [] /\
    filter f (x:: xs) = if (f x) then (x :: (filter f xs)) else (filter f xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.filter])
  ]);;
  (* }}} *)

liz_add {
liz_name = "filter";
liz_loc =  (holfile "List.thy",59,62); 
liz_holl = `filter`;
liz_thm = filter_liz;
};;

let filter_FILTER = prove_by_refinement(
  `filter = FILTER`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  GEN_TAC;
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.filter;FILTER])
  ]);;
  (* }}} *)

let concat_flatten = prove_by_refinement(
  `!x xs. flatten ([]:(A list)list) = [] /\
    flatten ( (x:A list) :: xs) = APPEND x (flatten xs)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Seq.flatten0;Seq.flatten_cons;APPEND_cat])
  ]);;
  (* }}} *)

liz_add {
liz_name = "concat";
liz_loc =  (holfile "List.thy",87,90); 
liz_holl = `flatten`;
liz_thm = concat_flatten;
};;

(*
let concat = new_recursive_definition list_RECURSION
  `concat ([]:(A list)list) = [] /\
    concat ( (x:A list) :: xs) = APPEND x (concat xs)`;;
*)

(* notation: disjoint_sum { x in xs } f  = flatten (MAP (\x. f) xs) *)

(* list_update *)

(* 1.2.3 listProd1, listProd *)

liz_add {
liz_name = "map";
liz_loc =  (holfile "List.thy",47,50); 
liz_holl = `MAP`;
liz_thm = MAP;
};;

Seq.map_MAP;; (`map = MAP`);;

let list_prod1 = new_definition' `list_prod1 (a:A) (b:B list) = 
   MAP(\x. (a,x)) b`;;

let list_prod = new_definition' `list_prod (a:A list) (b:B list) =
   flatten (MAP (\x. list_prod1 x b) a)`;;

liz_add {
liz_name = "listProd1";
liz_loc =  (tamefile "ListAux.thy",127,129); 
liz_holl = `list_prod1`;
liz_thm = list_prod1;
};;

liz_add {
liz_name = "listProd";
liz_loc =  (tamefile "ListAux.thy",130,132); 
liz_holl = `list_prod`;
liz_thm = list_prod;
};;

(* 1.2.5 *)

let bn_minimal = new_recursive_definition list_RECURSION
  `(bn_minimal (f:A->num)  [] = CHOICE (UNIV:A->bool)) /\ 
    (bn_minimal (f:A->num) ( (x:A) :: xs) = if (xs= []) then (x:A) else
        (let m = bn_minimal f xs in (if(f x <= f m) then x else m)))`;;

liz_add {
liz_name = "minimal";
liz_loc = ("",0,0); (* XX can't find it! *)
liz_holl = `bn_minimal`;
liz_thm = bn_minimal;
};;

(* benign redefinition from Misc_defs_and_lemmas module *)

let min_num = new_definition' `min_num X = (@m. (m:num) IN X /\ (!n. n IN X ==> m <= n))`;;

let min_list = new_definition' `min_list (xs:num list) = min_num (set_of_list xs)`;;

let min_num_single = prove_by_refinement(
  `!x. min_num {x} = x`,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `x IN {x} ==> min_num {x} IN {x}` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[IN];
    BY(MESON_TAC[Misc_defs_and_lemmas.min_least ]);
  BY(REWRITE_TAC[IN_SING])
  ]);;
  (* }}} *)

let min_num_in = prove_by_refinement(
  `!X. ~(X = {}) ==> min_num X IN X`,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_le = prove_by_refinement(
  `!X c. c IN X ==> min_num X <= c`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_unique = prove_by_refinement(
  `!X c. c IN X /\ (!c'. c' IN X ==> c <= c') ==> min_num X = c`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `x <= (c:num) /\ c <= x ==> x = c`);
  CONJ_TAC;
    MATCH_MP_TAC min_num_le;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  MATCH_MP_TAC min_num_in;
  BY(FIRST_X_ASSUM MP_TAC THEN SET_TAC[])
  ]);;
  (* }}} *)

let min_num_insert = prove_by_refinement(
  `!x X. ~(X = {}) ==> min_num (x INSERT X) = MIN x (min_num X)`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  TYPIFY `x IN x INSERT X` (C SUBGOAL_THEN ASSUME_TAC);
    BY(SET_TAC[]);
  DISCH_TAC;
  MATCH_MP_TAC min_num_unique;
  CONJ_TAC;
    REWRITE_TAC[MIN];
    COND_CASES_TAC;
      BY(SET_TAC[]);
    TYPIFY `min_num X IN X` ENOUGH_TO_SHOW_TAC;
      BY(SET_TAC[]);
    MATCH_MP_TAC min_num_in;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[IN_INSERT];
  REPEAT STRIP_TAC;
    ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC (arith `m <= min_num X /\ min_num X <= c' ==> m <= c'`);
  CONJ_TAC;
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC min_num_le;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let minn_MIN = prove_by_refinement(
  `minn = MIN`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[MIN;Ssrnat.minn];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let min_list_liz = prove_by_refinement(
  `!x xs. min_list (x :: xs) = if (xs = []) then x else MIN x (min_list xs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[min_list;set_of_list];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[set_of_list;min_num_single]);
  MATCH_MP_TAC min_num_insert;
  BY(ASM_REWRITE_TAC[SET_OF_LIST_EQ_EMPTY])
  ]);;
  (* }}} *)

liz_add {
liz_name = "min_list";
liz_loc =  (tamefile "ListAux.thy",149,151); 
liz_holl = `min_list`;
liz_thm = min_list_liz;
};;

(* 1.2.6 replace *)

let replace = new_recursive_definition list_RECURSION 
   `(replace x ys [] = []) /\
     replace x ys ( (z:A) :: zs) = 
            if (z = x) then APPEND ys zs else z:: (replace x ys zs)`;;

liz_add {
liz_name = "replace";
liz_loc =  (tamefile "ListAux.thy",167,171); 
liz_holl = `replace`;
liz_thm = replace;
};;

(* clean this up later.  Isabelle has special notation for (list_update f n [] xs) *)

(*
let map_at1 = new_recursive_definition list_RECURSION
   `map_at1 (f:A->A) n xs [] = REVERSE xs /\
     map_at1 (f:A->A) n xs ((y:A) :: ys) = if (n=0) then (APPEND (REVERSE xs) ( (f y) :: ys)) 
         else (map_at1 f (n-1) (y :: xs) ys)`;;
*)

let list_update = new_recursive_definition list_RECURSION
  `list_update [] i (v:A) = [] /\
   list_update (x :: xs) i (v:A) = 
      if (i=0) then (v :: xs) else (x :: list_update xs (i-1) v)`;;

let list_update_ALT = prove_by_refinement(
  `list_update [] i v = [] /\ 
   list_update (x :: xs) i v =   ((if (i = 0) then (v :: xs ) else (let j = PRE (i) in (x ):: list_update xs j v)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[list_update];
  COND_CASES_TAC THEN REWRITE_TAC[] THEN LET_TAC;
  TYPIFY `j = i-1` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

liz_add {
liz_name = "list_update";
liz_loc =  (holfile "List.thy",111,115); 
liz_holl = `list_update`;
liz_thm = list_update_ALT;
};;

(*
let map_at = new_recursive_definition list_RECURSION 
  `(map_at [] (f:A->A) (xs:A list) = xs) /\
    (map_at ((n:num) :: ns) (f:A->A) (xs:A list) = if (n < LENGTH xs) 
       then map_at ns f (map_at1 f n [] xs) else map_at ns f xs)`;;
*)

let mapAt = new_recursive_definition list_RECURSION 
  `(mapAt [] (f:A->A) (xs:A list) = xs) /\
    (mapAt ((n:num) :: ns) (f:A->A) (xs:A list) = if (n < LENGTH xs) 
       then mapAt ns f (list_update xs n (f (EL n xs))) else mapAt ns f xs)`;;

let mapAt_ALT = prove_by_refinement(
  `(mapAt [] (f:A->A) (xs:A list) = xs) /\
    (mapAt ((n:num) :: ns) (f:A->A) (xs:A list) = if (n < LENGTH xs) 
       then mapAt ns f (list_update xs n (f (xs #!# n))) else mapAt ns f xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[mapAt;nnnth])
  ]);;
  (* }}} *)

liz_add {
liz_name = "mapAt";
liz_loc =  (tamefile "ListAux.thy",172,177); 
liz_holl = `mapAt`;
liz_thm = mapAt_ALT;
};;

(* 1.2.9 rotate *)

(* `rot` is different because rot changes only up to the length of the list *)

let rotate1 = new_recursive_definition list_RECURSION
   `rotate1 ([]:A list) = [] /\
     rotate1 ((x:A) :: xs) = APPEND xs [x]`;;

let rotate = new_definition' `rotate (n:num) (xs:A list) = (ITER n rotate1) xs`;;

let ITER_o = prove_by_refinement(
  `(!f n. ITER 0 f = I /\ ITER (SUC n) f = f o ITER n f )`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;ITER;I_THM;o_THM])
  ]);;
  (* }}} *)

liz_add {
liz_name = "funpow";
liz_loc =  (holfile "Nat.thy",1246,1249); 
liz_holl = `ITER`;
liz_thm = ITER_o;
};;

liz_add {
liz_name = "rotate1";
liz_loc =  (holfile "List.thy",192,195); 
liz_holl = `rotate1`;
liz_thm = rotate1;
};;

let POWER_TO_ITER = Wrgcvdr_cizmrrh.POWER_TO_ITER;;

liz_add {
liz_name = "rotate";
liz_loc =  (holfile "List.thy",196,198); 
liz_holl = `rotate`;
liz_thm = REWRITE_RULE[GSYM POWER_TO_ITER] rotate;
};;

let rotate_rotate1 = prove_by_refinement(
  `rotate 1 = rotate1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[rotate];
  BY(REWRITE_TAC[rotate;ITER_1])
  ]);;
  (* }}} *)

let rotate1_rot1 = prove_by_refinement(
  `rotate1 = rot 1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate1;Seq2.rot_nil]);
  REWRITE_TAC[rotate1;Seq.rot1_cons];
  BY(REWRITE_TAC[rotate1;Seq.rot1_cons;GSYM Seq.cats1;APPEND_cat])
  ]);;
  (* }}} *)

let rotate_rot = prove_by_refinement(
  `!n x. n <= LENGTH x ==> rotate n x = rot n x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(REWRITE_TAC[Seq.rot0;rotate;ITER]);
  REWRITE_TAC[arith `SUC n = n + 1`];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.rot_addn;
  REWRITE_TAC[rotate;GSYM ITER_ADD;ITER_1];
  ASM_REWRITE_TAC[GSYM rotate;Seq.size;rotate1_rot1];
  FIRST_X_ASSUM MATCH_MP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size;Seq.size_rot];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rotate_add = prove_by_refinement(
  `!n m x. rotate (n+m) x = rotate n (rotate m x)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER_ADD])
  ]);;
  (* }}} *)

let rotate_nil = prove_by_refinement(
  `!n. rotate n [] = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate;ITER]);
  BY(ASM_REWRITE_TAC[arith `SUC n = n + 1`;rotate_add;rotate_rotate1;rotate1])
  ]);;
  (* }}} *)

let rotate_periodic = prove_by_refinement(
  `!n x. rotate (n + LENGTH x) x = rotate n x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[rotate_add];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  GMATCH_SIMP_TAC rotate_rot;
  REWRITE_TAC[arith `x <= (x:num)`];
  BY(REWRITE_TAC[GSYM Seq.size;Seq.rot_size])
  ]);;
  (* }}} *)

let rotate_mod = prove_by_refinement(
  `!(x:(A)list) n. rotate n x = rotate (n MOD LENGTH x) x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate_nil]);
  INTRO_TAC Oxl_2012.periodic_mod1 [`\n. rotate n (h::t)`];
  REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[LENGTH];
    BY(ARITH_TAC);
  REWRITE_TAC[ Oxl_def.periodic];
  BY(REWRITE_TAC[rotate_periodic])
  ]);;
  (* }}} *)

(* 1.3 splitAt *)

let split_at_rec = new_recursive_definition list_RECURSION 
 `split_at_rec (c:A) bs [] = (bs,[]) /\
   split_at_rec c bs ((a:A) :: xs) = if (a = c) then (bs,xs) else split_at_rec c (APPEND bs [a]) xs`;;

let split_at = new_definition' `split_at (c:A) xs = split_at_rec c [] xs`;;

liz_add {
liz_name = "splitAtRec";
liz_loc =  (tamefile "ListAux.thy",547,551); 
liz_holl = `split_at_rec`;
liz_thm = split_at_rec;
};;

liz_add {
liz_name = "splitAt";
liz_loc =  (tamefile "ListAux.thy",552,554); 
liz_holl = `split_at`;
liz_thm = split_at;
};;

(* 1.4 between *)

let INSERT_liz = prove_by_refinement(
  `(INSERT) a B = {x | x = a \/ x IN B}`,
  (* {{{ proof *)
  [
  REWRITE_TAC[INSERT;EXTENSION;IN_ELIM_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

unparse_as_infix "INSERT";;

liz_add {
liz_name = "insert";
liz_loc =  ("",0,0);  (* XX *)
liz_holl = `INSERT`;
liz_thm = INSERT_liz;
};;

liz_add {
liz_name = "set";
liz_loc =  (holfile "List.thy",40,43); 
liz_holl = `set_of_list`;
liz_thm = set_of_list;
};;

let betwn = new_definition' `betwn (vs:A list) (ram1:A) (ram2:A) = 
    (let (pre1,post1) = split_at ram1 vs in
       if (ram2 IN set_of_list post1) then
	 (let (pre2,post2) = split_at ram2 post1 in pre2)
       else (let (pre2,post2) = split_at ram2 pre1 in APPEND post1 pre2))`;;

liz_add {
liz_name = "between";
liz_loc =  (tamefile "ListAux.thy",985,991); 
liz_holl = `betwn`;
liz_thm = betwn;
};;

(* 1.5 Tables *)

(*
let is_table = new_definition' `is_table (f:A->B) vs t =
    !p. (set_of_list t p ==> ((SND p = f (FST p)) /\ set_of_list vs (FST p)))`;;
*)

(*
let remove_key = new_definition' `remove_key a (ps:(A#B) list) = 
    FILTER (\p. ~(a = FST p)) ps`;;

let remove_key_list = new_recursive_definition list_RECURSION
  `remove_key_list [] ps = ps /\
    remove_key_list (w :: ws) (ps:(A#B) list) = remove_key w (remove_key_list ws ps)`;;
*)

(* XX overloaded and infix *)

let cong = new_definition' `(__cong) (f1:A list) f2 <=> ?n. f2 = rotate n f1`;;

  parse_as_infix' ("__cong", (60, "right"));;

liz_add {  
liz_name = "__cong";
liz_loc =  (tamefile "PlaneGraphIso.thy",50,52); 
liz_holl = `__cong`;
liz_thm = cong;
};;

let congs_rot = prove_by_refinement(
  `!f1 f2.  f1 __cong f2 <=> (?n. n <= LENGTH f1 /\ f2 = rot n f1)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    REWRITE_TAC[cong;rotate_nil;Seq2.rot_nil;LENGTH];
    BY(MESON_TAC[arith `0 <= 0`]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REWRITE_TAC[cong];
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `n` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC rotate_rot;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `n MOD (LENGTH (h::t))` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM rotate_rot);
  REWRITE_TAC[GSYM rotate_mod];
  INTRO_TAC DIVISION [`n`;`LENGTH(h::t)`];
  ANTS_TAC;
    BY(REWRITE_TAC[LENGTH] THEN ARITH_TAC);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

(* 2.2 homomorphism and isomorphism *)

let inj_on = new_definition' 
  `inj_on (f:A->B) s = ( !x y. (s x /\ s y /\ (f x = f y)) ==> (x = y))`;;

let inj_on_ALT = prove_by_refinement(
  `inj_on (f:A->B) A <=> (!x. x IN A ==> (!y. y IN A ==> (f x = f y) ==> (x = y)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;IN];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let INJ_inj_on = prove_by_refinement(
  `!f s. inj_on f s <=> INJ f s (:UNIV)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;INJ;IN_UNIV];
  BY(REWRITE_TAC[IN])
  ]);;
  (* }}} *)

liz_add {
liz_name = "inj_on";
liz_loc =  (holfile "Fun.thy",116,118); 
liz_holl = `inj_on`;
liz_thm = inj_on_ALT;
};;

(* 3.0 More rotation *)

let rotate_to = new_definition' `rotate_to (vs:A list) v = 
    v :: (APPEND (SND (split_at v vs))  (FST (split_at v vs)))`;;

let rotate_min = new_definition' `rotate_min (vs:num list) = 
  rotate_to vs (min_list vs)`;;  

liz_add {
liz_name = "rotate_to";
liz_loc =  (tamefile "Rotation.thy",10,12); 
liz_holl = `rotate_to`;
liz_thm = rotate_to;
};;

liz_add {
liz_name = "rotate_min";
liz_loc =  (tamefile "Rotation.thy",13,15); 
liz_holl = `rotate_min`;
liz_thm = rotate_min;
};;

(* 4.0 Graph,   4.2 Faces  *)

(* XX *)
liz_add {
liz_name = "Final";
liz_loc =  ("",0,0);
liz_holl = `T`;
liz_thm = TRUTH;
};;

(* XX *)
liz_add {
liz_name = "Nonfinal";
liz_loc =  ("",0,0);
liz_holl = `F`;
liz_thm = TRUTH;
};;

let face_def = new_definition'  `Face (a:num list) (b:bool) = (a,b)`;;

(* XX *)
liz_add {
liz_name = "Face";
liz_loc =  ("",0,0);
liz_holl = `Face`;
liz_thm = face_def;
};;

let final_SND = prove_by_refinement(
  `SND (Face vs f) = if (f = T) then T else F`,
  (* {{{ proof *)
  [
  REWRITE_TAC[face_def];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

make_overloadable' "final" `:A -> bool`;;

overload_interface' ("final",`SND:num list # bool -> bool`);;

liz_add {
liz_name = "final_face";
liz_loc =  (tamefile "Graph.thy",47,49);  (* see also lines 260,263 *)
liz_holl = `SND`;
liz_thm = final_SND;
};;

let type_face_SND = prove_by_refinement(
  `SND (Face vs f) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[face_def])
  ]);;
  (* }}} *)

make_overloadable' "type" `:A -> bool`;;

overload_interface' ("type",`SND:num list # bool -> bool`);;

liz_add {
liz_name = "type_face";
liz_loc =  (tamefile "Graph.thy",50,52);  
liz_holl = `SND`;
liz_thm = type_face_SND;
};;

make_overloadable' "vertices" `:B -> (num list)`;;

overload_interface' ("vertices",`FST:num list # bool -> num list`);;

let vertices_face_FST = prove_by_refinement(
  `vertices (Face vs (f:bool)) = (vs:num list)`,
  (* {{{ proof *)
  [
  (REWRITE_TAC[face_def])
  ]);;
  (* }}} *)

liz_add {
liz_name = "vertices_face";
liz_loc =  (tamefile "Graph.thy",53,55);  
liz_holl = `FST:num list # bool -> num list`;
liz_thm = vertices_face_FST;
};;

(*
let bn_vertices_face = new_definition' `bn_vertices_face (vs:A,f:B) = vs`;;
*)

make_overloadable' "__V" `:B -> (num -> bool)`;;

let vertices_set1 = new_definition' `vertices_set1 (fs:num list#bool) = 
  set_of_list (vertices fs)`;;

liz_add {
liz_name = "vertices_set";
liz_loc =  (tamefile "Graph.thy",24,26);  
liz_holl = `vertices_set1`;
liz_thm = vertices_set1;
};;

(* =~ on faces means =~ on vertex list *)

let setFinal = new_definition' `setFinal (vs:num list ,f:bool) = (vs,T)`;;

let setFinal_ALT = prove_by_refinement(
  `setFinal f = Face(vertices f) T`,
  (* {{{ proof *)
  [
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[setFinal;vertices_set1;face_def])
  ]);;
  (* }}} *)

liz_add {
liz_name = "setFinal";
liz_loc =  (tamefile "Graph.thy",63,65);  
liz_holl = `setFinal`;
liz_thm = setFinal_ALT;
};;

liz_add {
liz_name = "hd";
liz_loc =  (holfile "List.thy",26,28);  
liz_holl = `HD`;
liz_thm = HD;
};;

let nextElem = new_recursive_definition list_RECURSION 
  `nextElem [] (b:A) x = b /\
    nextElem (a :: aas) b x = 
     if (x=a) then (if (aas = []) then b else HD aas) else nextElem aas b x`;;

let nextElem_ALT = prove_by_refinement(
  `nextElem [] (b:A) x = b /\
   nextElem (a :: as) b x =     
    (if x=a then ((if (as = []) then (b ) else 
		     (let a_ = HD (as) in (let as_ = TL (as) in a_)))) else nextElem as b x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextElem];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[LET_THM])
  ]);;
  (* }}} *)

liz_add {
liz_name = "nextElem";
liz_loc =  (tamefile "Graph.thy",70,74);  
liz_holl = `nextElem`;
liz_thm = nextElem_ALT;
};;

(* XX nextVertex written as a dot . __bullet postfix *)

let nextVertex = new_definition' `nextVertex (vs:num list,f:bool) =
   nextElem vs (HD vs)`;;

let nextVertex_ALT = prove_by_refinement(
  `nextVertex f = (let vs = vertices f in nextElem vs (HD vs))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM;nextVertex];
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[nextVertex])
  ]);;
  (* }}} *)

liz_add {
liz_name = "nextVertex";
liz_loc =  (tamefile "Graph.thy",75,77);  
liz_holl = `nextVertex`;
liz_thm = nextVertex_ALT;
};;

let nextVertices = new_definition' 
 `nextVertices (f:(num list # bool)) (n:num) v = 
    ITER n (nextVertex f) v`;;

liz_add {
liz_name = "nextVertices";
liz_loc =  (tamefile "Graph.thy",82,84);  
liz_holl = `nextVertices`;
liz_thm = REWRITE_RULE[GSYM POWER_TO_ITER] nextVertices;
};;

(* not used:
let bn_edges = new_definition' `bn_edges (fs:A list # bool)  =
   IMAGE (\a. (a, nextVertex fs a)) (vertices_set1 fs)`;;
*)

(* op = REVERSE,  op_graph = Graph.op, op_graph *)

(* not used.
let prevVertex = new_definition' `prevVertex (vs:A list,f:bool) v =
   (nextElem (REVERSE vs) (LAST vs) v)`;;

liz_add {
liz_name = "prevVertex";
liz_loc =  (tamefile "Graph.thy",107,109);  
liz_holl = `prevVertex`;
liz_thm = prevVertex;
};;
*)

(* 4.3 Graphs *)

(*
bn_graph:
list of faces (with boolean marking if each face is final),
number of vertices,
list whose ith entry is the list of faces containing vertex i,
a list of heights.

datatype graph = Graph "(face list)" "nat" "face list list" "nat list"
*)

let ( bn_Graph ) = new_definition' 
  `Graph (fs:((num list # bool)list)) (n:num) (f:((num list # bool) list) list) (h:num list) = 
  (fs,n,f,h)`;;

liz_add {
liz_name = "Graph";
liz_loc =  (tamefile "Graph.thy",117,117);  
liz_holl = `Graph`;
liz_thm = bn_Graph;
};;

(*
let new_graph_th = prove(`?(x:((num list # bool) list) #  (num) 
   # (((num list # bool) list) list) # (num list))  . T`,MESON_TAC[]);;

let bn_graph_type = new_type_definition 
  "bn_graph" ("mk_bn_graph","dest_bn_graph") new_graph_th;;
*)

let faces = new_definition' 
 `faces  = FST:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list -> 
    ((num)list#bool)list`;;

let faces_graph = prove_by_refinement(
  `faces (Graph fs n f h) = fs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[faces;bn_Graph]
  ]);;
  (* }}} *)

liz_add {
liz_name = "faces";
liz_loc =  (tamefile "Graph.thy",119,121);  
liz_holl = `faces`;
liz_thm = faces_graph;
};;

let bn_Faces = new_definition' `Faces g = set_of_list (faces g)`;;

liz_add {
liz_name = "Faces";
liz_loc =  (tamefile "Graph.thy",122,125);  
liz_holl = `Faces`;
liz_thm = bn_Faces;
};;

let countVertices_def = new_definition'
  `countVertices (g:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list) = FST (SND ( g))`;;

let countVertices = prove_by_refinement(
  `countVertices (Graph fs n f h) = n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[bn_Graph;countVertices_def;FST;SND]);
  ]);;
  (* }}} *)

liz_add {
liz_name = "countVertices";
liz_loc =  (tamefile "Graph.thy",126,128);  
liz_holl = `countVertices`;
liz_thm = countVertices;
};;

let upt = new_definition' `upt i j = iota i (j-i)`;;

let bn_upt = prove_by_refinement(
  `!i j. upt i 0 = [] /\ upt i (SUC j) = if (i <= j) then (APPEND (upt i j)  [j]) else []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[upt;arith `0-i = 0`;Seq.iota];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_SIMP_TAC [arith `i <= j ==> SUC j - i =  (j - i) + 1`];
    REWRITE_TAC[Seq.iota_add;Seq2.APPEND_cat];
    AP_TERM_TAC;
    ASM_SIMP_TAC[arith `i <= j ==> i + j - (i:num) = j`;arith `1 = SUC 0`];
    BY(REWRITE_TAC[Seq.iota]);
  ASM_SIMP_TAC[arith `~(i<=j) ==> SUC j - i = 0`];
  BY(REWRITE_TAC[Seq.iota])
  ]);;
  (* }}} *)

(* XX sypecial syntax *)

liz_add {
liz_name = "upt";
liz_loc =  (holfile "List.thy",149,152);  
liz_holl = `upt`;
liz_thm = bn_upt;
};;

let vertices_graph = new_definition' 
 `vertices_graph g = upt 0 (countVertices g)`;;

overload_interface' ("vertices",`vertices_graph`);;

let vertices_set2 = new_definition' 
 `vertices_set2 (g:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list) = set_of_list (vertices g)`;;

overload_interface' ("__V",`vertices_set2`);;

let bn_vertices_graph = prove_by_refinement(
  `vertices_graph (Graph fs n f h) = upt 0 n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[vertices_graph;bn_Graph;countVertices_def])
  ]);;
  (* }}} *)

liz_add {
liz_name = "vertices_graph";
liz_loc =  (tamefile "Graph.thy",133,134);  
liz_holl = `vertices_graph`;
liz_thm = bn_vertices_graph;
};;

let faceListAt = new_definition'
  `faceListAt (g:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list) = FST (SND (SND ( g)))`;;

let bn_faceListAt = prove_by_refinement(
  `faceListAt (Graph fs n f h) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[faceListAt;bn_Graph])
  ]);;
  (* }}} *)

liz_add {
liz_name = "faceListAt";
liz_loc =  (tamefile "Graph.thy",148,150);  
liz_holl = `faceListAt`;
liz_thm = bn_faceListAt;
};;

let facesAt = new_definition'
  `facesAt g v = EL v (faceListAt g )`;;

liz_add {
liz_name = "facesAt";
liz_loc =  (tamefile "Graph.thy",151,153);  
liz_holl = `facesAt`;
liz_thm = REWRITE_RULE[GSYM nnnth] facesAt;
};;

let heights = new_definition' 
  `heights (g:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list) = SND(SND(SND(g)))`;;

let bn_heights = prove_by_refinement(
  `heights (Graph fs n f h) = h`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[heights;bn_Graph])
  ]);;
  (* }}} *)

liz_add {
liz_name = "heights";
liz_loc =  (tamefile "Graph.thy",154,156);  
liz_holl = `heights`;
liz_thm = bn_heights;
};;

let height = new_definition' `height g v = EL v (heights g)`;;

liz_add {
liz_name = "height";
liz_loc =  (tamefile "Graph.thy",157,159);  
liz_holl = `height`;
liz_thm = REWRITE_RULE[GSYM nnnth] height;
};;

(* seed *)

liz_add {
liz_name = "replicate";
liz_loc =  (holfile "List.thy",181,184);  
liz_holl = `REPLICATE`;
liz_thm = REPLICATE;
};;

let graphl = new_definition'  `graphl n = 
     (let vs = upt 0  n in
      let fs =  [(vs,T);(REVERSE vs,F)] in
	(Graph fs  n (REPLICATE n fs) (REPLICATE n 0)))`;;

let graph_ALT = prove_by_refinement(
  `graphl n = 
     (let vs = upt 0  n in
      let fs =  [Face vs T;Face (REVERSE vs) F] in
	(Graph fs  n (REPLICATE n fs) (REPLICATE n 0)))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[face_def;graphl])
  ]);;
  (* }}} *)

liz_add {
liz_name = "graph";
liz_loc =  (tamefile "Graph.thy",160,165);  
liz_holl = `graphl`;
liz_thm = graph_ALT;
};;

(* 4.4 Operations on graphs *)

(*
let finals = new_definition' `finals g =
   FILTER SND (faces g)`;;

liz_add {
liz_name = "finals";
liz_loc =  (tamefile "Graph.thy",170,172);  
liz_holl = `finals`;
liz_thm = graph_ALT;
};;
*)

let nonFinals = new_definition' `nonFinals g = 
   FILTER (\f. ~( SND f)) (faces g)`;;

liz_add {
liz_name = "nonFinals";
liz_loc =  (tamefile "Graph.thy",173,175);  
liz_holl = `nonFinals`;
liz_thm = nonFinals;
};;

let countNonFinals = new_definition' `countNonFinals g =
   LENGTH (nonFinals g)`;;

liz_add {
liz_name = "countNonFinals";
liz_loc =  (tamefile "Graph.thy",176,178);  
liz_holl = `countNonFinals`;
liz_thm = countNonFinals;
};;

let finalGraph = new_definition' `finalGraph g = (nonFinals g = [])`;;

override_interface' ("final",`finalGraph`);;

liz_add {
liz_name = "finalGraph";
liz_loc =  (tamefile "Graph.thy",179,180);  
liz_holl = `finalGraph`;
liz_thm = finalGraph;
};;


(*
let finalVertex = new_definition' `finalVertex g v = 
   (!f.  f IN set_of_list(facesAt g v) ==> SND f)`;;

liz_add {
liz_name = "finalVertex";
liz_loc =  (tamefile "Graph.thy",188,190);  
liz_holl = `finalVertex`;
liz_thm = finalVertex;
};;
*)

let degree = new_definition' `degree g v = LENGTH(facesAt g v)`;;

liz_add {
liz_name = "degree";
liz_loc =  (tamefile "Graph.thy",200,202);  
liz_holl = `degree`;
liz_thm = degree;
};;

let tri = new_definition'  `tri g v =
    LENGTH(FILTER (\f. SND f /\ LENGTH(vertices f)=3) (facesAt g v))`;;

liz_add {
liz_name = "tri";
liz_loc =  (tamefile "Graph.thy",203,205);   
liz_holl = `tri`;
liz_thm = tri;
};;

let quad = new_definition'  `quad g v =
    LENGTH(FILTER (\f. SND f /\ LENGTH(vertices f)=4) (facesAt g v))`;;

liz_add {
liz_name = "quad";
liz_loc =  (tamefile "Graph.thy",206,208);   
liz_holl = `quad`;
liz_thm = quad;
};;

let except = new_definition'  `except g v =
    LENGTH(FILTER (\f. SND f /\ 5 <= LENGTH(vertices f)) (facesAt g v))`;;

liz_add {
liz_name = "except";
liz_loc =  (tamefile "Graph.thy",209,211);   
liz_holl = `except`;
liz_thm = except;
};;

let vertextype = new_definition' `vertextype g v = 
    (tri g v, quad g v, except g v)`;;

liz_add {
liz_name = "vertextype";
liz_loc =  (tamefile "Graph.thy",212,214);   
liz_holl = `vertextype`;
liz_thm = vertextype;
};;

let exceptionalVertex = new_definition' `exceptionalVertex g v = 
  (except g v ~= 0)`;;

liz_add {
liz_name = "exceptionalVertex";
liz_loc =  (tamefile "Graph.thy",222,224);   
liz_holl = `exceptionalVertex`;
liz_thm = exceptionalVertex;
};;

(* not used.
let noExceptionals = new_definition'   `noExceptionals g V =
   (!v. (v IN V ==> ~(exceptionalVertex g v)))`;;

liz_add {
liz_name = "noExceptionals";
liz_loc =  (tamefile "Graph.thy",225,227);   
liz_holl = `noExceptionals`;
liz_thm = noExceptionals;
};;

let bn_edges_graph = new_definition'
  `bn_edges_graph g = UNIONS { bn_edges f | Faces g f }`;; 
*)

let neighbors = new_definition'
  `neighbors g v = MAP (\f. nextVertex f v )  (facesAt g v)`;;

liz_add {
liz_name = "neighbors";
liz_loc =  (tamefile "Graph.thy",235,237);   
liz_holl = `neighbors`;
liz_thm = neighbors;
};;

(* 4.5 Navigation in graphs *)

(* nextFace *)

let directedLength = new_definition' `directedLength (f:num list # bool) a b =
  if (a=b) then 0 else LENGTH(betwn(vertices f) a b) + 1`;;

liz_add {
liz_name = "directedLength";
liz_loc =  (tamefile "Graph.thy",253,256);   
liz_holl = `directedLength`;
liz_thm = directedLength;
};;

(* 4.6 Code generator setup *)

(* 5 Vector *)

(* vector = list *)

(* 5.1 Tabulation *)

let vector_def = new_definition'  `Vector (a:A list) = a`;;

let tabulate0 = new_definition' `tabulate0 (p:num# (num->A)) =
    Vector (MAP (SND p) (upt 0  (FST p)))`;;

let tabulate = new_definition' `tabulate n (f:num->A) = tabulate0 (n,f)`;;

let tabulate2 = new_definition' `tabulate2 m n (f:num->num->A) =
   tabulate m (\i. tabulate n (f i))`;;

(* XX *)
liz_add {
liz_name = "Vector";
liz_loc =  ("",0,0);
liz_holl = `Vector`;
liz_thm = vector_def;
};;

liz_add {
liz_name = "tabulate_";
liz_loc =  (tamefile "Vector.thy",14,17);   
liz_holl = `tabulate0`;
liz_thm = tabulate0;
};;

liz_add {
liz_name = "tabulate";
liz_loc =  (tamefile "Vector.thy",18,20);   
liz_holl = `tabulate`;
liz_thm = tabulate;
};;

liz_add {
liz_name = "tabulate2";
liz_loc =  (tamefile "Vector.thy",21,23);   
liz_holl = `tabulate2`;
liz_thm = tabulate2;
};;

(*
syntax. [f. x < n], [f. x < m, y < n], [f. x < l, y < m, z < n].
*)

(* 5.2 Access *)

let sub1 = new_definition' `sub1 ((xs:A list), (n:num)) = EL n xs`;;

let sub1_ALT = prove_by_refinement(
  `sub1 p  =  (let (a, n) = p in (let as = a in (as #!# n)))`,
  (* {{{ proof *)
  [
  REPEAT LET_TAC;
  BY(REWRITE_TAC[sub1;nnnth])
  ]);;
  (* }}} *)
   
let sub = new_definition' `sub   (a:A list) n = sub1 (a,n)`;;

let sub_nth = prove_by_refinement(
  `sub a n = a #!# n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[sub;sub1;nnnth])
  ]);;
  (* }}} *)

liz_add {
liz_name = "sub1";
liz_loc =  (tamefile "Vector.thy",46,48);   
liz_holl = `sub1`;
liz_thm = sub1_ALT;
};;

liz_add {
liz_name = "sub";
liz_loc =  (tamefile "Vector.thy",49,51);   
liz_holl = `sub`;
liz_thm = sub;
};;

(* notaton: a[n] = sub a n, a[m,n] = sub (sub a m) n, a[l,m,n] = sub(sub(sub a l)m)n *)

(* 6 Enumerating Patches  *)

let enumBase = new_definition' 
  `enumBase nmax = MAP (\i. [i]) (upt 0  (SUC nmax))`;;

let enumAppend = new_definition'
   `enumAppend nmax iss = 
   flatten (MAP (\is.   MAP (\n.  is #@# [n]) (upt (LAST is) (SUC nmax))) iss)`;;

let enumerator = new_definition'
   `enumerator inner outer = 
      (let nmax = outer - 2 in
       let k = inner - 3 in
       (MAP (\is.  [0] #@# is #@# [outer -1]) 
	  ( (enumAppend nmax ^^ k) (enumBase nmax))))`;;

(*
let enumTab = new_definition'
  `enumTab = tabulate2 9 9 (\ inner outer. enumerator inner outer)`;;
*)

liz_add {
liz_name = "enumBase";
liz_loc =  (tamefile "Enumerator.thy",44,46);   
liz_holl = `enumBase`;
liz_thm = enumBase;
};;

liz_add {
liz_name = "enumAppend";
liz_loc =  (tamefile "Enumerator.thy",47,49);   
liz_holl = `enumAppend`;
liz_thm = enumAppend;
};;

liz_add {
liz_name = "enumerator";
liz_loc =  (tamefile "Enumerator.thy",50,54);   
liz_holl = `enumerator`;
liz_thm = enumerator;
};;

(*
liz_add {
liz_name = "enumTab";
liz_loc =  (tamefile "Enumerator.thy",55,57);   
liz_holl = `enumTab`;
liz_thm = enumTab;
};;
*)

let hideDupsRec = new_recursive_definition list_RECURSION 
  `hideDupsRec (a:A) [] = []  /\
    hideDupsRec a (b :: bs) = 
      if (a = b) then NONE :: (hideDupsRec b bs) 
      else  (SOME b) :: (hideDupsRec b bs)`;;

let hideDups = new_recursive_definition list_RECURSION
  `hideDups ([]:A list) = [] /\
    hideDups ((b:A) :: bs) = (SOME b) :: (hideDupsRec b bs)`;;

let indexToVertexList = new_definition' `indexToVertexList f v is = 
  hideDups (MAP (\k. nextVertices f k v) is)`;;

liz_add {
liz_name = "hideDupsRec";
liz_loc =  (tamefile "Enumerator.thy",65,70);   
liz_holl = `hideDupsRec`;
liz_thm = hideDupsRec;
};;

liz_add {
liz_name = "hideDups";
liz_loc =  (tamefile "Enumerator.thy",71,74);   
liz_holl = `hideDups`;
liz_thm = hideDups;
};;

liz_add {
liz_name = "indexToVertexList";
liz_loc =  (tamefile "Enumerator.thy",75,77);   
liz_holl = `indexToVertexList`;
liz_thm = indexToVertexList;
};;

(* 7 Subdividing a Face *)

let split_face = new_definition' 
   `split_face (f:num list # bool) (ram1) ram2 newVs = 
      (let vs = vertices f in
       let f1 =  [ram1] #@#  (betwn vs ram1 ram2) #@# [ram2] in
       let f2 =  [ram2] #@# (betwn vs ram2 ram1) #@# [ram1] in
	 (Face (REVERSE newVs #@# f1) F), Face (f2 #@# newVs) F)`;;

let split_list_face_n = new_definition' 
   `split_list_face_n (f:(A) list) (ram1) ram2 newVs = 
      (let f1 =  [ram1] #@#  (betwn f ram1 ram2) #@# [ram2] in
       let f2 =  [ram2] #@# (betwn f ram2 ram1) #@# [ram1] in
	 ( (REVERSE newVs #@# f1)),  (f2 #@# newVs))`;;


let replacefacesAt = new_definition'
  `replacefacesAt ns (f:(A) list # bool) fs Fs = mapAt ns (replace f fs) Fs`;;

let makeFaceFinalFaceList = new_definition'
  `makeFaceFinalFaceList f fs = replace f [setFinal f] fs`;;

let makeFaceFinal = new_definition'
  `makeFaceFinal f g = 
      Graph 
	(makeFaceFinalFaceList f (faces g))
	(countVertices g)
	(MAP (\fs. makeFaceFinalFaceList f fs) (faceListAt g))
	(heights g)
      `;;

liz_add {
liz_name = "split_face";
liz_loc =  (tamefile "FaceDivision.thy",10,16);   
liz_holl = `split_face`;
liz_thm = split_face;
};;

liz_add {
liz_name = "replacefacesAt";
liz_loc =  (tamefile "FaceDivision.thy",18,20);   
liz_holl = `replacefacesAt`;
liz_thm = replacefacesAt;
};;

liz_add {
liz_name = "makeFaceFinalFaceList";
liz_loc =  (tamefile "FaceDivision.thy",22,24);   
liz_holl = `makeFaceFinalFaceList`;
liz_thm = makeFaceFinalFaceList;
};;

liz_add {
liz_name = "makeFaceFinal";
liz_loc =  (tamefile "FaceDivision.thy",25,31);   
liz_holl = `makeFaceFinal`;
liz_thm = makeFaceFinal;
};;

let heightsNewVertices = new_definition' 
  `heightsNewVertices h1 h2 n = 
       MAP (\i. MIN  (h1 + i + 1) (h2 + n -i)  ) (upt 0  n)`;;

liz_add {
liz_name = "heightsNewVertices";
liz_loc =  (tamefile "FaceDivision.thy",33,35);   
liz_holl = `heightsNewVertices`;
liz_thm = heightsNewVertices;
};;

let splitFace = new_definition'
  `splitFace g ram1 ram2 oldF newVs = 
     (let fs = faces g in
      let n = countVertices g in
      let Fs = faceListAt g in
      let h = heights g in
      let vs1 = betwn (vertices oldF) ram1 ram2 in
      let vs2  = betwn (vertices oldF) ram2 ram1 in
      let (f1,f2) = split_face oldF ram1 ram2 newVs in
      let Fs = replacefacesAt vs1 oldF [f1] Fs in
      let Fs = replacefacesAt vs2 oldF [f2] Fs in
      let Fs = replacefacesAt [ram1] oldF [f2;f1] Fs in
      let Fs = replacefacesAt [ram2] oldF [f1;f2] Fs in
      let Fs = Fs #@# (REPLICATE (LENGTH (newVs)) [f1;f2]) in
	  (f1,f2, 
	   Graph ((replace oldF [f2] fs ) #@# [f1]) (n + LENGTH (newVs)) Fs 
	     (h #@# (heightsNewVertices ( h #!# ram1) (h #!# ram2) (LENGTH (newVs))))
	))`;;

liz_add {
liz_name = "splitFace";
liz_loc =  (tamefile "FaceDivision.thy",36,55);   
liz_holl = `splitFace`;
liz_thm = splitFace;
};;

let subdivFace0 = new_recursive_definition list_RECURSION
  `subdivFace0 g f u n [] = makeFaceFinal f g /\
    subdivFace0 g f u n (vo :: vos) = 
      if (vo = NONE) then subdivFace0 g f u (SUC n) vos else
	(let v = the vo in
	   if (nextVertex f u = v /\ n = 0) then subdivFace0 g f v 0 vos
	   else 
	     (let ws = upt (countVertices g) (countVertices g + n) in
	      let (f1,f2,g') = splitFace g u v f ws in
		subdivFace0 g' f2 v 0 vos))`;;

let subdivFace = new_definition' 
  `subdivFace g f vos = subdivFace0 g f (the(HD vos)) 0 (TL vos)`;;

liz_add {
liz_name = "subdivFace_";
liz_loc =  (tamefile "FaceDivision.thy",58,68);   
liz_holl = `subdivFace0`;
liz_thm = subdivFace0;
};;

liz_add {
liz_name = "subdivFace";
liz_loc =  (tamefile "FaceDivision.thy",69,71);   
liz_holl = `subdivFace`;
liz_thm = subdivFace;
};;

(* 8. Transitive closure *)

(*
let invariant = new_definition' `invariant (P:A->bool) succs = 
   !g g'.  g IN set_of_list (succs g) ==> P g ==> P g'`;;

liz_add {
liz_name = "invariant";
liz_loc =  (tamefile "RTranCl.thy",49,51);   
liz_holl = `invariant`;
liz_thm = invariant;
};;
*)

let RTranCl = new_definition' `RTranCl (g:A -> A list) = 
  UNCURRY    (RTC (\x y.  MEM y (g x)))`;;

(* Library/rstc.ml already does the reflexive and transitive closure of a relation 
 *)

let RTranCl_ALT = prove_by_refinement(
  `(g,g) IN RTranCl succs /\
    g' IN set_of_list (succs g) /\ (g',g'') IN RTranCl succs ==> (g,g'') IN RTranCl succs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[RTranCl;CURRY_DEF;UNCURRY_DEF;IN;RTC_REFL];
  INTRO_TAC RTC_RULES [`(\x y. MEM y (succs x))`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `g'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

(* notation: g  [s]->*   g'   for (g,g') IN (RTranCl' s)  *)

liz_add {
liz_name = "RTranCl";
liz_loc =  (tamefile "RTranCl.thy",17,26);   
liz_holl = `RTranCl'`;
liz_thm = RTranCl_ALT;
};;

(* 9. Plane Graph Enumeration  *)

let maxGon = new_definition' `maxGon (p:num) = p + 3`;;

(* a and b are vertices on the face f.  True if a and b are not
   equal and not adjacent, but connected by some "remote" edge *)

let duplicateEdge = new_definition' `duplicateEdge g f a b <=>
   (2 <= directedLength f a b /\ 2 <= directedLength f b a /\
    b IN set_of_list (neighbors g a))`;;

(* in practice, N = as defined below in containsDuplicateEdge.
   We test for enumerators (a weakly increasing list of indices)
   that are situated as v < w < w' with N w w' remote connection.
  
   N.B. The code states N w w'. That is, we never test for more
   than double joins.  The predecessor v is examined to make sure
   that there are no inserted vertices, as in v = w or w = w'.

   There is no testing for triangles or quads with enclosed vertices.

*)

let containsUnacceptableEdgeSnd = new_recursive_definition list_RECURSION
  `containsUnacceptableEdgeSnd N (v:num) [] = F /\
    (containsUnacceptableEdgeSnd N v (w :: ws) = 
  if (ws = []) then F else
    (let w' = HD ws in
     let ws' = TL ws in
  if (v < w /\ w < w' /\ N w w') then T 
  else containsUnacceptableEdgeSnd N w ws))`;;

(* in practice, N = as defined below in containsDuplicateEdge.
   We test for enumerators (an increasing list of indices)
   that are situated as v < w  with N v w remote connection.
   This would create a double join. 

   Note that the first call is containsUnacceptableEdge, then the
   recursion continues with containsDuplicateEdge.

*)
  
let containsUnacceptableEdge = new_recursive_definition list_RECURSION
  `containsUnacceptableEdge N [] = F /\
  containsUnacceptableEdge N (v :: vs) = 
  if (vs = []) then F else
    (let w = HD vs in
     let ws = TL vs in
       if ((v:num) < w /\ N v w) then T else containsUnacceptableEdgeSnd N v vs)`;;

let containsDuplicateEdge = new_definition'
  `containsDuplicateEdge g f v is = containsUnacceptableEdge
    (\i j. duplicateEdge g f (nextVertices f i v ) (nextVertices f j v)) is`;;

liz_add {
liz_name = "maxGon";
liz_loc =  (tamefile "Plane.thy",11,13);   
liz_holl = `maxGon`;
liz_thm = maxGon;
};;

liz_add {
liz_name = "duplicateEdge";
liz_loc =  (tamefile "Plane.thy",17,20);   
liz_holl = `duplicateEdge`;
liz_thm = duplicateEdge;
};;

liz_add {
liz_name = "containsUnacceptableEdgeSnd";
liz_loc =  (tamefile "Plane.thy",21,28);   
liz_holl = `containsUnacceptableEdgeSnd`;
liz_thm = containsUnacceptableEdgeSnd;
};;

liz_add {
liz_name = "containsUnacceptableEdge";
liz_loc =  (tamefile "Plane.thy",29,35);   
liz_holl = `containsUnacceptableEdge`;
liz_thm = containsUnacceptableEdge;
};;

liz_add {
liz_name = "containsDuplicateEdge";
liz_loc =  (tamefile "Plane.thy",36,39);   
liz_holl = `containsDuplicateEdge`;
liz_thm = containsDuplicateEdge;
};;

let generatePolygon = new_definition' 
  `generatePolygon n v (f:(num)list#bool) g = 
  (let enumeration = enumerator n (LENGTH (vertices f)) in
   let enumeration = FILTER (\is. ~(containsDuplicateEdge g f v is)) enumeration in
   let vertexLists = MAP (\is. indexToVertexList f v is) enumeration in
     MAP (\vs. subdivFace g f vs) vertexLists)`;;

(* 1/2014 problem with this definition.  For there to be dart-uniqueness,
   which is a property of good_lists, we must filter out the duplicate
   edges.  So this doesn't work. *)

(* deprecated: 
let generatePolygon_relaxed = new_definition' 
  `generatePolygon_relaxed n v (f:(num)list#bool) g = 
  (let enumeration = enumerator n (LENGTH (vertices f)) in
   let vertexLists = MAP (\is. indexToVertexList f v is) enumeration in
     MAP (\vs. subdivFace g f vs) vertexLists)`;;
*)

let bn_Seed = new_definition'
  `Seed p = graphl (maxGon p)`;;

liz_add {
liz_name = "generatePolygon";
liz_loc =  (tamefile "Plane.thy",49,55);   
liz_holl = `generatePolygon`;
liz_thm = generatePolygon;
};;

liz_add {
liz_name = "Seed";
liz_loc =  (tamefile "Plane.thy",62,64);   
liz_holl = `Seed`;
liz_thm = bn_Seed;
};;

(* Plane1 *)

let minimalFace = new_definition' 
  `minimalFace = bn_minimal (LENGTH o (vertices:num list # bool -> num list))`;;

let minimalVertex = new_definition'
  `minimalVertex g f = bn_minimal (height g) (vertices (f:num list # bool))`;;

let next_plane = new_definition'
  `next_plane p g = 
  (let fs = nonFinals g in
     if (fs = []) then [] else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (flatten (MAP (\i. generatePolygon i v f g) 
		      (upt 3 (SUC (maxGon p))) ))))`;;

(*
let next_plane_relaxed = new_definition'
  `next_plane_relaxed p g = 
  (let fs = nonFinals g in
     if (fs = []) then [] else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (flatten (MAP (\i. generatePolygon_relaxed i v f g) 
		      (upt 3 (SUC (maxGon p))) ))))`;;
*)

let PlaneGraphsP = new_definition'
  `planeGraphsP p = 
   { g | (Seed p,g) IN RTranCl (next_plane p)  /\ finalGraph g} `;;

(* XX Complete_Lattices.thy 930--955 contains special syntax for UNION <Union>,... *)

let PlaneGraphs = new_definition'
  `PlaneGraphs = UNIONS (IMAGE planeGraphsP UNIV)`;;

let planegraph = new_definition'
  `planegraph g = (?p. 
   (Seed p,g) IN RTranCl (next_plane p))`;;

(* add parameter q for variable upper bound on polygon size. *)

let planegraph_relaxed = new_definition'
  `planegraph_relaxed g = (?p q. 
   (Seed p,g) IN RTranCl (next_plane q))`;;

let planegraphP = new_definition'
  `planegraphP p g = ((Seed p,g) IN RTranCl (next_plane p))`;;

let planegraph_PlaneGraphs = prove_by_refinement(
  `!g. PlaneGraphs g <=> (planegraph g /\ finalGraph g)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[planegraph;PlaneGraphs];
  REWRITE_TAC[UNIONS;IN_ELIM_THM];
  REWRITE_TAC[IN_IMAGE;IN_UNIV];
  REWRITE_TAC[MESON [] `(?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?x. g IN planeGraphsP x)`];
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

liz_add {
liz_name = "minimalFace";
liz_loc =  (tamefile "Plane1.thy",16,18);   
liz_holl = `minimalFace`;
liz_thm = minimalFace;
};;

liz_add {
liz_name = "minimalVertex";
liz_loc =  (tamefile "Plane1.thy",19,21);   
liz_holl = `minimalVertex`;
liz_thm = minimalVertex;
};;

liz_add {
liz_name = "next_plane";
liz_loc =  (tamefile "Plane1.thy",23,28);   
liz_holl = `next_plane`;
liz_thm = next_plane;
};;

override_interface' ("PlaneGraphs",`PlaneGraphsP`);;

liz_add {
liz_name = "PlaneGraphsP";
liz_loc =  (tamefile "Plane1.thy",29,31);   
liz_holl = `PlaneGraphsP`;
liz_thm = PlaneGraphsP;
};;

liz_add {
liz_name = "PlaneGraphs";
liz_loc =  (tamefile "Plane1.thy",32,34);   
liz_holl = `PlaneGraphs:((num)list#bool)list#num#(((num)list#bool)list)list#(num)list->bool`;
liz_thm = PlaneGraphs;
};;

remove_interface ("PlaneGraphs");;

(* 10 Properties *)

(* 11 Properties of Patch Enumeration *)

(* increasing *)

(* 12 Properties of Face Division *)

(* is_prefix *)

(* is_sublist *)

(* 13 *)

(* 13.1, minVertex, normFace, normFaces, etc. *)

(* 16 Tameness *)

let squanderTarget = new_definition' `squanderTarget = 15410`;;

(* XXX XX XX tchales, changed constants 2014/1/21 to allow
   real to num conversion of inequalities *)

let excessTCount = new_definition' `excessTCount = 6295`;; (* was 6300 *)

let squanderVertex = new_definition' `squanderVertex p q = 
  if (p=0 /\ q=3) then 6177 else
    if (p=0 /\ q=4) then 9696 else
      if (p=1 /\ q=2) then 6557 else
	if (p=1 /\ q=3) then 6176 else
	  if (p=2 /\ q=1) then 7967 else
	    if (p=2 /\ q=2) then 4116 else
	      if (p=2 /\ q=3) then 12846 else
		if (p=3 /\ q=1) then 3106 else
		  if (p=3 /\ q=2) then 8165 else
		    if (p=4 /\ q=0) then 3466 else
		      if (p=4 /\ q=1) then 3655 else
			if (p=5 /\ q=0) then 395 else
			  if (p=5 /\ q=1) then 11354 else
			    if (p=6 /\ q=0) then 6854 else
			      if (p=7 /\ q=0) then 14493 else squanderTarget`;;

(*
let squanderVertex = new_definition' `squanderVertex p q = 
  if (p=0 /\ q=3) then 6180 else
    if (p=0 /\ q=4) then 9700 else
      if (p=1 /\ q=2) then 6560 else
	if (p=1 /\ q=3) then 6180 else
	  if (p=2 /\ q=1) then 7970 else
	    if (p=2 /\ q=2) then 4120 else
	      if (p=2 /\ q=3) then 12851 else
		if (p=3 /\ q=1) then 3110 else
		  if (p=3 /\ q=2) then 8170 else
		    if (p=4 /\ q=0) then 3470 else
		      if (p=4 /\ q=1) then 3660 else
			if (p=5 /\ q=0) then 400 else
			  if (p=5 /\ q=1) then 11360 else
			    if (p=6 /\ q=0) then 6860 else
			      if (p=7 /\ q=0) then 14500 else squanderTarget`;;
*)

let squanderFace = new_definition' `squanderFace n = 
  if (n=3) then 0 else
    if (n=4) then 2059 else
      if (n=5) then 4819 else
	if (n=6) then 7120 else squanderTarget`;;

(*
let squanderFace = new_definition' `squanderFace n = 
  if (n=3) then 0 else
    if (n=4) then 2060 else
      if (n=5) then 4819 else
	if (n=6) then 7120 else squanderTarget`;;
*)

(* XXX XX XX tchales, changed n=6 case from 7578, 1/15/2012 to match
    tame_defs.hl, main_estimate_ineq.hl and graph generator *)

liz_add {
liz_name = "squanderTarget";
liz_loc =  (tamefile "Tame.thy",16,18);   
liz_holl = `squanderTarget`;
liz_thm = squanderTarget;
};;

liz_add {
liz_name = "excessTCount";
liz_loc =  (tamefile "Tame.thy",19,22);   
liz_holl = `excessTCount`;
liz_thm = squanderTarget;
};;

liz_add {
liz_name = "squanderVertex";
liz_loc =  (tamefile "Tame.thy",23,41);   
liz_holl = `squanderVertex`;
liz_thm = squanderVertex;
};;

liz_add {
liz_name = "squanderFace";  (* __d *)
liz_loc =  (tamefile "Tame.thy",42,49);   
liz_holl = `squanderFace`;
liz_thm = squanderFace;
};;

(* 16.3 Admissible weight assignments *)

let foldr2 = new_definition'
  `foldr2 (f:B->A->A) xs z = foldr f z xs`;;

let foldr2_ALT = prove_by_refinement(
  `foldr2 f [] = I /\
    foldr2 f (y :: ys) = f y o (foldr2 f ys)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;foldr2;I_THM;o_THM;Seq.foldr])
  ]);;
  (* }}} *)

let sumn_ALT = prove_by_refinement(
  `!xs. sumn xs = foldr2 (+) xs 0`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.sumn;Seq.foldr;foldr2])
  ]);;
  (* }}} *)

liz_add {
liz_name = "foldr";
liz_loc =  (holfile "List.thy",79,82);   
liz_holl = `foldr2`;
liz_thm = foldr2_ALT;
};;

liz_add {
liz_name = "listsum";
liz_loc =  (holfile "List.thy",91,93);   
liz_holl = `sumn`;
liz_thm = sumn_ALT;
};;

let admissible1 = new_definition' `admissible1 w g =
  (!f. f IN __F g ==> __d (LENGTH (vertices (f:num list # bool))) <= w f)`;;

let admissible2 = new_definition'  `admissible2 w g = 
  (!v. v IN __V g ==> (except g v = 0) ==> 
     squanderVertex (tri g v) (quad g v) <= sumn (MAP (\ f. w f) (facesAt g v)))`;;

let triangle = new_definition' `triangle (f:num list # bool) = (LENGTH (vertices f) = 3)`;;

let admissible3 = new_definition' `admissible3 w g = 
  (!v. (v IN __V g) ==> (vertextype g v = (5,0,1)) ==>
     (sumn (map (\ f. w f) (FILTER triangle (facesAt g v))) >= __a))`;;

let admissible' = new_definition' `admissible' w g = 
  (admissible1 w g /\ 
  admissible2 w g /\ admissible3 w g) `;;

liz_add {
liz_name = "admissible1";
liz_loc =  (tamefile "Tame.thy",95,97);   
liz_holl = `admissible1`;
liz_thm = admissible1;
};;

liz_add {
liz_name = "admissible2";
liz_loc =  (tamefile "Tame.thy",98,101);   
liz_holl = `admissible2`;
liz_thm = admissible2;
};;

liz_add {
liz_name = "triangle";
liz_loc =  (tamefile "Graph.thy",110,113);   
liz_holl = `triangle`;
liz_thm = triangle;
};;

liz_add {
liz_name = "admissible3";
liz_loc =  (tamefile "Tame.thy",102,105);   
liz_holl = `admissible3`;
liz_thm = admissible3;
};;

liz_add {
liz_name = "admissible";
liz_loc =  (tamefile "Tame.thy",110,112);   
liz_holl = `admissible'`;
liz_thm = admissible';
};;

(* 16.4 Tameness *)

let tame9a = new_definition' `tame9a g = 
  (!f. (f IN __F g) ==> 
     3 <= LENGTH(vertices f) /\ LENGTH(vertices (f:num list # bool)) <= 6)`;;

let tame10 = new_definition' `tame10 g = 
  (let n = countVertices g in
     13 <= n /\ n <= 15)`;;

let tame11a = new_definition'  `tame11a g = 
  (!v. (v IN __V g) ==>  3 <= degree g v)`;;

let tame11b = new_definition'  `tame11b g = 
  (!v. v IN __V g ==> 
     degree g v <= (if (except g v = 0) then 7 else 6))`;;

let tame12o = new_definition' `tame12o g = 
  (!v. v IN __V g ==>
     (except g v ~= 0 /\ degree g v = 6) ==> (vertextype g v = (5,0,1)))`;;

let tame13a = new_definition' `tame13a g = 
  (?w. admissible' w g /\ sumn (MAP (\ f. w f) (faces g)) < squanderTarget)`;;

let tame = new_definition' `tame g = 
  (tame9a g /\ tame10 g/\ tame11a g/\ 
    tame11b g/\ tame12o g/\ tame13a g)`;;

liz_add {
liz_name = "tame9a";
liz_loc =  (tamefile "Tame.thy",115,117);   
liz_holl = `tame9a`;
liz_thm = tame9a;
};;

liz_add {
liz_name = "tame10";
liz_loc =  (tamefile "Tame.thy",118,120);   
liz_holl = `tame10`;
liz_thm = tame10;
};;

liz_add {
liz_name = "tame11a";
liz_loc =  (tamefile "Tame.thy",124,126);   
liz_holl = `tame11a`;
liz_thm = tame11a;
};;

liz_add {
liz_name = "tame11b";
liz_loc =  (tamefile "Tame.thy",127,129);   
liz_holl = `tame11b`;
liz_thm = tame11b;
};;

liz_add {
liz_name = "tame12o";
liz_loc =  (tamefile "Tame.thy",130,133);   
liz_holl = `tame12o`;
liz_thm = tame12o;
};;

liz_add {
liz_name = "tame13a";
liz_loc =  (tamefile "Tame.thy",137,139);   
liz_holl = `tame13a`;
liz_thm = tame13a;
};;

liz_add {
liz_name = "tame";
liz_loc =  (tamefile "Tame.thy",142,144);   
liz_holl = `tame`;
liz_thm = tame;
};;

(* 26 *)

let fgraph = new_definition' `fgraph g = MAP vertices (faces g)`;;

liz_add {
liz_name = "fgraph";
liz_loc =  (tamefile "ArchCompAux.thy",20,22);   
liz_holl = `fgraph`;
liz_thm = tame;
};;

(* the list Archive is the concatenation of Tri, Quad, Pent, and Hex.
    These definitions need to be loaded from the Arch theory (which converts
    them from .ML files)  
  tame_archive_lists is defined in good_list_archive.hl.
*)


(* completeness *)

let archive = new_definition' `archive = set_of_list tame_archive_lists`;;

(* XX need to check compatibility of lists.  Update Isabelle lists. *)

liz_add {
liz_name = "Archive";
liz_loc =  (tamefile "Completeness.thy",9,11);   
liz_holl = `archive`;
liz_thm = archive;
};;

(* See PlaneGraphIso.thy 891++, and Quasi_order.thy for notation in Completeness.thy:completeness *)

let EQ_CLASS = new_definition' ` ( //// ) A f = IMAGE (f:A->B) A`;;

parse_as_infix' ("////", (14, "right"));;

let IMAGE_INFIX = new_definition' `(  #?# ) f X = IMAGE (f:A->B) X`;;

parse_as_infix' ("#?#",(16,"right"));;

let is_pr_Hom = new_definition' `is_pr_Hom (phi:A->B) Fs1 Fs2 =
  ((( (MAP phi) #?# Fs1) //// (__cong)) = (Fs2 //// (__cong)))`;;

(* REWRITE_RULE[IMAGE_INFIX;EQ_CLASS] is_pr_Hom;; *)

let is_pr_Iso = new_definition' `is_pr_Iso (phi:A->B) Fs1 Fs2 = 
 (is_pr_Hom phi Fs1 Fs2 /\ inj_on phi (UNIONS (IMAGE (\ f. set_of_list f) Fs1  )))`;;

let is_Iso = new_definition' `is_Iso (phi:A->B) Fs1 Fs2 = 
 (is_pr_Iso phi Fs1 Fs2 \/ is_pr_Iso phi Fs1 (REVERSE #?# Fs2))`;;

let is_iso = new_definition' `is_iso (phi:A->B) Fs1 Fs2 = 
  is_Iso phi (set_of_list Fs1) (set_of_list Fs2)`;;

let iso_fgraph = new_definition' `iso_fgraph g1 g2 = 
  (? (phi:A->B). is_iso phi g1 g2)`;;

liz_add {
liz_name = "is_pr_Hom";
liz_loc =  (tamefile "PlaneGraphIso.thy",148,150);   
liz_holl = `is_pr_Hom`;
liz_thm = is_pr_Hom;
};;

liz_add {
liz_name = "is_pr_Iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",151,153);   
liz_holl = `is_pr_Iso`;
liz_thm = is_pr_Iso;
};;

liz_add {
liz_name = "is_Iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",815,817);   
liz_holl = `is_Iso`;
liz_thm = is_Iso;
};;

liz_add {
liz_name = "is_iso";
liz_loc =  (tamefile "PlaneGraphIso.thy",818,820);   
liz_holl = `is_iso`;
liz_thm = is_iso;
};;

liz_add {
liz_name = "iso_fgraph";
liz_loc =  (tamefile "PlaneGraphIso.thy",821,823);   
liz_holl = `iso_fgraph`;
liz_thm = iso_fgraph;
};;

(* (tamefile "Completeness.thy",48,49) *)

(* ?? __simeq = iso_fgraph??. Replace 2013-10-6 *)

let import_tame_classification = new_definition' 
  `import_tame_classification = 
  (!g. PlaneGraphs g /\ tame g ==> (?y. y IN archive /\ iso_fgraph (fgraph g) y))`;;


(*
report_tame_def "iso_fgraph" 4;;
report_def HOLDIR "*" "list_sum" 5;;
*)

let rotate_0 = prove_by_refinement(
  `!x n. rotate 0 x = x`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER])
  ]);;
  (* }}} *)

let rotate_eq_nil = prove_by_refinement(
  `!n (x:(A) list). rotate n x = [] <=> x = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate_0]);
  ASM_REWRITE_TAC[rotate_add;arith `SUC n = n + 1`];
  REWRITE_TAC[rotate;ITER_1];
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[rotate1;NOT_CONS_NIL;APPEND_EQ_NIL])
  ]);;
  (* }}} *)

let CONG_NIL = prove_by_refinement(
  `!x. (__cong) x = {[]} <=> (x:(A)list) = [] `,
  (* {{{ proof *)
  [
  GEN_TAC;
  REWRITE_TAC[EXTENSION;IN_SING];
  REWRITE_TAC[IN;cong];
  TYPIFY `x = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    BY(REWRITE_TAC[rotate_nil]);
  ASM_REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `[]:(A) list` EXISTS_TAC;
  REWRITE_TAC[NOT_EXISTS_THM];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REWRITE_TAC[rotate_eq_nil];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)




end;;
