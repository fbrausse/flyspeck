(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Conclusions 2                                                              *)
(* Chapter: Tame Hypermap                                                     *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2013-12-12                                                           *)
(* ========================================================================== *)

(* Final conclusions from Tame Hypermap chapter.
   SVN 3447 contains definitions in terms of hypermaps.
   Jan 31, 2014 switched definitions in terms of lists. *)

needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
(* flyspeck_needs "tame/import_tame_classification.hl";; *)

module More_tame_concl = struct

open Hales_tactic;;
open Hypermap;;
(* open Import_tame_classification;; *)


parse_as_infix("POWER",(24,"right"));;
unparse_as_infix "iso";;

(* 
parse_as_infix("in_dart_of_loop",(11,"right"));; 
make_overloadable "vertices" `:B -> (num list)`;;
overload_interface ("vertices",`FST:num list # bool -> num list`);;
Import_tame_classification.notation();;
*)

(* ========================================================================== *)
(* Matching Isabelle-planar with hypermap-planar *)
(* ========================================================================== *)

let import_tame_classification = 
  Import_tame_classification.import_tame_classification;;

(* This is the main result.  
It needs to be built up inductively step by step.   *)

let LSKOKJE_concl = `!H. is_restricted H ==>
  (?g. PlaneGraphs g /\ good_graph g /\
     iso H (hypermap_of_list (fgraph g)))`;;



(* ========================================================================== *)
(* good_list in Isabelle development. *)
(* ========================================================================== *)

(*

We don't need to prove these directly.  Properties of g can be deduced
when we match it with the core_list of (L,N) coming from the restricted
hypermap:

let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

let JUJUWAT_concl = `!g. planegraph_relaxed g ==> good_list (fgraph g)`;;

let ETDLJXT2_concl = `!g. planegraph_relaxed g ==> good_list_nodes (fgraph g)`;;

let CGGZYRC_concl = `!g f d. planegraph g /\ MEM f (faces g) /\ 
  MEM d (list_pairs (FST f))  /\ ~final f ==> 
  (?f'. MEM f' (faces g) /\ 
  MEM (SND d,FST d) (list_pairs (FST f')) /\ final f')`;;

*)


let DPZGBYF_concl = 
  "formalized DPZGBYU",
  (`!g. planegraph g ==> planegraph_relaxed g`);;

let ETDLJXT1_concl = `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`;;

let HWDMZDM_concl = `!g v. planegraph_relaxed g /\ v IN vertices_set2 g ==>
  facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)`;;

let SNVACWG_concl = `!L N. good_list L /\ 
  good_list_nodes L /\ is_restricted (hypermap_of_list L) /\
  normal_list L N ==>
  good_list (quotient_list L N)`;;

let PMBRINH_concl = `!L N. good_list_nodes L /\ normal_list L N ==>
  good_list_nodes (quotient_list L N)`;;

let LYNVPSU_concl = `!L N r x. marked_list L N r x ==>
    all uniq (quotient_list L N)`;;

(* ========================================================================== *)
(* Isomorphism *)
(* ========================================================================== *)


let iso_list_isop_list = `!L N L' N'. iso_list (L,N) (L',N') <=> 
  (?phi. isop_list phi (L,N) (L',N'))`;;

(* compare Elllnyz.hypermap_of_list_map *)



let GNBEVVU_concl = `!L N L' N'. 
    good_list L /\ iso_list (L,N) (L',N') ==> 
    iso (hypermap_of_list L) (hypermap_of_list L')`;;

let iso_list_refl = ("done",`!a. iso_list a a`);;

let iso_list_sym = ("done",`!a b. iso_list a b ==> iso_list b a`);;

let iso_list_trans = ("done",
 `!a b c. iso_list a b /\ iso_list b c ==> iso_list a b`);;

let isop_append = `!L N L' N' phi.
   (isop_list phi (L,APPEND N1 N2) (L',APPEND N1' N2') /\ 
      sizel N1 = sizel N1' ) <=>
   (isop_list phi (L,N1) (L',N1') /\ isop_list phi (L,N2) (L',N2'))`;;

let isop_cons = `!L N L' N' r r' phi.
    (isop_list phi (L,(r::N)) (L',(r'::N'))) <=>
    (isop_list phi (L,N) (L',N') /\ r' = 
	MAP (\u. (phi (FST u),phi(SND u))) r)`;;

let PEUTLZH_concl = ("done",`!L N L' N'.
  good_list L /\ iso_list (L,N) (L',N') ==>
  good_list L'`);;

let OISRWOF_concl = ("done",`!L N L' N'.
  good_list_nodes L /\ iso_list (L,N) (L',N') ==>
  good_list_nodes L'`);;

let UEYETNI_concl = ("done",`!L N L' N'.
  all uniq L /\ iso_list (L,N) (L',N') ==>
  all uniq L'`);;

let XKDZKWV_concl = `!L N L' N'.
  good_list L /\ iso_list (L,N) (L',N') /\ normal_list L N ==>
  normal_list L' N'`;;

let DAKEFCC_concl = ("done 3/2014",
  `!H K. is_restricted H /\ iso H K ==> is_restricted K`);;

let MEEIXJO_concl = `!L N L' N' r r' (x:A#A) (x':B#B).
  good_list L /\ 
  iso_list (L,([x]:: r :: N)) (L',([x']::r' :: N')) /\
  marked_list L N r x ==> marked_list L' N' r' x'`;;

(* ========================================================================== *)
(* Reduction of restricted hypermap to special hypermap_of_list form. *)
(* ========================================================================== *)

(* reductions to hypermap_of_list L, then num, then ordered_list form *)

				
let RXOKSKC_concl = 
  `!H. is_restricted H ==> 
    (?L. good_list L /\ good_list_nodes L /\ all uniq L /\
       iso H (hypermap_of_list L))`;;

let JXBJOAB_concl = 
  `!(L:((A)list)list). 
   ?(L':((num)list)list). iso_list (L,[]) (L',[])`;;


(* ordering the list of darts in L. rotate_to is deprecated. Rewrite.... *)

let SHXWKXQ_concl = 
  `!L:((num)list)list N x. 
     (
       let f = find_face L x in
       let r = find_list N x in
	 MEM x (flatten N) /\
	 uniq (MAP FST f) /\ 
	   set_of_list (flatten N) SUBSET (set_of_list (list_of_darts L)) ==>
	 (?L' N' x'.
	   iso_list (L,([x]::N)) (L',([x']::N')) /\
	   (let f' = find_face L' x' in
	    let r' = find_list N' x' in
	    let extra' = MAP FST (filter (\d. ~MEM d r') (rotate_to f' x')) in
	      ordered_list (set_of_list(MAP FST (flatten N'))) extra')))`;;

(* main reduction to lists *)

let JCAJYDU_concl = `(!L. 
  good_list L /\ good_list_nodes L /\ all uniq L /\
  is_restricted (hypermap_of_list L) ==>
  (?g. PlaneGraphs g /\ 
     good_graph g /\
     iso (hypermap_of_list L) (hypermap_of_list (fgraph g))))
   ==> 
   (!H. is_restricted H ==>
  (?g. PlaneGraphs g /\ good_graph g /\
     iso H (hypermap_of_list (fgraph g))))`;;


(* ========================================================================== *)
(* Translate hypermap notions into list notions *)
(* AQIUNPP in Hypermaps chapter *)
(* ========================================================================== *)

let GZLJIGN1_concl = `!L N r x.
      hyp'm (hypermap_of_list L) N (loop_of_list r) x = 
	l'm L r x`;;

let GZLJIGN2_concl = `!L N r x.
  hyp'p (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) x = 
	l'p L N r x`;;

let GZLJIGN3_concl = `!L N r x.
  hyp'q (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) x = 
  l'q L N r x`;;

let GZLJIGN4_concl = `!L N r x.
  hyp'y (hypermap_of_list L) N (loop_of_list r) x = 
  l'y L r x`;;

let GZLJIGN5_concl = `!L N r x.
  hyp'z (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) x = 
  l'z L N r x`;;

let EVNAPDQ_concl = ("done",`!L N.
  good_list L /\ normal_list L N ==>
  is_normal (hypermap_of_list L) (loop_family_of_list N)`);;

let ABKCJWD_concl = `!L N.
  good_list L /\ normal_list L N ==>
  iso (quotient (hypermap_of_list L) (loop_family_of_list N))
  (hypermap_of_list (quotient_list L N))`;;

let ODWAFRG_concl = `!L N r x.
  good_list L /\ marked_list L N r x ==>
  is_marked 
  ((hypermap_of_list L),(loop_family_of_list N),(loop_of_list r),x)`;;



(* Translate known lemmas. *)

let HQYMRTX = Hypermap.lemmaHQYMRTX;;

let HQYMRTX1_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> MEM (l'z L N r x) r /\
    (!i. 1 <= i /\ i <= SUC (l'm L r x) ==>
       ~(l'z L N r x = (f_list L POWER i) x))`;;

let HQYMRTX2_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'y L r x)`;;

let HQYMRTX3_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'z L N r x)`;;

let QRDYXYJ = Hypermap.lemmaParameters;;

let QRDYXYJ_list = `!L N r x.
  marked_list L N r x /\ ~(final_list L r) ==>
  l'm L r x < l'q L N r x /\
  l'q L N r x < sizel (parts L r) /\
  SUC (l'm L r x) < l'p L N r x + l'q L N r x /\
  ~(FST (l'y L r x) = FST x) /\
  ~(FST (l'y L r x) = FST (l'z L N r x))`;;

let AQIUNPP1 = Hypermap.lemma_normal_family_transform;;

let AQIUNPP1_list = `!L N r (x:A#A).
  marked_list L N r x /\ ~(final_list L r) ==> 
       normal_list L (ntrans L N r x 1)`;;

let AQIUNPP2_concl = 
  `!L N r (x:A#A).
    marked_list L N r x ==> 
    marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x`;;

let AQIUNPP3_concl = 
  `!L N r (x:A#A) i.
    marked_list L N r x ==> 
    marked_list L (ntrans L N r x i) (rtrans L N r x i) x`;;



(* ========================================================================== *)
(* Initialization. dih2k *)
(* ========================================================================== *)


let FOEGZEQ1_concl = 
  ("good-list-seed",
  `!p. good_list (fgraph (Seed p))`);;

let FOEGZEQ2_concl = 
  ("all-uniq-seed",
  `!p. good_list (fgraph (Seed p))`);;

let TAGYMW_concl = 
  `!p. good_list_nodes (fgraph (Seed p))`;;

let ENWCUED_concl = 
  `!p.  dih2k_list ( (fgraph (Seed p)))`;;

let DLWOJBB_concl = 
  `!L. dih2k_list L ==> 
    dih2k (hypermap_of_list L) (sizel (HD L))`;;

let KUKASGD_concl = 
  `!L. dih2k_list L /\ dih2k_list L' /\
     sizel (HD L) = sizel (HD L') ==> iso_list (L,[]) (L',[])`;;

let UNHQYQM_concl = 
  `!L L'. iso_list (L,[]) (L',[]) /\ dih2k_list L
    ==> dih2k_list L'`;;

let AUQTZYZ_concl = `!H (x:A) L1. is_restricted H /\ (x IN dart H)  /\ 
  (L1 = loop_of_face H x) ==>
  (?L2. is_normal H {L1,L2}  /\ 
    (path_of_loop L2 x = complement H x) /\ 
     dih2k (quotient H {L1,L2}) (CARD (face H x)))`;;

let AUQTZYZ_list = `!L f. is_restricted (hypermap_of_list L) /\
  good_list L /\ MEM f (list_of_faces L) ==>
   (?f'. normal_list L [f;f'] /\ quotient_list L [f;f'] = 
      [(MAP FST f); rev (MAP FST f)])`;;

let UYOUIXG_concl = `!L f .  is_restricted (hypermap_of_list L) /\
   good_list L /\ MEM f (list_of_faces L) /\ ~dih2k_list L ==>
     (?L' N' f2. iso_list (L,[f;f2]) (L',N') /\
	normal_list L' N' /\ 
	 match_core_list (Seed (sizel f -3)) L' N')`;;
     
(* ========================================================================== *)
(* Termination. *)
(* ========================================================================== *)

(*			
let ADACDYF_concl = `!H NF L MF M (x:A).  is_marked(H,NF,L,x) /\
   ~(L IN final_loops H NF) /\
   (MF,M) = transform H x (NF,L) ==>
  CARD (dart (quotient H NF)) < CARD (dart (quotient H MF))`;;
*)

let ADACDYF_concl = `!L N r N' r' (x:A#A). marked_list L N r x /\
    ~final_list L r /\ 
  sizel (list_of_darts (quotient_list L N)) <
  sizel (list_of_darts (quotient_list L (ntrans L N r x 1)))`;;

let ZBHENEI_hypermap = Hypermap.lemma_finite_normal_loops;;

let XWCNBMA_hypermap = Hypermap.face_quotient_lemma;;

let ZBHENEI_concl = `!L N. normal_list L N ==>
  sizel (list_of_darts (quotient_list L N)) 
  <= sizel (list_of_darts L)`;;

(* This and monotonicity will give termination *)

let XZAJELF_concl = `!g L N. 
     match_core_list g L N ==>
     sizel (flatten (MAP FST (finals g))) <=
     sizel (list_of_darts L)`;;

let XWCNBMA_concl = `!L N. normal_list L N /\
  is_restricted (hypermap_of_list L) /\ 
  all (final_list L) N ==> L = quotient_list L N`;;

(* ========================================================================== *)
(* nonFinals and finals of g. *)
(* ========================================================================== *)

let more_concl = `subdivFaceFinal = subdivFace`;;

(* This shows that the set of finals of g never out-paces L//N.
   Only one more final face is created by subdivFaceFinal.  *)

let subdivFace0_finals = `!g f u n vs.
  ~(MEM f (finals g)) ==> 
  (finals g = finals (SND(subdivFace0_alt g f u n vs)))`;;


(* ========================================================================== *)
(* Enumeration Lists *)
(* ========================================================================== *)


let show_hideDups_concl = ("done",
  `!s. showDups (hideDups s) = s`);;

let hideDups_show_concl = ("done",
  `!s. image_hideDups s ==> hideDups (showDups s) = s`);;

let enum_indexToVertexList_concl = ("done",
  `!e f v. MEM v (FST f) /\ (uniq (FST f)) /\ 
    (all (\n. n < sizel (FST f)) e) ==>
    enum_of_VertexList (FST f) v (indexToVertexList f v e) = e`);;

let indexToVertexList_enum_concl = ("done",
  `!vs f v. uniq (FST f) /\ MEM v (FST f) /\ 
    image_hideDups vs /\
    all (\t.  MEM (the t) (FST f)) (filter isSome vs) ==>
    indexToVertexList f v (enum_of_VertexList (FST f) v vs) = vs`);;

let more_concl = 
  `!f vs. hypotheses ==> dest_triple f (mk_triple1 f vs) = vs`;;

let more_concl = 
  `!f vs. hypotheses ==> mk_triple1 f (dest_triple f vs) = vs`;;


let more_concl = `hypotheses ==>
  subdivFaceFinal2 g f (mk_triple1 (FST f) vs) = subdivFace g f vs`;;

(* this justifies the duplicate edge filter *)

let more_concl = 
  `!g f v enum. containsDuplicateEdge g f v enum ==>
    (let vs = indexToVertexList f v enum in
     let triple = mk_triple1 (FST f) vs in
       (?u v. MEM (u,v,0) triple /\ MEM (u,v) (list_of_darts (fgraph g))))`;;




(* ========================================================================== *)
(* The Index Calculus of Higher Transforms. *)
(* ========================================================================== *)


let QYHXIVZ1_concl = `!s x. indexf x x s = 0`;;

let QYHXIVZ2_concl = `!s a b. indexf a b s = 1 <=> next_el s a = b`;;

let QYHXIVZ3_concl = `!s x y k. uniq s ==> indexf x y s = indexf x y (rot k s)`;;

let QYHXIVZ4_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\ MEM c s /\
   indexf b c s <= indexf a c s ==> indexf a b s + indexf b c s = indexf a c s`;;

let QYHXIVZ5_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\ MEM c s /\
   indexf a b s <= indexf a c s ==> indexf a b s + indexf b c s = indexf a c s`;;

let QYHXIVZ6_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\ MEM c s /\
   indexf a b s + indexf b c s < sizel s  
   ==> indexf a b s + indexf b c s = indexf a c s`;;

let QYHXIVZ7_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\ ~(a = b) ==>
   indexf a b s + indexf b a s = sizel s`;;

let QYHXIVZ8_concl = `!s x y. uniq s /\ MEM x s /\ MEM y s ==> 
  (next_el s POWER (indexf x y s)) x = y`;;

let QYHXIVZ9_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\
   MEM c s ==>
    (MEM b (betwn s a c) <=> 1 < indexf a b s /\ indexf a b s < indexf a c s)`;;

let QYHXIVZ10_concl = `!s a b c. uniq s /\ MEM a s /\ MEM b s /\
   MEM c s /\ ~(MEM b (betwn s c a)) ==>
 indexf a b s + indexf b c s = indexf a c s`;;  

let FWDDPHY_concl =  `!f w (x:A). 
  MEM x f /\
  w = next_el f x ==>
  indexf w x f + 1 = sizel f`;;

let DANGEYJ_concl = ("done",`!L N r (x:A#A) i j. marked_list L N r x /\ i <= j ==>
  set_of_list (flatten (ntrans L N r x i)) SUBSET 
  set_of_list (flatten (ntrans L N r x j))`);;

let PWSSRAT_concl = `!L N r (x:A#A) d i. good_list L /\ marked_list L N r x /\ 
  MEM d (rtrans L N r x i) /\ ~(final_list L (rtrans L N r x i)) ==>
   (MEM d (rtrans L N r x (SUC i)) <=>
      indexf (ztrans L N r x i) d (rtrans L N r x i) <=
      indexf (ztrans L N r x i) (ytrans L N r x i) (rtrans L N r x i))`;;

let OHCGKFU_concl = `!L N r (x:A#A) d i. marked_list L N r x /\ 
  MEM d (rtrans L N r x i) /\ (MEM d (rtrans L N r x (SUC i))) ==>
      indexf (ztrans L N r x i) d (rtrans L N r x i) =
      indexf (ztrans L N r x i) d (rtrans L N r x (SUC i))`;;

let PPLHULJ_concl = `!L N r (x:A#A) d i. marked_list L N r x /\
    f = find_face L x /\
    w = next_el f x ==>
    MEM (ytrans L N r x i) f /\ MEM (ztrans L N r x i) f /\
    indexf w (ytrans L N r x i) f < indexf w (ztrans L N r x i) f`;;

let NCVIBWU_concl = `!L N r f w (x:A#A) i j. marked_list L N r x /\
  f = find_face L x /\
  w = next_el f x /\
  j <= indexf w (ztrans L N r x i) f  ==>
  (MEM (((next_el f) POWER j) w)  (rtrans L N r x i) /\
     j = indexf w ((next_el f POWER j) w) (rtrans L N r x i))`;;

let QCDVKEA_concl = `!L N r f w (x:A#A) i j. marked_list L N r x /\
  f = find_face L x /\
  w = next_el f x ==>
  indexf w (ztrans L N r x i) f <= indexf w (ytrans L N r x (SUC i)) f`;;

let PBFLHET_concl = `!L N d r ri w (x:A#A) i. marked_list L N r x /\
  MEM d (rtrans L N r x i) /\
  ri = rtrans L N r x i /\
  w = next_el (find_face L x) x /\
  indexf w (ztrans L N r x i) ri <=   indexf w d ri /\
  indexf w d ri <= indexf w (ytrans L N r x 0) ri
   ==>
   MEM d r`;;

let PNXVWFS1_concl = `!L N r (x:A#A) i. marked_list L N r x 
   ==>
  MEM (ytrans L N r x i) r`;;

let PNXVWFS2_concl = `!L N r (x:A#A) i. marked_list L N r x 
  ==>
  MEM (ytrans L N r x i) r`;;

let DIOWAAS_concl = `!L N r (x:A#A) i. marked_list L N r x /\
  w = next_el (find_face L x) x ==>
  indexf w (ytrans L N r x i) r < indexf w (ztrans L N r x i) r`;;

let RYIUUVK_concl = `!L N r (x:A#A) i. marked_list L N r x /\
  w = next_el (find_face L x) x ==>
  indexf w (ztrans L N r x i) r < indexf w (ytrans L N r x (SUC i)) r`;;

let XBXFJPH1_concl = `!L N r (x:A#A) u. marked_list L N r x /\
  MEM u (flatten N) /\ MEM u (find_face L x) ==>
  ((?j. u = ytrans L N r x j) <=> 
     ~(next_el (find_list N u) u = f_list L u))`;;

let XBXFJPH2_concl = `!L N r (x:A#A) u. marked_list L N r x /\
  MEM u (flatten N) /\ MEM u (find_face L x) ==>
  ((?j. u = ztrans L N r x j) <=> 
     ~(f_list L (prev_el (find_list N u) u) = u))`;;

(*
let XBXFJPH_concl = `!L N r (x:A#A).
   marked_list L N r x ==>
   (let f = find_face L x in
   (set_of_list (filter (\d. MEM d f) (flatten N))) SUBSET
   (set_of_list r))`;;

let RYIUUVK_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'z L (N' i) (r' i) x) r <
      indexf x (l'y L (r' (SUC i)) x) r)`;; 

let CESHTIN1_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'z L (N' i) (r' i) x) r)`;;

let CESHTIN2_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'y L (r' i) x) r)`;;

let CESHTIN3_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' (SUC i)) ==>
      indexf x (l'z L (N' i) (r' i) x) (find_face L x) <=
      indexf x (l'y L (r' (SUC i)) x) (find_face L x))`;;

let CESHTIN4_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'y L (r' i) x) (find_face L x) <
      indexf x (l'z L (N' i) (r' i) x) (find_face L x))`;;

let CESHTIN5_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let y = l'y L (r' i) x in
     let z' = l'z L (N' i) (r' i) x in
     let y' = f_list L (e_list y) in 
     let z = n_list L z' in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r y' z = betwn ri y' z)))`;;


let CESHTIN6_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let z = l'z L (N' i) (r' i) x in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r z x = betwn ri z x)))`;;
*)


(* ========================================================================== *)
(* Match g L N *)
(* ========================================================================== *)

(* primary reduction.  

   Termination guaranteed by the
   strictly increasing quantity sizel(flatten(finals g)).

 *)

let more_concl = `!L.  
  is_restricted (hypermap_of_list L) /\
  good_list L /\
  good_list_nodes L /\
  all uniq L /\
  (!N g. premarked_list g L N /\ planegraph g /\ (~(nonFinals g = [])) 
   ==>
     (?L' N' g'. iso_list (L,[]) (L',[]) /\
	premarked_list g' L' N' /\ planegraph g' /\
	sizel (flatten (MAP FST (finals g'))) > sizel (flatten (MAP FST (finals g)))))
  ==>
   (?g. PlaneGraphs g /\ 
     iso (hypermap_of_list L) (hypermap_of_list (fgraph g)))`;;

let HKBGWJI_concl = 
  `!L N r x g.
    is_restricted (hypermap_of_list L) /\
    ~(nonFinals g = []) /\
    match_core_list g L N /\
    (r,x) = loop_choice g L N ==>
  marked_list L N r x`;;

(* explicit powers of transform list *)

let more_concl = `!g L N i. hypotheses ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let f = find_face L x in
      (!i. i <= k ==>
	 (ntrans L N r x i,rtrans L N r x i) = FST (ITER i
	   (\ Nrz. 
	      (let (N,r) = FST Nrz in
	       let zs = SND Nrz in
               let (y,z,b) = HD zs in
	       let ram2 = prev_el r z in
	       let split = split_normal_list L r f y ram2 in
	       let N' = APPEND (replace r [SND split] N) [FST split] in
		 if (final_list L r) 
		 then ((N,r),[]) else ((N', SND split),TL zs))) 
	      ((N,r),triple_data g L N))))`;;

(* explicit powers on core_list *)

let more_concl = `!g L N i. hypotheses /\ i <= transform_count L N r x 
  ==>
  (let (r,x) = loop_choice g L N in
   let triples = core_triple g L N in
   let mf = (FST (minimalFace (nonFinals g))) in
     quotient_list L (ntrans L N r x i) = part1 (ITER i (\ t.
	(let oldF,L',zs = t in
	 let ram1,ram2,n = HD zs in
	 let newVs = betwn mf ram1 ram2 in
	 let f1,f2,L'' = splitFace_list L' ram1 ram2 oldF newVs in
	   (f2,L'',TL zs)))
			      (mf,(fgraph g),triples)
					      ))`;;

(* transform and subdiv both recover the face f.
   Needed to match up finals g at rk'. *)

let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let f = find_face L x in
      (f = rtrans L N r x k))`;;

let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let f = find_face L x in
    let mf = minimalFace (nonFinals g) in
    let triples = triple_data g L N in
    let uvns = MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) triples in
    let (f',g') = subdivFace0_alt2 g mf (countVertices g) uvns in
      FST f' = MAP FST f)`;;

(* main matching result of transform^k with subdivFaceFinal2 *)

let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let mf = minimalFace (nonFinals g) in
    let triples = triple_data g L N in
    let uvns = MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) triples in
    let g' = subdivFaceFinal2 g mf uvns in
      match_list g' L (ntrans L N r x k))`;;

(* XX Now we just need to show that uvns comes from an enumeration
   and we are home. *)


(* ========================================================================== *)
(* Tame- Part 1 *)
(* ========================================================================== *)

(* done by Solovyev, Jan 10, 2014 *)
let XRFJNDO_concl = `!y. y IN archive ==> good_list y`;;

(* done by tch *)
let ELLLNYZ_concl = `!x y. good_list x /\ good_list y /\ iso_fgraph x y ==>
  (iso (hypermap_of_list (x)) (hypermap_of_list (y)) \/
     iso (opposite_hypermap (hypermap_of_list (x))) (hypermap_of_list (y)))`;;

(* done by tch, Jan 11, 2014 *)
let ASFUTBF_concl = `!H:(A)hypermap .
   (?V'. contravening V' /\
      iso (opposite_hypermap (hypermap_of_fan (V',ESTD V'))) H)
   ==> (?V. contravening V /\ iso (hypermap_of_fan (V,ESTD V)) H)`;;

(* ========================================================================== *)
(* Tame- Part 2 *)
(* ========================================================================== *)

(* WMLNYMD, done tch. *)

let tame9a_correspondence_weak = 
  `!g. tame_hypermap (hypermap_of_list (fgraph g)) /\ PlaneGraphs g 
   ==>
  tame9a g`;;

let tame9a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame9a g`;;

let tame10_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame10 g`;;

let tame11a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame11a g`;;

let tame11b_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame11b g`;;

let tame12o_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame12o g`;;

let tame13a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame13a g`;;

let tame_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame g`;;


(* ========================================================================== *)
(* Final conclusions *)
(* ========================================================================== *)

(* easy corollary of tame_good, archive_good, good_iso, TAME_CORRESPONDENCE_MAIN *)

let TAME_CORRESPONDENCE_2_concl = 
 `!H. tame_hypermap H /\ import_tame_classification ==>
  (?x. x IN archive /\ (iso H (hypermap_of_list x) \/  
  iso (opposite_hypermap H)  (hypermap_of_list x)))`;;

end;;
