(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Conclusions 2                                                              *)
(* Chapter: Tame Hypermap                                                     *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2013-12-12                                                           *)
(* ========================================================================== *)

(* Final conclusions from Tame Hypermap chapter *)

needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "../tame_archive/tame_archive.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;

module More_tame_concl = struct
end;;

open Hypermap;;
open Import_tame_classification;;

parse_as_infix("POWER",(24,"right"));;
parse_as_infix("in_dart_of_loop",(11,"right"));;
Import_tame_classification.notation();;

(* parse_as_infix("iso",(24,"right"));; *)
unparse_as_infix "iso";;

(*
make_overloadable "vertices" `:B -> (num list)`;;
overload_interface ("vertices",`FST:num list # bool -> num list`);;
*)

(* ========================================================================== *)
(* What is needed to finish AQIUNPP in Hypermaps chapter *)
(* ========================================================================== *)

let QRDYXYJ = Hypermap.lemmaParameters;;

let AQIUNPP1 = Hypermap.lemma_normal_family_transform;;

let transform = new_definition `transform (H:(A)hypermap) x (NF,L) = 
  (family_transform H NF L x,loop1_transform H NF L x)`;;

let AQIUNPP2_concl = 
  `!H:(A)hypermap NF:(A)loop->bool L:(A)loop x:A. 
  is_marked (H ,NF, L, x) /\ ~(L IN final_loops H NF) 
   ==> (let (NF',L') =  (transform H x (NF,L)) in is_marked (H,NF',L',x))`;;

(* ========================================================================== *)
(* good_list in Isabelle development. *)
(* ========================================================================== *)

(*
let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;
*)

let JUJUWAT_concl = `!g. planegraph g ==> good_list (fgraph g)`;;

let ETDLJXT1_concl = `!g. planegraph g ==> 
  (vertices_set2 g = set_of_list (flatten (fgraph g)))`;;

let ETDLJXT2_concl = `!g. planegraph g ==> good_list_nodes (fgraph g)`;;

let CGGZYRC_concl = `!g f d. planegraph g /\ MEM f (faces g) /\ 
  MEM d (list_pairs (FST f))  /\ ~final f ==> 
  (?f'. MEM f' (faces g) /\ 
  MEM (SND d,FST d) (list_pairs (FST f')) /\ final f')`;;
    `;;

(* ========================================================================== *)
(* Matching Isabelle-planar with hypermap-planar *)
(* ========================================================================== *)

let import_tame_classification = new_definition
  `import_tame_classification_FAKE = 
  (!g. PlaneGraphs g /\ tame g ==> 
     (?y. y IN archive /\ iso_fgraph (fgraph g) y))`;;

(* This needs to be built up inductively step by step.
This result should hold more generally for any restricted
hypermap.   *)

let LSKOKJE_concl = `!H. is_restricted H ==>
  (?g. PlaneGraphs g /\ iso H (hypermap_of_list (fgraph g)))`;;

(* ========================================================================== *)
(* Initialization. Construction of LL0 *)
(* ========================================================================== *)

let AUQTZYZ_concl = `!H (x:A). is_restricted H /\ (x IN dart H) ==>
  (? L1 L2. is_normal H {L1,L2} /\ (L1 = loop_of_face H x) /\ 
    (path_of_loop L2 x = complement H x) /\ 
     dih2k (quotient H {L1,L2}) (CARD (face H x)))`;;

let ENWCUED_concl = 
  `!n.  dih2k (hypermap_of_list (fgraph (Seed n))) (n+3)`;;

let PFUWHJH_concl = 
  `!H (x:A) y n. dih2k H n /\ x IN dart H /\ y IN dart H ==>  
    (?phi. hyp_iso phi (H,H) /\ phi x = y)`;;

let respect_final = new_definition 
  `respect_final (phi:num#num->A->bool) g H NF = 
  final_quotient_faces H NF =  set_of_list 
    (MAP ((IMAGE phi) o set_of_list o list_pairs o FST) 
       (FILTER SND (faces g)))`;;

let UYOUIXG_concl = 
  `!H (x:A) n L1 L2. is_restricted H /\ x IN dart H /\ (n = CARD(face H x)) /\
    is_normal H {L1,L2} /\ (L1 = loop_of_face H x) /\
    (path_of_loop L2 x = complement H x) /\
    dih2k (quotient H {L1,L2}) n /\
    ~(L2 = loop_of_face H x) ==>
    (?phi. 
      hyp_iso phi ((hypermap_of_list (fgraph (Seed (n-3)))) ,
		   (quotient H {L1,L2})) /\
      respect_final phi (Seed (n-3)) H {L1,L2}) `;;


(* ========================================================================== *)
(* Termination. *)
(* ========================================================================== *)
			
let ADACDYF_concl = `!H NF L MF M (x:A).  is_marked(H,NF,L,x) /\
   L IN final_loops H NF /\
   (MF,M) = transform H x (NF,L) ==>
  CARD (dart (quotient H NF)) < CARD (dart (quotient H MF))`;;

let ZBHENEI_concl = `!H NF. is_restricted H /\ is_normal H NF ==>
  CARD (dart (quotient H NF)) <= CARD (dart H)`;;

let XWCNBMA_concl = `!H NF.  is_restricted H /\ is_normal H NF /\
  final_loops H NF = NF ==> iso H (quotient H NF)`;;

(* ========================================================================== *)
(* Higher Transforms. *)
(* ========================================================================== *)

let path_index = new_definition `path_index n p x = 
  indexl (x:A) (mkseq p n)`;;

let modify_loop = new_definition `modify_loop n L (x:A) y p = 
  (let q1 = path_of_loop L y in 
   let index' = path_index n in
   let q2 = shift_path p (index' p x) in
   let m = index L y x in
   let q = glue q1 q2 m  in
   let n = index' q2 y + m in
  loop (support_of_sequence q n, samsara q n))
  `;;

let LPWFYMU_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     (let f =  face_contour H x in
      let fc =  complement H x in
      let z = hyp'z H (MF i) (M i) x in
      let n = CARD (dart H) in
      let Mminus  = modify_loop n (M i) x z f in 
      let Mplus = modify_loop n (M i) 
	(inverse (node_map H) x) (node_map H z) fc in
	(MF (SUC i) = ((MF i) DIFF {M i}) UNION {Mminus,Mplus}) /\
	  M (SUC i) = Mminus))`;;

let RYIUUVK_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
       index (loop_of_face H x) x (hyp'z H (MF i) (M i) x) < 
	 index (loop_of_face H x) x (hyp'y H (MF (SUC i)) (M (SUC i)) x))`;;

(* XX I might not have the condition on final_loops quite right on these.
   Check this. *)

let CESHTIN1_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     hyp'z H (MF i) (M i) x IN dart_of_loop L)`;;

let CESHTIN2_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     hyp'y H (MF i) (M i) x IN dart_of_loop L)`;;

let CESHTIN3_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     index L x (hyp'z H (MF i) (M i) x) < 
	 index L x (hyp'y H (MF (SUC i)) (M (SUC i)) x))`;;

let CESHTIN4_concl = `!H NF L (x:A) M MF.
  is_marked (H,NF,L,x) /\ ~(L IN final_loops H NF) /\
  (!i. (MF i,M i) = (transform H x POWER i) (NF,L)) ==>
  (!i. ~(M i IN final_loops H NF) ==>
     index L x (hyp'y H (MF i) (M i) x) < 
	 index L x (hyp'z H (MF i) (M i) x))`;;








  


(* ========================================================================== *)
(* Induction step. *)
(* ========================================================================== *)

let corresponding_hyperdata = new_definition `
  corresponding_hyperdata (H,NF,g,phi) <=> 
  (is_normal (H:(A) hypermap) NF /\
    planegraph g /\
    hyp_iso phi (hypermap_of_list (fgraph g),quotient H NF) /\
    respect_final phi g H NF /\
   simple_hypermap (quotient H NF) /\
   is_node_nondegenerate (quotient H NF) /\
   empty_flagged H NF)`;;

let loop_choice = new_definition `loop_choice (H,NF,g,phi) = @Lx.
  (
    let L = FST Lx in
    let x = SND Lx in
   let f = minimalFace (nonFinals g) in
   let v = minimalVertex g f in
   let w = nextVertex f v in
   let d = phi(v,w) in
      (x = tail_of_atom H NF (d:A) /\ d IN dart_of_loop L))`;;

let HKBGWJI_concl = new_definition 
  `!H NF g phi L (x:A).
      is_restricted H /\
     corresponding_hyperdata (H,NF,g,phi) /\
     ~(nonFinals g = []) /\
     ((L,x) = loop_choices(H,NF,g,phi)) ==>
    is_marked (H,NF,L,x)`;;

let dart_of_lgraph = new_definition `dart_of_lgraph g f v = 
  (


(* ========================================================================== *)
(* Matching Isabelle-tame with hypermap-tame *)
(* ========================================================================== *)

let archive_good_concl = `!y. y IN archive ==> good_list y`;;

let good_iso = `!x y. good_list x /\ good_list y /\ iso_fgraph x y ==>
  (iso (hypermap_of_list (x)) (hypermap_of_list (y)) \/
     iso (opposite_hypermap (hypermap_of_list (x))) (hypermap_of_list (y)))`;;

(* ========================================================================== *)
(* Matching Isabelle-tame with hypermap-tame *)
(* ========================================================================== *)


let tame9a_correspondence_weak = 
  `!g. tame_hypermap (hypermap_of_list (fgraph g)) /\ PlaneGraphs g 
   ==>
  tame9a g`;;

let tame9a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame9a g`;;

let tame10_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame10 g`;;

let tame11a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame11a g`;;

let tame12o_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame12o g`;;

let tame13a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame13a g`;;

let tame_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame g`;;


(* ========================================================================== *)
(* Final conclusions *)
(* ========================================================================== *)

(* easy corollary of tame_good, archive_good, good_iso, TAME_CORRESPONDENCE_MAIN *)

let TAME_CORRESPONDENCE_2_concl = 
 `!H. tame_hypermap H /\ import_tame_classification_FAKE ==>
  (?x. x IN archive /\ (iso H (hypermap_of_list x) \/  
  iso (opposite_hypermap H)  (hypermap_of_list x)))`;;

end;;
