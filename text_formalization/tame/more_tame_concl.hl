(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Conclusions 2                                                              *)
(* Chapter: Tame Hypermap                                                     *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2013-12-12                                                           *)
(* ========================================================================== *)

(* Final conclusions from Tame Hypermap chapter.
   SVN 3447 contains definitions in terms of hypermaps.
   Jan 31, 2014 switched definitions in terms of lists. *)

needs "Library/rstc.ml";;
flyspeck_needs "hypermap/hypermap.hl";;
flyspeck_needs "../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl";;
flyspeck_needs "../formal_lp/hypermap/computations/list_conversions2.hl";;
flyspeck_needs "tame/import_tame_classification.hl";;

module More_tame_concl = struct
end;;

open Hypermap;;
open Import_tame_classification;;

parse_as_infix("POWER",(24,"right"));;
unparse_as_infix "iso";;

(* 
parse_as_infix("in_dart_of_loop",(11,"right"));; 
make_overloadable "vertices" `:B -> (num list)`;;
overload_interface ("vertices",`FST:num list # bool -> num list`);;
Import_tame_classification.notation();;
*)


(* ========================================================================== *)
(* definitions *)
(* ========================================================================== *)

let good_list = new_definition
  `!L. good_list L <=>
            uniq (list_of_darts L) /\
            all (\l. ~(l = [])) L /\
            (!d. MEM d (list_of_darts L)
                 ==> MEM (SND d,FST d) (list_of_darts L))`;;

let good_list_nodes = new_definition
  `!L. good_list_nodes L <=>
            node_set (hypermap_of_list L) = 
      set_of_list (nodes_of_list L)`;;

let good_graph = new_definition
 `!g. good_graph g <=>
            good_list (fgraph g) /\
            good_list_nodes (fgraph g) /\
            finalGraph g /\
            all uniq (fgraph g) /\
            (!v. v IN vertices_set2 g
                 ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
            vertices_set2 g = elements_of_list (fgraph g)`;;

let iso_list = new_definition `!L N L' N'. iso_list (L,N) (L',N') <=>
   (?phi.  inj_on phi (elements_of_list L) /\
      L' = MAP (MAP phi) L /\
      N' = MAP (MAP (\u. phi (FST u),phi (SND u))) N)`;;

let isop_list = new_definition `!L N L' N'. isop_list phi (L,N) (L',N') <=>
   (inj_on phi (elements_of_list L) /\
      L' = MAP (MAP phi) L /\
      N' = MAP (MAP (\u. phi (FST u),phi (SND u))) N)`;;

let indexf = new_definition `!s x y. indexf (x:A) y s = 
   (indexl y s + (sizel s - indexl x s) MOD (sizel s))`;;

let f_last = new_definition 
 `f_last L s <=> (next_el s (LAST s) = f_list L (LAST s))`;;

let one_step_list = new_definition `one_step_list L x y = 
  (y = f_list L x \/ y = (f_list L (e_list x)))`;;

let loop_list = new_definition
  `loop_list L (s:(A#A)list) <=>
    (all (\x. MEM x (list_of_darts L) /\ one_step_list L x (next_el s x)) s)`;;

let contour_list = new_definition
  `contour_list L (s:(A#A) list) <=>
    (all (\x. MEM x (list_of_darts L) /\ 
       (x = LAST s \/ one_step_list L x (next_el s x))) s)`;;

let normal_list = new_definition
  `normal_list L N <=>
    (uniq (flatten N) /\
     all (\s. ~(s = [])) N /\
     all (f_last L) N /\
     all (loop_list L) N /\
     (!d. MEM d (flatten N) ==> 
	(node (hypermap_of_list L) d SUBSET set_of_list (flatten N))))`;;

let list_of_face = new_definition `list_of_face H ff = 
  map (\i. node H ((face_map H POWER i) (CHOICE ff))) (upt 0 (CARD ff))`;;

let list_of_hypermap = new_definition `list_of_hypermap H = 
  map (list_of_face H) (list_of_set (face_set H))`;;

let core_list = new_definition `core_list PN = 
  map (\f. map (\x. FST (HD x)) f) PN`;;

let partition_into_atom0 = new_recursive_definition list_RECURSION
  `partition_into_atom0 (n:A->A) acc [] = acc /\
   partition_into_atom0 n acc (r::rs) = 
     if (acc = []) then partition_into_atom0 n [[r]] rs
     else (if (n r = HD(HD acc)) 
           then partition_into_atom0 n ((r:: HD acc)::TL acc) rs
	   else partition_into_atom0 n ([r]::acc) rs)`;;
     
let partition_into_atom = new_definition `partition_into_atom n r =
  partition_into_atom0 n [] (rev r)`;;

(* old:
let parts = new_definition `parts L r = 
  (let H = hypermap_of_list L in
     partition_into_atom (inverse (node_map H)) r)`;;
*)

let parts = new_definition `parts L r = 
  partition_into_atom ((f_list L) o e_list) r`;;

(* redone, feb 2 2014 *)

let quotient_list = new_definition 
 `quotient_list (L:((A)list)list) N = 
  core_list (map (parts L) N)`;;

let final_list = new_definition `final_list L r = 
   all (\p. sizel p = 1) (parts L r)`;;

let final_dart_list = new_definition `final_dart_list L N = 
  flatten (filter (final_list L) N)`;;

let loop_of_list_v2 = new_definition `loop_of_list_v2 r = 
  loop(set_of_list r, next_el r)`;;

let loop_family_of_list = new_definition `loop_family_of_list N = 
  set_of_list (map loop_of_list_v2 N )`;;

let split_list_face_n = new_definition `!newVs (f:(A) list) ram1 ram2.
         split_list_face_n f ram1 ram2 newVs =
         (let f1 = APPEND [ram1] (APPEND (betwn f ram1 ram2) [ram2]) in
          let f2 = APPEND [ram2] (APPEND (betwn f ram2 ram1) [ram1]) in
          APPEND (REVERSE newVs) f1,APPEND f2 newVs)`;;

let splitFace_list = new_definition
  `!newVs oldF ram1 ram2 (fs:((A) list)list).
      splitFace_list fs ram1 ram2 oldF newVs =
         (let f1,f2 = split_list_face_n oldF ram1 ram2 newVs in
            f1,f2,(APPEND (replace oldF [f2] fs) [f1]))`;;

let split_normal_list = new_definition `!L r f (ram1:A#A) (ram2:A#A). 
  split_normal_list L r f ram1 ram2 = 
    (let ram1' = next_el r ram1 in
     let ram2' = next_el r ram2 in
     let sz = (\x. sizel (filter (\t. t = x) (flatten L))) in
     let nd = (\x. map (\i. (n_list L POWER i) x) (upt 1 (sz (FST x)))) in
     let new2 = betwn f ram1 ram2' in
     let new1 = flatten (map nd new2) in
     let f1 = APPEND [ram1'] (APPEND (betwn r ram1' ram2) [ram2]) in
     let f2 = APPEND [ram2'] (APPEND (betwn r ram2' ram1) [ram1]) in
       (APPEND (REVERSE new1) f1,APPEND f2 new2))`;;

(* hyp'm: l'm *) (* was l'm *)

let l_m = new_definition `!L r x. l'm L r x = 
  (let r' = rotate_to r x in
     min_num 
       { m | ~(ITER (SUC(SUC m)) (nextElem r' x) x = 
	     f_list L (ITER (SUC m) (nextElem r' x) x))  })`;;

let l_y = new_definition `!L r x. l'y L r x = 
   ((f_list L) POWER (SUC (l'm L r x))) x`;;

let l_p = new_definition `!L N r x. l'p L N r x = 
  min_num 
  { p | MEM ((f_list L POWER (SUC p)) (l'y L r x)) (flatten N) }`;;

let l_z = new_definition `!L N r x. l'z L N r x =
  (f_list L POWER (SUC (l'p L N r x))) (l'y L r x)`;;

let l_q = new_definition `!L N r (x:A#A). l'q L N r x = 
  (let x' = find_list (parts L r) x in
   let z' = find_list (parts L r) (l'z L N r x) in
  min_num { q | l'm L r x < q /\ 
		(next_el (parts L r) POWER (SUC q)) x' = z' })`;;

let transform_list = new_definition `!L N r (x:A#A).
  transform_list L x (N, r)  = 
  (
   let y = l'y L r x in
   let z = l'z L N r x in
   let ram2 = prev_el r z in
   let f = find_face L y in
   let split = split_normal_list L r f y ram2 in
   let N' = APPEND (replace r [SND split] N) [FST split] in
     if (final_list L r) then (N,r) else (N', SND split))`;;

let transform_count = new_definition
  `!L N r (x:A#A). transform_count L N r x = 
      min_num {k | 
	final_list L (SND ((transform_list L x POWER k) (N,r))) }`;;

(* hyp'S: *)

let s_list = new_definition `!L r x. s_list L r x =
  (let r' = rotate_to r x in
     betwn r x (ITER (SUC (l'm L r x)) (nextElem r' x) x))`;;

let s_flag_list = new_definition `!L N r x.
     s_flag_list L N r x <=>
     (!u v.
          MEM u (final_dart_list L N) /\ MEM v (final_dart_list L N)
          ==> (?s. contour_list L s /\
                   HD s = u /\
                   LAST s = v /\
                   set_of_list s SUBSET set_of_list (final_dart_list L N))) /\
     (!r' p y.
          y = HD p /\
          MEM p (parts L r') /\
          MEM r' N /\
          ~final_list L r' /\
          ~MEM y (s_list L r x)
          ==> MEM (e_list y) (cat (s_list L r x) (final_dart_list L N)))`;;

(* was empty_flag_list *)

let flag_list = new_definition `!L N.
     flag_list L N <=>
     (!u v.
          MEM u (final_dart_list L N) /\ MEM v (final_dart_list L N)
          ==> (?s. contour_list L s /\
                   HD s = u /\
                   LAST s = v /\
                   set_of_list s SUBSET set_of_list (final_dart_list L N))) /\
     (!r' p y.
          y = HD p /\
          MEM p (parts L r') /\
          MEM r' N /\
          ~final_list L r' 
          ==> MEM (e_list y) (final_dart_list L N))`;;


(* was respect_final_exact.  The set of finals in g can
   lag behind the set of finals in L//N. *)

let match_core_list = new_definition
 `match_core_list g L N <=>
   (
    set_of_list (MAP (list_pairs o FST) 
       (filter SND (faces g)))
     SUBSET (set_of_list (filter (final_list L) N)) /\
   (fgraph g = core_list (map (parts L) N )))`;;

(* Compare with the definition of marked_list.
   premarked_list gives conditions that will lead to a marked_list, 
   when supplied with a loop_choice r and x *)

let premarked_list = new_definition
  `!g L N. premarked_list g L N <=> 
     (normal_list L N /\
     match_core_list g L N /\ 
     flag_list L N /\
     all uniq (fgraph g) /\  // 1. simple
     all (\v. sizel (filter (MEM v) (fgraph g)) > 1) (flatten (fgraph g))) 
        // 2. n' nondeg.
     `;;

let marked_list = new_definition `!L N r (x:A#A).
  marked_list L N r x <=>
    is_restricted (hypermap_of_list L) /\
    normal_list L N /\
    MEM r N /\
    MEM x r /\
    (let qs = quotient_list L N in
       all uniq qs /\ // 1. simple
       all (\v. sizel (filter (MEM v) qs) > 1) (flatten qs)) /\ // 2. n' nondeg.
    next_el r x = f_list L x /\  // 3.
    (let r' = find_list N (e_list x) in final_list L r') /\ // 4.
    (final_list L r ==> flag_list L N) /\
    (~final_list L r ==> s_flag_list L N r x) // 5. flag
     `;;

let loop_choice = new_definition 
 `!g L N. loop_choice g (L:((num)list)list) N =
  (let f = minimalFace (nonFinals g) in
   let v = minimalVertex g f in
   let w = nextVertex f v in
   let d = (v,w) in
   let r = find_list N d in
   let p = parts L r in
     (r,LAST (find_list p d)))`;;

let transform_data = new_definition
  `!g L N. transform_data g L N = 
    (
      let (r,x) = loop_choice g L N in
      let k = transform_count L N r x in
      let f = rotate_to (find_face L x) x in
      let a = filter (\x. MEM x r /\ ~(next_el f x = next_el r x)) f in
      let b = filter (\x. MEM x r /\ ~(prev_el f x = prev_el r x)) f in
	(zip a b))`;;

let ordered_list_v2 = new_definition
  `!vset extra. ordered_list_v2 vset extra <=>
      (let n = CARD vset in
	 vset = (0.. (n-1)) /\ extra = upt n (n+sizel extra))`;;

let dih2k_list =
  new_definition `dih2k_list L <=> (?(u:A list). uniq u /\
				      L = [u;rev u])`;;

(*  enumeration lists.
    mk_triple inverse of dest_triple
    enum_of_VertexList inverse of indexToVertexList.

   enum (Isabelle side) -> VertexList -> triples (hypermap list side)

 *)

(* was mk_triples0, mk_triples *)

let mk_triple0 = new_recursive_definition list_RECURSION
    `mk_triple0 f u n sofar [] = rev sofar /\
     mk_triple0 f u n sofar (vo::vos) = 
      if (vo = NONE) then mk_triple0 f u (SUC n) sofar vos else
	(let (v:A) = the vo in 
	   if (next_el f u = v /\ n = 0) 
	   then 
	     mk_triple0 f v 0 sofar vos
	   else 
	     mk_triple0 f v 0 ((u,v,n)::sofar) vos)`;;

let mk_triple = new_definition
 `mk_triple f (vs:((A)option)list) = mk_triple0 f (the (HD vs)) 0 [] (TL vs)`;;

(* was dest_triples0, dest_triple *)

let dest_triple0 = new_recursive_definition list_RECURSION
   `dest_triple0 f sofar [] = sofar /\
    dest_triple0 f sofar (uvn::uvns) =
      (let ((u:A),v,n) = uvn in
       let ns = nseq n NONE in
       let u0 = the (LAST sofar) in
       let b = MAP SOME (betwn f u0 u) in
	 if (sofar = []) 
	 then dest_triple0 f (flatten[sofar;[SOME u];ns;[SOME v]]) uvns
	 else
	   (if (u0 = u) then dest_triple0 f (flatten[sofar;ns;[SOME v]]) uvns
	    else (if (next_el f u0 = u) 
		  then dest_triple0 f (flatten[sofar;[SOME u];ns;[SOME v]]) uvns
		  else (dest_triple0 f (flatten[sofar;b;[SOME u];ns;[SOME v]]) uvns)
		 )))`;;

let dest_triple = new_definition
  `dest_triple f uvns = dest_triple0 f [] uvns`;;

(* next 3 defs are from Isabelle *)

let hideDupsRec = new_recursive_definition list_RECURSION 
  `hideDupsRec (a:A) [] = []  /\
    hideDupsRec a (b :: bs) = 
      if (a = b) then NONE :: (hideDupsRec b bs) 
      else  (SOME b) :: (hideDupsRec b bs)`;;

let hideDups = new_recursive_definition list_RECURSION
  `hideDups ([]:A list) = [] /\
    hideDups ((b:A) :: bs) = (SOME b) :: (hideDupsRec b bs)`;;

let indexToVertexList = new_definition' `indexToVertexList f v is = 
  hideDups (MAP (\k. nextVertices f k v) is)`;;

let showDups0 = new_recursive_definition list_RECURSION
  `showDups0 (a:A) [] = [] /\
   showDups0 a (b::bs) = 
    if (b = NONE) then (a:: (showDups0 a bs))
    else ((the b) :: (showDups0 (the b) bs))`;;

let showDups = new_recursive_definition list_RECURSION
  `showDups ([]:((A)option)list) = [] /\
   showDups (b::bs) = showDups0 (the b) (b::bs)`;;

let enum_of_VertexList = new_definition'' 
  `enum_of_VertexList f (v:A) vs = 
    MAP (\u. indexf v u f  ) (showDups vs)`;;


(* ========================================================================== *)
(* Matching Isabelle-planar with hypermap-planar *)
(* ========================================================================== *)

let import_tame_classification = 
  Import_tame_classification.import_tame_classification;;

(* This is the main result.  
It needs to be built up inductively step by step.   *)

let LSKOKJE_concl = `!H. is_restricted H ==>
  (?g. PlaneGraphs g /\ good_graph g /\
     iso H (hypermap_of_list (fgraph g)))`;;



(* ========================================================================== *)
(* good_list in Isabelle development. *)
(* ========================================================================== *)

(*

We don't need to prove these directly.  Properties of g can be deduced
when we match it with the core_list of (L,N) coming from the restricted
hypermap:

let tame_good_concl = `!g. PlaneGraphs g /\ tame g ==> good_list (fgraph g)`;;

let JUJUWAT_concl = `!g. planegraph_relaxed g ==> good_list (fgraph g)`;;

let ETDLJXT2_concl = `!g. planegraph_relaxed g ==> good_list_nodes (fgraph g)`;;

let CGGZYRC_concl = `!g f d. planegraph g /\ MEM f (faces g) /\ 
  MEM d (list_pairs (FST f))  /\ ~final f ==> 
  (?f'. MEM f' (faces g) /\ 
  MEM (SND d,FST d) (list_pairs (FST f')) /\ final f')`;;

*)


let DPZGBYF_concl = 
  "formalized DPZGBYU",
  (`!g. planegraph g ==> planegraph_relaxed g`);;

let ETDLJXT1_concl = `!g. planegraph_relaxed g ==> 
  (vertices_set2 g = elements_of_list (fgraph g))`;;

let HWDMZDM_concl = `!g v. planegraph_relaxed g /\ v IN vertices_set2 g ==>
  facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)`;;

let SNVACWG_concl = `!L N. good_list L /\ 
  good_list_nodes L /\ is_restricted (hypermap_of_list L) /\
  normal_list L N ==>
  good_list (quotient_list L N)`;;

let PMBRINH_concl = `!L N. good_list_nodes L /\ normal_list L N ==>
  good_list_nodes (quotient_list L N)`;;

let LYNVPSU_concl = `!L N r x. marked_list L N r x ==>
    all uniq (quotient_list L N)`;;

(* ========================================================================== *)
(* Isomorphism *)
(* ========================================================================== *)


let iso_list_isop_list = `!L N L' N'. iso_list (L,N) (L',N') <=> 
  (?phi. isop_list phi (L,N) (L',N'))`;;

(* compare Elllnyz.hypermap_of_list_map *)



let GNBEVVU_concl = `!L N L' N'. 
    good_list L /\ iso_list (L,N) (L',N') ==> 
    iso (hypermap_of_list L) (hypermap_of_list L')`;;

let iso_list_refl = `!a. iso_list a a`;;

let iso_list_sym = `!a b. iso_list a b ==> iso_list b a`;;

let iso_list_trans = 
 `!a b c. iso_list a b /\ iso_list b c ==> iso_list a b`;;

let isop_append = `!L N L' N' phi.
   (isop_list phi (L,APPEND N1 N2) (L',APPEND N1' N2') /\ 
      sizel N1 = sizel N1' ) <=>
   (isop_list phi (L,N1) (L',N1') /\ isop_list phi (L,N2) (L',N2'))`;;

let isop_cons = `!L N L' N' r r' phi.
    (isop_list phi (L,(r::N)) (L',(r'::N'))) <=>
    (isop_list phi (L,N) (L',N') /\ r' = 
	MAP (\u. (phi (FST u),phi(SND u))) r)`;;

let PEUTLZH_concl = `!L N L' N'.
  good_list L /\ iso_list (L,N) (L',N') ==>
  good_list L'`;;

let OISRWOF_concl = `!L N L' N'.
  good_list_nodes L /\ iso_list (L,N) (L',N') ==>
  good_list_nodes L'`;;

let UEYETNI_concl = `!L N L' N'.
  all uniq L /\ iso_list (L,N) (L',N') ==>
  all uniq L'`;;

let XKDZKWV_concl = `!L N L' N'.
  good_list L /\ iso_list (L,N) (L',N') /\ normal_list L N ==>
  normal_list L' N'`;;

let MEEIXJO_concl = `!L N L' N' r r' x x'.
  good_list L /\ 
  iso_list (L,([x]:: r :: N)) (L',([x']::r' :: N')) /\
  marked_list L N r x ==> marked_list L' N' r' x'`;;

(* tautology 
let concl = `!L N.
  good_list L /\ all uniq L /\ normal_list L N ==>
  iso_list ((quotient_list L N),[])
     ((core_list(map (parts L) N)),[])`;;
*)

(* ========================================================================== *)
(* Reduction of restricted hypermap to special hypermap_of_list form. *)
(* ========================================================================== *)

(* reductions to hypermap_of_list L, then num, then ordered_list form *)

let DAKEFCC_concl = 
  `!H K. is_restricted H /\ iso H K ==> is_restricted K`;;

				
let RXOKSKC_concl = 
  `!H. is_restricted H ==> 
    (?L. good_list L /\ good_list_nodes L /\ all uniq L /\
       iso H (hypermap_of_list L))`;;

let JXBJOAB_concl = 
  `!(L:((A)list)list). 
   ?(L':((num)list))list. iso_list (L,[]) (L',[])`;;

let SHXWKXQ_concl = 
  `!L:((num)list)list N x. 
     (
       let f = find_face L x in
       let r = find_list N x in
	 MEM x (flatten N) /\
	 uniq (MAP FST f) /\ 
	   set_of_list (flatten N) SUBSET (set_of_list (list_of_darts L)) ==>
	 (?L' N' x'.
	   iso_list (L,([x]::N)) (L',([x']::N')) /\
	   (let f' = find_face L' x' in
	    let r' = find_list N' x' in
	    let extra' = MAP FST (filter (\d. ~MEM d r') (rotate_to f' x')) in
	      ordered_list_v2 (set_of_list(MAP FST (flatten N'))) extra')))`;;

(* main reduction to lists *)

let JCAJYDU_concl = `(!L. 
  good_list L /\ good_list_nodes L /\ all uniq L /\
  is_restricted (hypermap_of_list L) ==>
  (?g. PlaneGraphs g /\ 
     good_graph g /\
     iso (hypermap_of_list L) (hypermap_of_list (fgraph g))))
   ==> 
   (!H. is_restricted H ==>
  (?g. PlaneGraphs g /\ good_graph g /\
     iso H (hypermap_of_list (fgraph g))))`;;


(* ========================================================================== *)
(* Translate hypermap notions into list notions *)
(* AQIUNPP in Hypermaps chapter *)
(* ========================================================================== *)

let GZLJIGN1_concl = `!L N r x.
      hyp'm (hypermap_of_list L) N (loop_of_list_v2 r) x = 
	l'm L r x`;;

let GZLJIGN2_concl = `!L N r x.
  hyp'p (hypermap_of_list L) (loop_family_of_list N) (loop_of_list_v2 r) x = 
	l'p L N r x`;;

let GZLJIGN3_concl = `!L N r x.
  hyp'q (hypermap_of_list L) (loop_family_of_list N) (loop_of_list_v2 r) x = 
  l'q L N r x`;;

let GZLJIGN4_concl = `!L N r x.
  hyp'y (hypermap_of_list L) N (loop_of_list_v2 r) x = 
  l'y L r x`;;

let GZLJIGN5_concl = `!L N r x.
  hyp'z (hypermap_of_list L) (loop_family_of_list N) (loop_of_list_v2 r) x = 
  l'z L N r x`;;

let EVNAPDQ_concl = `!L N.
  good_list L /\ normal_list L N ==>
  normal_family (hypermap_of_list L) (loop_family_of_list N)`;;

let ABKCJWD_concl = `!L N.
  good_list L /\ normal_list L N ==>
  iso (quotient (hypermap_of_list L) (loop_family_of_list N))
  (hypermap_of_list (quotient_list L N))`;;

let ODWAFRG_concl = `!L N r x.
  good_list L /\ marked_list L N r x ==>
  is_marked 
  ((hypermap_of_list L),(loop_family_of_list N),(loop_of_list_v2 r),x)`;;



(* Translate known lemmas. *)

let HQYMRTX = Hypermap.lemmaHQYMRTX;;

let HQYMRTX1_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> MEM (l'z L N r x) r /\
    (!i. 1 <= i /\ i <= SUC (l'm L r x) ==>
       ~(l'z L N r x = (f_list L POWER i) x))`;;

let HQYMRTX2_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'y L r x)`;;

let HQYMRTX3_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'z L N r x)`;;

let QRDYXYJ = Hypermap.lemmaParameters;;

let QRDYXYJ_list = `!L N r x.
  marked_list L N r x /\ ~(final_list L r) ==>
  l'm L r x < l'q L N r x /\
  l'q L N r x < sizel (parts L r) /\
  SUC (l'm L r x) < l'p L N r x + l'q L N r x /\
  ~(FST (l'y L r x) = FST x) /\
  ~(FST (l'y L r x) = FST (l'z L N r x))`;;

let AQIUNPP1 = Hypermap.lemma_normal_family_transform;;

let AQIUNPP1_list = `!L N r (x:A#A).
  marked_list L N r x /\ ~(final_list L r) ==> 
       normal_list L (FST (transform_list L x (N,r)))`;;

let AQIUNPP2_concl = 
  `!L N r (x:A#A).
    marked_list L N r x ==>
    (let (N',r') = transform_list L x (N,r) in marked_list L N r x)`;;



(* ========================================================================== *)
(* Initialization. dih2k *)
(* ========================================================================== *)


let FOEGZEQ1_concl = 
  ("good-list-seed",
  `!p. good_list (fgraph (Seed p))`);;

let FOEGZEQ2_concl = 
  ("all-uniq-seed",
  `!p. good_list (fgraph (Seed p))`);;

let TAGYMW_concl = 
  `!p. good_list_nodes (fgraph (Seed p))`;;

let ENWCUED_concl = 
  `!p.  dih2k_list ( (fgraph (Seed p)))`;;

let DLWOJBB_concl = 
  `!L. dih2k_list L ==> 
    dih2k (hypermap_of_list L) (sizel (HD L))`;;

let KUKASGD_concl = 
  `!L. dih2k_list L /\ dih2k_list L' /\
     sizel (HD L) = sizel (HD L') ==> iso_list (L,[]) (L',[])`;;

let UNHQYQM_concl = 
  `!L L'. iso_list (L,[]) (L',[]) /\ dih2k_list L)
    ==> dih2k_list L'`;;

let AUQTZYZ_concl = `!H (x:A) L1. is_restricted H /\ (x IN dart H)  /\ 
  (L1 = loop_of_face H x) ==>
  (?L2. is_normal H {L1,L2}  /\ 
    (path_of_loop L2 x = complement H x) /\ 
     dih2k (quotient H {L1,L2}) (CARD (face H x)))`;;

let AUQTZYZ_list = `!L f. is_restricted (hypermap_of_list L) /\
  good_list L /\ MEM f (list_of_faces L) ==>
   (?f'. normal_list L [f;f'] /\ quotient_list L [f;f'] = 
      [f; rev f])`;;

let UYOUIXG_concl = `!L f .  is_restricted (hypermap_of_list L) /\
   good_list L /\ MEM f (list_of_faces L) /\ ~dih2k_list L ==>
     (?L' N' f2. iso_list (L,[f;f2]) (L',N') /\
	normal_list L' N' /\ 
	 match_core_list (Seed (sizel f -3)) L' N')`;;
     
(* ========================================================================== *)
(* Termination. *)
(* ========================================================================== *)

(*			
let ADACDYF_concl = `!H NF L MF M (x:A).  is_marked(H,NF,L,x) /\
   ~(L IN final_loops H NF) /\
   (MF,M) = transform H x (NF,L) ==>
  CARD (dart (quotient H NF)) < CARD (dart (quotient H MF))`;;
*)

let ADACDYF_concl = `!L N r N' r' (x:A#A). marked_list L N r x /\
    ~final_list L r /\ (N',r') = transform_list L x (N,r) ==>
  sizel (list_of_darts (quotient_list L N)) <
  sizel (list_of_darts (quotient_list L N'))`;;

let ZBHENEI_hypermap = Hypermap.lemma_finite_normal_loops;;

let XWCNBMA_hypermap = Hypermap.face_quotient_lemma;;

let ZBHENEI_concl = `!L N. normal_list L N ==>
  sizel (list_of_darts (quotient_list L N)) 
  <= sizel (list_of_darts L)`;;

(* This and monotonicity will give termination *)

let XZAJELF_concl** = `!g L N. 
     match_core_list g L N ==>
     sizel (flatten (finals g)) <=
     sizel (list_of_darts L)`;;

let XWCNBMA_concl = `!L N. normal_list L N /\
  is_restricted (hypermap_of_list L) /\ 
  all (final_list L) N ==> L = quotient_list L N`;;

(* ========================================================================== *)
(* nonFinals and finals of g. *)
(* ========================================================================== *)

let concl = `subdivFaceFinal = subdivFace`;;

(* This shows that the set of finals of g never out-paces L//N.
   Only one more final face is created by subdivFaceFinal.  *)

let subdivFace0_finals = `!g f u n vs.
  ~(MEM f (finals g)) ==> 
  (finals g = finals (subdivFace0_alt g f u n vs))`;;

(* ========================================================================== *)
(* Enumeration Lists *)
(* ========================================================================== *)

(* this justifies the duplicate edge filter *)

let concl = 
  `!g f v enum. containsDuplicateEdge g f v enum ==>
    (let vs = indexToVertexList f v enum in
     let triple = mk_triple (FST f) vs in
       (?u v. MEM (u,v,0) triple /\ MEM (u,v) (list_of_darts (fgraph g))))`;;

let concl = 
  `showDups (HideDups A) = A`;;

let concl = 
  `HideDups (showDups A) = A`;;

let concl = 
  `!f vs. hypotheses ==> dest_triple f (mk_triple f vs) = vs`;;

let concl = 
  `!f vs. hypotheses ==> mk_triple f (dest_triple f vs) = vs`;;

let concl = 
  `!f e. hypotheses ==> 
    Enum_of_VertexList (FST f) (indexToVertexList f e) = e`;;

let concl = 
  `!f vs. hypotheses ==>
    indexToVertexList f (Enum_of_VertexList (FST f) vs) = vs`;;

(* ========================================================================== *)
(* The Index Calculus of Higher Transforms. *)
(* ========================================================================== *)

let concl = `!s x. indexf x x s = indexl x s`;;

let concl = `!s x y k. indexf x y s = indexf x y (rot k s)`;;

let concl = `!s x y. uniq s /\ MEM x s /\ MEM y s ==> 
  (next_el s POWER (indexf x y s)) x = y`;;

(* Do a massive simultaneous induction to prove the various statements
   together. *)

let RYIUUVK_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'z L (N' i) (r' i) x) r <
      indexf x (l'y L (r' (SUC i)) x) r)`;; 

let CESHTIN1_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'z L (N' i) (r' i) x) r)`;;

let CESHTIN2_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'y L (r' i) x) r)`;;

let CESHTIN3_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' (SUC i)) ==>
      indexf x (l'z L (N' i) (r' i) x) (find_face L x) <=
      indexf x (l'y L (r' (SUC i)) x) (find_face L x))`;;

let CESHTIN4_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'y L (r' i) x) (find_face L x) <
      indexf x (l'z L (N' i) (r' i) x) (find_face L x))`;;

let CESHTIN5_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let y = l'y L (r' i) x in
     let z' = l'z L (N' i) (r' i) x in
     let y' = f_list L (e_list y) in 
     let z = n_list L z' in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r y' z = betwn ri y' z)))`;;


let CESHTIN6_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let z = l'z L (N' i) (r' i) x in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r z x = betwn ri z x)))`;;

let XBXFJPH_concl = `!L N r (x:A#A).
   marked_list L N r x ==>
   (let f = find_face L x in
   (set_of_list (filter (\d. MEM d f) (flatten N))) SUBSET
   (set_of_list r))`;;



(* ========================================================================== *)
(* Connect L with g *)
(* ========================================================================== *)



(* primary reduction.  

   Termination guaranteed by the
   strictly increasing quantity sizel(flatten(finals g)).

 *)

let concl = `!L.  
  is_restricted (hypermap_of_list L) /\
  good_list L /\
  good_list_nodes L /\
  all uniq L /\
  (!N g. premarked_list g L N /\ planegraph g /\ (~(nonFinals g = [])) 
   ==>
     (?L' N' g'. iso_list (L,[]) (L',[]) /\
	premarked_list g' L' N' /\ planegraph g' /\
	sizel (flatten (finals g')) > sizel (flatten (finals g))))
  ==>
   (?g. PlaneGraphs g /\ 
     iso (hypermap_of_list L) (hypermap_of_list (fgraph g)))`;;


let HKBGWJI_concl = 
  `!L N r x g.
    is_restricted (hypermap_of_list L) /\
    ~(nonFinals g = []) /\
    match_core_list g L N /\
    (r,x) = loop_choice g L N ==>
  marked_list L N r x`;;


let concl = `!g L N i. hypotheses ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let f = find_face L x in
      (!i. i <= k ==>
	 (transform_list L x POWER i) (N,r) = FST (ITER i
	   (\ Nrz. 
	      (let (N,r) = FST Nrz in
	       let zs = SND Nrz in
               let (y,z) = HD zs in
	       let ram2 = prev_el r z in
	       let split = split_normal_list L r f y ram2 in
	       let N' = APPEND (replace r [SND split] N) [FST split] in
		 if (final_list L r) 
		 then ((N,r),[]) else ((N', SND split),TL zs))) 
	      ((N,r),transform_data g L N))))`;;

let concl = `!g L N i. hypotheses ==>
  (let (r,x) = loop_choice g L N in
   let k = transform_count L N r x in
   let f = find_face L x in
   let vf = MAP FST f in
     (!i. i <= k ==>
	(let (Ni,ri) = (transform_list L x POWER i) (N,r) in
         let dat = (map (\u. (FST (FST u),FST (SND u))) 
		     (transform_data g L N)) in
	   core_list (map (parts L) Ni) = SND (FST (ITER i
	     (\ ffszs.
		(let oldF,fs = FST ffszs in
		 let zs = SND ffszs in
		 let ram1,ram2 = HD zs in
		 let newVs = betwn vf ram1 ram2 in
		 let f1,f2,fs' = splitFace_list fs ram1 ram2 oldF newVs in
		   ((f2,fs'),(TL zs))))
	     ((FST (minimalFace (nonFinals g)),fgraph g),dat)
					      )))))`;;

(* XX TO DO.

Next theorem: relate the core of (transform_list L x POWER k) (N,r)
   to the isabelle development.

*)




(* ========================================================================== *)
(* Matching Isabelle-tame with hypermap-tame *)
(* ========================================================================== *)

(* done by Solovyev, Jan 10, 2014 *)
let XRFJNDO_concl = `!y. y IN archive ==> good_list y`;;

(* done by tch *)
let ELLLNYZ_concl = `!x y. good_list x /\ good_list y /\ iso_fgraph x y ==>
  (iso (hypermap_of_list (x)) (hypermap_of_list (y)) \/
     iso (opposite_hypermap (hypermap_of_list (x))) (hypermap_of_list (y)))`;;

(* done by tch, Jan 11, 2014 *)
let ASFUTBF_concl = `!H:(A)hypermap .
   (?V'. contravening V' /\
      iso (opposite_hypermap (hypermap_of_fan (V',ESTD V'))) H)
   ==> (?V. contravening V /\ iso (hypermap_of_fan (V,ESTD V)) H)`;;

(* ========================================================================== *)
(* Matching Isabelle-tame with hypermap-tame *)
(* ========================================================================== *)

(* WMLNYMD, done tch. *)

let tame9a_correspondence_weak = 
  `!g. tame_hypermap (hypermap_of_list (fgraph g)) /\ PlaneGraphs g 
   ==>
  tame9a g`;;

let tame9a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame9a g`;;

let tame10_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame10 g`;;

let tame11a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame11a g`;;

let tame11b_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame11b g`;;

let tame12o_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame12o g`;;

let tame13a_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame13a g`;;

let tame_correspondence = `!H g. tame_hypermap H /\ PlaneGraphs g /\
  iso H (hypermap_of_list (fgraph g)) ==>
  tame g`;;


(* ========================================================================== *)
(* Final conclusions *)
(* ========================================================================== *)

(* easy corollary of tame_good, archive_good, good_iso, TAME_CORRESPONDENCE_MAIN *)

let TAME_CORRESPONDENCE_2_concl = 
 `!H. tame_hypermap H /\ import_tame_classification ==>
  (?x. x IN archive /\ (iso H (hypermap_of_list x) \/  
  iso (opposite_hypermap H)  (hypermap_of_list x)))`;;

end;;
