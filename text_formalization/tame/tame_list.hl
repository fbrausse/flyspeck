(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: February 9, 2014                                                 *)
(* ========================================================================== *)

(* general list processing results and small common lemmas. *)


module Tame_list  = struct

  open Hales_tactic;;
  open Hypermap;;
  open Tame_defs;;
  open Tame_defs2;;

let POWER_TO_ITER = Wrgcvdr_cizmrrh.POWER_TO_ITER;;

let EQ_EXPAND = Geomdetail.EQ_EXPAND;;

let nth_EL = prove_by_refinement(
  `!x xs n k.
    ((n = 0) ==> (\l n. EL n l) (x::xs) n = x) /\ 
     ((n = SUC k) ==> (\l n. EL n l) (x::xs) n = (\l n. EL n l) xs k)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL]
  ]);;
  (* }}} *)

let the_some = prove_by_refinement(
  `!(x:A). the (SOME x) = x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[the];
  GEN_TAC;
  SELECT_TAC;
    INTRO_TAC option_RECURSION [`x`;`I:A->A`];
    REWRITE_TAC[I_THM];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let filter_rec = prove_by_refinement(
  `filter (f:A->bool) [] = [] /\
    filter f (x:: xs) = if (f x) then (x :: (filter f xs)) else (filter f xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.filter])
  ]);;
  (* }}} *)

let filter_FILTER = prove_by_refinement(
  `filter = FILTER`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  GEN_TAC;
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.filter;FILTER])
  ]);;
  (* }}} *)

let APPEND_cat = prove_by_refinement(
  `APPEND = cat`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[APPEND; Seq.cat0s]);
  BY(ASM_REWRITE_TAC[APPEND;Seq.cat_cons])
  ]);;
  (* }}} *)

let faces_graph = prove_by_refinement(
  `faces (Graph fs n f h) = fs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[faces;GRAPH]
  ]);;
  (* }}} *)

let fgraph_graph = prove_by_refinement(
  `!f n a b. fgraph (Graph f n a b) = MAP FST f`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GRAPH;fgraph;faces;vertices])
  ]);;
  (* }}} *)

let final_SND = prove_by_refinement(
  `SND (Face vs f) = if (f = T) then T else F`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FACE];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let type_face_SND = prove_by_refinement(
  `SND (Face vs f) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FACE])
  ]);;
  (* }}} *)

let vertices_face_FST = prove_by_refinement(
  `FST (Face (vs:num list) (f:bool)) = (vs:num list)`,
  (* {{{ proof *)
  [
  (REWRITE_TAC[FACE])
  ]);;
  (* }}} *)

let setFinal_ALT = prove_by_refinement(
  `setFinal f = Face(FST f) T`,
  (* {{{ proof *)
  [
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[setFinal;vertices_set;FACE])
  ]);;
  (* }}} *)

let countVertices = prove_by_refinement(
  `countVertices (Graph fs n f h) = n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[GRAPH;countVertices_def;FST;SND]);
  ]);;
  (* }}} *)

let vertices_graph_alt = prove_by_refinement(
  `vertices_graph (Graph fs n f h) = upt 0 n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[vertices_graph;GRAPH;countVertices_def])
  ]);;
  (* }}} *)

let FACE_LIST_AT = prove_by_refinement(
  `faceListAt (Graph fs n f h) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[faceListAt;GRAPH])
  ]);;
  (* }}} *)

let graph_ALT = prove_by_refinement(
  `graphl n = 
     (let vs = upt 0  n in
      let fs =  [Face vs T;Face (REVERSE vs) F] in
	(Graph fs  n (REPLICATE n fs) (REPLICATE n 0)))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FACE;graphl])
  ]);;
  (* }}} *)

let MEMf_MAP = prove_by_refinement(
  `!f:A->B x u. MEM x u ==> MEM (f x) (MAP f u)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_HD = prove_by_refinement(
  `!xs:(A)list. ~(xs = []) ==> MEM (HD xs) xs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM EL];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC MEM_EL;
  BY(ASM_REWRITE_TAC[arith `0 < m <=> ~(m=0)`;LENGTH_EQ_NIL])
  ]);;
  (* }}} *)

let MEM_EQ_NIL = prove_by_refinement(
  `!s. s = [] <=> (!x. ~MEM x s)`,
  (* {{{ proof *)
  [
  BY(MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let fgraph_Faces = prove_by_refinement(
  `!g f. f IN Faces g ==> MEM (FST f) (fgraph g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;FACES];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let FST_setFinal = prove_by_refinement(
  `!vs f. MAP FST (replace f [setFinal f] vs) = MAP FST vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[replace]);
  REWRITE_TAC[replace];
  GEN_TAC;
  REWRITE_TAC[APPEND_SING];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MAP];
    BY(REWRITE_TAC[setFinal_ALT;vertices_face_FST]);
  BY(ASM_REWRITE_TAC[MAP])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!g f. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;fgraph;GRAPH;faces;makeFaceFinalFaceList;setFinal];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

let concat_flatten = prove_by_refinement(
  `!x xs. flatten ([]:(A list)list) = [] /\
    flatten ( (x:A list) :: xs) = APPEND x (flatten xs)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Seq.flatten0;Seq.flatten_cons;APPEND_cat])
  ]);;
  (* }}} *)

let min_num_single = prove_by_refinement(
  `!x. min_num {x} = x`,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `x IN {x} ==> min_num {x} IN {x}` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[IN];
    BY(MESON_TAC[Misc_defs_and_lemmas.min_least ]);
  BY(REWRITE_TAC[IN_SING])
  ]);;
  (* }}} *)

let min_num_in = prove_by_refinement(
  `!X. ~(X = {}) ==> min_num X IN X`,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_le = prove_by_refinement(
  `!X c. c IN X ==> min_num X <= c`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_unique = prove_by_refinement(
  `!X c. c IN X /\ (!c'. c' IN X ==> c <= c') ==> min_num X = c`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `x <= (c:num) /\ c <= x ==> x = c`);
  CONJ_TAC;
    MATCH_MP_TAC min_num_le;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  MATCH_MP_TAC min_num_in;
  BY(FIRST_X_ASSUM MP_TAC THEN SET_TAC[])
  ]);;
  (* }}} *)

let min_num_insert = prove_by_refinement(
  `!x X. ~(X = {}) ==> min_num (x INSERT X) = MIN x (min_num X)`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  TYPIFY `x IN x INSERT X` (C SUBGOAL_THEN ASSUME_TAC);
    BY(SET_TAC[]);
  DISCH_TAC;
  MATCH_MP_TAC min_num_unique;
  CONJ_TAC;
    REWRITE_TAC[MIN];
    COND_CASES_TAC;
      BY(SET_TAC[]);
    TYPIFY `min_num X IN X` ENOUGH_TO_SHOW_TAC;
      BY(SET_TAC[]);
    MATCH_MP_TAC min_num_in;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[IN_INSERT];
  REPEAT STRIP_TAC;
    ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC (arith `m <= min_num X /\ min_num X <= c' ==> m <= c'`);
  CONJ_TAC;
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC min_num_le;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let minn_MIN = prove_by_refinement(
  `minn = MIN`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[MIN;Ssrnat.minn];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let min_list_cons = prove_by_refinement(
  `!x xs. min_list (x :: xs) = if (xs = []) then x else MIN x (min_list xs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[min_list;set_of_list];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[set_of_list;min_num_single]);
  MATCH_MP_TAC min_num_insert;
  BY(ASM_REWRITE_TAC[SET_OF_LIST_EQ_EMPTY])
  ]);;
  (* }}} *)

let ITER_o = prove_by_refinement(
  `(!f n. ITER 0 f = I /\ ITER (SUC n) f = f o ITER n f )`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;ITER;I_THM;o_THM])
  ]);;
  (* }}} *)

let rotate_rotate1 = prove_by_refinement(
  `rotate 1 = rotate1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[rotate];
  BY(REWRITE_TAC[rotate;ITER_1])
  ]);;
  (* }}} *)

let rotate1_rot1 = prove_by_refinement(
  `rotate1 = rot 1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate1;Seq2.rot_nil]);
  REWRITE_TAC[rotate1;Seq.rot1_cons];
  BY(REWRITE_TAC[rotate1;Seq.rot1_cons;GSYM Seq.cats1;APPEND_cat])
  ]);;
  (* }}} *)

let rotate_rot = prove_by_refinement(
  `!n x. n <= LENGTH x ==> rotate n x = rot n x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(REWRITE_TAC[Seq.rot0;rotate;ITER]);
  REWRITE_TAC[arith `SUC n = n + 1`];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.rot_addn;
  REWRITE_TAC[rotate;GSYM ITER_ADD;ITER_1];
  ASM_REWRITE_TAC[GSYM rotate;Seq.size;rotate1_rot1];
  FIRST_X_ASSUM MATCH_MP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size;Seq.size_rot];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rotate_add = prove_by_refinement(
  `!n m x. rotate (n+m) x = rotate n (rotate m x)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER_ADD])
  ]);;
  (* }}} *)

let rotate_nil = prove_by_refinement(
  `!n. rotate n [] = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate;ITER]);
  BY(ASM_REWRITE_TAC[arith `SUC n = n + 1`;rotate_add;rotate_rotate1;rotate1])
  ]);;
  (* }}} *)

let rotate_periodic = prove_by_refinement(
  `!n x. rotate (n + LENGTH x) x = rotate n x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[rotate_add];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  GMATCH_SIMP_TAC rotate_rot;
  REWRITE_TAC[arith `x <= (x:num)`];
  BY(REWRITE_TAC[GSYM Seq.size;Seq.rot_size])
  ]);;
  (* }}} *)

let rotate_mod = prove_by_refinement(
  `!(x:(A)list) n. rotate n x = rotate (n MOD LENGTH x) x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate_nil]);
  INTRO_TAC Oxl_2012.periodic_mod1 [`\n. rotate n (h::t)`];
  REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[LENGTH];
    BY(ARITH_TAC);
  REWRITE_TAC[ Oxl_def.periodic];
  BY(REWRITE_TAC[rotate_periodic])
  ]);;
  (* }}} *)

let INSERT_alt = prove_by_refinement(
  `(INSERT) a B = {x | x = a \/ x IN B}`,
  (* {{{ proof *)
  [
  REWRITE_TAC[INSERT;EXTENSION;IN_ELIM_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let congs_rot = prove_by_refinement(
  `!f1 f2. __cong f1  f2 <=> (?n. n <= LENGTH f1 /\ f2 = rot n f1)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    REWRITE_TAC[cong;rotate_nil;Seq2.rot_nil;LENGTH];
    BY(MESON_TAC[arith `0 <= 0`]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REWRITE_TAC[cong];
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `n` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC rotate_rot;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `n MOD (LENGTH (h::t))` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM rotate_rot);
  REWRITE_TAC[GSYM rotate_mod];
  INTRO_TAC DIVISION [`n`;`LENGTH(h::t)`];
  ANTS_TAC;
    BY(REWRITE_TAC[LENGTH] THEN ARITH_TAC);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let inj_on_ALT = prove_by_refinement(
  `inj_on (f:A->B) A <=> (!x. x IN A ==> (!y. y IN A ==> (f x = f y) ==> (x = y)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;IN];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let INJ_inj_on = prove_by_refinement(
  `!f s. inj_on f s <=> INJ f s (:UNIV)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;INJ;IN_UNIV];
  BY(REWRITE_TAC[IN])
  ]);;
  (* }}} *)

let nextElem_ALT = prove_by_refinement(
  `nextElem [] (b:A) x = b /\
   nextElem (a :: as) b x =     
    (if x=a then ((if (as = []) then (b ) else 
		     (let a_ = HD (as) in (let as_ = TL (as) in a_)))) else nextElem as b x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextElem];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[LET_THM])
  ]);;
  (* }}} *)

let nextVertex_ALT = prove_by_refinement(
  `nextVertex f = (let vs = FST f in nextElem vs (HD vs))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM;nextVertex];
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[nextVertex])
  ]);;
  (* }}} *)

let upt_rec = prove_by_refinement(
  `!i j. upt i 0 = [] /\ upt i (SUC j) = if (i <= j) then (APPEND (upt i j)  [j]) else []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[upt;arith `0-i = 0`;Seq.iota];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_SIMP_TAC [arith `i <= j ==> SUC j - i =  (j - i) + 1`];
    REWRITE_TAC[Seq.iota_add;Seq2.APPEND_cat];
    AP_TERM_TAC;
    ASM_SIMP_TAC[arith `i <= j ==> i + j - (i:num) = j`;arith `1 = SUC 0`];
    BY(REWRITE_TAC[Seq.iota]);
  ASM_SIMP_TAC[arith `~(i<=j) ==> SUC j - i = 0`];
  BY(REWRITE_TAC[Seq.iota])
  ]);;
  (* }}} *)

let RTranCl_ALT = prove_by_refinement(
  `(g,g) IN RTranCl succs /\
    g' IN set_of_list (succs g) /\ (g',g'') IN RTranCl succs ==> (g,g'') IN RTranCl succs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[RTranCl;CURRY_DEF;UNCURRY_DEF;IN;RTC_REFL];
  INTRO_TAC RTC_RULES [`(\x y. MEM y (succs x))`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `g'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

let RTranCl_REFL = prove_by_refinement(
  `!P x. (x,x) IN RTranCl P`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[RTranCl;IN;UNCURRY_DEF;RTC_REFL])
  ]);;
  (* }}} *)

let rotate_0 = prove_by_refinement(
  `!x n. rotate 0 x = x`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER])
  ]);;
  (* }}} *)

let rotate_eq_nil = prove_by_refinement(
  `!n (x:(A) list). rotate n x = [] <=> x = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate_0]);
  ASM_REWRITE_TAC[rotate_add;arith `SUC n = n + 1`];
  REWRITE_TAC[rotate;ITER_1];
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[rotate1;NOT_CONS_NIL;APPEND_EQ_NIL])
  ]);;
  (* }}} *)

let MEM_replace = prove_by_refinement(
  `!x f xs g. MEM x (replace f xs g) ==> (MEM x g \/ (MEM f g /\ (MEM x xs)))`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    REWRITE_TAC[replace];
    BY(MESON_TAC[]);
  REWRITE_TAC[replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MEM];
    REWRITE_TAC[MEM_APPEND];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM2_replace = prove_by_refinement(
  `!x f xs g. MEM f g /\ MEM x xs ==> MEM x (replace f xs g)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM;replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM3_replace = prove_by_refinement(
  `!x f xs g. ~(x = f) /\ MEM x g ==> MEM x (replace f xs g)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM;replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let REVERSE_rev = prove_by_refinement(
  ` REVERSE = rev`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[REVERSE;Seq.rev;Seq.catrev]);
  ASM_REWRITE_TAC[REVERSE;Seq.rev];
  REWRITE_TAC[Seq.catrev];
  REWRITE_TAC[Seq.catrevE];
  BY(REWRITE_TAC[Seq.cats0;Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let upt0 = prove_by_refinement(
  `!i. upt 0 i = iota 0 i`,
  (* {{{ proof *)
  [
  REWRITE_TAC[upt];
  GEN_TAC;
  BY(REWRITE_TAC[arith `i - 0 = i`])
  ]);;
  (* }}} *)

let list_pairs_rev = prove_by_refinement(
  `!a. list_pairs (rev a) = rev (zip a (rotr 1 a))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs;GSYM Seq.rev_rotr];
  GEN_TAC;
  GMATCH_SIMP_TAC (GSYM Seq.rev_zip);
  BY(REWRITE_TAC[Seq.size_rotr])
  ]);;
  (* }}} *)

let nth_iota_nod = prove_by_refinement(
  `!x0 k i. i < k ==> nth x (iota 0 k) i = i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
  GMATCH_SIMP_TAC Seq2.EL_nth;
  TYPIFY `0` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.size_iota];
  GMATCH_SIMP_TAC Seq.nth_iota;
  BY(ASM_REWRITE_TAC[] THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota0 = prove_by_refinement(
  `!i' i j k x y. i' + 1 = k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',0)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ i' = k - 1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zipr_iota0 = prove_by_refinement(
  `!i j k x y. 0 < k  ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) 0 = 0,k-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota = prove_by_refinement(
  `!i' i j k x y. i' + 1 < k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',i'+1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ ~(i' = k-1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nth_zipr_iota = prove_by_refinement(
  `!i' i j k x y. 0 < i' /\ i' < k ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) i' = i',i'-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `~(i' = 0)` (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_iota = prove_by_refinement(
  `!i j k.  (MEM (i,j) (list_pairs (iota 0 k)) <=> ((i+1 < k /\ j = i+1) \/ (i+1=k  /\ j=0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.size_list_pairs [`iota 0 k`];
  REWRITE_TAC[List_hypermap.list_pairs;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `i' + 1 < k \/ i' + 1 = k` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      GMATCH_SIMP_TAC nth_zip_iota;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zip_iota0;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    TYPIFY `i` EXISTS_TAC;
    GMATCH_SIMP_TAC nth_zip_iota;
    REWRITE_TAC[PAIR_EQ];
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `i` EXISTS_TAC;
  GMATCH_SIMP_TAC nth_zip_iota0;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_rev_iota = prove_by_refinement(
  `!i j k.  0 < k ==> 
     (MEM (i,j) (list_pairs (rev (iota 0 k))) <=> ((i = 0 /\ j=k-1) \/ (0 < i /\ i < k /\ j = i-1)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[list_pairs_rev;Seq.mem_rev];
  INTRO_TAC List_hypermap.size_list_pairs [`rev (iota 0 k)`];
  REWRITE_TAC[list_pairs_rev;Seq.size_rev;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `(i' =0 \/ 0 < i')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      ASM_REWRITE_TAC[];
      GMATCH_SIMP_TAC nth_zipr_iota0;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zipr_iota;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i` EXISTS_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC nth_zipr_iota0;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC nth_zipr_iota;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_minimal_el = prove_by_refinement(
  `!f xs. ~(xs = []) ==> MEM (minimal_el f xs) xs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[minimal_el];
  GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[]);
  REWRITE_TAC[minimal_el];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let uniq_perm_eq_map  = prove_by_refinement(
  `! (x:(A)list) y. uniq x /\ uniq y /\ set_of_list  x = 
    set_of_list y ==> perm_eq x y`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN_SET_OF_LIST;EXTENSION];
  BY(MESON_TAC[ Seq.uniq_perm_eq])
  ]);;
  (* }}} *)

let o_nth = prove_by_refinement(
  `!f x0. f o nth x0 x = nth (f x0) (map f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[o_THM;FUN_EQ_THM];
  X_GENv_TAC "i";
  TYPIFY `(i:num) < sizel x` ASM_CASES_TAC;
    GMATCH_SIMP_TAC Seq.nth_map;
    TYPIFY `x0` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT (GMATCH_SIMP_TAC Seq.nth_default);
  REWRITE_TAC[Seq.size_map];
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let perm_eq_map = prove_by_refinement(
  `!x y. perm_eq (map f x) (map f y) ==> (?x'.
    perm_eq x' x /\ (map f x' = map f y))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  (FIRST_X_ASSUM (MP_TAC o (MATCH_MP Seq2.perm_eq_iota)));
  DISCH_THEN (C INTRO_TAC [`f (HD x)`]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `map (nth (HD x) x) l` EXISTS_TAC;
  REWRITE_TAC[GSYM Seq.map_comp];
  REWRITE_TAC[GSYM Seq.map_comp;o_nth];
  TYPIFY `perm_eq (map (nth (HD x) x) l) (map (nth (HD x) x) (iota 0 (sizel (map f x))))` ENOUGH_TO_SHOW_TAC;
    TYPIFY `(map (nth (HD x) x) (iota 0 (sizel (map f x)))) = x` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    REWRITE_TAC[Seq.size_map];
    REWRITE_TAC[GSYM Seq.mkseq];
    BY(MESON_TAC[Seq2.seq_eq_mkseq]);
  MATCH_MP_TAC Seq2.perm_eq_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let MAP_flatten = prove_by_refinement(
  `!f x. MAP f (flatten x) = flatten (MAP (MAP f) x)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[concat_flatten;MAP;MAP_APPEND])
  ]);;
  (* }}} *)

let zip_map = prove_by_refinement(
  `!f g x y. MAP (\ u. f(FST u),g(SND u)) (zip x y) = zip (MAP f x) (MAP g y)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.zip;MAP;CONS_11];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let ONE_ONE_IMP_BIJ_IMAGE = prove_by_refinement(
  `!f:A->B S. (!x y. x IN S /\ y IN S /\ f x = f y ==> x = y) ==>
   BIJ f S (IMAGE f S)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Lunar_deform.INJ_IMP_BIJ_IMAGE);
  ASM_REWRITE_TAC[INJ];
  TYPIFY `(:B)` EXISTS_TAC;
  BY(REWRITE_TAC[IN_UNIV])
  ]);;
  (* }}} *)

let REVERSE_rev = prove_by_refinement(
  ` REVERSE = rev`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[REVERSE;Seq.rev;Seq.catrev]);
  ASM_REWRITE_TAC[REVERSE;Seq.rev];
  REWRITE_TAC[Seq.catrev];
  REWRITE_TAC[Seq.catrevE];
  BY(REWRITE_TAC[Seq.cats0;Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let zip_swap = prove_by_refinement(
  `!x y. MAP (\d. SND d,FST d) (zip x y) = zip y x`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.zip;MAP])
  ]);;
  (* }}} *)

let I_BIJ_EQ = prove_by_refinement(
  `!s t. BIJ I s t <=> s = t`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT WEAKER_STRIP_TAC THEN CONJ_TAC;
    REWRITE_TAC[BIJ;INJ;SURJ;EXTENSION;I_THM];
    BY(MESON_TAC[]);
  BY(MESON_TAC[Hypermap.I_BIJ])
  ]);;
  (* }}} *)

let indexl_uniq = prove_by_refinement(
  `!x0 y (d:A) i. uniq y /\ i < sizel y /\ nth x0 y i = d ==>
    indexl d y = i`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.index_uniq])
  ]);;
  (* }}} *)

let prev_el_map = prove_by_refinement(
  `!y d f:A->B. (!x y. f x = f y ==> x = y) ==> 
	prev_el (MAP f y) (f d) = f (prev_el y d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq2.prev_el];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (f d) (MAP f y) = MEM d y` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[GSYM Seq.map_MAP];
  FIRST_ASSUM (ASSUME_TAC o (MATCH_MP Seq.index_map));
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[Seq.last_map]);
  GMATCH_SIMP_TAC Seq.nth_map;
  TYPIFY `d` EXISTS_TAC;
  REWRITE_TAC[];
  BY(ASM_MESON_TAC[Seq.index_mem;arith `d < s ==> d - 1 < s`])
  ]);;
  (* }}} *)

let uniq_map = prove_by_refinement(
  `!y f:A->B. uniq y /\
     (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v) ==>
    uniq (MAP f y)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;MAP;Seq.uniq];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexl_map = prove_by_refinement(
  `!y d f:A->B. uniq y /\
    MEM d y /\ (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v)
  ==> indexl (f d) (MAP f y) = indexl d y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexl_uniq [`f(CHOICE (:A))`];
  DISCH_THEN MATCH_MP_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[uniq_map]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.index_mem;Seq.map_MAP;Seq.size_map]);
  DISCH_TAC;
  REWRITE_TAC[GSYM o_nth;Seq.map_MAP;o_THM];
  REWRITE_TAC[GSYM o_nth;GSYM Seq.map_MAP;o_THM];
  AP_TERM_TAC;
  MATCH_MP_TAC Seq.nth_index;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_MEM_map = prove_by_refinement(
  `!y d f:A->B. uniq y /\ MEM d y /\ (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v) ==> 
	next_el (MAP f y) (f d) = f (next_el y d)`,
  (* {{{ proof *)
  [
  INTRO_TAC Seq2.next_el_alt [`CHOICE (:A)`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (f d) (MAP f y)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[];
  INTRO_TAC Seq2.next_el_alt [`f (CHOICE (:A))`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REPEAT (GMATCH_SIMP_TAC Seq2.nth_shift_left);
  ASM_REWRITE_TAC[Seq.index_mem];
  TYPIFY `indexl (f d) (MAP f y) = indexl d y` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (SUBST1_TAC);
    REWRITE_TAC[GSYM Seq.map_MAP];
    REWRITE_TAC[Seq.size_map];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[GSYM o_nth;o_THM]);
  MATCH_MP_TAC indexl_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let map_list_pairs = prove_by_refinement(
  `!phi:A->B x. list_pairs (MAP phi x) =
     MAP (\u. phi (FST u),phi (SND u)) (list_pairs x)`,
  (* {{{ proof *)
  [
    GEN_TAC;
  X_GENv_TAC "a";
  REWRITE_TAC[List_hypermap.list_pairs];
  REWRITE_TAC[zip_map];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  BY(REWRITE_TAC[Seq.map_rot;GSYM Seq.map_MAP])
  ]);;
  (* }}} *)

let map_list_of_darts = prove_by_refinement(
  `!x phi. list_of_darts (MAP (MAP phi) x) = MAP (\ x. (phi (FST x),phi(SND x))) (list_of_darts x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_darts_alt];
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[MAP_flatten];
  X_GENv_TAC "a";
  GEN_TAC;
  REWRITE_TAC[GSYM MAP_o];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[FUN_EQ_THM;o_THM;map_list_pairs];  
  ]);;
  (* }}} *)

let elements_of_list_unions = prove_by_refinement(
  `!L. elements_of_list L = (UNIONS (IMAGE (\f. set_of_list f) (set_of_list L)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  REWRITE_TAC[SET_OF_LIST_MAP];
  REWRITE_TAC[GSYM SET_OF_LIST_MAP];
  REWRITE_TAC[List_hypermap.set_of_list_flatten_map];
  REWRITE_TAC[Seq.map_MAP];
  GEN_TAC;
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  BY(REWRITE_TAC[FUN_EQ_THM])
  ]);;
  (* }}} *)

let mem_list_of_darts_imp_mem_list_of_elements_alt = prove_by_refinement(
	   `!L a b.
         MEM (a,b) (list_of_darts L)
         ==> MEM a (list_of_elements L) /\ MEM b (list_of_elements L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.mem_list_of_darts];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (MESON[] `(?l. P l /\ Q l) ==> ((?l. P l) /\ (?l. Q l))`);
  TYPIFY `l` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs])
  ]);;
  (* }}} *)

let inj_on_imp_inj_dart = prove_by_refinement(
  `!L phi. inj_on phi (elements_of_list L) ==>
   (!x y.
      MEM x (list_of_darts L)
      ==> MEM y (list_of_darts L)
      ==> phi (FST x) = phi (FST y) /\ phi (SND x) = phi (SND y)
      ==> x = y) `,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM (MP_TAC o MATCH_MP mem_list_of_darts_imp_mem_list_of_elements_alt));
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `inj_on` MP_TAC;
  REWRITE_TAC[inj_on];
  REWRITE_TAC[List_hypermap.elements_of_list];
  REPEAT (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[GSYM IN_SET_OF_LIST;IN];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let BIJ_IMAGE_darts_of_list = prove_by_refinement(
 `!x (phi:A->B). good_list x /\ inj_on phi (elements_of_list x) ==>
   BIJ (\u. phi (FST u),phi (SND u)) (darts_of_list x)
 (darts_of_list (MAP (MAP phi) x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.darts_of_list;];
  REWRITE_TAC[map_list_of_darts;SET_OF_LIST_MAP];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC ONE_ONE_IMP_BIJ_IMAGE;
  (FIRST_X_ASSUM (MP_TAC o MATCH_MP inj_on_imp_inj_dart));
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REWRITE_TAC[GSYM IN_SET_OF_LIST];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let f_list_ext_f_list = prove_by_refinement(
  `!L d. d IN darts_of_list L ==> f_list_ext L d = f_list L d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.f_list_ext;Sphere.res];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let inj_on_subset = prove_by_refinement(
  `!phi:A->B U V. inj_on phi U /\ V SUBSET U ==> inj_on phi V`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on];
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let list_pairs2_rev = prove_by_refinement(
  `!x:(A)list.  (list_pairs (REVERSE x)) = (rot 1 (REVERSE (MAP (\d. SND d,FST d) (list_pairs x))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs;FORALL_PAIR_THM];
  GEN_TAC;
  MATCH_MP_TAC (REWRITE_RULE[MESON[] `(a ==> b ==> c) <=> (a /\ b ==> c)`] Seq.eq_from_nth);
  EXISTS_TAC `CHOICE (:A),CHOICE(:A)`;
  TYPED_ABBREV_TAC `c = CHOICE (:A)`;
  GMATCH_SIMP_TAC Seq.size2_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[arith `n:num <= n`];
  REWRITE_TAC[REVERSE_rev];
  TYPIFY `sizel (rot 1 x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Seq.size_rot]);
  TYPIFY `sizel (rev x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Seq.size_rev]);
  TYPIFY `sizel (rot 1 (rev x)) = sizel ( x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Seq.size_rot;Seq.size_rev]);
  TYPIFY `sizel (zip (rev x) (rot 1 (rev x))) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  TYPIFY `sizel (rev (MAP (\d. SND d,FST d) (zip x (rot 1 x)))) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq.size_rev;Seq.size_map;GSYM Seq.map_MAP];
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[];
  TYPIFY `sizel (zip (rot 1 x) x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
  ASM_SIMP_TAC[Seq2.nth_shift_left];
  REWRITE_TAC[zip_swap];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC Seq.nth_rev);
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
    ASM_SIMP_TAC[Seq2.nth_shift_left];
    GMATCH_SIMP_TAC Seq2.nth_shift_left;
    NUM_REDUCE_TAC;
    TYPIFY `sizel x - SUC (sizel x - 1) = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
    ASM_REWRITE_TAC[];
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC Seq.nth_rev);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  TYPIFY_GOAL_THEN `~(sizel x - SUC (i + 1) = sizel x - 1)` (unlist REWRITE_TAC);
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  TYPIFY_GOAL_THEN `sizel x - SUC (i+1) + 1 = sizel x - SUC i` (unlist REWRITE_TAC);
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_rev = prove_by_refinement(
  `!(x:(A)list) d. MEM d (list_pairs x) ==> MEM (SND d,FST d) (list_pairs ( REVERSE x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[list_pairs2_rev;Seq.mem_rot;REVERSE_rev;Seq.mem_rev;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP;EXISTS_PAIR_THM;PAIR_EQ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let list_pairs_rev_eq = prove_by_refinement(
  `!(x:(A)list) d. MEM d (list_pairs x) <=> MEM (SND d,FST d) (list_pairs ( REVERSE x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Geomdetail.EQ_EXPAND;list_pairs_rev];
  REWRITE_TAC[FORALL_PAIR_THM];
  BY(ASM_MESON_TAC[REVERSE_REVERSE;PAIR;FST;SND;list_pairs_rev])
  ]);;
  (* }}} *)

let list_of_darts_rev = prove_by_refinement(
  `!x d. MEM (p2,p1)
    (list_of_darts (MAP REVERSE x)) <=> MEM (p1,p2) (list_of_darts x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.mem_list_of_darts;MEM_MAP];
  BY(ASM_MESON_TAC[list_pairs_rev_eq;PAIR;FST;SND])
  ]);;
  (* }}} *)

let list_of_darts_rev_uniq = prove_by_refinement(
  `!x:((A)list)list. uniq (list_of_darts x) ==> uniq (map (\d. SND d,FST d) (list_of_darts (map REVERSE x)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (REWRITE_RULE[TAUT `(a ==> b==> c) <=> (a /\ b ==> c)`] Seq.leq_size_uniq);
  TYPIFY `list_of_darts x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Seq.size_map];
  REWRITE_TAC[FORALL_PAIR_THM];
  REWRITE_TAC[Seq.mapP];
  CONJ_TAC;
    REWRITE_TAC[list_of_darts_rev;Seq.map_MAP;EXISTS_PAIR_THM];
    BY(MESON_TAC[]);
  REWRITE_TAC[List_hypermap.list_of_faces;GSYM Seq.map_MAP;List_hypermap.list_of_darts_alt;Seq.size_flatten;Seq.shape];
  REWRITE_TAC[GSYM Seq.map_comp];
  TYPIFY_GOAL_THEN `(sizel:(A#A)list -> num) o list_pairs = sizel` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[FUN_EQ_THM;o_THM;List_hypermap.size_list_pairs]);
  MATCH_MP_TAC (arith `(a:num = b) ==> (a <= b)`);
  REPEAT (AP_THM_TAC ORELSE AP_TERM_TAC);
  REWRITE_TAC[FUN_EQ_THM;o_THM;REVERSE_rev];
  BY(REWRITE_TAC[FUN_EQ_THM;o_THM;REVERSE_rev;Seq.size_rev])
  ]);;
  (* }}} *)

let FILTER_CONJ = prove_by_refinement(
  `!f g xs. FILTER f (FILTER g xs) = FILTER (\(x:A). f x /\ g x) xs`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[FILTER]);
  REWRITE_TAC[FILTER];
  REPEAT COND_CASES_TAC THEN RULE_ASSUM_TAC(REWRITE_RULE[]) THEN ASM_REWRITE_TAC[FILTER];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let FILTER_NEGATE  = prove_by_refinement(
  `!f xs. FILTER f xs = xs <=> FILTER (\ (x:A). ~(f x)) xs = []`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[FILTER];
  BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FILTER;CONS_11;NOT_CONS_NIL] THEN ASM_MESON_TAC[MEM_FILTER;Seq.mem_head])
  ]);;
  (* }}} *)

let CARD_upt = prove_by_refinement(
  `!n. CARD (set_of_list (upt 0 n)) = n`,
  (* {{{ proof *)
  [
  GEN_TAC;
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  REWRITE_TAC[upt0];
  REWRITE_TAC[Seq.iota_uniq];
  BY(REWRITE_TAC[Seq.iota_uniq;Seq.size_iota])
  ]);;
  (* }}} *)

let undup_cat = prove_by_refinement(
  `!s t. (!x. MEM x s ==> MEM x t) ==> undup (cat s t) = undup t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.undup;Seq.cat0s;MEM;Seq.cat];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM h t'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY_GOAL_THEN `MEM h (cat t t')` (unlist REWRITE_TAC);
    BY(ASM_REWRITE_TAC[Seq.mem_cat]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let EL_REPLICATE = prove_by_refinement(
  `!n i s. i < n ==> EL i (REPLICATE n s) = s`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[REPLICATE;EL_CONS];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let next_el1 = prove_by_refinement(
  `!h. next_el [h] h = h`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INTRO_TAC Seq2.next_el_last [`h`;`[h]`];
  REWRITE_TAC[Seq.size;LENGTH;HD;Seq.uniq;MEM];
  NUM_REDUCE_TAC;
  TYPIFY `last h [h] = h` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  BY(REWRITE_TAC[Seq.last])
  ]);;
  (* }}} *)

let last_LAST = prove_by_refinement(
  `!s x0. ~(s = []) ==> last x0 s = LAST s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REWRITE_TAC[NOT_CONS_NIL;Seq.last;LAST];
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[Seq.last]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_LAST = prove_by_refinement(
  `!s. ~(s = []) ==> MEM (LAST s) s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.mem_last [`h`;`t`];
  REWRITE_TAC[LAST];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  BY(ASM_MESON_TAC[last_LAST])
  ]);;
  (* }}} *)

let uniq_last = prove_by_refinement(
  `!h s. ~(MEM h s) /\ ~(s = []) ==> ~(LAST (h::s) = h)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL];
  FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[MEM;LAST;NOT_CONS_NIL];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rev0 = prove_by_refinement(
  `rev [] = []`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[REVERSE;REVERSE_rev])
  ]);;
  (* }}} *)

let lower_case = end_itlist CONJ
 [GSYM Seq.map_MAP;GSYM Seq.size;GSYM filter_FILTER;
  REVERSE_rev;GSYM last_LAST;APPEND_cat;Seq2.ALL_all];;

let upper_case  = GSYM lower_case;;

(* QYHXIVZ *)

let PAIR_EQ2 = Wrgcvdr_cizmrrh.PAIR_EQ2;;

(*
let PAIR_EQ_EXPAND = prove_by_refinement(
  `!x a b. x = (a,b) <=> (FST x = a /\ SND x = b)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ])
  ]);;
  (* }}} *)
*)

let rcons_nonnil = prove_by_refinement(
  `!s x. ~(rcons s x = [])`,
  (* {{{ proof *)
  [
BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.rcons;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let index_uniq = prove_by_refinement(
  `!x y. MEM x s /\ MEM y s /\ indexl x s = indexl y s ==> (x = y)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.nth_index])
  ]);;
  (* }}} *)

let index0 = prove_by_refinement(
  `!s x. MEM x s /\ indexl x s = 0 ==> x = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl (HD s) s = 0` ENOUGH_TO_SHOW_TAC;
    TYPIFY `MEM (HD s) s` (C SUBGOAL_THEN MP_TAC);
      MATCH_MP_TAC MEM_HD;
      BY(ASM_MESON_TAC[MEM]);
    DISCH_TAC;
    BY(ASM_MESON_TAC[index_uniq]);
  INTRO_TAC (GSYM Seq2.index_head) [`x`;`s`];
  DISCH_THEN (SUBST1_TAC);
  REPLICATE_TAC 2 (AP_TERM_TAC ORELSE AP_THM_TAC);
  GMATCH_SIMP_TAC Seq2.head_HD;
  REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
  BY(ASM_MESON_TAC[Seq.size_eq0;MEM])
  ]);;
  (* }}} *)

let index_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> SUC (indexl x (rot 1 s)) = indexl x s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;HD;Seq.index;Seq.find;Seq.rot1_cons;Seq.has_pred1];
  REWRITE_TAC[Seq.pred1];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  AP_TERM_TAC;
  REWRITE_TAC[Seq.find_cat;GSYM Seq.cats1];
  REWRITE_TAC[GSYM Seq.pred1];
  REWRITE_TAC[GSYM Seq.pred1;Seq.has_pred1];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexf = new_definition' `indexf (x:A) y s = 
  if (MEM x s /\ MEM y s) then (indexl y s + (sizel s - indexl x s)) MOD sizel s 
  else sizel s`;;

let indexf0 = prove_by_refinement(
  `!(x:A) y s. indexf x y [] = 0`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[indexf;MEM;Seq.size_nil])
  ]);;
  (* }}} *)

let indexf_mem1 = prove_by_refinement(
  `!(x:A) y s. ~MEM x s ==> indexf x y s = sizel s`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[indexf])
  ]);;
  (* }}} *)

let indexf2 = prove_by_refinement(
  `!(x:A) y s. ~MEM y s ==> indexf x y s = sizel s`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[indexf])
  ]);;
  (* }}} *)

let sizel0 = prove_by_refinement(
  `!s:A list. sizel s = 0 <=> ~(?x. MEM x s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size;LENGTH_EQ_NIL;List_hypermap.mem_not_nil];
  BY(MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let indexf_le_sizel = prove_by_refinement(
  `!s (x:A) y. indexf x y s <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[arith `n <= n:num`];
  TYPIFY `~(sizel s = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[DIVISION;arith `a < (b:num) ==> a <= b`]);
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf_lt_sizel = prove_by_refinement(
  `!s (x:A) y. MEM x s /\ MEM y s ==> indexf x y s < sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `~(sizel s = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[DIVISION]);
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf_refl = prove_by_refinement(
  `!(x:A) s. MEM x s ==> indexf x x s = 0`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  ASM_SIMP_TAC[indexf];
  ASM_SIMP_TAC[arith `i < s ==> i + s - i = (s:num)`];
  MATCH_MP_TAC Oxl_2012.MOD_REFL;
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf0 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ indexf x y s = 0 ==> (x = y)`,
  (* {{{ proof *)
  [
  SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl y s = indexl x s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[index_uniq]);
  FIRST_X_ASSUM MP_TAC;
  GMATCH_SIMP_TAC MOD_EQ_0;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[sizel0]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`y`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `q = 1` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `a = q* sizel s` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  REWRITE_TAC[arith `q = 1 <=> ~(q = 0) /\ (q < 2)`];
  SUBCONJ_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `a = q* sizel s` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `q * sizel s < 2 * sizel s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[LT_MULT_RCANCEL]);
  BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_antisym_wlog = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) /\ indexl x s < indexl y s 
    ==> indexf x y s + indexf y x s = sizel s`,
  (* {{{ proof *)
  [
  SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel s = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[sizel0]);
  INTRO_TAC Seq.index_mem [`y`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(indexl y s + sizel s - indexl x s) MOD sizel s = indexl y s - indexl x s /\ (indexl x s + sizel s - indexl y s) MOD sizel s = indexl x s + sizel s - indexl y s` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  CONJ2_TAC;
    MATCH_MP_TAC MOD_LT;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY_GOAL_THEN `indexl y s + sizel s - indexl x s = 1 * sizel s + (indexl y s - indexl x s)` (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  SIMP_TAC[MOD_MULT_ADD];
  MATCH_MP_TAC MOD_LT;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_antisym = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) 
    ==> indexf x y s + indexf y x s = sizel s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(indexl x s = indexl y s) \/ indexl x s < indexl y s \/ indexl y s < indexl x s` (C SUBGOAL_THEN MP_TAC);
    BY(ARITH_TAC);
  REPEAT STRIP_TAC;
      BY(ASM_MESON_TAC[index_uniq]);
    BY(ASM_MESON_TAC[indexf_antisym_wlog]);
  BY(ASM_MESON_TAC[indexf_antisym_wlog;arith `x + (y:num) = y + x`])
  ]);;
  (* }}} *)

let indexf_cond = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s ==>
    indexf x y s = if (indexl x s <= indexl y s) 
    then indexl y s - indexl x s 
    else indexl y s + (sizel s - indexl x s)`,
  (* {{{ proof *)
  [
  ASM_SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    ASM_SIMP_TAC[arith `x <= y /\ x < n ==> (y + n -x = 1*n + (y - x))`];
    REWRITE_TAC[MOD_MULT_ADD];
    MATCH_MP_TAC MOD_LT;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC MOD_LT;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_left = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf x y s <= indexf x z s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_right = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf y z s <= indexf x z s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_sum = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf x y s + indexf y z s < sizel s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let sizel_gt_1 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) ==>
    1 < sizel s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC LTE_TRANS;
  TYPIFY `CARD (set_of_list s)` EXISTS_TAC;
  REWRITE_TAC[CARD_SET_OF_LIST_LE;Seq.size];
  TYPIFY `FINITE (set_of_list s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[FINITE_SET_OF_LIST]);
  REWRITE_TAC[arith `1 < n <=> (1 <= n) /\ ~(n = 1)`];
  TYPIFY `x IN set_of_list s /\ y IN set_of_list s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  TYPIFY `~({x} = {y})` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN SET_TAC[]);
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[Hypermap.CARD_ATLEAST_1]);
  BY(ASM_MESON_TAC[Hypermap.set_one_point])
  ]);;
  (* }}} *)

let indexf_rot = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s ==>
    indexf x y s = indexf x y (rot 1 s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.mem_rot [`1`;`s`;`x`];
  INTRO_TAC Seq.mem_rot [`1`;`s`;`y`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[indexf_refl]);
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC sizel_gt_1;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[indexf_cond;];
  ASM_SIMP_TAC [Seq2.index_rot];
  REWRITE_TAC[Seq.size_rot];
  BY(REPEAT (COND_CASES_TAC THEN ASM_REWRITE_TAC[]) THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_rotn = prove_by_refinement(
  `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ n <= sizel s ==>
    indexf x y s = indexf x y (rot n s)`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.rot0]);
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.rotS;
  CONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM (GMATCH_SIMP_TAC);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC indexf_rot;
  BY(ASM_REWRITE_TAC[Seq.mem_rot;Seq.rot_uniq])
  ]);;
  (* }}} *)

let indexf1 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ indexf x y s = 1 ==>
    next_el s x = y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. next_el (rot n s) x = y` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq]);
  INTRO_TAC Seq2.rot_to_index [`s`;`x`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl x s` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_rotn [`indexl x s`;`x`;`y`;`s`];
  ASM_SIMP_TAC[arith `i < (s:num) ==> i <= s`];
  TYPIFY `MEM x (x::t) /\ MEM y (x::t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.mem_rot]);
  ASM_SIMP_TAC[indexf_cond];
  REWRITE_TAC[Seq2.index_cons;arith `0 <= n`;arith `n - 0 = n`];
  COND_CASES_TAC THEN REWRITE_TAC[arith `~(1 = 0)`;arith `1 = SUC n <=> n = 0`];
  TYPIFY `MEM y t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  DISCH_TAC;
  TYPIFY `y = HD t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index0]);
  GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `sizel` MP_TAC THEN ASM_REWRITE_TAC[Seq.size_cons];
  INTRO_TAC sizel_gt_1 [`x`;`y`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `sizel s = sizel (x::t)` ENOUGH_TO_SHOW_TAC;
    BY(REWRITE_TAC[Seq.size_cons] THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.size_rot])
  ]);;
  (* }}} *)

let next_el_indexf = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ next_el s x = y /\ 1 < sizel s ==>
    indexf x y s = 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. n <= sizel s /\ indexf x y (rot n s) =1` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[indexf_rotn]);
  INTRO_TAC Seq2.rot_to_index [`s`;`x`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl x s` EXISTS_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_SIMP_TAC[arith `i < (s:num) ==> i <= s`] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq2.next_el_rot_eq [`s`;`indexl x s`];
  ASM_REWRITE_TAC[FUN_EQ_THM] THEN DISCH_THEN (C INTRO_TAC [`x`]);
  DISCH_TAC;
  TYPIFY `MEM x (x::t) /\ MEM y (x::t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.mem_rot]);
  ASM_SIMP_TAC[indexf_cond];
  REWRITE_TAC[Seq2.index_cons;arith `0 <= n`;arith `n - 0 = n`];
  INTRO_TAC Seq2.next_el_hd_cons [`x`;`t`];
  TYPIFY `0 < sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `sizel s = sizel (x::t)` ENOUGH_TO_SHOW_TAC;
      BY(REWRITE_TAC[Seq.size_cons] THEN ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Seq.size_rot]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `uniq (x:: t)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  COND_CASES_TAC THEN REWRITE_TAC[arith `~(1 = 0)`;arith `SUC n = 1 <=> n = 0`];
    REWRITE_TAC[Seq.cons_uniq];
    REWRITE_TAC[Seq.cons_uniq;DE_MORGAN_THM];
    DISJ1_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_HD;Seq.size_eq0;arith `0 < s ==> ~(s = 0)`]);
  (DISCH_TAC);
  TYPIFY `headl y t = HD t` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq2.index_head]);
  MATCH_MP_TAC Seq2.head_HD;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_eln_indexf = prove_by_refinement(
  `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ 
    (next_el s POWER n) x = y /\ n < sizel s ==>
    indexf x y s = n`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER;I_THM];
    BY(MESON_TAC[indexf_refl]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `yn = (next_el s POWER n) x`;
  FIRST_X_ASSUM (C INTRO_TAC [`x`;`yn`;`s`]);
  ASM_SIMP_TAC[arith `SUC n < s ==> n < s`];
  TYPIFY `MEM yn s` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "yn";
    FIRST_X_ASSUM kill;
    ASM_SIMP_TAC[Seq2.next_el_power];
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_MESON_TAC[DIVISION;arith `n < (s:num) ==> ~(s = 0)`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC indexf_add_sum [`x`;`yn`;`y`;`s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (GMATCH_SIMP_TAC o GSYM);
  TYPIFY `indexf yn y s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC next_el_indexf;
  ASM_SIMP_TAC[arith `SUC n < s ==> 1 < s`];
  CONJ2_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FULL_EXPAND_TAC "y";
  FULL_EXPAND_TAC "yn";
  BY(REWRITE_TAC[Hypermap.COM_POWER;o_THM])
  ]);;
  (* }}} *)

let indexf_n = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s ==>
    ((next_el s) POWER (indexf x y s)) x = y`,
  (* {{{ proof *)
  [
  TYPIFY `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ (indexf x y s = n) ==>    ((next_el s) POWER n) x = y` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x = y` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[indexf0]);
    BY(ASM_REWRITE_TAC[Fan.POWER;I_THM]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPED_ABBREV_TAC `yn = (next_el s POWER n) x`;
  TYPIFY `MEM yn s` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "yn";
    FIRST_X_ASSUM kill;
    ASM_SIMP_TAC[Seq2.next_el_power];
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_MESON_TAC[DIVISION;arith `n < (s:num) ==> ~(s = 0)`]);
  INTRO_TAC indexf_lt_sizel [`s`;`x`;`yn`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC indexf_lt_sizel [`s`;`x`;`y`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC next_eln_indexf [`n`;`x`;`yn`;`s`];
  ASM_SIMP_TAC[arith `SUC n < s ==> n < s`];
  DISCH_TAC;
  INTRO_TAC indexf_add_left [`x`;`yn`;`y`;`s`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[arith `n + i = SUC n <=> i = 1`];
  DISCH_TAC;
  INTRO_TAC indexf1 [`yn`;`y`;`s`];
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Hypermap.COM_POWER;o_THM])
  ]);;
  (* }}} *)

let nextElem_nonmem = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem s u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)


let nextElem_nonmem_rcons = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem (rcons s a) u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rcons = prove_by_refinement(
  `!s h x u. MEM x s ==> (nextElem s h x = nextElem (rcons s h) u x)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    TYPIFY `x = h` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    SIMP_TAC[];
    COND_CASES_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[HD;Seq.rcons];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0;MEM]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> nextElem s (HD s) x = nextElem (rot 1 s) (HD (rot 1 s)) x `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[nextElem;Seq.head;MEM;Seq.rot1_cons] THEN GEN_TAC;
  REWRITE_TAC[HD];
  DISCH_TAC;
  TYPIFY `MEM x t /\ ~(x = h)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM kill THEN DISCH_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[nextElem_rcons])
  ]);;
  (* }}} *)


let index_nextElem_next_el = prove_by_refinement(
  `!n s x. MEM x s /\ indexl x s = n ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    LIST_INDUCT_TAC;
      BY(REWRITE_TAC[MEM]);
    REWRITE_TAC[HD;nextElem];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC index0 [`h::t`;`x`];
    ASM_REWRITE_TAC[HD];
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC;
      BY(ASM_REWRITE_TAC[next_el1]);
    GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
    BY(ASM_MESON_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0]);
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC nextElem_rot;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    DISCH_TAC;
    INTRO_TAC Seq2.head_HD [`x`;`s`];
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0];
    BY(ASM_MESON_TAC[MEM;arith `~(0=SUC n)`;Seq2.index_head]);
  DISCH_TAC;
  GMATCH_SIMP_TAC Seq2.next_el_alt;
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`rot 1 s`;`x`]);
  TYPIFY `MEM x (rot 1 s) /\ indexl x (rot 1 s) = n` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[Seq.mem_rot];
    MATCH_MP_TAC (arith `SUC u = SUC v ==> u = v`);
    GMATCH_SIMP_TAC index_rot;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC Seq2.next_el_mod [`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[arith `n+1 = SUC n`] THEN MATCH_MP_TAC MOD_LT;
  BY(ASM_MESON_TAC[Seq.index_mem;Seq.size_rot])
  ]);;
  (* }}} *)

let nextElem_next_el = prove_by_refinement(
  `!s x. MEM x s ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
BY(MESON_TAC[index_nextElem_next_el])
  ]);;
  (* }}} *)

let nextVertex_next_el = prove_by_refinement(
  `!f x. MEM x (FST f) ==> nextVertex f x = next_el (FST f) x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextVertex;FORALL_PAIR_THM];
  BY(SIMP_TAC[nextElem_next_el])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!f g. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;makeFaceFinal;faces_graph;makeFaceFinalFaceList];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

(*
let vertices_set2_makeFaceFinal = prove_by_refinement(
  `!f g. vertices_set2 (makeFaceFinal f' g) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;makeFaceFinal;(*bn_*)vertices_graph];
  BY(REWRITE_TAC[vertices_graph])
  ]);;
  (* }}} *)
*)

let vertices_set2_makeFaceFinal = prove_by_refinement(
  `!f g. vertices_set2 (makeFaceFinal f' g) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;makeFaceFinal;(*bn_*)vertices_graph];
  BY(REWRITE_TAC[countVertices])
  ]);;
  (* }}} *)


let set_of_list_flatten_APPEND = prove_by_refinement(
  `!a b. set_of_list (flatten (APPEND a b)) = 
    set_of_list (flatten a) UNION set_of_list (flatten b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[List_hypermap.set_of_list_flatten_map];
  REWRITE_TAC[upper_case;SET_OF_LIST_APPEND;MAP_APPEND];
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let split_at_mem_fst = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (FST(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* replace with snd_split_at_acc.
let split_at_snd_acc = prove_by_refinement(
  `!f (u:A) v b. MEM v (SND (split_at_rec u [] f)) <=>
    MEM v (SND (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let snd_split_at_acc = prove_by_refinement(
  `!f (u:A) b.  (SND (split_at_rec u b f)) =
     (SND (split_at_rec u [] f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(*
let split_at_mem_snd = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (SND(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let split_at_mem_snd = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (SND(split_at_rec u b f))) ==> MEM v f`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[snd_split_at_acc];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[SND;MEM];
    BY(MESON_TAC[]);
  BY(ASM_MESON_TAC[snd_split_at_acc])
  ]);;
  (* }}} *)

(* was SPLIT_AT_ACC *)

let split_at_acc_fst = prove_by_refinement(
  `!f (u:A) v b. MEM v b ==>
    (MEM v (FST (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[MEM_APPEND])
  ]);;
  (* }}} *)

let split_at_both = prove_by_refinement(
  `!f (u:A) v b.  
    (MEM v f) /\ (v = u ==> MEM v b) ==>
    (MEM v (FST (split_at_rec u b f)) \/ MEM v (SND (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v = h` ASM_CASES_TAC;
    DISJ1_TAC;
    MATCH_MP_TAC split_at_acc_fst;
    BY(ASM_REWRITE_TAC[MEM_APPEND;MEM]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[MEM_APPEND;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* replaced with fst_split_at_acc.
let split_at_fst_acc = prove_by_refinement(
  `!f (u:A) v b. MEM v (FST (split_at_rec u [] f)) \/ MEM v b <=>
    MEM v (FST (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  FIRST_X_ASSUM_ST `MEM` (unlist ONCE_REWRITE_TAC o GSYM);
  REWRITE_TAC[MEM;MEM_APPEND];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)
*)

let fst_split_at_acc = prove_by_refinement(
  `!f (u:A) b. APPEND b (FST (split_at_rec u [] f)) = 
     (FST (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;APPEND_NIL];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM;APPEND_NIL];
  FIRST_X_ASSUM_ST `APPEND` (unlist ONCE_REWRITE_TAC o GSYM);
  BY(MESON_TAC[APPEND_ASSOC])
  ]);;
  (* }}} *)

let split_at_fst_antirefl = prove_by_refinement(
  `!f (u:A) b. MEM u (FST (split_at_rec u b f)) ==> MEM u b`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[fst_split_at_acc;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_at_snd_antirefl = prove_by_refinement(
  `!f (u:A) b. uniq f ==> ~(MEM u (SND (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(MESON_TAC[Seq.cons_uniq]);
  BY(ASM_MESON_TAC[Seq.cons_uniq])
  ]);;
  (* }}} *)

let split_at_fst_antisym = prove_by_refinement(
  `!f (u:A) v b. MEM v (FST (split_at_rec u b f)) /\ 
    MEM u (FST (split_at_rec v b f)) ==>
     (MEM u b \/ MEM v b)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
    REPEAT GEN_TAC;
    BY(MESON_TAC[]);
  REPEAT GEN_TAC;
  REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM];
        BY(MESON_TAC[]);
      BY(MESON_TAC[]);
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  BY(ASM_REWRITE_TAC[MEM_APPEND;MEM])  
  ]);;
  (* }}} *)

let split_at_snd_antisym = prove_by_refinement(
  `!f (u:A) v b. uniq f /\ MEM v (SND (split_at_rec u b f)) /\ 
    MEM u (SND (split_at_rec v b f)) ==> F`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM;Seq.cons_uniq] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_MESON_TAC[split_at_mem_snd;snd_split_at_acc])
  ]);;
  (* }}} *)

let snd_split_at_hd = prove_by_refinement(
  `!f (u:A) v b. ~(f=[]) ==> SND(split_at_rec (HD f) b f) = TL f`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL])
  ]);;
  (* }}} *)

let fst_split_at_hd = prove_by_refinement(
  `!f (u:A) v b.  FST(split_at_rec (HD f) b f) = b`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL])
  ]);;
  (* }}} *)

let fst_split_at_take = prove_by_refinement(
  `!f (u:A) b. 
     FST(split_at_rec u b f) = APPEND b (take (indexl u f) f)`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL;Seq.take;APPEND_NIL]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_head;Seq.take0;APPEND_NIL];
  ASM_SIMP_TAC[GSYM APPEND_ASSOC];
  AP_TERM_TAC;
  ASM_REWRITE_TAC[Seq2.index_cons;];
  ASM_REWRITE_TAC[Seq.take_cons];
  BY(ASM_REWRITE_TAC[Seq.take_cons;APPEND_SING])
  ]);;
  (* }}} *)

let snd_split_at_drop = prove_by_refinement(
  `!f (u:A) b.
    SND(split_at_rec u b f) = (dropl (SUC(indexl u f)) f)`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL;Seq.drop;APPEND_NIL]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_head;Seq.drop0;APPEND_NIL];
  ASM_REWRITE_TAC[Seq2.index_cons;];
  ]);;
  (* }}} *)

let split_at_take_drop = prove_by_refinement(
  `!f (u:A) b.
    split_at_rec u b f = (APPEND b (take (indexl u f) f)),dropl (SUC(indexl u f)) f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[fst_split_at_take;snd_split_at_drop;PAIR_EQ2])
  ]);;
  (* }}} *)

let split_at_nil_take_drop = prove_by_refinement(
  `!f (u:A).
    split_at_rec u [] f = take (indexl u f) f,dropl (SUC(indexl u f)) f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[split_at_take_drop;APPEND])
  ]);;
  (* }}} *)


(* was BETWN_MEM *)

let betwn_mem = prove_by_refinement(
  `!f (u:A) v w. MEM w (betwn f u v) ==>
     MEM w f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn;split_at;split_at_rec];
  REPEAT GEN_TAC;
  REPEAT (LET_TAC);
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM w post1 \/ MEM w pre2 \/ MEM w pre2' ==> MEM w f` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    FIRST_X_ASSUM MP_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN ASM_REWRITE_TAC[];
  BY(MESON_TAC[split_at_mem_snd;split_at_mem_fst;MEM])
  ]);;
  (* }}} *)

let mem_drop_index = prove_by_refinement(
  `!k (v:A) s. uniq s /\ MEM v s ==>
    (MEM v (dropl k s) <=> k <= indexl v s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT STRIP_TAC;
    ONCE_REWRITE_TAC[arith `k <= i <=> ~(i < k:num)`];
    DISCH_TAC;
    INTRO_TAC Seq.cat_take_drop [`k`;`s`];
    DISCH_TAC;
    INTRO_TAC Seq2.mem_imp_not_uniq_cat [`v`;`take k s`;`dropl k s`];
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      REWRITE_TAC[GSYM Seq.index_mem;Seq2.index_take];
      ASM_REWRITE_TAC[];
      GMATCH_SIMP_TAC Seq.size_takel;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC (arith `~(s <= k:num) ==> (k <= s)`);
      DISCH_THEN (MP_TAC o MATCH_MP Seq.drop_oversize);
      BY(ASM_MESON_TAC[MEM]);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  DISCH_TAC;
  INTRO_TAC Seq.index_cat [`v`;`take k s`;`dropl k s`];
  COND_CASES_TAC;
    FIRST_X_ASSUM_ST `MEM` MP_TAC THEN REWRITE_TAC[GSYM Seq.index_mem];
    GMATCH_SIMP_TAC Seq.size_takel;
    SUBCONJ_TAC;
      MATCH_MP_TAC LE_TRANS;
      TYPIFY `indexl v s` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[Seq.index_size]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `x < k:num` MP_TAC THEN REWRITE_TAC[Seq2.index_take];
    COND_CASES_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.mem_cat])
  ]);;
  (* }}} *)

let size_take_le = prove_by_refinement(
  `!k (v:A) s. sizel (take k s) <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_take];
  BY(REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let size_drop_le = prove_by_refinement(
  `!k (v:A) s. sizel (dropl k s) <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_drop];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_take_index = prove_by_refinement(
  `!k (v:A) s. uniq s /\ 
    MEM v s ==>
    (MEM v (take k s) <=>  indexl v s < k)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT STRIP_TAC;
    ONCE_REWRITE_TAC[arith `k < i <=> ~(i <= k:num)`];
    DISCH_TAC;
    INTRO_TAC Seq.cat_take_drop [`k`;`s`];
    DISCH_TAC;
    INTRO_TAC Seq2.mem_imp_not_uniq_cat [`v`;`take k s`;`dropl k s`];
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[mem_drop_index]);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  DISCH_TAC;
  INTRO_TAC Seq.index_cat [`v`;`take k s`;`dropl k s`];
  TYPIFY `sizel s <= k` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.take_oversize]);
  COND_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `MEM` MP_TAC THEN REWRITE_TAC[GSYM Seq.index_mem]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq.size_takel;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let take_take = prove_by_refinement(
  `!i j s. i <= j ==> take i (take j s) = take i s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s <= j` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[Seq.take_oversize]);
  INTRO_TAC Seq.cat_take_drop [`j`;`s`];
  TYPIFY `i <= sizel (take j s)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq.takel_cat]);
  REWRITE_TAC[Seq.size_take];
  BY(COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let drop_drop = prove_by_refinement(
  `!(s:A list) j i. dropl i (dropl j s) = dropl (i+j) s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.drop];
  BY(INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.drop;arith `i+0 = i`;arith `i + SUC j = SUC (i+j)`])
  ]);;
  (* }}} *)

let betwn_take_drop = prove_by_refinement(
  `!f (u:A) (v:A).  MEM v f /\ uniq f ==> betwn f u v = 
      if (indexl u f < indexl v f) 
      then take (PRE(indexl v f - indexl u f)) (dropl (SUC (indexl u f)) f)
      else APPEND (dropl (SUC (indexl u f)) f) (take (indexl v f) f)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn;split_at_nil_take_drop;split_at;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN ASM_REWRITE_TAC[];
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  ASM_SIMP_TAC[mem_drop_index];
  REWRITE_TAC[arith `SUC n <= i <=> n < i`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL [ALL_TAC;AP_TERM_TAC];
    TYPIFY `(indexl v (dropl (SUC (indexl u f)) f)) = (PRE (indexl v f - indexl u f))` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN (unlist REWRITE_TAC));
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    CONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC take_take;
  TYPIFY `indexl v (take (indexl u f) f) = indexl v f` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist ASM_REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq2.index_take];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let drop_take_commute = prove_by_refinement(
  `!(s:A list) k n. k <= n ==> dropl k (take n s) = take (n-k) (dropl k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s <= k` ASM_CASES_TAC;
    REPEAT (GMATCH_SIMP_TAC Seq.drop_oversize);
    ASM_REWRITE_TAC[Seq.take];
    MATCH_MP_TAC LE_TRANS;
    TYPIFY `sizel s` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[Seq.size_take] THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `take n s = take n (cat (take k s) (dropl k s))` (C SUBGOAL_THEN SUBST1_TAC);
    BY(MESON_TAC[ Seq.cat_take_drop]);
  REWRITE_TAC[Seq.take_cat];
  COND_CASES_TAC;
    FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[Seq.size_take];
    BY(COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.drop_cat];
  TYPIFY_GOAL_THEN `sizel (take k s) = k` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[Seq.size_take] THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[arith `~(k<k:num)`;arith `(k:num) - k = 0`;Seq.drop0])
  ]);;
  (* }}} *)

let take_drop_commute = prove_by_refinement(
  `!(s:A list) k n. take n (dropl k s) = dropl k (take (n+k) s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC drop_take_commute;
  BY(REWRITE_TAC[arith `(n + k) - (k:num) = n`;arith `(k:num) <= n+ k`])
  ]);;
  (* }}} *)

(*
let betwn_hd = prove_by_refinement(
  `!f (u:A) v x. MEM u f /\ MEM v f /\ ~(u = v) ==>
    betwn f u v = if (u = HD f) then take (indexl v f - 1) (TL f) else 
      betwn (rot 1 f) u v`,
  (* {{{ proof *)
  [
  st/r
  rt[betwn]
  repeat (LET_TAC)
  rule(rr[PAIR_EQ2])
  rule(orr[EQ_SYM_EQ])
  art[] then rep 6 (fxa kill)
  rt[IN_SET_OF_LIST]
  repeat condcse then art[]
  ...
  ]);;
  (* }}} *)
*)

let size_betwn = prove_by_refinement(
  `!x:A y s. uniq s /\ MEM x s /\  MEM y s /\ ~(x= y) ==>
    sizel (betwn s x y ) = PRE (indexf x y s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    GMATCH_SIMP_TAC Seq.size_takel;
    REWRITE_TAC[Seq.size_drop];
    REWRITE_TAC[arith `n - SUC u = PRE (n - u)`];
    CONJ_TAC;
      MATCH_MP_TAC (arith `n <= m ==> PRE n <= PRE m`);
      INTRO_TAC Seq.index_size [`y`;`s`];
      BY(ASM_TAC THEN ARITH_TAC);
    MATCH_MP_TAC (arith `n = m ==> PRE n = PRE m`);
    GMATCH_SIMP_TAC indexf_cond;
    BY(ASM_SIMP_TAC[arith `x < y ==> x <= (y:num)`]);
  REWRITE_TAC[lower_case];
  REWRITE_TAC[Seq.size_cat];
  GMATCH_SIMP_TAC Seq.size_takel;
  REWRITE_TAC[Seq.size_drop];
  SUBCONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.index_mem] THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `~(indexl x s = indexl y s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  ASM_SIMP_TAC[indexf_cond];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.index_mem] THEN ARITH_TAC)
  ]);;
  (* }}} *)

let uniq_drop = prove_by_refinement(
  `!k v:A s. uniq s ==> uniq (dropl k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let uniq_take = prove_by_refinement(
  `!k v:A s. uniq s ==> uniq (take k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let not_betwn1 = prove_by_refinement(
  `!x:A z s. uniq s /\ MEM z s ==> ~(MEM x (betwn s x z))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  STRIP_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ARITH_TAC);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  FIRST_X_ASSUM_ST `take` MP_TAC;
  BY(ASM_SIMP_TAC[mem_take_index])
  ]);;
  (* }}} *)

let not_betwn2 = prove_by_refinement(
  `!x:A z s. uniq s ==> ~(MEM z (betwn s x z))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM z s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[betwn_mem]);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `take` MP_TAC;
    REWRITE_TAC[take_drop_commute];
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  STRIP_TAC;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `take` MP_TAC;
  (ASM_SIMP_TAC[mem_take_index]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let indexl_betwn = prove_by_refinement(
  `!x:A y z s. uniq s /\ MEM x s /\ MEM z s /\ MEM y (betwn s x z) ==>
    SUC (indexl y (betwn s x z)) = indexf x y s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(x = y)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1]);
  REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.index_take];
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `take` MP_TAC;
    GMATCH_SIMP_TAC mem_take_index;
    ASM_SIMP_TAC[uniq_drop];
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    GMATCH_SIMP_TAC mem_drop_index;
    ASM_REWRITE_TAC[];
    REPEAT STRIP_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC indexf_cond;
    ASM_SIMP_TAC[arith `SUC i <= j ==> i <= j`];
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  COMMENT "cases";
  DISCH_TAC;
  TYPIFY `MEM y (dropl (SUC (indexl x s)) s)` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `take` kill;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    REWRITE_TAC[Seq2.APPEND_cat];
    REWRITE_TAC[Seq.index_cat];
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    GMATCH_SIMP_TAC mem_drop_index;
    ASM_REWRITE_TAC[];
    SIMP_TAC[];
    DISCH_TAC;
    GMATCH_SIMP_TAC indexf_cond;
    ASM_SIMP_TAC[arith `SUC i <= j ==> i <= j`];
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `take` MP_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  REWRITE_TAC[Seq2.APPEND_cat];
  ASM_REWRITE_TAC[Seq.index_cat];
  REWRITE_TAC[ Seq.size_drop];
  REWRITE_TAC[Seq2.index_take];
  FIRST_X_ASSUM_ST `take` MP_TAC;
  GMATCH_SIMP_TAC mem_take_index;
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  DISCH_TAC;
  GMATCH_SIMP_TAC indexf_cond;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `dropl` MP_TAC;
  GMATCH_SIMP_TAC mem_drop_index;
  ASM_SIMP_TAC[];
  DISCH_TAC THEN COND_CASES_TAC;
    TYPIFY `indexl x s = indexl y s` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  TYPIFY `indexl x s < sizel s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[Seq.index_mem])
  ]);;
  (* }}} *)

let indexf_betwn = prove_by_refinement(
  `!s x:A y z. ~(x = z) /\ uniq s /\ MEM x s /\
     MEM z s /\ MEM y (betwn s x z) ==>
    0 < indexf x y s /\ indexf x y s < indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexl_betwn [`x`;`y`;`z`;`s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  CONJ_TAC;
    BY(ARITH_TAC);
  MATCH_MP_TAC (arith (`u < PRE i ==> SUC u < i`));
  GMATCH_SIMP_TAC (GSYM size_betwn);
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.index_mem])
  ]);;
  (* }}} *)

let not_take_drop = prove_by_refinement(
  `!s x:A k. uniq s ==>  ~(MEM x (take k s) /\ MEM x (dropl k s))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq2.mem_imp_not_uniq_cat])
  ]);;
  (* }}} *)

let take_or_drop = prove_by_refinement(
  `!s x:A k. uniq s /\ MEM x s ==>  (MEM x (take k s) \/ MEM x (dropl k s))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.mem_cat])
  ]);;
  (* }}} *)

let betwn_cases = prove_by_refinement(
  `!s x:A y z. ~(x = z) /\ uniq s /\ 
    MEM x s /\ MEM y s /\ MEM z s ==>
      (y = x) \/ (y = z) \/ (MEM y (betwn s x z)) \/ MEM y (betwn s z x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(y = x)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `(y = z)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM y (betwn s x z)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `~(indexl x s =indexl z s) /\ ~(indexl x s = indexl y s) /\ ~(indexl y s = indexl z s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC THEN ASM_SIMP_TAC[arith `x < z:num ==> ~(z < x:num)`;arith `~(x < z:num) /\ ~(x = z) ==> (z < x)`;Seq2.APPEND_cat;Seq.mem_cat];
    DISCH_TAC;
    TYPIFY `MEM y (take (indexl x s) s)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `PRE` MP_TAC;
    REWRITE_TAC[ take_drop_commute];
    ASM_SIMP_TAC[arith `x < z:num ==> (PRE( z - x) + SUC x = z)`];
    FIRST_X_ASSUM MP_TAC;
    TYPIFY `MEM y (take(indexl z s) s)` ASM_CASES_TAC;
      ASM_SIMP_TAC[mem_take_index];
      ASM_SIMP_TAC[uniq_take;mem_drop_index];
      REWRITE_TAC[Seq2.index_take];
      TYPIFY `indexl y s < indexl z s` (C SUBGOAL_THEN ASSUME_TAC);
        BY(ASM_MESON_TAC[mem_take_index]);
      ASM_REWRITE_TAC[];
      BY(ASM_TAC THEN ARITH_TAC);
    REPLICATE_TAC 2 (DISCH_THEN kill);
    FIRST_X_ASSUM MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    ASM_SIMP_TAC[uniq_take;mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  COMMENT "last case";
  REWRITE_TAC[DE_MORGAN_THM];
  REWRITE_TAC[ take_drop_commute];
  TYPIFY `indexl z s < indexl x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_SIMP_TAC[arith `x < z:num ==> (PRE( z - x) + SUC x = z)`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y (take(indexl x s) s)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    ASM_SIMP_TAC[uniq_take;mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `( ~)` MP_TAC);
  ASM_SIMP_TAC[mem_take_index];
  ASM_SIMP_TAC[uniq_take;mem_drop_index];
  REWRITE_TAC[Seq2.index_take];
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_betwn_eq = prove_by_refinement(
  `!s x:A y z.
    ~(x = z) /\ uniq s /\ MEM x s /\ MEM z s ==>
    (MEM y (betwn s x z) <=>
    0 < indexf x y s /\ indexf x y s < indexf x z s
    )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    DISCH_TAC;
    MATCH_MP_TAC indexf_betwn;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y s` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC;
    FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2);
    BY(ASM_MESON_TAC[indexf_lt_sizel;arith `~(a < b:num /\ b < a)`]);
  INTRO_TAC betwn_cases [`s`;`x`;`y`;`z`];
  ASM_REWRITE_TAC[];
  TYPIFY `y = x` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[indexf_refl;arith `~(x < x:num)`]);
  TYPIFY `y = z` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[arith `~(x < x:num)`]);
  TYPIFY `~(MEM y (betwn s z x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexf_betwn [`s`;`z`;`y`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_add_left [`z`;`y`;`x`;`s`];
  ASM_SIMP_TAC[arith `x < (y:num) ==> x <= y`];
  DISCH_TAC;
  TYPIFY `indexf y x s <= indexf z x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC indexf_antisym [`y`;`x`;`s`];
  INTRO_TAC indexf_antisym [`z`;`x`;`s`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_betwn = prove_by_refinement(
  `!x y z s. ~(x = z) /\ uniq s /\ MEM x s /\ MEM y (betwn s x z) /\ MEM z s ==>
   indexf x y s + indexf y z s = indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexf_add_left;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP betwn_mem);
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC (arith `x < y:num ==> x <= y`);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  GMATCH_SIMP_TAC indexf_betwn_eq;
  ASM_REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let indexf_add_not_betwn = prove_by_refinement(
  `!x y z s. ~(x = z) /\ uniq s /\ MEM x s /\ MEM y s /\
    ~MEM y (betwn s z x) /\ MEM z s ==>
   indexf x y s + indexf y z s = indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC betwn_cases [`s`;`x`;`y`;`z`];
  ASM_REWRITE_TAC[];
  BY(REPEAT STRIP_TAC THEN ASM_SIMP_TAC[indexf_add_betwn;indexf_refl;arith `n +0 = n /\ 0 + n = n`])
  ]);;
  (* }}} *)

let next_el_refl = prove_by_refinement(
  `!(x:A) s. MEM x s /\ next_el s x = x /\ uniq s ==> s = [x]`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel s = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0;MEM]);
  TYPIFY `indexl x s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(INTRO_TAC Seq.index_mem [`x`;`s`] THEN ASM_MESON_TAC[]);
  TYPIFY `sizel s = 1` ENOUGH_TO_SHOW_TAC;
    REWRITE_TAC[Seq2.size1_eq];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_ASSUM_ST `MEM` MP_TAC;
    BY(ASM_MESON_TAC[MEM]);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq2.next_el_mod);
  PROOF_BY_CONTR_TAC;
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC (GEN_ALL Qknvmlb.SUC_MOD_NOT_EQ) [`sizel s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`indexl x s`]);
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  DISCH_TAC;
  INTRO_TAC Seq.nth_uniq [`x`;`s`;`indexl x s`;`SUC (indexl x s) MOD sizel s`];
  TYPIFY `SUC (indexl x s) MOD sizel s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[DIVISION]);
  TYPIFY_GOAL_THEN `~(indexl x s = SUC (indexl x s) MOD sizel s)` (unlist ASM_REWRITE_TAC);
    BY(ASM_MESON_TAC[MOD_LT]);
  (ASM_SIMP_TAC[Seq.nth_index]);
  BY(ASM_MESON_TAC[arith `SUC x = x + 1`])
  ]);;
  (* }}} *)

(* FWDDPHY: *)

let indexf_prev = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\  
   next_el s x = y ==> indexf y x s = 
      sizel s - 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    INTRO_TAC next_el_refl [`x`;`s`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[indexf_refl;Seq2.size1;arith `0 = 1 - 1`]);
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC sizel_gt_1;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexf_antisym [`x`;`y`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `indexf x y s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC next_el_indexf;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let not_some_none = prove_by_refinement(
  `!x:A. ~(SOME x = NONE)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

(* was show_HideDups *)

let show_hideDups = prove_by_refinement(
  `!s. showDups (hideDups s) = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups;hideDups;showDups0;the_some;not_some_none];
  AP_TERM_TAC;
  REWRITE_TAC[hideDupsRec];
  FIRST_X_ASSUM MP_TAC;
  TYPIFY `t` (fun t -> SPEC_TAC (t,t));
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups;hideDups;hideDupsRec;showDups0;the_some;not_some_none;CONS_11];
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[showDups0;CONS_11]);
  BY(ASM_REWRITE_TAC[showDups0;not_some_none;the_some;CONS_11])
  ]);;
  (* }}} *)

let some_the = prove_by_refinement(
  `!(x:(A)option). ~(x = NONE) ==> SOME (the x) = x`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_OPTION;the_some])
  ]);;
  (* }}} *)

(*
let hideDupsRec_showDups0 = prove_by_refinement(
  `!s b a c. 
     hideDupsRec c (showDups0 b []) = [] /\
     hideDupsRec c (showDups0 b (SOME a :: s)) = (if (c=a) then NONE else SOME a) :: s /\
    hideDupsRec c (showDups0 b (NONE :: s)) = g`,
  (* {{{ proof *)
  [
  rt[showDups0;the_some;not_some_none;hideDupsRec]

  LIST_INDUCT_TAC then art[hideDupsRec;showDups0;not_some_none;the_some]
  st/r then condcase then art[hideDupsRec]
  asimp[some_the]
  ]);;
  (* }}} *)
*)


let unadj = new_recursive_definition list_RECURSION
  `(unadj (([]:(A)list)) = T) /\
   unadj ((h:A) ::t) = if (t = []) then T else (~((h:A) = HD t) /\ unadj t)`;;

(* deleted image_hide1 *)

let image_hideDups = new_definition
  `image_hideDups s = 
    (s = [] \/ (unadj (filter isSome s) /\ isSome (HD s)))`;;

(*
let image_hideDups_alt = prove_by_refinement(
  `image_hideDups s = 
     ((s = []) \/ (~(s = []) /\ (unadj (filter isSome s) /\ isSome (HD s))))`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[image_hideDups])
  ]);;
  (* }}} *)
*)

let some_inj = prove_by_refinement(
  `!x y. SOME x = SOME y <=> x = y`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[the_some])
  ]);;
  (* }}} *)

let hideDups_eq_nil = prove_by_refinement(
  `!s. hideDups s = [] <=> s = []`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[hideDups;hideDupsRec;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let image_hideDups2 = prove_by_refinement(
  `!s. image_hideDups (hideDups s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[hideDups;hideDupsRec;image_hideDups;NOT_CONS_NIL;HD;Ssrbool.isSome];
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[image_hideDups];
  REWRITE_TAC[Seq.filter_cons;Ssrbool.isSome;unadj;hideDups_eq_nil];
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  TYPIFY `t = []` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `filter` MP_TAC;
    BY(ASM_REWRITE_TAC[hideDups;hideDupsRec;Seq.filter_nil]);
  ASM_REWRITE_TAC[];
  INTRO_TAC list_CASES [`t`] THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[hideDups;hideDupsRec;NOT_CONS_NIL;unadj;HD;Ssrbool.isSome];
  REPEAT (FIRST_X_ASSUM kill);
  REWRITE_TAC[Seq.filter];
  TYPIFY `h = h'` ASM_CASES_TAC THEN ASM_REWRITE_TAC[Ssrbool.isSome;Seq.filter;unadj;HD];
    BY(SIMP_TAC[]);
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[some_inj])
  ]);;
  (* }}} *)

let the_inj = prove_by_refinement(
  `!a b. isSome a /\ isSome b ==> (the a = the b <=> a = b)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_OPTION;Ssrbool.isSome;the_some];
  BY(MESON_TAC[some_inj])
  ]);;
  (* }}} *)

let hideDupsRec_show = prove_by_refinement(
  `!t a. (~(filter isSome t = []) ==> ~(a = HD (filter isSome t)) /\ unadj (filter isSome t)) /\ isSome a ==> hideDupsRec (the a) (showDups0 (the a) t) = t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups0;hideDupsRec;Seq.filter;unadj];
  GEN_TAC;
  COND_CASES_TAC;
    TYPIFY `~(h = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Ssrbool.isSome]);
    ASM_REWRITE_TAC[hideDupsRec;HD];
    ASM_SIMP_TAC[the_inj;NOT_CONS_NIL;some_the;CONS_11;unadj];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `h = NONE` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Ssrbool.isSome;some_the]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[hideDupsRec;CONS_11];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hideDups_show = prove_by_refinement(
  `!s. image_hideDups s ==> hideDups (showDups s) = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[image_hideDups;showDups;hideDups;showDups0;the_some;not_some_none;HD;NOT_CONS_NIL];
  SIMP_TAC[];
  REWRITE_TAC[Seq.filter];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `unadj` MP_TAC;
  ASM_REWRITE_TAC[unadj];
  DISCH_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[Ssrbool.isSome]);
  REWRITE_TAC[hideDups];
  ASM_SIMP_TAC[hideDups;some_the;CONS_11];
  MATCH_MP_TAC hideDupsRec_show;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_nextVertices = prove_by_refinement(
  `!v f n. MEM v (FST f) ==> MEM (nextVertices f n v) (FST f)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextVertices];
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC THEN REWRITE_TAC[ITER];
  DISCH_TAC;
  GMATCH_SIMP_TAC nextVertex_next_el;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  BY(ASM_MESON_TAC[Seq2.mem_next_el])
  ]);;
  (* }}} *)

let nextVertices0 = prove_by_refinement(
  `!f v. nextVertices f 0 v = v`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[nextVertices;ITER])
  ]);;
  (* }}} *)

let nextVertices1 = prove_by_refinement(
  `!f v. nextVertices f 1 v = nextVertex f v`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[nextVertices;ITER_1])  
  ]);;
  (* }}} *)



(*
let indexToVertexList_lt = prove_by_refinement(
  `!e f v n. MEM v (FST f) ==> 
    indexf v (nextVertices f v n) (FST f) < sizel (FST f)`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)
*)

let indexf_nextVertices = prove_by_refinement(
  `!f v n. MEM v (FST f) /\ (uniq (FST f)) /\ n < sizel (FST f) 
     ==> indexf v (nextVertices f n v) (FST f) = n`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC THEN DISCH_TAC;
    REWRITE_TAC[nextVertices0];
    MATCH_MP_TAC indexf_refl;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[nextVertices;ITER];
  REWRITE_TAC[GSYM nextVertices];
  INTRO_TAC MEM_nextVertices [`v`;`f`;`n`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[nextVertex_next_el];
  DISCH_TAC;
  INTRO_TAC indexf_add_sum [`v`;`nextVertices f n v`;`next_el (FST f) (nextVertices f n v)`;`FST f`];
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (next_el (FST f) (nextVertices f n v)) (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf v (nextVertices f n v) (FST f) = n` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `SUC n < s ==> n < s`]);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf (nextVertices f n v) (next_el (FST f) (nextVertices f n v)) (FST f) = 1` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[arith `SUC n = n+1`]);
  MATCH_MP_TAC next_el_indexf;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let enum_indexToVertexList = prove_by_refinement(
  `!e f v. MEM v (FST f) /\ (uniq (FST f)) /\ (all (\n. n < sizel (FST f)) e) ==>
    enum_of_VertexList (FST f) v (indexToVertexList f v e) = e`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs2.enum_of_VertexList;indexToVertexList];
  REWRITE_TAC[show_hideDups];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\u. indexf v u (FST f)) o (\k. nextVertices f k v)) e = MAP I e` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[I_THM;o_THM;Seq2.ALL_all;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x < sizel (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.allP]);
  MATCH_MP_TAC indexf_nextVertices;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nextVertices_indexf = prove_by_refinement(
  `!f v w. uniq (FST f) /\ MEM v (FST f) /\ MEM w (FST f) ==> 
    nextVertices f (indexf v w (FST f)) v = w`,
  (* {{{ proof *)
  [
  TYPIFY `!n f v w. uniq (FST f) /\ MEM v (FST f) /\ MEM w (FST f) /\ indexf v w (FST f)= n ==> nextVertices f n v = w` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INDUCT_TAC THEN REWRITE_TAC[nextVertices0];
    BY(MESON_TAC[indexf0]);
  REWRITE_TAC[nextVertices;ITER];
  REWRITE_TAC[GSYM nextVertices];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC MEM_nextVertices [`v`;`f`;`n`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[nextVertex_next_el];
  DISCH_TAC;
  MATCH_MP_TAC indexf1;
  ASM_REWRITE_TAC[];
  INTRO_TAC indexf_add_left [`v`;`nextVertices f n v`;`w`;`FST f`];
  ASM_REWRITE_TAC[];
  INTRO_TAC indexf_nextVertices [`f`;`v`;`n`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[indexf_lt_sizel;arith `SUC n < m ==> n < m`]);
  DISCH_TAC THEN ASM_REWRITE_TAC[arith `n <= SUC n`];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let not_isSome_NONE = prove_by_refinement(
  `!x. isSome x <=> ~(x = NONE)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FORALL_OPTION;Ssrbool.isSome;not_some_none])
  ]);;
  (* }}} *)

let MEM_showDups0 = prove_by_refinement(
  `!vs a. 
    all (\t. (t=a)\/ MEM t (MAP the (filter isSome vs))) (showDups0 a vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM Seq.allP];
  LIST_INDUCT_TAC THEN REWRITE_TAC[showDups;GSYM Seq.allP;MEM;Seq.filter;showDups0];
  REPEAT GEN_TAC;
  TYPIFY `isSome h` ASM_CASES_TAC THEN ASM_SIMP_TAC[MEM;not_isSome_NONE];
    TYPIFY `~(h=NONE)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
    ASM_REWRITE_TAC[MEM;MAP];
    BY(ASM_MESON_TAC[]);
  TYPIFY `(h=NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_isSome_NONE]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_showDups = prove_by_refinement(
  `!vs. (~(vs = []) ==> (isSome (HD vs))) ==>
    all (\t. MEM t (MAP the (filter isSome vs))) (showDups vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM Seq.allP];
  GEN_TAC;
  INTRO_TAC list_CASES [`vs`];
  REPEAT STRIP_TAC;
    BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[Seq.filter;MAP;MEM;showDups;showDups0]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[MEM;showDups;MAP;HD;NOT_CONS_NIL;Seq.filter];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[MAP;MEM];
  INTRO_TAC MEM_showDups0 [`h::t`;`the h`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq.filter;MAP;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexToVertexList_enum = prove_by_refinement(
  `!vs f v. uniq (FST f) /\ MEM v (FST f) /\ 
    image_hideDups vs /\
    all (\t.  MEM (the t) (FST f)) (filter isSome vs) ==>
    indexToVertexList f v (enum_of_VertexList (FST f) v vs) = vs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs2.enum_of_VertexList;indexToVertexList];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\k. nextVertices f k v) o (\u. indexf v u (FST f))) (showDups vs) = MAP I (showDups vs)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    REWRITE_TAC[MAP_I;I_THM];
    MATCH_MP_TAC hideDups_show;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;I_THM;o_THM;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC nextVertices_indexf;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `all` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC MEM_showDups [`vs`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[image_hideDups]);
  REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`SOME x`]);
  REWRITE_TAC[the_some];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC;
  TYPIFY `x = the (SOME x)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[the_some]);
  DISCH_TAC;
  INTRO_TAC MEMf_MAP [`SOME:num->(num)option`];
  DISCH_THEN (fun t -> (FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP t)));
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[the_some;GSYM MAP_o];
  TYPIFY `(MAP (SOME o the) (filter isSome vs)) = MAP I (filter isSome vs)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(ASM_REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP;o_THM;I_THM];
  REPEAT WEAKER_STRIP_TAC THEN MATCH_MP_TAC some_the;
  DISCH_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[Seq.mem_filter];
  BY(ASM_MESON_TAC[not_isSome_NONE])
  ]);;
  (* }}} *)

(* added 2/25/2014 *)

let inj_on_I = prove_by_refinement(
  `!L. inj_on I L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;I_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(* was iso_list_ref *)

let iso_list_refl  = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list). iso_list L L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC THEN TYPIFY `I:A->A` EXISTS_TAC;
  BY(REWRITE_TAC[I_THM;MAP_I;inj_on_I;GSYM I_DEF])
  ]);;
  (* }}} *)

let inj_on_o = prove_by_refinement(
  `!X phi phi'. inj_on phi X /\ inj_on phi' (IMAGE phi X) ==>
    inj_on (phi' o phi) X`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;o_THM;IMAGE;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[IN])
  ]);;
  (* }}} *)

let undup_map_undup = prove_by_refinement(
  `!f s. undup (MAP f (undup s)) = undup (MAP f s)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MAP;Seq.undup]);
  REWRITE_TAC[MAP;Seq.undup];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEMf_MAP]);
  ASM_REWRITE_TAC[Seq.undup;MAP];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC;
      BY(REWRITE_TAC[]);
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[MEM_MAP];
    BY(MESON_TAC[Seq.mem_undup]);
  COND_CASES_TAC;
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[MEM_MAP] THEN MESON_TAC[Seq.mem_undup]);
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let list_of_elements_map = prove_by_refinement(
  `!f s. undup (MAP f (list_of_elements s)) = list_of_elements (MAP (MAP f) s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[GSYM MAP_flatten];
  BY(REWRITE_TAC[undup_map_undup])
  ]);;
  (* }}} *)

let elements_of_list_MAP = prove_by_refinement(
  `elements_of_list (MAP (MAP phi) s) = IMAGE phi (elements_of_list s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list];
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;GSYM SET_OF_LIST_MAP];
  REWRITE_TAC[GSYM list_of_elements_map];
  BY(REWRITE_TAC[Seq.mem_undup])
  ]);;
  (* }}} *)

let iso_list_trans = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list) 
    (L':((B)list)list#((B#B)list)list)
    (L'':((C)list)list#((C#C)list)list).
   iso_list L L' /\ iso_list L' L'' ==> iso_list L L''`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `phi' o phi` EXISTS_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC inj_on_o;
    ASM_REWRITE_TAC[];
    TYPIFY `elements_of_list p1' = IMAGE phi (elements_of_list p1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[elements_of_list_MAP];
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM MAP_o];
  CONJ_TAC;
    REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
    REWRITE_TAC[FUN_EQ_THM];
    BY(REWRITE_TAC[o_THM;MAP_o]);
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[o_THM;GSYM MAP_o];
  GEN_TAC;
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP];
  BY(REWRITE_TAC[o_THM])
  ]);;
  (* }}} *)

let inj_on_INJ = prove_by_refinement(
  `!(f:A->B) s. inj_on f s <=> INJ f s (:B)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;INJ;IN_UNIV];
  BY(REWRITE_TAC[IN])
  ]);;
  (* }}} *)

let inj_on_BIJ = prove_by_refinement(
  `!f (s:A->bool). inj_on (f:A->B) s ==> BIJ f s (IMAGE f s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Lunar_deform.INJ_IMP_BIJ_IMAGE);
  TYPIFY `(:B)` EXISTS_TAC;
  BY(ASM_REWRITE_TAC[GSYM inj_on_INJ])
  ]);;
  (* }}} *)

let iso_list_sym = prove_by_refinement(
  `!(L:((A)list)list#((A#A)list)list) 
    (L':((B)list)list#((B#B)list)list).
    iso_list L L' /\
    (set_of_list (MAP FST (flatten (SND L))) SUBSET elements_of_list (FST L)) /\
    (set_of_list (MAP SND (flatten (SND L))) SUBSET elements_of_list (FST L)) 
     ==> iso_list L' L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `phi' = INVERSE phi (elements_of_list p1) (elements_of_list p1')`;
  TYPIFY `phi'` EXISTS_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP inj_on_BIJ);
  TYPIFY `IMAGE phi (elements_of_list p1) = elements_of_list p1'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[elements_of_list_MAP]);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Misc_defs_and_lemmas.INVERSE_BIJ);
  SUBCONJ_TAC;
    REWRITE_TAC[inj_on_INJ;INJ;IN_UNIV];
    BY(FIRST_X_ASSUM MP_TAC THEN ASM_MESON_TAC[BIJ;INJ]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[GSYM MAP_o];
  TYPIFY `!t. t IN (elements_of_list p1) ==> phi' (phi t) = t` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "phi'";
    GMATCH_SIMP_TAC Misc_defs_and_lemmas.INVERSE_XY;
    BY(ASM_MESON_TAC[FUN_IN_IMAGE]);
  CONJ_TAC;
    TYPIFY `MAP (MAP phi' o MAP phi) p1 = MAP I p1` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[MAP_I;I_THM]);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
    REWRITE_TAC[upper_case;GSYM MAP_o];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MAP (phi' o phi) x = MAP I x` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      BY(REWRITE_TAC[MAP_I;I_THM]);
    MATCH_MP_TAC MAP_EQ;
    REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements];
    REWRITE_TAC[Seq.mem_undup];
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  TYPIFY `MAP (MAP (\u. phi' (FST u),phi' (SND u)) o MAP (\u. phi (FST u),phi (SND u))) p2 = MAP I p2` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
  REWRITE_TAC[upper_case;GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\u. phi' (FST u),phi' (SND u)) o (\u. phi (FST u),phi (SND u))) x = MAP I x` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM;o_THM];
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `flatten` MP_TAC) THEN REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.elements_of_list];
  REWRITE_TAC[List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REPEAT WEAKER_STRIP_TAC;
  CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC[List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements] THEN REWRITE_TAC[Seq.mem_undup];
    FIRST_X_ASSUM kill;
    FIRST_X_ASSUM MATCH_MP_TAC;
    REWRITE_TAC[MEM_MAP];
    BY(TYPIFY `(p1'',p2'')` EXISTS_TAC THEN REWRITE_TAC[] THEN ASM_MESON_TAC[Seq2.mem_flatten]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  REWRITE_TAC[MEM_MAP];
  BY(TYPIFY `(p1'',p2'')` EXISTS_TAC THEN REWRITE_TAC[] THEN ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let map_good_list = prove_by_refinement(
  `!x (phi:A->B). 
    good_list x /\ inj_on phi    (elements_of_list x) ==>
    good_list (MAP (MAP phi) x)
  `,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.good_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 1;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `MEM` MP_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[MEM_EXISTS_EL];
    REWRITE_TAC[NOT_EXISTS_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `~` (C INTRO_TAC [`EL i x`]);
    ANTS_TAC;
      BY(ASM_MESON_TAC[LENGTH_MAP;MEM_EL]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `[] = u` MP_TAC THEN (ASM_SIMP_TAC[LENGTH_MAP;EL_MAP]);
    GMATCH_SIMP_TAC EL_MAP;
    CONJ_TAC;
      BY(ASM_MESON_TAC[LENGTH_MAP]);
    BY(ASM_MESON_TAC [MAP_EQ_NIL]);
  ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `[]` kill);
  COMMENT "uniq";
  REWRITE_TAC[map_list_of_darts];
  REWRITE_TAC[FORALL_PAIR_THM];
  REWRITE_TAC[MEM_MAP];
  REWRITE_TAC[EXISTS_PAIR_THM;PAIR_EQ];
  CONJ2_TAC;
    X_GENv_TAC "q1";
    X_GENv_TAC "q2";
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`(p1,p2)`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM Seq.map_MAP];
  GMATCH_SIMP_TAC Seq.map_inj_in_uniq;
  ASM_REWRITE_TAC[PAIR_EQ];
  MATCH_MP_TAC inj_on_imp_inj_dart;
  BY(ASM_REWRITE_TAC[])
]);;
  (* }}} *)

let find_face_map = prove_by_refinement(
  `!p1 p2 x. good_list x /\ inj_on phi (elements_of_list x) /\
     MEM (p1,p2) (list_of_darts x) ==>
    find_face (MAP (MAP phi) x) (phi p1,phi p2) = 
    MAP (\d. phi(FST d),phi(SND d)) (find_face x (p1,p2))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC List_hypermap.find_face_eq;
  INTRO_TAC map_good_list [`x`;`phi`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  SUBCONJ_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.good_list]);
    REWRITE_TAC[map_list_of_darts;MEM_MAP;EXISTS_PAIR_THM;PAIR_EQ];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[MEM_MAP;EXISTS_PAIR_THM;PAIR_EQ];
    GEXISTL_TAC [`p1`;`p2`];
    BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
  FIRST_X_ASSUM MP_TAC;
  FIRST_ASSUM (MP_TAC o (MATCH_MP List_hypermap.mem_find_face));
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[GSYM MAP_o];
  TYPIFY `list_pairs o (MAP phi) = MAP (\d. phi (FST d),phi (SND d)) o list_pairs` (C SUBGOAL_THEN SUBST1_TAC);
    BY(MESON_TAC[GSYM map_list_pairs;FUN_EQ_THM;o_THM]);
  REWRITE_TAC[MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.map_MAP];
  MATCH_MP_TAC Seq.map_f;
  BY(ASM_MESON_TAC[Seq.map_MAP])
  ]);;
  (* }}} *)

let hypermap_of_list_map = prove_by_refinement(
  `!x (phi:A->B). good_list x /\ inj_on phi (elements_of_list x) ==>
    iso (hypermap_of_list x) (hypermap_of_list (MAP (MAP phi) x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC map_good_list [`x`;`phi`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC Hypermap_iso.hyp_iso_imp_iso;
  TYPIFY `(\ u. phi (FST u),phi (SND u))` EXISTS_TAC;
  REWRITE_TAC[Hypermap_iso.hyp_iso_edge_face];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[FORALL_PAIR_THM];
  COMMENT "BIJ";
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[BIJ_IMAGE_darts_of_list]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "0";
  TYPIFY `phi p1,phi p2 IN darts_of_list (MAP (MAP phi) x)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `BIJ` MP_TAC THEN REWRITE_TAC[BIJ;SURJ;FORALL_PAIR_THM];
    BY(ASM_MESON_TAC[]);
  REPEAT (GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list);
  TYPIFY `MEM (p1,p2) (list_of_darts x) /\  MEM (phi p1,phi p2) (list_of_darts (MAP (MAP phi) x))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;GSYM List_hypermap.darts_of_list]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[List_hypermap.e_list];
  COMMENT "f_list";
  REPEAT (GMATCH_SIMP_TAC f_list_ext_f_list);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[ List_hypermap.f_list];
  GMATCH_SIMP_TAC find_face_map;
  ASM_REWRITE_TAC[];
  TYPIFY `(phi p1,phi p2) = (\d. phi (FST d),phi (SND d)) (p1,p2)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[]);
  GMATCH_SIMP_TAC next_el_MEM_map;
  SUBCONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_find_face;
    BY(RULE_ASSUM_TAC(REWRITE_RULE[List_hypermap.good_list]) THEN ASM_REWRITE_TAC[]);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o (MATCH_MP inj_on_imp_inj_dart));
  FIRST_X_ASSUM (fun t -> MATCH_MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] t));
  RULE_ASSUM_TAC (REWRITE_RULE[PAIR_EQ]) THEN ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC(REWRITE_RULE[List_hypermap.good_list]) THEN ASM_REWRITE_TAC[];
  TYPIFY `find_face x u = find_face x (p1,p2) /\ find_face x v = find_face x (p1,p2)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_faces_eq]);
  BY(ASM_MESON_TAC[List_hypermap.dart_in_face])
  ]);;
  (* }}} *)

let GNBEVVU = prove_by_refinement(
  `!L N L' N'. 
    good_list L /\ iso_list (L,N) (L',N') ==> 
    iso (hypermap_of_list L) (hypermap_of_list L')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC (* Elllnyz. *) hypermap_of_list_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let iso_list_non_nil = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ all (\l. ~(l = [])) L ==>
					    all (\l. ~(l = [])) L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC THEN ASM_REWRITE_TAC[MAP_EQ_NIL];
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[MAP_EQ_NIL])
  ]);;
  (* }}} *)

let iso_list_uniq = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ uniq (list_of_darts L) ==>
					    uniq (list_of_darts L')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[map_list_of_darts];
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[PAIR_EQ];
  BY(ASM_MESON_TAC[inj_on_imp_inj_dart])
  ]);;
  (* }}} *)


let iso_list_good_list = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ 
    good_list L ==>
    good_list L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC (* Elllnyz. *) map_good_list;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let PEUTLZH = iso_list_good_list;;

let iso_list_good_list_nodes = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) /\ 
    good_list L /\ good_list_nodes L ==>
    good_list_nodes L'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso (hypermap_of_list L) (hypermap_of_list L')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[GNBEVVU]);
  TYPIFY `good_list L'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[PEUTLZH]);
  ASM_TAC THEN REWRITE_TAC[iso_list;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC List_hypermap.good_list_nodes_condition;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[GSYM Hypermap.number_of_nodes];
  FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.iso_imp_hyp_iso);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.iso_number_of_nodes [`f`;`hypermap_of_list L'`;`hypermap_of_list L`];
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  REWRITE_TAC[GSYM list_of_elements_map];
  INTRO_TAC uniq_map [`list_of_elements L`;`phi`];
  ANTS_TAC;
    REWRITE_TAC[List_hypermap.uniq_list_of_elements];
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    REWRITE_TAC[inj_on;List_hypermap.elements_of_list;IN_SET_OF_LIST];
    BY(REWRITE_TAC[IN;GSYM IN_SET_OF_LIST]);
  SIMP_TAC[Seq.undup_id];
  REWRITE_TAC[lower_case;Seq.size_map];
  BY(ASM_MESON_TAC[Hypermap.number_of_nodes;List_hypermap.good_list_nodes_condition])
  ]);;
  (* }}} *)

let OISRWOF = iso_list_good_list_nodes;;

let IN_ELIM_SET_OF_LIST = prove_by_refinement(
  `!u s. set_of_list s u = MEM u s`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

let iso_list_all_uniq = prove_by_refinement(
  `!L L'. iso_list(L,[]) (L',[]) /\
    all uniq L ==> all uniq L'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[iso_list] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `all` MP_TAC;
  ASM_REWRITE_TAC[GSYM Seq.allP;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x'`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `inj_on` MP_TAC;
  REWRITE_TAC[inj_on;List_hypermap.elements_of_list;IN_SET_OF_LIST;List_hypermap.list_of_elements];
  ASM_REWRITE_TAC[Seq2.set_of_list_undup];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Seq2.mem_flatten;IN;IN_ELIM_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let UEYETNI = iso_list_all_uniq;;

let normal_list_list_of_darts = prove_by_refinement(
  `!L N. normal_list L N ==> all (\x. MEM x (list_of_darts L)) (flatten N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list;loop_list;GSYM Seq.allP];
  BY(ASM_MESON_TAC[Seq2.mem_flatten])
  ]);;
  (* }}} *)

let normal_list_darts_of_list = prove_by_refinement(
  `!L N. normal_list L N ==> (set_of_list (flatten N) SUBSET (darts_of_list L))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list;loop_list;GSYM Seq.allP];
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.darts_of_list];
  REWRITE_TAC[Seq2.mem_flatten];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let normal_list_darts_of_list_mem = prove_by_refinement(
  `!L N. normal_list L N ==> (all (\x. MEM x(list_of_darts L)) (flatten N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list;loop_list;GSYM Seq.allP];
  REWRITE_TAC[Seq2.mem_flatten];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_sym_normal = prove_by_refinement(
  `!L N L' N'. normal_list L N /\ iso_list (L,N) (L',N') ==> iso_list (L',N') (L,N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC iso_list_sym;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
  INTRO_TAC normal_list_list_of_darts [`L`;`N`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  REWRITE_TAC[List_hypermap.list_of_darts_alt;Seq2.mem_flatten;List_hypermap.list_of_faces];
  REWRITE_TAC[MEM_MAP;List_hypermap.list_pairs];
  REWRITE_TAC[FORALL_PAIR_THM;EXISTS_PAIR_THM];
  BY(MESON_TAC[Seq.mem_rot;Seq2.mem_zip])
  ]);;
  (* }}} *)

let normal_list_nil = prove_by_refinement(
  `!L. normal_list L []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[normal_list];
  BY(REWRITE_TAC[concat_flatten;Seq.all;MEM;Seq.uniq])
  ]);;
  (* }}} *)

let iso_list_sym_nil = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) ==> iso_list (L',[]) (L,[])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC iso_list_sym_normal;
  BY(ASM_REWRITE_TAC[normal_list_nil])
  ]);;
  (* }}} *)

let iso_list_sym_nil_eq = prove_by_refinement(
  `!L L'. iso_list (L,[]) (L',[]) <=> iso_list (L',[]) (L,[])`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[iso_list_sym_nil])
  ]);;
  (* }}} *)

let INJ_NUM_EXISTS = prove_by_refinement(
  `!A:A->bool. FINITE A ==> (?j:A->num. inj_on j A)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[inj_on_INJ];
  INTRO_TAC Counting_spheres.INJ_FINITE_EXISTS [`CARD A`;`A`;`1..(CARD A)`];
  REWRITE_TAC[HAS_SIZE;FINITE_NUMSEG;CARD_NUMSEG_1];
  ASM_REWRITE_TAC[arith `n:num <= n`];
  REWRITE_TAC[INJ;IN_UNIV];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let JXBJOAB = prove_by_refinement(
  `!(L:((A)list)list). 
   ?(Ln:((num)list)list). iso_list (L,[]) (Ln,[])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[iso_list;MAP];
  INTRO_TAC INJ_NUM_EXISTS [`elements_of_list L`];
  REWRITE_TAC[List_hypermap.elements_of_list;FINITE_SET_OF_LIST];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_num = JXBJOAB;;

let inj_on_dart_of_list = prove_by_refinement(
  `!p L. inj_on (p:A->B) (elements_of_list L) ==> 
    inj_on (\t. p(FST t),p(SND t))   (darts_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;List_hypermap.darts_of_list;List_hypermap.elements_of_list];
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REWRITE_TAC[IN_ELIM_SET_OF_LIST];
  BY(MESON_TAC[mem_list_of_darts_imp_mem_list_of_elements_alt])
  ]);;
  (* }}} *)

let iso_list_uniq_flatten = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. normal_list L N /\
      iso_list (L,N) (L',N') ==> uniq (flatten N')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[GSYM MAP_flatten];
  MATCH_MP_TAC uniq_map;
  ASM_REWRITE_TAC[];
  INTRO_TAC inj_on_subset [`nphi`;`darts_of_list L`;`set_of_list(flatten N)`];
  ASM_REWRITE_TAC[inj_on];
  BY(REWRITE_TAC[IN_ELIM_SET_OF_LIST])
  ]);;
  (* }}} *)

let iso_list_all_nonnil = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. normal_list L N /\
      iso_list (L,N) (L',N') ==> all (\s. ~(s = [])) N'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `s = []` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[MAP_EQ_NIL];
  BY(ASM_MESON_TAC[MAP_EQ_NIL])
  ]);;
  (* }}} *)

let iso_list_all_darts = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. normal_list L N /\
      iso_list (L,N) (L',N') ==> all (\x. MEM x(list_of_darts L')) (flatten N')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list_mem [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REWRITE_TAC[GSYM MAP_flatten];
  ASM_REWRITE_TAC[map_list_of_darts];
  REWRITE_TAC[MEM_MAP];
  FIRST_X_ASSUM_ST `all` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* was inj_on_e_list *)

let e_list_fun = prove_by_refinement(
  `!phi:A->B x. 
  (let nphi = (\u. phi (FST u),phi (SND u)) in
   (    e_list (nphi x) = nphi (e_list x)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  BY(REWRITE_TAC[List_hypermap.e_list])
  ]);;
  (* }}} *)


let f_list_map = prove_by_refinement(
  `!L phi x. good_list L /\ inj_on phi (elements_of_list L) /\
     MEM x (list_of_darts L) ==>
    (let nphi = (\u. phi (FST u),phi (SND u)) in
       f_list (MAP (MAP phi) L) (nphi x) = nphi (f_list L x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[LET_THM];
  REWRITE_TAC[List_hypermap.f_list];
  GMATCH_SIMP_TAC (* Elllnyz. *) find_face_map;
  ASM_REWRITE_TAC[];
  TYPIFY `(phi p1,phi p2) = (\d. phi (FST d),phi (SND d)) (p1,p2)` ((C SUBGOAL_THEN SUBST1_TAC));
    BY(REWRITE_TAC[]);
  GMATCH_SIMP_TAC next_el_MEM_map;
  TYPED_ABBREV_TAC `s = find_face L (p1,p2)`;
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face]);
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;List_hypermap.good_list]);
  ASM_REWRITE_TAC[];
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[inj_on;List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_faces_eq;List_hypermap.good_list;List_hypermap.dart_in_face])
  ]);;
  (* }}} *)

let uniq_flatten_uniq = prove_by_refinement(
  `!L s. uniq (flatten L) /\ MEM s L ==> uniq s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[Seq.flatten_cons;MEM;Seq.cat_uniq;];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let good_list_e_list = prove_by_refinement(
  `!L d. good_list L /\ MEM d (list_of_darts L) ==> 
    MEM (e_list d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.e_list];
  BY(MESON_TAC[List_hypermap.good_list])
  ]);;
  (* }}} *)

let iso_list_all_loop_list = prove_by_refinement(
  `!(L:((A)list)list) N L' N'. good_list L /\ normal_list L N /\
      iso_list (L,N) ((L':((B)list)list),N') ==> all (loop_list L') N'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list_mem [`L`;`N`];
  REWRITE_TAC[loop_list;GSYM Seq.allP];
  INTRO_TAC iso_list_all_darts [`L`;`N`;`L'`;`N'`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  CONJ_TAC;
    REPEAT (FIRST_X_ASSUM_ST `list_of_darts` MP_TAC) THEN ASM_REWRITE_TAC[GSYM Seq.allP];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  COMMENT "second conj";
  REWRITE_TAC[one_step_list];
  INTRO_TAC f_list_map [`L`;`phi:A->B`];
  LET_TAC;
  ASM_REWRITE_TAC[];
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC e_list_fun [`phi`;`x'''`];
  LET_TAC;
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  FIRST_X_ASSUM_ST `f_list` (REPEAT o GMATCH_SIMP_TAC );
  REPEAT (GMATCH_SIMP_TAC next_el_MEM_map);
  REWRITE_TAC[List_hypermap.f_list];
  COMMENT "now do conj";
  REPLICATE_TAC 7 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[];
  FIRST_X_ASSUM kill;
  REPLICATE_TAC 2 DISCH_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM kill;
  REPEAT WEAKER_STRIP_TAC;
  RENAME_FREE_VAR (`x'':(A#A)list`,"r");
  RENAME_FREE_VAR (`x:(B#B)list`,"r'");
  RENAME_FREE_VAR (`x''':(A#A)`,"d");
  RENAME_FREE_VAR (`x':(B#B)`,"d'");
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    MATCH_MP_TAC uniq_flatten_uniq;
    BY(TYPIFY `N` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC;
    FIRST_X_ASSUM_ST `flatten` MP_TAC;
    REWRITE_TAC[Seq2.mem_flatten;List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    MATCH_MP_TAC good_list_e_list;
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Seq2.mem_flatten] THEN ASM_MESON_TAC[]);
  DISCH_TAC;
  SUBCONJ_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_REWRITE_TAC[Seq2.mem_flatten] THEN ASM_MESON_TAC[]);
  DISCH_TAC;
  TYPIFY `(next_el r d) =  (next_el (find_face L d) d) \/ (next_el r d) =  (next_el (find_face L (e_list d)) (e_list d))` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  FIRST_X_ASSUM_ST `loop_list` MP_TAC;
  REWRITE_TAC[loop_list;GSYM Seq.allP;one_step_list];
  REWRITE_TAC[List_hypermap.f_list];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let LAST_MAP = prove_by_refinement(
  `!s f. ~(s = []) ==> LAST (MAP f s) = f (LAST s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(MAP f s = [])` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[MAP_EQ_NIL]);
  ASM_REWRITE_TAC[GSYM Seq.map_MAP];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[last_LAST;Seq.last_map])
  ]);;
  (* }}} *)

let iso_list_f_last = prove_by_refinement(
  `!(L:((A)list)list) N (L':((B)list)list) N'. good_list L /\ normal_list L N /\
      iso_list (L,N) (L',N') ==> all (f_last L') N'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list_mem [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[GSYM Seq.allP;f_last];
  GEN_TAC;
  INTRO_TAC f_list_map [`L`;`phi`];
  LET_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `~( x' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.allP]);
  ASM_SIMP_TAC[LAST_MAP];
  FIRST_X_ASSUM_ST `f_list` GMATCH_SIMP_TAC;
  GMATCH_SIMP_TAC next_el_MEM_map;
  nCONJ_TAC 1;
    MATCH_MP_TAC MEM_LAST;
    BY(ASM_REWRITE_TAC[]);
  TYPED_ABBREV_TAC `d =  LAST x'`;
  FIRST_X_ASSUM_ST `flatten` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 3;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(TYPIFY `x'` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    MATCH_MP_TAC uniq_flatten_uniq;
    BY(TYPIFY `N` EXISTS_TAC THEN ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FIRST_X_ASSUM_ST `inj_on` MP_TAC;
    REWRITE_TAC[inj_on];
    REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC;
    FIRST_X_ASSUM_ST `==>` MP_TAC;
    REWRITE_TAC[Seq2.mem_flatten;List_hypermap.darts_of_list;IN_ELIM_SET_OF_LIST];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  AP_TERM_TAC;
  FIRST_X_ASSUM_ST `f_last` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP;f_last];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_iso_hypermap_of_list = prove_by_refinement(
  `!x (phi:A->B). good_list x /\ inj_on phi (elements_of_list x) ==>
    hyp_iso (\u. phi(FST u),phi (SND u)) ((hypermap_of_list x), (hypermap_of_list (MAP (MAP phi) x)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (* Elllnyz. *) map_good_list [`x`;`phi`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  REWRITE_TAC[Hypermap_iso.hyp_iso_edge_face];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[FORALL_PAIR_THM];
  COMMENT "BIJ";
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[BIJ_IMAGE_darts_of_list]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "0";
  TYPIFY `phi p1,phi p2 IN darts_of_list (MAP (MAP phi) x)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `BIJ` MP_TAC THEN REWRITE_TAC[BIJ;SURJ;FORALL_PAIR_THM];
    BY(ASM_MESON_TAC[]);
  REPEAT (GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list);
  TYPIFY `MEM (p1,p2) (list_of_darts x) /\  MEM (phi p1,phi p2) (list_of_darts (MAP (MAP phi) x))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;GSYM List_hypermap.darts_of_list]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[List_hypermap.e_list];
  COMMENT "f_list";
  REPEAT (GMATCH_SIMP_TAC f_list_ext_f_list);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[ List_hypermap.f_list];
  GMATCH_SIMP_TAC (* Elllnyz. *) find_face_map;
  ASM_REWRITE_TAC[];
  TYPIFY `(phi p1,phi p2) = (\d. phi (FST d),phi (SND d)) (p1,p2)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[]);
  GMATCH_SIMP_TAC next_el_MEM_map;
  SUBCONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_find_face;
    BY(RULE_ASSUM_TAC(REWRITE_RULE[List_hypermap.good_list]) THEN ASM_REWRITE_TAC[]);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o (MATCH_MP inj_on_imp_inj_dart));
  FIRST_X_ASSUM (fun t -> MATCH_MP_TAC (REWRITE_RULE[TAUT `(a ==> b ==> c) <=> (a /\ b ==> c)`] t));
  RULE_ASSUM_TAC (REWRITE_RULE[PAIR_EQ]) THEN ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC(REWRITE_RULE[List_hypermap.good_list]) THEN ASM_REWRITE_TAC[];
  TYPIFY `find_face x u = find_face x (p1,p2) /\ find_face x v = find_face x (p1,p2)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_faces_eq]);
  BY(ASM_MESON_TAC[List_hypermap.dart_in_face])
  ]);;
  (* }}} *)

let dart_hypermap_of_list = prove_by_refinement(
  `!(L:((A)list)list). good_list L ==> 
   (dart(hypermap_of_list L) = set_of_list (list_of_darts (L)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.components_hypermap_of_list [`L`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[List_hypermap.darts_of_list])
  ]);;
  (* }}} *)

let list_pairs_unique = prove_by_refinement(
  `!f:(A)list d1 d2. uniq f /\ MEM d1 (list_pairs f) /\ MEM d2 (list_pairs f) /\
     FST d1 = FST d2 ==> d1 = d2`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_explicit])
  ]);;
  (* }}} *)

let iso_list_normal_node = prove_by_refinement(
  `!(L:((A)list)list) N (L':((B)list)list) N' d'. good_list L /\ 
    normal_list L N /\ MEM d' (flatten N') /\
      iso_list (L,N) (L',N') ==> 
    node(hypermap_of_list L') d' SUBSET set_of_list (flatten N')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list_mem [`L`;`N`];
  ASM_REWRITE_TAC[] THEN ASM_TAC THEN REWRITE_TAC[iso_list;normal_list];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nphi = (\u. phi(FST u),phi(SND u))`;
  INTRO_TAC inj_on_dart_of_list [`phi`;`L`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC hyp_iso_hypermap_of_list [`L`;`phi`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Lp_gen_theory.components_iso_image [`hypermap_of_list L'`;`nphi`;`hypermap_of_list L`];
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `MEM d' (flatten N')` MP_TAC;
  ASM_REWRITE_TAC[Seq2.mem_flatten];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC);
  ASM_REWRITE_TAC[MEM_MAP] THEN REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  (FIRST_X_ASSUM (C INTRO_TAC [`x'`]));
  DISCH_THEN GMATCH_SIMP_TAC;
  REWRITE_TAC[GSYM MAP_flatten];
  REWRITE_TAC[SET_OF_LIST_MAP];
  ASM_SIMP_TAC[(* Wmlnymd. *) dart_hypermap_of_list];
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  SUBCONJ_TAC;
    FIRST_X_ASSUM_ST `all` MP_TAC;
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x'`]);
  ANTS_TAC;
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let iso_list_normal = prove_by_refinement(
 `!L N L' N'.
  good_list L /\ iso_list (L,N) (L',N') /\ normal_list L N ==>
  normal_list L' N'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[normal_list];
  nCONJ_TAC 4;
    BY(ASM_MESON_TAC[iso_list_normal_node]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 3;
    BY(ASM_MESON_TAC[ iso_list_all_loop_list]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[iso_list_f_last]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[iso_list_all_nonnil]);
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[iso_list_uniq_flatten]);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let XKDZKWV = iso_list_normal;;

let planegraph_PlaneGraphs = prove_by_refinement(
  `!g. PlaneGraphs g <=> (planegraph g /\ finalGraph g)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[planegraph;PlaneGraphs];
  REWRITE_TAC[UNIONS;IN_ELIM_THM];
  REWRITE_TAC[IN_IMAGE;IN_UNIV];
  REWRITE_TAC[MESON [] `(?u. (?x. u = planeGraphsP x) /\ g IN u) <=> (?x. g IN planeGraphsP x)`];
  REWRITE_TAC[PlaneGraphsP;IN_ELIM_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let loop_map_next_el = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> loop_map (loop_of_list s) = (next_el s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[loop_of_list];
  REWRITE_TAC[ (GSYM (CONJUNCT2 Hypermap.loop_tybij))];
  REWRITE_TAC[Hypermap.loop_map];
  INTRO_TAC (GSYM (CONJUNCT2 Hypermap.loop_tybij)) [`set_of_list s, (next_el s)`];
  REWRITE_TAC[];
  REWRITE_TAC[FINITE_SET_OF_LIST;IN_SET_OF_LIST];
  ASM_SIMP_TAC[Seq2.next_el_permutes];
  TYPIFY_GOAL_THEN `(?x. MEM x s /\ orbit_map (next_el s) x = set_of_list s)` (unlist REWRITE_TAC);
    TYPIFY `HD s` EXISTS_TAC;
    SUBCONJ_TAC;
      MATCH_MP_TAC MEM_HD;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    MATCH_MP_TAC Seq2.next_el_orbit;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[PAIR_EQ2];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let dart_of_loop_of_list = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> dart_of_loop (loop_of_list s) = set_of_list s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[loop_of_list];
  REWRITE_TAC[ (GSYM (CONJUNCT2 Hypermap.loop_tybij))];
  INTRO_TAC (GSYM (CONJUNCT2 Hypermap.loop_tybij)) [`set_of_list s, next_el s`];
  REWRITE_TAC[];
  REWRITE_TAC[FINITE_SET_OF_LIST;IN_SET_OF_LIST];
  ASM_SIMP_TAC[Seq2.next_el_permutes];
  TYPIFY_GOAL_THEN `(?x. MEM x s /\ orbit_map (next_el s) x = set_of_list s)` (unlist REWRITE_TAC);
    TYPIFY `HD s` EXISTS_TAC;
    SUBCONJ_TAC;
      MATCH_MP_TAC MEM_HD;
      BY(ASM_REWRITE_TAC[]);
    DISCH_TAC;
    MATCH_MP_TAC Seq2.next_el_orbit;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[Hypermap.dart_of_loop];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let inverse_e_list_ext = prove_by_refinement(
  `!L. good_list (L:((A)list)list) ==> inverse(e_list_ext L) = e_list_ext L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC INVERSE_UNIQUE_o;
  MATCH_MP_TAC (TAUT `a ==> a /\ a`);
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[List_hypermap.e_list_ext;good_list];
  REWRITE_TAC[Hypermap.res;FUN_EQ_THM;I_THM;o_THM];
  REWRITE_TAC[Hypermap.res;List_hypermap.darts_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[FORALL_PAIR_THM;EXISTS_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[List_hypermap.e_list];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `~` MP_TAC THEN ASM_REWRITE_TAC[List_hypermap.e_list];
  BY(ASM_MESON_TAC[])
    ]);;
  (* }}} *)

let inverse_n_list_ext = prove_by_refinement(
  `!L. good_list L ==> inverse(n_list_ext L) = f_list_ext L o e_list_ext L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC List_hypermap.n_eq_e_fi;
  CONJ_TAC;
    BY(ASM_MESON_TAC[good_list]);
  GMATCH_SIMP_TAC PERMUTATION_INVERSE_COMPOSE;
  GMATCH_SIMP_TAC PERMUTATION_INVERSE;
  GMATCH_SIMP_TAC PERMUTES_INVERSE_INVERSE;
  GMATCH_SIMP_TAC inverse_e_list_ext;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[PERMUTATION_PERMUTES];
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  TYPIFY `FINITE (darts_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[List_hypermap.darts_of_list;FINITE_SET_OF_LIST]);
  BY(ASM_MESON_TAC[List_hypermap.f_list_ext_permutes_darts;List_hypermap.e_list_ext_permutes_darts])
  ]);;
  (* }}} *)

let e_list_ext_n_f = prove_by_refinement(
  `!L. good_list L ==> e_list_ext L = n_list_ext L o f_list_ext L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC List_hypermap.n_eq_e_fi;
  CONJ_TAC;
    BY(ASM_MESON_TAC[good_list]);
  REWRITE_TAC[GSYM o_ASSOC];
  TYPIFY `inverse (f_list_ext L) o f_list_ext L = I` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[I_O_ID]);
  INTRO_TAC PERMUTES_INVERSES_o [`f_list_ext L`;`darts_of_list L`];
  GMATCH_SIMP_TAC List_hypermap.f_list_ext_permutes_darts;
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let is_loop_of_list = prove_by_refinement(
  `!L r. good_list L /\ uniq r /\ ~(r = []) /\ loop_list L r 
   ==> is_loop (hypermap_of_list L) (loop_of_list r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_loop;Hypermap.in_dart_of_loop];
  SIMP_TAC[dart_of_loop_of_list;loop_map_next_el];
  REWRITE_TAC[IN_SET_OF_LIST;loop_list;GSYM Seq.allP;one_step_list];
  REWRITE_TAC[Hypermap.one_step_contour];
  REPEAT STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x`]) THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    ASM_REWRITE_TAC[];
    DISJ1_TAC;
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    INTRO_TAC f_list_ext_f_list [`L`;`x`];
    ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list];
    BY(DISCH_THEN (unlist REWRITE_TAC));
  ASM_REWRITE_TAC[];
  DISJ2_TAC;
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  ASM_SIMP_TAC[inverse_n_list_ext];
  REWRITE_TAC[o_THM];
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  GMATCH_SIMP_TAC f_list_ext_f_list;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
  MATCH_MP_TAC good_list_e_list;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let in_dart_loop_of_list = prove_by_refinement(
  `!r x. uniq r /\ ~(r = []) ==> (x IN dart_of_loop (loop_of_list r) <=> MEM x r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_SIMP_TAC[dart_of_loop_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let is_restricted_nonnil = prove_by_refinement(
  `!L. good_list L /\ is_restricted (hypermap_of_list L) ==> ~(L=[])`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_restricted];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `{}` MP_TAC);
  ASM_REWRITE_TAC[NOT_IN_EMPTY;EXTENSION];
  FIRST_X_ASSUM_ST `good_list` MP_TAC;
  BY(ASM_SIMP_TAC[(* Wmlnymd. *)dart_hypermap_of_list;IN_SET_OF_LIST;List_hypermap.list_of_darts_nil;MEM])
  ]);;
  (* }}} *)

let is_restricted_e_list_nondeg = prove_by_refinement(
  `!L d. good_list L /\ is_restricted (hypermap_of_list L) /\ 
    MEM d (list_of_darts L) ==> ~(e_list d = d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_restricted;Hypermap.is_edge_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `edge_map` MP_TAC);
  ASM_SIMP_TAC[(* Wmlnymd. *) dart_hypermap_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `d` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  BY(ASM_SIMP_TAC[Lp_gen_theory.e_list_ext_eq_e_list])
  ]);;
  (* }}} *)

let node_of_element = prove_by_refinement(
  `!L (v:A).  MEM v (list_of_elements L) ==>
    MEM (filter (\d. FST d = v) (list_of_darts L)) (list_of_nodes L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_nodes;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v` EXISTS_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let MEM_hypermap_of_list_node = prove_by_refinement(
  `!L x y.  good_list_nodes L /\ MEM x (list_of_darts L) ==>
     (y IN (node (hypermap_of_list L) x) <=>
     (FST x = FST y /\ MEM y (list_of_darts L)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC More_list_hypermap.node_hypermap_of_list_explicit;
  TYPIFY ` ((filter (\d. FST d = FST x) (list_of_darts L)))` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    CONJ_TAC;
      MATCH_MP_TAC node_of_element;
      INTRO_TAC mem_list_of_darts_imp_mem_list_of_elements_alt [`L`;`FST x`;`SND x`];
      BY(ASM_MESON_TAC[PAIR]);
    BY(ASM_REWRITE_TAC[filter_FILTER;MEM_FILTER]);
  ASM_REWRITE_TAC[IN_SET_OF_LIST;filter_FILTER;MEM_FILTER];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(* used to get at least two nodes on each contour loop in normal-list *)

let is_restricted_node_f_list = prove_by_refinement(
  `!L (d:A#A). good_list L /\ good_list_nodes L /\
    is_restricted (hypermap_of_list L) /\
    MEM d (list_of_darts L) ==> ~(FST (f_list L d) = FST d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_restricted;List_hypermap.f_list];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `dart` MP_TAC;
  ASM_SIMP_TAC[(* Wmlnymd. *) dart_hypermap_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `d` EXISTS_TAC;
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `next_el (find_face L d) d = d` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    INTRO_TAC next_el_refl [`d`;`find_face L d`];
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      CONJ2_TAC;
        BY(ASM_MESON_TAC[List_hypermap.uniq_find_face;List_hypermap.good_list]);
      BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
    DISCH_TAC;
    FIRST_X_ASSUM_ST `face` MP_TAC;
    ASM_SIMP_TAC[List_hypermap.card_face_of_list];
    REWRITE_TAC[Seq2.size1];
    BY(ARITH_TAC);
  FIRST_X_ASSUM_ST `simple_hypermap` MP_TAC;
  REWRITE_TAC[Hypermap.simple_hypermap];
  ASM_SIMP_TAC[(* Wmlnymd. *) dart_hypermap_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[EXTENSION;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `f_list L d IN node (hypermap_of_list L) d /\ f_list L d IN face (hypermap_of_list L) d` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[List_hypermap.f_list]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM kill);
  ASM_SIMP_TAC[(* Wmlnymd. *) MEM_hypermap_of_list_node];
  TYPIFY ` (face_map (hypermap_of_list L) d) IN (face (hypermap_of_list L) d)` (C SUBGOAL_THEN ASSUME_TAC);
    ONCE_REWRITE_TAC[GSYM Rnsyjxm.face_face_map_eq];
    BY(REWRITE_TAC[Hypermap.face_refl]);
  nCONJ_TAC 2;
    FIRST_X_ASSUM MP_TAC;
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    GMATCH_SIMP_TAC f_list_ext_f_list;
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list]);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[List_hypermap.f_list]);
  BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.mem_f_list;List_hypermap.find_face_f_list;List_hypermap.good_list])
  ]);;
  (* }}} *)

let normal_list_normal_is_loop = prove_by_refinement(
  `!L N r. is_restricted (hypermap_of_list L) /\ 
  good_list L /\ normal_list L N /\ r IN (loop_family_of_list N) ==>
   is_loop (hypermap_of_list L) r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC is_loop_of_list;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `normal_list` MP_TAC;
  REWRITE_TAC[normal_list];
  REWRITE_TAC[GSYM Seq.allP];
  BY(ASM_MESON_TAC[uniq_flatten_uniq])
  ]);;
  (* }}} *)

let normal_list_in_dart_of_loop = prove_by_refinement(
  `!L N r. is_restricted (hypermap_of_list L) /\ 
  good_list L /\ normal_list L N /\ r IN (loop_family_of_list N) ==>
   (?x. x IN dart (hypermap_of_list L) /\ in_dart_of_loop x r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  ASM_SIMP_TAC[(* Tame_list.*) dart_hypermap_of_list;IN_SET_OF_LIST];
  TYPIFY `?t. MEM t x` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `t` EXISTS_TAC;
    GMATCH_SIMP_TAC in_dart_loop_of_list;
    REWRITE_TAC[List_hypermap.mem_not_nil];
    INTRO_TAC normal_list_list_of_darts [`L`;`N`] THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[Tame_defs2.normal_list];
    BY(ASM_MESON_TAC[(* Tame_list. *)uniq_flatten_uniq]);
  FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[Tame_defs2.normal_list];
  REWRITE_TAC[GSYM Seq.allP];
  BY(ASM_MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let normal_list_uniq_nonnil = prove_by_refinement(
  `!L N r. normal_list L N /\ MEM r N ==> (uniq r /\ ~(r = []))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Tame_defs2.normal_list];
  REWRITE_TAC[GSYM Seq.allP];
  BY(ASM_MESON_TAC[(* Tame_list. *)uniq_flatten_uniq])
  ]);;
  (* }}} *)

let normal_list_nodes_exist = prove_by_refinement(
  `!L N r. is_restricted (hypermap_of_list L) /\ 
  good_list L /\ good_list_nodes L /\
    normal_list L N /\ r IN (loop_family_of_list N) ==>
   (?y z. in_dart_of_loop y r /\
                       in_dart_of_loop z r /\
                       ~(node (hypermap_of_list L) y = node (hypermap_of_list L) z))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  TYPIFY_GOAL_THEN `!u. u IN dart_of_loop (loop_of_list x) <=> MEM u x` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil;in_dart_loop_of_list]);
  GEXISTL_TAC [`HD x`;`LAST x`];
  TYPED_ABBREV_TAC `d = LAST x`;
  INTRO_TAC is_restricted_node_f_list [`L`;`d`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`;`x`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[(* Tame_list. *)MEM_HD]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[(* Tame_list. *)MEM_LAST]);
  DISCH_TAC;
  TYPIFY `~(FST d = FST (HD x))` ENOUGH_TO_SHOW_TAC;
    TYPIFY ` d IN (node (hypermap_of_list L) d)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[List_hypermap.fst_node_hypermap_of_list]);
    BY(REWRITE_TAC[Hypermap.node_refl]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  TYPIFY `f_list L d = next_el x d` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[normal_list;f_last;GSYM Seq.allP];
    BY(ASM_MESON_TAC[]);
  TYPIFY `HD x = next_el x d` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[normal_list_list_of_darts;Seq.allP;Seq2.mem_flatten]);
  GMATCH_SIMP_TAC (GSYM Seq2.next_el_last);
  ASM_SIMP_TAC[(* Tame_list. *)last_LAST];
  BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n <=> ~(n = 0)`])
  ]);;
  (* }}} *)

let normal_list_11 = prove_by_refinement(
  `!L N (r:(A#A)loop) r' d. is_restricted (hypermap_of_list L) /\ 
  good_list L /\ 
    normal_list L N /\ r IN (loop_family_of_list N) /\
   r' IN (loop_family_of_list N) /\
              in_dart_of_loop d r /\
              in_dart_of_loop d r'
              ==> r = r'`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `!u x. MEM x N ==> (u IN dart_of_loop (loop_of_list x) <=> MEM u x)` (unlist ASM_SIMP_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil;in_dart_loop_of_list]);
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[normal_list];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  GEXISTL_TAC[ `N`; `(d:(A#A))`];
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let normal_list_full_node = prove_by_refinement(
  `!L N (r:(A#A)loop) d d'. is_restricted (hypermap_of_list L) /\ 
  good_list L /\ 
    normal_list L N /\ r IN (loop_family_of_list N) /\
in_dart_of_loop d r /\ d' IN node (hypermap_of_list L) d ==>
   (?r'. r' IN loop_family_of_list N /\ in_dart_of_loop d' r')`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!u x. MEM x N ==> (u IN dart_of_loop (loop_of_list x) <=> MEM u x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil;in_dart_loop_of_list]);
  TYPIFY `node (hypermap_of_list L) d SUBSET (set_of_list (flatten N))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_flatten;normal_list]);
  REWRITE_TAC[SUBSET;IN_SET_OF_LIST;Seq2.mem_flatten];
  DISCH_THEN (C INTRO_TAC [`d'`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `loop_of_list l` EXISTS_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let normal_list_normal = prove_by_refinement(
  `!L N . is_restricted (hypermap_of_list L) /\ 
  good_list L /\ good_list_nodes L /\
    normal_list L N ==> 
   is_normal (hypermap_of_list L) (loop_family_of_list N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_normal];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 3;
    BY(ASM_MESON_TAC[normal_list_full_node]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[normal_list_11]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[normal_list_nodes_exist]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    BY(ASM_MESON_TAC[normal_list_in_dart_of_loop]);
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC is_loop_of_list;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 2;
    FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[normal_list;GSYM Seq.allP];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil])
  ]);;
  (* }}} *)

let EVNAPDQ = normal_list_normal;;

let marked_list_restricted = prove_by_refinement(
  `!L N r d. marked_list L N r d ==>
    is_restricted (hypermap_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let marked_list_normal = prove_by_refinement(
  `!L N r d. good_list L /\ good_list_nodes L /\ marked_list L N r d ==> 
    is_normal (hypermap_of_list L) (loop_family_of_list N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC normal_list_normal;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let marked_list_mem_family = prove_by_refinement(
  `!L N r d. marked_list L N r d ==> 
    loop_of_list r IN loop_family_of_list N`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;loop_family_of_list;IN_SET_OF_LIST;upper_case;MEM_MAP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let marked_list_mem_loop = prove_by_refinement(
  `!L N r d. good_list L /\ good_list_nodes L /\ marked_list L N r d ==> 
    in_dart_of_loop d (loop_of_list r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC in_dart_loop_of_list;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC normal_list_uniq_nonnil;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let marked_list_loop_eq_face_map = prove_by_refinement(
  `!L N r d. good_list L /\ 
    marked_list L N r d ==> 
    loop_map (loop_of_list r) d = face_map (hypermap_of_list L) d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC (* Tame_list. *)f_list_ext_f_list;
  ASM_REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
  GMATCH_SIMP_TAC loop_map_next_el;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
  BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten])
  ]);;
  (* }}} *)

let mem_find_list1 = prove_by_refinement(
  `!L x. MEM x (flatten L) ==> MEM x (find_list L x)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;concat_flatten;List_hypermap.find_list];
  REWRITE_TAC[MEM_APPEND];
  GEN_TAC;
  BY(TYPIFY `MEM x h` ASM_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let n_list_ext_n_list = prove_by_refinement(
  `!L. good_list L /\ MEM d (list_of_darts L) ==> n_list_ext L d = n_list L d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[List_hypermap.n_list_ext];
  REWRITE_TAC[Sphere.res];
  BY(ASM_REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let normal_list_mem_n = prove_by_refinement(
  `!L N r d. good_list L /\ normal_list L N /\ MEM d (flatten N) ==>
    MEM (n_list L d) (flatten N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `node (hypermap_of_list L) d SUBSET set_of_list (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list]);
  TYPIFY ` (node_map (hypermap_of_list L) d) IN (node (hypermap_of_list L) d)` ENOUGH_TO_SHOW_TAC;
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    GMATCH_SIMP_TAC n_list_ext_n_list;
    ASM_REWRITE_TAC[];
    FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    REWRITE_TAC[GSYM Seq.allP];
    ASM_SIMP_TAC[];
    FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[SUBSET;IN_SET_OF_LIST];
    BY(MESON_TAC[]);
  MATCH_MP_TAC Hypermap.lemma_in_node1;
  BY(REWRITE_TAC[Hypermap.node_refl])
  ]);;
  (* }}} *)

(* was MEM_splitFace *)

let MEM_splitFace1 = prove_by_refinement(
  `!g u v f ws.  
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM f1 (faces g'))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  ASM_REWRITE_TAC[faces_graph];
  REWRITE_TAC[MEM_APPEND];
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let MEM_splitFace2 = prove_by_refinement(
  `!g u v f ws.  MEM f (faces g) ==>
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM f2 (faces g'))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "g'";
  ASM_REWRITE_TAC[faces_graph];
  REWRITE_TAC[MEM_APPEND];
  DISJ1_TAC;
  MATCH_MP_TAC MEM2_replace;
  BY(ASM_REWRITE_TAC[MEM])
  ]);;
  (* }}} *)

let split_face2_vertex1 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM u (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face2_vertex2 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM v (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f2";
  FULL_EXPAND_TAC "f2'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face1_vertex1 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM u (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_face1_vertex2 = prove_by_refinement(
  `!f u v ws. 
  (let (f1,f2) = split_face f u v ws in
    MEM v (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[split_face];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "f1";
  FULL_EXPAND_TAC "f1'";
  REWRITE_TAC[vertices_face_FST];
  BY(REWRITE_TAC[vertices_face_FST;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let splitFace1_vertex1 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM u (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face1_vertex1 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace1_vertex2 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM v (FST f1))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face1_vertex2 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace2_vertex1 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM u (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face2_vertex1 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)

let splitFace2_vertex2 = prove_by_refinement(
  `!g u v f ws. 
  (let (f1,f2,g') = splitFace g u v f ws in
    MEM v (FST f2))`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  LET_TAC;
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[splitFace];
  REPEAT (LET_TAC);
  REWRITE_TAC[PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC split_face2_vertex2 [`f`;`u`;`v`;`ws`];
  REPEAT LET_TAC;
  BY(ASM_MESON_TAC[PAIR_EQ])
  ]);;
  (* }}} *)


let pairwise_lt_shift = prove_by_refinement(
  `!ts f u v.  indexf u v f <= indexf u (HD ts) f /\
    pairwisel (\i j. indexf u i f < indexf u j f) ts ==>
    pairwisel (\i j. indexf v i f < indexf v j f) ts`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[pairwisel]);
  REWRITE_TAC[NOT_CONS_NIL;HD;pairwisel];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `T` MP_TAC) THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    TYPIFY `u` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[arith `iv <= ih /\ ih < iH:num ==> iv <= iH`]);
  TYPIFY `indexf u (HD t) f <= sizel f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[indexf_le_sizel]);
  TYPIFY `MEM u f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf_mem1 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`h`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM v f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM h f` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC THEN FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2 );
    BY(FIRST_X_ASSUM (C INTRO_TAC [`u`]) THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `indexf v (HD t) f = sizel f` ASM_CASES_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC indexf_lt_sizel;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (HD t) f` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[indexf2]);
  INTRO_TAC indexf_add_left [`u`;`v`;`h`;`f`];
  INTRO_TAC indexf_add_left [`u`;`v`;`HD t`;`f`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let HD_MAP = prove_by_refinement(
  `!s f. ~(s = []) ==> HD (MAP f s) = f (HD s)`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[HD;MAP])
  ]);;
  (* }}} *)

let pairwise_o = prove_by_refinement(
  `!ts f g. (pairwisel (\x y. f (g x) (g y)) ts = pairwisel f (MAP g ts))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[pairwisel;MAP;o_THM];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[MAP_EQ_NIL];
  BY(ASM_SIMP_TAC[HD_MAP])
  ]);;
  (* }}} *)

let splitFace_split_face = prove_by_refinement(
  `!g u v f ws f1 f2 g'. splitFace g u v f ws = f1,f2,g' ==>
    split_face f u v ws = (f1,f2)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[splitFace];
  REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT LET_TAC THEN ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[PAIR_EQ];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)


let C_EL_REC = prove_by_refinement(
  `(#!#) (x::xs) n = if (n = 0) then (x:A) else (let k = PRE n in (#!#) xs k)`,
  (* {{{ proof *)
  [
  COND_CASES_TAC THEN ASM_REWRITE_TAC[C_EL;EL;HD;TL];
  LET_TAC;
  TYPIFY `n = SUC k` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[EL;HD;TL])
  ]);;
  (* }}} *)

let list_update_ALT = prove_by_refinement(
  `list_update [] i v = [] /\ 
   list_update (x :: xs) i v =   ((if (i = 0) then (v :: xs ) else (let j = PRE (i) in (x ):: list_update xs j v)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[list_update];
  COND_CASES_TAC THEN REWRITE_TAC[] THEN LET_TAC;
  TYPIFY `j = i-1` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[])
  ]);;
  (* }}} *)

let mapAt_ALT = prove_by_refinement(
  `(mapAt [] (f:A->A) (xs:A list) = xs) /\
    (mapAt ((n:num) :: ns) (f:A->A) (xs:A list) = if (n < LENGTH xs) 
       then mapAt ns f (list_update xs n (f ((#!#) xs n))) else mapAt ns f xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[mapAt;C_EL])
  ]);;
  (* }}} *)

let HEIGHTS = prove_by_refinement(
  `heights (Graph fs n f h) = h`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[heights;GRAPH])
  ]);;
  (* }}} *)

let sub1_ALT = prove_by_refinement(
  `sub1 p  =  (let (a, n) = p in (let as = a in ((#!#) as n)))`,
  (* {{{ proof *)
  [
  REPEAT LET_TAC;
  BY(REWRITE_TAC[sub1;C_EL])
  ]);;
  (* }}} *)
   


let sub_nth = prove_by_refinement(
  `sub a n = (#!#) a n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[sub;sub1;C_EL])
  ]);;
  (* }}} *)

let foldr2_ALT = prove_by_refinement(
  `foldr2 f [] = I /\
    foldr2 f (y :: ys) = f y o (foldr2 f ys)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;foldr2;I_THM;o_THM;Seq.foldr])
  ]);;
  (* }}} *)

let sumn_ALT = prove_by_refinement(
  `!xs. sumn xs = foldr2 (+) xs 0`,
  (* {{{ proof *)
  [
    BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.sumn;Seq.foldr;foldr2])
  ]);;
  (* }}} *)


let NOT_IMP_THM = prove_by_refinement(
  `!a b. (~(a ==> b)) <=> (~b /\ a)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let IMP_IMP_THM = prove_by_refinement(
  `!a b. (a ==> b ==> c) <=> (a /\ b ==> c)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let inverse_node_map_list = prove_by_refinement(
  `!L d. good_list L /\ MEM d (list_of_darts L) ==>
    inverse(node_map (hypermap_of_list L)) d = f_list L (e_list d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.inverse_hypermap_maps];
  REWRITE_TAC[o_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `edge_map (hypermap_of_list L) d IN dart (hypermap_of_list L)` (C SUBGOAL_THEN MP_TAC);
    GMATCH_SIMP_TAC Hypermap.lemma_dart_invariant;
    GMATCH_SIMP_TAC dart_hypermap_of_list;
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  ASM_SIMP_TAC[Lp_gen_theory.e_list_ext_eq_e_list];
  BY(ASM_SIMP_TAC[f_list_ext_f_list])
  ]);;
  (* }}} *)

let face_map_list = prove_by_refinement(
  `!L d. good_list L /\ MEM d (list_of_darts L) ==>
    (face_map (hypermap_of_list L)) d = f_list L (d)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC f_list_ext_f_list;
  BY(ASM_REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

(* was normal_list_f_or_ni *)

let loop_list_f_or_ni = prove_by_refinement(
  `!L r x. loop_list L r /\ MEM x r  ==>
   (next_el r x = f_list L x \/ next_el r x = f_list L (e_list x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[loop_list;one_step_list;GSYM Seq.allP];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

(* was normal_list_f_xor_ni *)

let edge_nondeg_f_xor_ni = prove_by_refinement(
  `!L x. good_list L /\  MEM x (list_of_darts L) /\
     is_edge_nondegenerate (hypermap_of_list L) ==>
     ~(f_list L x = f_list L (e_list x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_edge_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  BY(ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST;face_map_list;inverse_node_map_list])
  ]);;
  (* }}} *)

(* removed March 9, 2014. Based on a bad def of contour_list 
contour_list_contour
*)

let index_hd0 = prove_by_refinement(
  `!s. ~(s = []) ==> indexl (HD s) s = 0`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[Seq2.index_head;Seq2.head_HD;Seq.size_eq0;arith `0 < n <=> ~(n=0)`])
  ]);;
  (* }}} *)

let next_el_power_eq = prove_by_refinement(
  `!s t.  ~(s = []) /\ ~(t = []) /\ uniq (s:(A)list) /\ uniq t /\
     (!i. (next_el s POWER i) (HD s) = (next_el t POWER i) (HD t)) ==>
    (s = t)`,
  (* {{{ proof *)
  [
  TYPIFY `!s t.  ~(s = []) /\ ~(t = []) /\ uniq (s:(A)list) /\ uniq t /\ (sizel s <= sizel t) /\     (!i. (next_el s POWER i) (HD s) = (next_el t POWER i) (HD t)) ==>    (s = t)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[arith `n <= m:num \/ m <= n`]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_from_nth) [`HD s`];
  DISCH_THEN MATCH_MP_TAC;
  TYPIFY `MEM (HD s) s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  TYPIFY `MEM (HD t) t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD]);
  INTRO_TAC Seq2.next_el_power [`HD s`;`s`;`HD s`];
  ASM_SIMP_TAC[index_hd0];
  INTRO_TAC Seq2.next_el_power [`HD t`;`t`;`HD t`];
  ASM_SIMP_TAC[index_hd0];
  TYPIFY `HD t = HD s` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    REWRITE_TAC[Hypermap.POWER_0];
    REWRITE_TAC[I_THM];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[arith `0 + i = i`];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`i`]);
    TYPIFY `i MOD sizel s = i` ((C SUBGOAL_THEN SUBST1_TAC));
      BY(ASM_SIMP_TAC[MOD_LT]);
    TYPIFY `i MOD sizel t = i` (C SUBGOAL_THEN SUBST1_TAC);
      MATCH_MP_TAC MOD_LT;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(MESON_TAC[]);
  MATCH_MP_TAC (arith `n <= m:num /\ ~(n < m) ==> (n = m)`);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_ASSUM (C INTRO_TAC [`0`]);
  REPEAT (FIRST_X_ASSUM (C INTRO_TAC [`sizel s`]));
  TYPIFY `sizel s MOD sizel t = sizel s` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC MOD_LT;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `sizel s MOD sizel s = 0` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC Oxl_2012.MOD_REFL;
    REWRITE_TAC[Seq.size_eq0];
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `~(sizel s = 0) /\ ~(sizel t = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  ASM_SIMP_TAC[MOD_0];
  INTRO_TAC Seq2.uniq_nthP [`HD s`;`t`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`0`;`sizel s`]);
  ASM_SIMP_TAC[arith `~(n = 0) ==> 0 < n`];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rot_eq_rot = prove_by_refinement(
  `!n m s t. rot n s = rot m t ==> (?l. rot l s = t)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s = sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_rot]);
  TYPIFY `sizel t <= m` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.rot_oversize]);
  TYPIFY `rot (sizel t - m) (rot n s) = rot (sizel t - m) (rot m t)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `sizel t - m + m <= sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `rot` kill;
  ASM_SIMP_TAC[GSYM Seq.rot_addn];
  TYPIFY `sizel t - m + m = sizel t` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.rot_size];
  BY(ASM_MESON_TAC[Seq2.rot_rot_eq_rot])
  ]);;
  (* }}} *)

let next_el_power_rot = prove_by_refinement(
`!s t d.   uniq (s:(A)list) /\ uniq t /\
    MEM d s /\ MEM d t /\
     (!i. (next_el s POWER i) d = (next_el t POWER i) d) ==>
    (?k. rot k s = t)`,
   (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC rot_eq_rot;
  INTRO_TAC Seq2.rot_to_index [`s`;`d`];
  INTRO_TAC Seq2.rot_to_index [`t`;`d`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [ `indexl d s`;`indexl d t`];
  MATCH_MP_TAC next_el_power_eq;
  ASM_SIMP_TAC[Seq2.next_el_rot_eq];
  REWRITE_TAC[NOT_CONS_NIL];
  ASM_REWRITE_TAC[HD];
  BY(ASM_MESON_TAC[Seq.rot_uniq])
  ]);;
  (* }}} *)

let final_list_power = prove_by_refinement(
  `!L r i d. good_list L /\ final_list L r /\ MEM d r /\ uniq r /\ 
    MEM d (list_of_darts L) ==>
     MEM ((next_el r POWER i) d) r  /\
     MEM ((next_el r POWER i) d) (list_of_darts L) /\
    (next_el r POWER i) d = (next_el (find_face L d) POWER i) d`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER_0;I_THM];
    BY(SIMP_TAC[]);
  REWRITE_TAC[Hypermap.POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`next_el r d`]);
  ASM_REWRITE_TAC[];
  TYPIFY `next_el r d = f_list L d` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    REWRITE_TAC[final_list];
    REWRITE_TAC[GSYM Seq.allP];
    DISCH_THEN (C INTRO_TAC [`d`]) THEN ASM_REWRITE_TAC[];
    BY(DISCH_THEN (unlist REWRITE_TAC));
  ANTS_TAC;
    ASM_SIMP_TAC[Seq2.mem_next_el];
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP List_hypermap.mem_f_list);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP List_hypermap.mem_find_face_imp_mem_darts);
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `find_face L (f_list L d) = find_face L d /\  f_list L d = next_el (find_face L d) d ` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  GMATCH_SIMP_TAC List_hypermap.find_face_f_list;
  REWRITE_TAC[List_hypermap.f_list];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let final_list_rot = prove_by_refinement(
  `!L r d.  good_list L /\ final_list L r /\ MEM d r /\ uniq r /\
     MEM d (list_of_darts L)  ==>
     (?n.  rot n r = find_face L d)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC next_el_power_rot;
  TYPIFY `d` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  ASM_SIMP_TAC[List_hypermap.uniq_find_face];
  ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face];
  GEN_TAC;
  INTRO_TAC final_list_power [`L`;`r`;`i`;`d`];
  ASM_REWRITE_TAC[];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let rot_sym = prove_by_refinement(
  `! r (s:(A)list). (?k. rot k r = s) <=> (?k. rot k s = r)`,
  (* {{{ proof *)
  [
  TYPIFY `!r (s:(A)list). (?k. rot k r = s) ==> (?k. rot k s = r)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC rot_eq_rot;
  GEXISTL_TAC [`0`;`k`];
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.rot0])
  ]);;
  (* }}} *)

let set_of_list_rot = prove_by_refinement(
  `!s n. set_of_list (rot n s) = set_of_list s`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;Seq.mem_rot])
  ]);;
  (* }}} *)

let loop_of_face_list = prove_by_refinement(
  `!L r x. good_list L /\ final_list L r /\ uniq r /\
    MEM x r /\ MEM x (list_of_darts L)
     ==>
    loop_of_face (hypermap_of_list L) x = loop_of_list r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_loop_identity];
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_SIMP_TAC[(* Tame_list. *) loop_map_next_el];
  ASM_SIMP_TAC[dart_of_loop_of_list];
  INTRO_TAC final_list_rot [`L`;`r`;`x`];
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[rot_sym];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "r";
  REWRITE_TAC[set_of_list_rot];
  GMATCH_SIMP_TAC Seq2.next_el_rot_eq;
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  SUBCONJ_TAC;
    BY(ASM_SIMP_TAC[List_hypermap.face_of_list]);
  DISCH_TAC;
  REWRITE_TAC[FUN_EQ_THM];
  INTRO_TAC Seq2.next_el_permutes [`find_face L x`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  DISCH_TAC;
  TYPIFY_GOAL_THEN `res (next_el (find_face L x)) (set_of_list (find_face L x)) = next_el (find_face L x)` (SUBST1_TAC o GSYM);
    BY(ASM_SIMP_TAC[Hypermap_and_fan.PERMUTES_IMP_RES_EQ_FUN]);
  GEN_TAC THEN REWRITE_TAC[Sphere.res];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC THEN ASM_SIMP_TAC[];
    REWRITE_TAC[IN_SET_OF_LIST];
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    DISCH_TAC;
    GMATCH_SIMP_TAC (* Tame_list. *) f_list_ext_f_list;
    REWRITE_TAC[List_hypermap.f_list];
    TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[good_list]);
    REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.mem_find_face_imp_faces_eq]);
  FIRST_X_ASSUM MP_TAC;
  BY(ASM_SIMP_TAC[])
  ]);;
  (* }}} *)

let final_list_face = prove_by_refinement(
  `!L r. good_list L /\ MEM r (list_of_faces L) ==> final_list L r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[final_list;List_hypermap.list_of_faces;MEM_MAP;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.f_list];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[List_hypermap.find_face_alt];
  AP_TERM_TAC;
  MATCH_MP_TAC (GSYM List_hypermap.find_pair_list_unique);
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let marked_list_edge_map_final = prove_by_refinement(
  `!L N r d. good_list L /\ 
    marked_list L N r d ==> 
    edge_map (hypermap_of_list L) d IN 
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `find_list` MP_TAC;
  LET_TAC;
  DISCH_TAC;
  TYPIFY `set_of_list r'` EXISTS_TAC;
  REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (f_list L d) (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `f_list` (SUBST1_TAC o GSYM);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC Seq2.mem_next_el;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  TYPIFY `e_list_ext L d = e_list d` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "r'";
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC mem_find_list1;
  SUBCONJ_TAC;
    INTRO_TAC e_list_ext_n_f [`L`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[FUN_EQ_THM;o_THM];
    DISCH_THEN (C INTRO_TAC [`d`]);
    ASM_SIMP_TAC[];
    GMATCH_SIMP_TAC f_list_ext_f_list;
    ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list];
    DISCH_THEN kill;
    GMATCH_SIMP_TAC n_list_ext_n_list;
    ASM_REWRITE_TAC[];
    nCONJ_TAC 0;
      FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
      BY(REWRITE_TAC[GSYM Seq.allP] THEN ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC normal_list_mem_n;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  COMMENT "finals";
  TYPIFY `loop_of_list (find_list N (e_list d))` EXISTS_TAC;
  (REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST;upper_case]);
  TYPED_ABBREV_TAC `r' = find_list N (e_list d)`;
  TYPIFY `MEM r' N` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "r'";
    MATCH_MP_TAC List_hypermap.mem_find_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  nCONJ_TAC 2;
    GMATCH_SIMP_TAC dart_of_loop_of_list;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  nCONJ_TAC 0;
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  TYPIFY `e_list d` EXISTS_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  ASM_SIMP_TAC[in_dart_loop_of_list];
  SUBCONJ_TAC;
    FULL_EXPAND_TAC "r'";
    MATCH_MP_TAC mem_find_list1;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  GMATCH_SIMP_TAC loop_of_face_list;
  TYPIFY `r'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC normal_list_list_of_darts [`L`;`N`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_list = prove_by_refinement(
  `!L N r d. good_list L /\ 
       MEM d r /\ MEM r N /\ normal_list L N /\ final_list L r ==>
    d IN (
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `set_of_list r` EXISTS_TAC;
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `loop_of_face (hypermap_of_list L) d` EXISTS_TAC;
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case;MEM_MAP];
  TYPIFY `loop_of_face (hypermap_of_list L) d = loop_of_list r` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC loop_of_face_list;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  nCONJ_TAC 0;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  nCONJ_TAC 1;
    REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
    GEN_TAC;
    MATCH_MP_TAC (GSYM in_dart_loop_of_list);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  REWRITE_TAC[IN_SET_OF_LIST];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let final_loops_list = prove_by_refinement(
  `!L N r. good_list L /\ 
       MEM r N /\ normal_list L N /\ final_list L r ==>
    loop_of_list r IN (final_loops (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[loop_family_of_list;upper_case;IN_SET_OF_LIST];
  CONJ_TAC;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  TYPIFY `?d. MEM d r` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[GSYM List_hypermap.mem_not_nil];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d` EXISTS_TAC;
  TYPIFY `MEM d (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq2.mem_flatten];
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    BY(ASM_MESON_TAC[Seq.allP;Seq2.mem_flatten]);
  TYPIFY `loop_of_face (hypermap_of_list L) d = loop_of_list r` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC loop_of_face_list;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC in_dart_loop_of_list;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list_uniq_nonnil])
  ]);;
  (* }}} *)

let face_loop_imp_final_list = prove_by_refinement(
  `!L N r x. good_list L /\ normal_list L N /\ MEM r N /\ MEM x r /\
    loop_of_face (hypermap_of_list L) x = loop_of_list r ==>
    final_list L r`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_loop_identity];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `dart_of_loop` MP_TAC;
  ASM_SIMP_TAC[dart_of_loop_of_list];
  FIRST_X_ASSUM_ST `loop_map` MP_TAC;
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  ASM_SIMP_TAC[ loop_map_next_el];
  GMATCH_SIMP_TAC List_hypermap.face_of_list;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[final_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY ` x' IN (set_of_list (find_face L x))` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[];
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  FIRST_X_ASSUM_ST `next_el` (SUBST1_TAC o GSYM);
  REWRITE_TAC[Sphere.res];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC f_list_ext_f_list;
  REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST];
  FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_conv = prove_by_refinement(
  `!L N d. good_list L /\ 
       d IN (
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N)) /\
       normal_list L N ==> (?r. MEM d r /\ MEM r N /\ final_list L r)
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "t";
  FULL_EXPAND_TAC "L'";
  REPEAT (FIRST_X_ASSUM_ST `=` kill);
  FIRST_X_ASSUM_ST `loop_family_of_list` MP_TAC;
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `in_dart_of_loop` MP_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  FIRST_X_ASSUM_ST `IN` MP_TAC;
  TYPIFY `dart_of_loop (loop_of_face (hypermap_of_list L) x) = dart_of_loop (loop_of_list x')` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  SUBCONJ_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  SUBCONJ_TAC;
    ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  MATCH_MP_TAC face_loop_imp_final_list;
  GEXISTL_TAC [`N`;`x`];
  (ASM_REWRITE_TAC[]);
  ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.face_refl])
  ]);;
  (* }}} *)

let final_loops_conv = prove_by_refinement(
  `!L N z. good_list L /\ 
    z IN final_loops (hypermap_of_list L) (loop_family_of_list N) /\
       normal_list L N ==> (?r. MEM r N /\ final_list L r /\ z = loop_of_list r)
`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;Hypermap.in_dart_of_loop];
  REWRITE_TAC[Hypermap.darts_in_final_loops;IN_UNIONS;IN_ELIM_THM];
  SIMP_TAC[List_hypermap.components_hypermap_of_list];
  REWRITE_TAC[Hypermap.final_loops;IN_ELIM_THM];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "z";
  REPEAT (FIRST_X_ASSUM_ST `=` kill);
  FIRST_X_ASSUM_ST `loop_family_of_list` MP_TAC;
  REWRITE_TAC[loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `in_dart_of_loop` MP_TAC;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  TYPIFY `dart_of_loop (loop_of_face (hypermap_of_list L) x) = dart_of_loop (loop_of_list x')` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Hypermap.loop_of_face_rep];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  SUBCONJ_TAC;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC face_loop_imp_final_list;
  GEXISTL_TAC [`N`;`x`];
  (ASM_REWRITE_TAC[]);
  ONCE_REWRITE_TAC[GSYM IN_SET_OF_LIST];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.face_refl])
  ]);;
  (* }}} *)

let final_loops_list_eq = prove_by_refinement(
  `!L N. good_list L /\ normal_list L N ==>
    final_loops (hypermap_of_list L) (loop_family_of_list N) = 
      set_of_list (MAP loop_of_list (filter (final_list L) N))
   `,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP;Seq.mem_filter];
  MATCH_MP_TAC (TAUT `((a ==>b ) /\ (b ==> a)) ==> (a = b)`);
  REPEAT STRIP_TAC;
    INTRO_TAC final_loops_conv [`L`;`N`;`x`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC final_loops_list [`L`;`N`;`x'`];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let darts_in_final_loops_list_eq = prove_by_refinement(
  `!L N. good_list L /\ normal_list L N ==>
    darts_in_final_loops (hypermap_of_list L) (loop_family_of_list N) = 
   set_of_list (final_dart_list L N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST;final_dart_list];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (TAUT `((a ==>b ) /\ (b ==> a)) ==> (a = b)`);
  CONJ_TAC;
    DISCH_TAC;
    INTRO_TAC darts_in_final_loops_conv [`L`;`N`;`x`];
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `r` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[Seq.mem_filter]);
  REWRITE_TAC[Seq2.mem_flatten;Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC darts_in_final_loops_list;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let support_of_sequence_list = prove_by_refinement(
  `!s.  ~(s=[]) ==>  
    support_of_sequence (\i. EL i s) (PRE (sizel s)) = set_of_list s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.support_of_sequence];
  REWRITE_TAC[EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_EXISTS_EL];
  REWRITE_TAC[arith `!i. i <= n <=> i < SUC n`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `SUC (PRE (sizel s)) = sizel s` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[lower_case]);
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size_eq0];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let next_el_cat_sym = prove_by_refinement(
  `!s t. uniq (cat s t) ==> next_el (cat s t) = next_el (cat t s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.rot_size_cat [`s`;`t`];
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(ASM_SIMP_TAC[Seq2.next_el_rot_eq])
  ]);;
  (* }}} *)

let indexl_last = prove_by_refinement(
  `!x s. uniq s /\ ~(s = []) ==> indexl (last x s) s = sizel s - 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.nth_last];
  GMATCH_SIMP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.index_uniq);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size_eq0];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let indexl_LAST = prove_by_refinement(
  `!s. uniq s /\ ~(s = []) ==> indexl (LAST s) s = sizel s - 1`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[indexl_last;last_LAST])
  ]);;
  (* }}} *)

let next_el_cat1 = prove_by_refinement(
  `!s t.   uniq s /\ MEM x s /\ ~(x = LAST s) ==>
    next_el (cat s t) x = next_el s x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC Seq2.next_el_mod);
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.mem_cat];
  ASM_REWRITE_TAC[Seq.index_cat];
  ASM_REWRITE_TAC[Seq.nth_cat];
  TYPIFY `indexl x s + 1 < sizel s` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    TYPIFY `indexl x s + 1 < sizel (cat s t)` (C SUBGOAL_THEN ASSUME_TAC);
      REWRITE_TAC[Seq.size_cat];
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_SIMP_TAC[MOD_LT]);
  TYPIFY `indexl x s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  TYPIFY `~(sizel s - 1 = indexl x s)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  DISCH_TAC;
  INTRO_TAC indexl_LAST [`s`] THEN ASM_REWRITE_TAC[];
  TYPIFY `~(s = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.uniq_index_inj;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC MEM_LAST;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_cat2 = prove_by_refinement(
  `!s t.   uniq (cat s t) /\ MEM x t /\ ~(x = LAST t) ==>
    next_el (cat s t) x = next_el t x`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[next_el_cat_sym;next_el_cat1;Seq.uniq_catC;Seq.cat_uniq])
  ]);;
  (* }}} *)

let cat_eq_nil = prove_by_refinement(
  `!s t. cat s t = [] <=> (s = [] /\ t = [])`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[upper_case;APPEND_EQ_NIL])
  ]);;
  (* }}} *)

let next_el_cat_last2 = prove_by_refinement(
  `!s t. uniq (cat s t) /\ ~(t = []) /\ ~(s = []) ==>
      next_el (cat s t) (LAST t) = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `HD s = HD (cat s t)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[upper_case;HD_APPEND]);
  GMATCH_SIMP_TAC (GSYM Seq2.next_el_last);
  TYPIFY `~(cat s t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[cat_eq_nil]);
  ASM_SIMP_TAC[last_LAST];
  CONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.size_eq0;Seq.size_cat] THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[LAST_APPEND;upper_case])
  ]);;
  (* }}} *)

let next_el_cat_last1 = prove_by_refinement(
  `!s t. uniq (cat s t) /\ ~(t = []) /\ ~(s = []) ==>
      next_el (cat s t) (LAST s) = HD t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC next_el_cat_sym;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC next_el_cat_last2;
  BY(ASM_MESON_TAC[Seq.uniq_catC])
  ]);;
  (* }}} *)

let LAST_find_list = prove_by_refinement(
  `!s x. x = LAST(flatten s) /\ ~(flatten s = []) /\ uniq (flatten s) ==>
      LAST (find_list s x) = x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[List_hypermap.find_list;LAST;Seq.flatten_cons;Seq.flatten0];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    FIRST_X_ASSUM_ST `LAST` MP_TAC THEN ASM_REWRITE_TAC[LAST_APPEND;upper_case];
    COND_CASES_TAC;
      BY(MESON_TAC[]);
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cat_uniq];
    REWRITE_TAC[GSYM Seq.hasP];
    REWRITE_TAC[NOT_EXISTS_THM];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`x`]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `MEM x (cat h (flatten t))` (C SUBGOAL_THEN MP_TAC);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_LAST]);
  ASM_REWRITE_TAC[Seq.mem_cat];
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `~(flatten t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  SUBCONJ_TAC;
    BY(ASM_REWRITE_TAC[LAST_APPEND;upper_case]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.cat_uniq];
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let find_list_uniq = prove_by_refinement(
  `!L s x. uniq (flatten L) /\ MEM x s /\ MEM s L ==> find_list L x = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;List_hypermap.find_list];
  REWRITE_TAC[Seq.flatten_cons;Seq.cat_uniq];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = s` ASM_CASES_TAC;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM s t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM_ST `has` MP_TAC THEN REWRITE_TAC[GSYM Seq.hasP;Seq2.mem_flatten];
  DISCH_TAC;
  TYPIFY `~(MEM x h)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_flatten_unlast = prove_by_refinement(
  `!s r (x:A). uniq (flatten s) /\ MEM x r /\ MEM r s /\ ~(x = LAST r) ==>
     next_el (flatten s) x = next_el r x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = h` ASM_CASES_TAC;
    FULL_EXPAND_TAC "h";
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  GMATCH_SIMP_TAC next_el_cat2;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `next_el` GMATCH_SIMP_TAC;
  TYPIFY `r` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq2.mem_flatten];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  DISCH_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC LAST_find_list [`t`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq2.mem_flatten;MEM]);
  TYPIFY `find_list t x = r` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC find_list_uniq;
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let HD_flatten = prove_by_refinement(
  `!t. ~(flatten t = []) /\ ~(HD t = []) ==> HD (flatten t) = HD (HD t)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0]);
  REWRITE_TAC[HD];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP CONS_HD_TL);
  TYPIFY `cat h = cat (HD h :: TL h)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.cat_cons];
  BY(REWRITE_TAC[HD])
  ]);;
  (* }}} *)

let next_el_flatten_last_hd = prove_by_refinement(
  `!s (r:A list). uniq (flatten s) /\ all (\r. ~(r = [])) s /\ r = HD s /\
    ~(s = []) ==>
     next_el (flatten s) (LAST r) = HD (next_el s r)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;HD];
  REWRITE_TAC[Seq.flatten_cons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  FULL_EXPAND_TAC "h";
  TYPIFY `(flatten t = [])` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq.cats0];
    TYPIFY `t = []` (C SUBGOAL_THEN ASSUME_TAC);
      PROOF_BY_CONTR_TAC;
      TYPIFY `?x. MEM x (flatten t)` ENOUGH_TO_SHOW_TAC;
        BY(ASM_REWRITE_TAC[MEM]);
      REWRITE_TAC[Seq2.mem_flatten];
      FIRST_X_ASSUM MP_TAC;
      REWRITE_TAC[List_hypermap.mem_not_nil];
      REPEAT WEAKER_STRIP_TAC;
      FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
      BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[next_el1];
    GMATCH_SIMP_TAC (GSYM Seq2.next_el_last);
    ASM_SIMP_TAC[last_LAST];
    CONJ_TAC;
      BY(ASM_MESON_TAC[Seq.size_eq0;arith `0 < n <=> ~(n = 0)`]);
    BY(ASM_MESON_TAC[Seq.cat_uniq]);
  (GMATCH_SIMP_TAC next_el_cat_last1);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
  REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.flatten0]);
  DISCH_TAC;
  GMATCH_SIMP_TAC HD_flatten;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (HD t) t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_HD]);
  FIRST_X_ASSUM_ST `all` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let HD_take = prove_by_refinement(
  `!i. ~(i=0) /\ ~(s = []) ==> HD (take i s) = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM (MP_TAC o MATCH_MP CONS_HD_TL);
  DISCH_THEN SUBST1_TAC;
  BY(REWRITE_TAC[Seq.take_cons;HD])
  ]);;
  (* }}} *)

let cat_to = prove_by_refinement(
  `!(x:A) s. MEM x s ==> (?a b. s = cat a b /\ x = HD b /\ ~(b = []))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.rot_to [`s`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `?i s'. rot i (x :: s') = s` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[rot_sym]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i = 0` ASM_CASES_TAC;
    TYPIFY `s = x::s'` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.rot0]);
    GEXISTL_TAC [`[]:A list`;`s`];
    BY(ASM_MESON_TAC[Seq.cat0s;HD;MEM]);
  FIRST_X_ASSUM_ST `rot` MP_TAC;
  REWRITE_TAC[Seq.rot];
  DISCH_TAC;
  GEXISTL_TAC [`dropl i (x :: s')`;`take i (x :: s')`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC HD_take;
  (ASM_REWRITE_TAC[HD;NOT_CONS_NIL]);
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[Seq.take_cons;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let next_el_flatten_last = prove_by_refinement(
  `!s (r:A list). uniq (flatten s) /\ all (\r. ~(r = [])) s /\ MEM r s 
   ==> 
     next_el (flatten s) (LAST r) = HD (next_el s r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (GSYM cat_to) [`r`;`s`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "s";
  GMATCH_SIMP_TAC next_el_cat_sym;
  REWRITE_TAC[Seq.flatten_cat];
  TYPIFY `next_el (cat (flatten a) (flatten b)) (LAST r) = next_el (cat (flatten b) (flatten a)) (LAST r)` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC next_el_cat_sym;
    BY(ASM_REWRITE_TAC[GSYM Seq.flatten_cat]);
  SUBCONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[]);
  DISCH_TAC;
  REWRITE_TAC[GSYM Seq.flatten_cat];
  MATCH_MP_TAC next_el_flatten_last_hd;
  ASM_REWRITE_TAC[];
  nCONJ_TAC 3;
    BY(ASM_REWRITE_TAC[cat_eq_nil]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[upper_case;HD_APPEND]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[Seq.allP;Seq.mem_cat]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.uniq_catC;Seq.flatten_cat]);
  BY(ASM_REWRITE_TAC[])
   ]);;
  (* }}} *)

let index_indexf = prove_by_refinement(
  `!x y. uniq r /\ MEM x r /\ MEM y r ==> 
    index (loop_of_list r) x y = indexf x y r`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC Hypermap.determine_loop_index;
  REWRITE_TAC[Hypermap.in_dart_of_loop];
  GMATCH_SIMP_TAC in_dart_loop_of_list;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Hypermap.pre_card_dart_of_loop];
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  GMATCH_SIMP_TAC loop_map_next_el;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC indexf_n;
  INTRO_TAC indexf_lt_sizel [`r`;`x`;`y`];
  ASM_SIMP_TAC[];
  TYPIFY `~(r  = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  ASM_REWRITE_TAC[];
  TYPIFY `~(sizel r = 0)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rev1 = prove_by_refinement(
  `!h. rev [h] = [h]`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.rev_cons;rev0;Seq.rcons])
  ]);;
  (* }}} *)

let LAST_rev = prove_by_refinement(
  `!t. ~(t = []) ==> LAST (rev t) = HD t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM];
  REWRITE_TAC[Seq.rev_cons;Seq.rcons];
  REWRITE_TAC[Seq.rev_cons;Seq.rcons;HD];
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  REWRITE_TAC[GSYM Seq.cats1];
  TYPIFY `t = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[rev0;Seq.cat0s];
    BY(REWRITE_TAC[LAST_CLAUSES]);
  TYPIFY `~(rev t = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.revK;rev0]);
  INTRO_TAC Seq.last_cat [`h`;`rev t`;`[h]`];
  REPEAT (GMATCH_SIMP_TAC last_LAST);
  ASM_REWRITE_TAC[NOT_CONS_NIL;cat_eq_nil];
  BY(ASM_MESON_TAC[LAST_CLAUSES])
  ]);;
  (* }}} *)

let cat_from = prove_by_refinement(
  `!(x:A) s. MEM x s ==> (?a b. s = cat a b /\ x = LAST a /\ ~(a = []))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_to [`x`;`rev s`];
  ASM_REWRITE_TAC[Seq.mem_rev];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`rev b`;`rev a`];
  ASM_REWRITE_TAC[GSYM Seq.rev_cat];
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.revK]);
  CONJ2_TAC;
    BY(ASM_MESON_TAC[rev0;Seq.revK]);
  BY(ASM_SIMP_TAC[LAST_rev])
  ]);;
  (* }}} *)

let LAST_cat = prove_by_refinement(
  `!u v. ~(v = []) ==> LAST (cat u v) = LAST v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.last_cat [`LAST v`;`u`;`v`];
  REPEAT (GMATCH_SIMP_TAC last_LAST);
  BY(ASM_REWRITE_TAC[NOT_CONS_NIL;cat_eq_nil])
  ]);;
  (* }}} *)

let HD_rev = prove_by_refinement(
  `!t. ~(t = []) ==> HD (rev t) = LAST t`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM LAST_rev);
  REWRITE_TAC[Seq.revK];
  BY(ASM_MESON_TAC[rev0;Seq.revK])
  ]);;
  (* }}} *)

let FORALL_REV_THM = prove_by_refinement(
  ` (!r. f (rev r)) <=> (!r. f r)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.revK]);
  ]);;
  (* }}} *)

let partition_into_atom0r_cases = prove_by_refinement(
  `!r rs n acc.  partition_into_atom0r n acc [] = acc /\
    partition_into_atom0r n acc (rcons rs r) =
     (if acc = []
      then partition_into_atom0r n [[r]] rs
      else if n r = HD (HD acc)
           then partition_into_atom0r n ((r :: HD acc) :: TL acc) rs
           else partition_into_atom0r n ([r] :: acc) rs)
   `,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[partition_into_atom0r;rev0;partition_into_atom0;Seq.rev_rcons])
  ]);;
  (* }}} *)

let partsr = prove_by_refinement(
  `!L r. parts L r = partition_into_atom0r (f_list L o e_list) [] r`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[parts;partition_into_atom0r;partition_into_atom])
  ]);;
  (* }}} *)

let LISTR_INDUCT = prove_by_refinement(
  `!f. (f []) /\ (!h t. f t ==> f (rcons t h)) ==> (!r. f r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  ONCE_REWRITE_TAC[GSYM FORALL_REV_THM];
  REPEAT DISCH_TAC;
  (LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[rev0;Seq.rev_cons]);
  ASM_MESON_TAC[]
  ]);;
  (* }}} *)

let LISTR_INDUCT_TAC = 
  MATCH_MP_TAC LISTR_INDUCT THEN CONJ_TAC 
    THENL[ALL_TAC;REPEAT GEN_TAC THEN DISCH_TAC];;

let LAST_rcons = prove_by_refinement(
  `!t h. LAST (rcons t h) = h`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.last_rcons;last_LAST;rcons_nonnil])
  ]);;
  (* }}} *)

let partition_into_atom0r_pure = prove_by_refinement(
  `!n r a. ~(r = []) /\ uniq r /\
    (!x. MEM x r ==> x = LAST r \/ (next_el r x = n x)) ==>
    partition_into_atom0r n a r = 
   if (a = [] \/ ~(n (LAST r) = HD (HD a))) then r :: a 
   else (cat r (HD a)) :: TL a`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases;MEM;HD];
  GEN_TAC;
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "insert";
  TYPIFY `t = []` ASM_CASES_TAC;
    (ASM_REWRITE_TAC[LAST;partition_into_atom0r_cases;Seq.rev_cons;rev0;rev1;Seq.rcons]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.cat1s]);
  TYPIFY `!x. MEM x t ==> x = LAST t \/ next_el t x = n x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x = LAST t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (C INTRO_TAC [`x`]);
    REWRITE_TAC[Seq.mem_rcons;MEM;LAST_rcons];
    TYPIFY `~(x = h)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq.rcons_uniq]);
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_MESON_TAC[Seq.rcons_uniq]);
  TYPIFY `n (LAST t) = h` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `rcons` (C INTRO_TAC [`LAST t`]);
    REWRITE_TAC[GSYM Seq.cats1;Seq.mem_cat];
    ASM_SIMP_TAC[MEM_LAST];
    REWRITE_TAC[Seq.cats1;LAST_rcons];
    DISCH_THEN DISJ_CASES_TAC;
      BY(ASM_MESON_TAC[MEM_LAST;Seq.rcons_uniq]);
    FIRST_X_ASSUM MP_TAC;
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat_last1;
    (ASM_REWRITE_TAC[HD;Seq.cats1;Seq.rcons_uniq;NOT_CONS_NIL]);
    BY(SIMP_TAC[]);
  COMMENT "a empty";
  TYPIFY `a = []` ASM_CASES_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases];
    FIRST_X_ASSUM GMATCH_SIMP_TAC;
    ASM_REWRITE_TAC[NOT_CONS_NIL;HD;TL;GSYM Seq.cats1];
    FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.rcons_uniq];
    BY(SIMP_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "now ~(a = [])";
  SIMP_TAC[LAST_rcons];
  FIRST_X_ASSUM_ST `uniq` MP_TAC THEN REWRITE_TAC[Seq.rcons_uniq] THEN DISCH_TAC;
  ((COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN FIRST_X_ASSUM GMATCH_SIMP_TAC THEN ASM_REWRITE_TAC[NOT_CONS_NIL;HD;TL]));
    ONCE_REWRITE_TAC[GSYM Seq.cats1];
    REWRITE_TAC[GSYM Seq.catA];
    BY(MESON_TAC[Seq.cat1s]);
  BY(MESON_TAC[Seq.cats1])
  ]);;
  (* }}} *)

let parts_pure = prove_by_refinement(
  `!L r. ~(r = []) /\ uniq r /\
    (!x. MEM x r ==> x = LAST r \/ next_el r x = f_list L (e_list x)) 
  ==> parts L r = [r]`,
  (* {{{ proof *)
  [
  REWRITE_TAC[partsr];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC partition_into_atom0r_pure;
  BY(ASM_REWRITE_TAC[o_THM])
  ]);;
  (* }}} *)

let eqseq_cat2 = prove_by_refinement(
  `!s1 s2 s3 s4.
    sizel s3 = sizel s4 ==>
    (cat s1 s3 = cat s2 s4 <=> s1 = s2 /\ s3 = s4)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `s1 = s2 /\ s3 = s4` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `sizel (cat s1 s3) = sizel (cat s2 s4)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq.size_cat];
  DISCH_TAC;
  TYPIFY `sizel s1 = sizel s2` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.eqseq_cat])
  ]);;
  (* }}} *)

let partition_into_atom0r_cons_acc = prove_by_refinement(
  `!n r a0 a. 
    partition_into_atom0r n (a0::a) r = 
      cat (partition_into_atom0r n [a0] r) a`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC;
    REWRITE_TAC[partition_into_atom0r_cases;MEM;];
    BY(REWRITE_TAC[Seq.cat1s]);
  REWRITE_TAC[partition_into_atom0r_cases;MEM;];
  REWRITE_TAC[rcons_nonnil;NOT_CONS_NIL;HD;TL];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(DISCH_THEN (unlist REWRITE_TAC o GSYM));
  DISCH_THEN (unlist ONCE_REWRITE_TAC);
  ONCE_REWRITE_TAC[GSYM Seq.cat1s];
  BY(REWRITE_TAC[Seq.cats0;Seq.catA])
  ]);;
  (* }}} *)

let partition_into_atom0r_cat = prove_by_refinement(
  `!n r u v x a. MEM x r  /\ ~(next_el r x = n x) /\
     r = cat u v /\ LAST u = x /\ ~(u= []) /\ ~(v = []) /\ uniq r ==>
    partition_into_atom0r n a r = 
    cat (partition_into_atom0r n [] u) (partition_into_atom0r n a v)`,
  (* {{{ proof *)
  [
  GEN_TAC THEN LISTR_INDUCT_TAC THEN ASM_REWRITE_TAC[partition_into_atom0r_cases;MEM;LAST_rcons;Seq.rcons_uniq;Seq.mem_rcons];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `LAST v = h` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[LAST_cat;LAST_rcons]);
  TYPIFY `?v'. rcons v' h = v` (C SUBGOAL_THEN MP_TAC);
    INTRO_TAC Seq2.cat_butlast_last [`h`;`v`];
    ASM_REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
    DISCH_THEN SUBST1_TAC;
    REWRITE_TAC[Seq.cats1];
    ASM_SIMP_TAC[last_LAST];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "v";
  TYPIFY `t = cat u v'` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `rcons t h = cat u k` MP_TAC;
    REWRITE_TAC[GSYM Seq.cats1;Seq.catA];
    BY(GMATCH_SIMP_TAC eqseq_cat2);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v'`;`x`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_REWRITE_TAC[partition_into_atom0r_cases];
  TYPIFY `v' = []` ASM_CASES_TAC;
    ASM_REWRITE_TAC[Seq.cats0;partition_into_atom0r_cases];
    COMMENT "expand u";
    TYPIFY `?u'. rcons u' x = u` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC Seq2.cat_butlast_last [`x`;`u`];
      ASM_REWRITE_TAC[arith `0 < n <=> ~(n = 0)`;Seq.size_eq0];
      DISCH_THEN SUBST1_TAC;
      REWRITE_TAC[Seq.cats1];
      ASM_SIMP_TAC[last_LAST];
      BY(MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    FULL_EXPAND_TAC "u";
    REWRITE_TAC[partition_into_atom0r_cases;NOT_CONS_NIL;HD;TL];
    TYPIFY `~(n x = h)` (C SUBGOAL_THEN ASSUME_TAC);
      DISCH_TAC;
      FIRST_X_ASSUM_ST `next_el` kill;
      FIRST_X_ASSUM_ST `next_el` MP_TAC;
      REWRITE_TAC[];
      ASM_REWRITE_TAC[Seq.rcons];
      INTRO_TAC next_el_cat_last1 [`rcons u' x`;`[h]`];
      SIMP_TAC[LAST_rcons;NOT_CONS_NIL;HD];
      DISCH_THEN MATCH_MP_TAC;
      REWRITE_TAC[Seq.cats1;rcons_nonnil];
      TYPIFY `t = (rcons u' x)` ENOUGH_TO_SHOW_TAC;
        DISCH_THEN (SUBST1_TAC o GSYM);
        REWRITE_TAC[Seq.rcons_uniq];
        BY(ASM_REWRITE_TAC[]);
      BY(ASM_REWRITE_TAC[Seq.cats0]);
    ASM_REWRITE_TAC[];
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
    COND_CASES_TAC THEN ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
    BY(REWRITE_TAC[GSYM partition_into_atom0r_cons_acc]);
  COMMENT "now v' nonnil";
  TYPIFY `MEM x (cat u v')` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[Seq.mem_cat];
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `~(next_el (cat u v') x = n x)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `next_el` kill;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `next_el (rcons t h)` MP_TAC;
    REWRITE_TAC[];
    TYPIFY `rcons t h = rcons (cat u v') h` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[GSYM Seq.cats1];
    GMATCH_SIMP_TAC next_el_cat1;
    TYPIFY `~(x = LAST (cat u v'))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[Seq.mem_cat;MEM_LAST]);
    ASM_SIMP_TAC[LAST_cat];
    FIRST_X_ASSUM_ST `uniq` MP_TAC;
    ASM_REWRITE_TAC[Seq.cat_uniq;GSYM Seq.hasP];
    BY(ASM_MESON_TAC[MEM_LAST]);
  FIRST_X_ASSUM_ST `partition_into_atom0r` MP_TAC;
  ASM_REWRITE_TAC[];
  DISCH_THEN (unlist REWRITE_TAC);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let parts_cat = prove_by_refinement(
  `!L r u v x.  r = cat u v /\ LAST u = x /\ ~(u = []) /\ ~(v = []) /\
    ~(next_el r x = f_list L (e_list x)) /\ uniq r ==> 
     parts L r = cat (parts L u) (parts L v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[partsr];
  GMATCH_SIMP_TAC (GSYM partition_into_atom0r_cat);
  TYPIFY `r` EXISTS_TAC;
  REWRITE_TAC[];
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[o_THM];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[Seq.mem_cat];
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let parts_cases = prove_by_refinement(
  `!n r. (!x. MEM x r ==> x = LAST r \/ next_el r x = n x) \/
     (?u v x. r = cat u v /\ LAST u = x /\ ~(u = []) /\ ~(v = []) /\
	 ~(next_el r x = n x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (TAUT (`(~a ==> b) ==> (a \/ b)`));
  REWRITE_TAC[NOT_FORALL_THM;DE_MORGAN_THM];
  REWRITE_TAC[TAUT `(~(a ==> b \/ c) <=> a /\ ~b /\ ~c)`];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_from [`x`;`r`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`a`;`b`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `cat` MP_TAC;
  ASM_REWRITE_TAC[Seq.cats0];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let size_induct = prove_by_refinement(
  `!P.  (!i. (!r:A list. sizel r < i ==> P r) ==> 
	   (!r:A list. sizel r = i ==> P r  )) 
    ==> (!r:A list. P r)`,
  (* {{{ proof *)
  [
  GEN_TAC THEN DISCH_TAC;
  TYPIFY `!n r. sizel r <= n ==> P r` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[arith `n <= n:num`]);
  TYPIFY `!i. (!r. sizel r < i ==> P r) ==> (!r. sizel r <= i ==> P r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `n <= i <=> n < i:num \/ n = i`]);
  INDUCT_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(REWRITE_TAC[arith `~(n < 0)`]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[arith `m <= n <=> m < SUC n`])
  ]);;
  (* }}} *)

let parts_induct_lemma = prove_by_refinement(
  `!r u v. uniq r /\ r = cat u v /\ ~(u = []) /\ ~(v = []) ==>
   sizel u < sizel r /\ sizel v < sizel r /\ uniq u /\ uniq v`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel r = sizel u + sizel v` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `cat` (SUBST1_TAC);
    BY(REWRITE_TAC[Seq.size_cat]);
  TYPIFY `~(sizel u = 0) /\ ~(sizel v = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  TYPIFY `sizel u < sizel r /\ sizel v < sizel r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `uniq` MP_TAC;
  BY(ASM_SIMP_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let parts_flatten = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> flatten (parts L r) = r`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq.flatten_cons];
    BY(REWRITE_TAC[concat_flatten;Seq.cats0]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.flatten_cat];
  REPEAT (FIRST_ASSUM_ST `flatten` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_all_nonnil = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> all (\p. ~(p = [])) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  REPEAT (FIRST_ASSUM_ST `all` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_next_unlast = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> 
     all (\p. (!x. MEM x p /\ ~(x = LAST p) ==> 
		 next_el p x = f_list L (e_list x))) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  RULE_ASSUM_TAC (REWRITE_RULE[IMP_IMP_THM]);
  TYPIFY `cat u v = r` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[]);
  REPEAT (FIRST_ASSUM_ST `all` GMATCH_SIMP_TAC);
  BY(ASM_MESON_TAC[parts_induct_lemma])
  ]);;
  (* }}} *)

let parts_next_last = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==>
     all (\p. (!(x:A#A). MEM x p /\ (x = LAST p) /\ ~(x = LAST r) ==> 
		 ~(next_el r x = f_list L (e_list x)))) (parts L r)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  MATCH_MP_TAC size_induct;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_cases [`f_list L o e_list`;`r`];
  REWRITE_TAC[o_THM];
  DISCH_THEN DISJ_CASES_TAC THEN FIRST_X_ASSUM MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_pure;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[GSYM Seq.allP;MEM];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_cat;
  GEXISTL_TAC [`u`;`v`];
  REWRITE_TAC[Seq.all_cat];
  RULE_ASSUM_TAC (REWRITE_RULE[IMP_IMP_THM]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[parts_induct_lemma]);
  REWRITE_TAC[GSYM Seq.allP;MEM];
  TYPIFY `sizel v < i /\ sizel u < i /\ uniq u /\ uniq v` (C SUBGOAL_THEN ASSUME_TAC);
    BY((ASM_MESON_TAC[parts_induct_lemma]));
  COMMENT "u";
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    RENAME_FREE_VAR (`x':(A#A)list`,"p");
    TYPIFY `~(x'' = LAST u)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    TYPIFY `MEM x'' u` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[parts_flatten;Seq2.mem_flatten]);
    FIRST_X_ASSUM (C INTRO_TAC [`u`]);
    ANTS_TAC;
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
    TYPIFY `p` EXISTS_TAC;
    ASM_REWRITE_TAC[NOT_FORALL_THM];
    TYPIFY `x''` EXISTS_TAC;
    REWRITE_TAC[TAUT `~(a ==> ~b) <=> a /\ b`];
    ASM_REWRITE_TAC[];
    TYPIFY `next_el r x'' = next_el u x''` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    TYPIFY `r = cat u v` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[]);
    GMATCH_SIMP_TAC next_el_cat1;
    BY(ASM_REWRITE_TAC[]);
  COMMENT "v";
  REPEAT WEAKER_STRIP_TAC;
  RENAME_FREE_VAR (`x':(A#A)list`,"p");
  TYPIFY `MEM x'' v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten;Seq2.mem_flatten]);
  FIRST_X_ASSUM (C INTRO_TAC [`v`]);
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
  TYPIFY `p` EXISTS_TAC;
  ASM_REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `x''` EXISTS_TAC;
  REWRITE_TAC[TAUT `~(a ==> ~b) <=> a /\ b`];
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `LAST (cat u v)` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC[LAST_cat]);
  DISCH_TAC;
  TYPIFY `next_el r x'' = next_el v x''` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `r = cat u v` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC next_el_cat2;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* was next_el_parts1 *)
let next_el_parts1 = 0;;

let next_el_parts_unlast = prove_by_refinement(
  `!L r p x.  uniq r /\ ~(r = []) /\
     MEM x p /\ MEM p (parts L r) /\ ~(x = LAST p) ==>
    next_el r x = next_el p x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_SIMP_TAC[parts_flatten]);
  GMATCH_SIMP_TAC next_el_flatten_unlast;
  TYPIFY `p` EXISTS_TAC;
  BY(ASM_SIMP_TAC[parts_flatten])
  ]);;
  (* }}} *)

let next_el_parts_last = prove_by_refinement(
  `!L r p x.  uniq r /\ ~(r = []) /\
     MEM x p /\ MEM p (parts L r) /\ (x = LAST p) ==>
    next_el r x =  HD (next_el (parts L r) p) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = flatten (parts L r)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(ASM_SIMP_TAC[parts_flatten]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC next_el_flatten_last;
  (ASM_SIMP_TAC[parts_flatten]);
  MATCH_MP_TAC parts_all_nonnil;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let quotient_all_uniq = prove_by_refinement(
  `!L N r x. marked_list L N r x ==>
    all uniq (quotient_list L N)`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[marked_list;LET_THM])
  ]);;
  (* }}} *)

let LYNVPSU = quotient_all_uniq;;

let parts_nonnil = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> ~(parts L r = [])`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_flatten [`L`;`r`] THEN ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.flatten0])
  ]);;
  (* }}} *)

let quotient_all_nonnil = prove_by_refinement(
  `!L N.  normal_list L N ==>
  all (\l. ~(l = [])) (quotient_list L N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[quotient_list;core_list];
  REWRITE_TAC[GSYM Seq.allP;upper_case];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[MAP_EQ_NIL];
  MATCH_MP_TAC parts_nonnil;
  FIRST_X_ASSUM_ST `normal_list` MP_TAC;
  REWRITE_TAC[normal_list;GSYM Seq.allP];
  BY(ASM_MESON_TAC[uniq_flatten_uniq])
  ]);;
  (* }}} *)

let parts_uniq  = prove_by_refinement(
  `!L r p. ~(r = []) /\ uniq r /\ MEM p (parts L r) ==> uniq p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC uniq_flatten_uniq;
  BY(ASM_MESON_TAC[parts_flatten])
  ]);;
  (* }}} *)

let parts_uniq_nonnil = prove_by_refinement(
  `!L N r p. normal_list L N /\ MEM r N /\ MEM p (parts L r) ==>
    uniq r /\ ~(r = []) /\ uniq p /\ ~(p = []) /\
    (!x. MEM x p ==> MEM x r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    INTRO_TAC parts_uniq [`L`;`r`;`p`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  TYPIFY `!x. MEM x p ==> MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten;Seq.allP;Seq2.mem_flatten]);
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let indexl_next_el = prove_by_refinement(
  `!s x. uniq s /\ MEM x s ==> indexl (next_el s x) s = 
     if (indexl x s = sizel s - 1) then 0 else (indexl x s + 1) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[Seq2.next_el];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq2.index_head];
  GMATCH_SIMP_TAC Seq.index_uniq;
  ASM_REWRITE_TAC[];
  RULE_ASSUM_TAC (REWRITE_RULE[GSYM Seq.index_mem]);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let parts_node_inverse_power = prove_by_refinement(
  `!L N r p k x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\
    MEM x p /\ k + indexl x p < sizel p 
     ==>  ((inverse (node_map (hypermap_of_list L)) POWER k) x = 
      EL (k + indexl x p) p)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 4 GEN_TAC;
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER_0;I_THM;arith `0+n=n`];
    BY(SIMP_TAC[Seq2.EL_index]);
  REWRITE_TAC[Hypermap.POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    INTRO_TAC parts_uniq [`L`;`r`;`p`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  TYPIFY `~(x = LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    DISCH_TAC;
    INTRO_TAC indexl_LAST [`p`] THEN ASM_REWRITE_TAC[];
    BY(FIRST_X_ASSUM_ST `SUC` MP_TAC THEN ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    TYPIFY `MEM x (flatten (parts L r))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  INTRO_TAC inverse_node_map_list [`L`;`x`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_SIMP_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`p`]);
  ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  ASM_SIMP_TAC[Seq2.mem_next_el];
  TYPIFY `indexl (next_el p x) p = indexl x p + 1` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(CONJ_TAC THEN REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC) THEN ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC indexl_next_el;
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let parts_in_node = prove_by_refinement(
  `!L N r p x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\ MEM x p ==>
     x IN (node (hypermap_of_list L) (HD p))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_node_inverse_power [`L`;`N`;`r`;`p`;`indexl x p`;`HD p`];
  ASM_REWRITE_TAC[];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[] THEN DISCH_TAC;
  ASM_SIMP_TAC[MEM_HD];
  ASM_SIMP_TAC[index_hd0];
  REWRITE_TAC[arith `n + 0 = n`];
  ASM_SIMP_TAC[Seq2.EL_index];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[Seq.index_mem]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[Hypermap.lemma_power_inverse_in_node2])
  ]);;
  (* }}} *)

let parts_fst = prove_by_refinement(
  `!L N r p x. normal_list L N /\ good_list L /\
    MEM r N /\ MEM p (parts L r) /\ MEM x p ==>
     FST x = FST (HD p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.fst_node_hypermap_of_list [`L`;`HD p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  MATCH_MP_TAC parts_in_node;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let f_list_fst_snd = prove_by_refinement(
  `!L x.  all uniq L /\ MEM x (list_of_darts L) ==> 
     FST (f_list L x) = SND x `,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (MP_TAC o MATCH_MP List_hypermap.mem_find_face);
  TYPIFY `MEM (p1,p2) (find_face L (p1,p2))` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_REWRITE_TAC[GSYM List_hypermap.dart_in_face]);
  REWRITE_TAC[List_hypermap.f_list;List_hypermap.find_face];
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC List_hypermap.next_el_list_pairs;
  BY(ASM_MESON_TAC[Seq.allP])
  ]);;
  (* }}} *)

let parts_darts = prove_by_refinement(
  `!L N r p x. MEM x p /\ MEM p (parts L r) /\ MEM r N /\
      normal_list L N ==> MEM x (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    TYPIFY `MEM x (flatten (parts L r))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  FIRST_ASSUM (MP_TAC o MATCH_MP normal_list_list_of_darts);
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let parts_last_as_fst_hd = prove_by_refinement(
  `!L N r p p'.  
     normal_list L N /\
    is_edge_nondegenerate (hypermap_of_list L) /\
    good_list L /\
    all uniq L /\
    MEM r N /\
    MEM p (parts L r) /\ p' = next_el (parts L r) p ==>
    FST (HD p), FST (HD p') = LAST p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[PAIR_EQ2];
  REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC parts_fst;
    GEXISTL_TAC [`L`;`N`;`r`];
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC MEM_LAST;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC (GSYM f_list_fst_snd);
  TYPIFY `L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    TYPIFY `MEM(LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC[parts_darts]);
  DISCH_TAC;
  AP_TERM_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  GMATCH_SIMP_TAC (GSYM next_el_parts_last);
  TYPIFY `LAST p` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[MEM_LAST];
  INTRO_TAC parts_next_last [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`p`]);
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`LAST p`]);
  ASM_SIMP_TAC[MEM_LAST];
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`LAST p`];
  ASM_REWRITE_TAC[];
  INTRO_TAC loop_list_f_or_ni [`L`;`r`;`LAST p`];
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[normal_list;Seq.allP]);
    BY(ASM_MESON_TAC[MEM_LAST;Seq2.mem_flatten;parts_flatten]);
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  TYPIFY `~(LAST p = LAST r)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `normal_list` MP_TAC;
  REWRITE_TAC[normal_list;GSYM Seq.allP;f_last];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `f_list` (C INTRO_TAC [`r`]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let uniq_parts  = prove_by_refinement(
  `!L r. uniq r /\ ~(r = []) ==> uniq (parts L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC List_hypermap.uniq_flatten;
  INTRO_TAC parts_flatten [`L`;`r`];
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC parts_all_nonnil;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let parts_list_pairs = prove_by_refinement(
  `!L N r. normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         MEM (r:(A#A)list) N /\
         all uniq L ==>
     list_pairs (MAP (\x. FST (HD x)) (parts L r)) =
         MAP LAST (parts L r)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (REWRITE_RULE[IMP_IMP_THM] Seq.eq_from_nth);
  TYPED_ABBREV_TAC `x0 = FST (HD r)`;
  TYPED_ABBREV_TAC `x1 = SND (HD r)`;
  TYPIFY `x0,x1` EXISTS_TAC;
  TYPED_ABBREV_TAC `lz = sizel (zip (MAP (\x. FST (HD x)) (parts L r)) (rot 1 (MAP (\x. FST (HD x)) (parts L r))))`;
  TYPED_ABBREV_TAC `lm = sizel (MAP LAST (parts L r))`;
  TYPIFY `lm = lz /\ sizel (MAP (\x. FST (HD x)) (parts L r)) = lz /\ sizel (rot 1 (MAP (\x. FST (HD x)) (parts L r))) = lz /\ sizel (parts L r) = lz /\ sizel (rot 1 (parts L r)) = lz /\ sizel (MAP (\x. FST (HD x)) (rot 1 (parts L r))) = lz` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "lm";
    FULL_EXPAND_TAC "lz";
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[Seq.size_rot;Seq.size_map;lower_case];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[lower_case;GSYM Seq.map_rot];
  REPEAT (GMATCH_SIMP_TAC (GSYM Seq2.EL_nth));
  ASM_REWRITE_TAC[upper_case];
  REPEAT (GMATCH_SIMP_TAC EL_MAP);
  TYPED_ABBREV_TAC `p = EL i (parts L r)`;
  ASM_REWRITE_TAC[lower_case];
  ASM_REWRITE_TAC[Seq.map_MAP];
  GMATCH_SIMP_TAC (GSYM parts_last_as_fst_hd);
  TYPIFY `next_el (parts L r) p` EXISTS_TAC;
  TYPIFY `MEM p (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "p";
    MATCH_MP_TAC MEM_EL;
    BY(ASM_REWRITE_TAC[lower_case]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[PAIR_EQ];
  AP_TERM_TAC THEN AP_TERM_TAC;
  GMATCH_SIMP_TAC Seq2.next_el_alt;
  TYPIFY `p` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC (GSYM Seq2.EL_nth));
  ASM_REWRITE_TAC[];
  TYPIFY `indexl p (parts L r) = i` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC uniq_parts [`L`;`r`];
  FULL_EXPAND_TAC "p";
  GMATCH_SIMP_TAC Seq2.EL_nth;
  TYPIFY `HD (parts L r)` EXISTS_TAC;
  GMATCH_SIMP_TAC Seq.index_uniq;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC uniq_parts;
  MATCH_MP_TAC normal_list_uniq_nonnil;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let list_of_darts_quotient = prove_by_refinement(
  `!L N.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    list_of_darts (quotient_list L N) = 
	     MAP LAST (flatten (MAP (parts L) N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[quotient_list;core_list];
  REWRITE_TAC[List_hypermap.list_of_darts_alt;MAP_flatten;upper_case];
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!r. MEM r N ==> ((list_pairs o (\f. MAP (\x. FST (HD x)) f)) o parts L) r = (MAP LAST o parts L) r` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    AP_TERM_TAC;
    MATCH_MP_TAC MAP_EQ;
    ASM_REWRITE_TAC[lower_case;GSYM Seq.allP];
    BY(ASM_REWRITE_TAC[upper_case]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[o_THM];
  BY(ASM_MESON_TAC[parts_list_pairs;Seq2.ALL_all])
  ]);;
  (* }}} *)

let mem_list_of_darts_quotient = prove_by_refinement(
  `!L N d. normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    (MEM d (list_of_darts (quotient_list L N)) <=>
     (?p r. MEM p (parts L r) /\ MEM r N /\ d = LAST p))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[list_of_darts_quotient];
  REWRITE_TAC[MEM_MAP;Seq2.mem_flatten];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let flatten_flatten = prove_by_refinement(
  `!s. 
    flatten (MAP flatten s) = flatten (flatten s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[Seq.flatten0;MAP]);
  BY(ASM_REWRITE_TAC[MAP;Seq.flatten_cons;Seq.flatten_cat])
  ]);;
  (* }}} *)

let normal_list_flatten_flatten = prove_by_refinement(
  `!L N. normal_list L N ==>
    flatten (flatten (MAP (parts L) N)) = flatten N`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `!r. MEM r N ==> (flatten o (parts L)) r = r` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[o_THM];
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC parts_flatten;
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MAP (flatten o (parts L)) N = MAP I N` (C SUBGOAL_THEN MP_TAC);
    MATCH_MP_TAC MAP_EQ;
    BY(ASM_REWRITE_TAC[lower_case;GSYM Seq.allP;I_THM]);
  REWRITE_TAC[MAP_I;I_THM];
  TYPIFY `flatten (flatten (MAP (parts L) N)) = flatten (MAP (flatten o parts L) N)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  BY(REWRITE_TAC[ MAP_o;flatten_flatten])
  ]);;
  (* }}} *)

let list_of_darts_quotient_uniq = prove_by_refinement(
  `!L N.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    uniq (list_of_darts (quotient_list L N))`,
  (* {{{ proof *)
  [
  SIMP_TAC[list_of_darts_quotient];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC uniq_map;
  CONJ_TAC;
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    ASM_SIMP_TAC[normal_list_flatten_flatten];
    CONJ_TAC;
      BY(ASM_MESON_TAC[normal_list]);
    REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten;MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC parts_all_nonnil [`L`;`x'`];
    ANTS_TAC;
      MATCH_MP_TAC normal_list_uniq_nonnil;
      BY(ASM_MESON_TAC[]);
    BY(ASM_MESON_TAC[Seq.allP]);
  COMMENT "LAST INJ";
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `d = LAST u`;
  REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC);
  ASM_REWRITE_TAC[Seq2.mem_flatten;MEM_MAP;MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq x /\ ~(x = []) /\ uniq x' /\ ~(x' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `~(u = []) /\ ~(v = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_all_nonnil;Seq.allP]);
  TYPIFY `MEM d u /\ MEM d v` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `MEM d x /\ MEM d x'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten;Seq2.mem_flatten]);
  TYPIFY `uniq (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list]);
  INTRO_TAC find_list_uniq [`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `x = x'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[find_list_uniq]);
  INTRO_TAC uniq_parts [`L`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `find_list (parts L x) d = u /\ find_list (parts L x) d = v` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  TYPIFY `uniq (flatten (parts L x))` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC parts_flatten;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC THEN MATCH_MP_TAC find_list_uniq;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let list_of_darts_quotient_sym = prove_by_refinement(
  `!L N.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    (!(d:A#A). MEM d (list_of_darts (quotient_list L N)) ==> 
       MEM (SND d,FST d) (list_of_darts (quotient_list L N)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[list_of_darts_quotient;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC THEN REWRITE_TAC[Seq2.mem_flatten;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x'` (fun t -> RENAME_FREE_VAR (t,"r"));
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "l";
  TYPIFY `x` (fun t -> RENAME_FREE_VAR (t,"p"));
  TYPED_ABBREV_TAC `d' = p2,p1`;
  TYPIFY `e_list d' = p1,p2` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[List_hypermap.e_list];
    BY(EXPAND_TAC "d'" THEN REWRITE_TAC[]);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
  TYPIFY `MEM (p1,p2) r` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  TYPIFY `next_el r (p1,p2) = f_list L (p1,p2)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC loop_list_f_or_ni [`L`;`r`;`(p1,p2)`];
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[normal_list;Seq.allP]);
    DISCH_THEN DISJ_CASES_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    TYPIFY `(p1,p2) = LAST r` ASM_CASES_TAC;
      FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[normal_list;f_last;GSYM Seq.allP];
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    INTRO_TAC parts_next_last [`L`;`r`];
    ASM_REWRITE_TAC[GSYM Seq.allP];
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (f_list L (p1,p2)) r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_next_el]);
  TYPIFY `MEM (f_list L (p1,p2)) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC normal_list_list_of_darts [`L`;`N`];
    ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    DISCH_THEN MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  COMMENT "n f d IN flatten N";
  TYPIFY `MEM (n_list L (f_list L (p1,p2))) (flatten N)` (C SUBGOAL_THEN MP_TAC);
    FIRST_X_ASSUM_ST `normal_list` MP_TAC;
    REWRITE_TAC[normal_list];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`f_list L (p1,p2)`]);
    ANTS_TAC;
      BY(ASM_MESON_TAC[Seq2.mem_flatten]);
    REWRITE_TAC[SUBSET;IN_SET_OF_LIST;Seq2.mem_flatten];
    TYPIFY `n_list L (f_list L (p1,p2)) IN node (hypermap_of_list L) (f_list L (p1,p2))` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    INTRO_TAC Hypermap.lemma_in_node2 [`hypermap_of_list L`;`f_list L (p1,p2)`;`1`];
    REWRITE_TAC[Hypermap.POWER_1];
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    GMATCH_SIMP_TAC n_list_ext_n_list;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[Seq2.mem_flatten];
  DISCH_THEN (X_CHOOSEv_TAC "r'");
  INTRO_TAC e_list_ext_n_f [`L`] THEN ASM_REWRITE_TAC[];
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  DISCH_THEN (C INTRO_TAC [`p1,p2`]);
  REWRITE_TAC[o_THM];
  GMATCH_SIMP_TAC n_list_ext_n_list;
  GMATCH_SIMP_TAC f_list_ext_f_list;
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  ASM_REWRITE_TAC[dart_hypermap_of_list;IN_SET_OF_LIST;List_hypermap.darts_of_list];
  nCONJ_TAC 0;
    INTRO_TAC normal_list_list_of_darts [`L`;`N`];
    ASM_REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM d' r'` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `e_list (p1,p2) = p2,p1` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    BY(REWRITE_TAC[List_hypermap.e_list]);
  TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  TYPIFY `?p'. MEM d' p' /\ MEM p' (parts L r')` (C SUBGOAL_THEN MP_TAC);
    INTRO_TAC parts_flatten [`L`;`r'`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    TYPIFY `MEM d' (flatten (parts L r'))` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_REWRITE_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d' = LAST p'` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  PROOF_BY_CONTR_TAC;
  COMMENT "show r= r'";
  TYPIFY `next_el r' d' = f_list L (p1,p2)` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_next_unlast [`L`;`r'`];
    INTRO_TAC next_el_parts_unlast [`L`;`r'`;`p'`;`d'`];
    ASM_REWRITE_TAC[GSYM Seq.allP];
    DISCH_TAC;
    DISCH_THEN (C INTRO_TAC [`p'`]);
    ASM_REWRITE_TAC[];
    DISCH_THEN (C INTRO_TAC [`d'`]);
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `MEM (f_list L (p1,p2)) r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_next_el]);
  TYPIFY `r = r'` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `uniq (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[normal_list]);
    BY(ASM_MESON_TAC[find_list_uniq]);
  TYPIFY `(p1,p2) = d'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.next_el_inj]);
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`(p1,p2)`];
  ANTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let good_list_quotient = prove_by_refinement(
  `!L N.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L ==>
    good_list (quotient_list L N)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[good_list];
  ASM_SIMP_TAC[list_of_darts_quotient_uniq];
  BY(ASM_SIMP_TAC[list_of_darts_quotient_uniq;list_of_darts_quotient_sym;quotient_all_nonnil])
  ]);;
  (* }}} *)

let atom_list_last = prove_by_refinement(
  `!L N r p. 
     normal_list L N /\
   MEM p (parts L r) /\ MEM r N ==>
    atom_list L r (LAST p) = p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[atom_list];
  MATCH_MP_TAC find_list_uniq;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC parts_flatten;
  GMATCH_SIMP_TAC MEM_LAST;
  BY(ASM_MESON_TAC[parts_uniq_nonnil])
  ]);;
  (* }}} *)

let is_node_going_refl = prove_by_refinement(
  `!H L d. is_node_going H L d d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[is_node_going];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `0` EXISTS_TAC;
  REWRITE_TAC[arith `i <= 0 <=> i = 0`];
  BY(SIMP_TAC[POWER_0;I_THM])
  ]);;
  (* }}} *)

let normal_list_parts_next_last = prove_by_refinement(
  `!L N r p. normal_list L N /\ MEM r N /\ MEM p (parts L r) ==>
     next_el r (LAST p) = f_list L (LAST p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (LAST p) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_darts;MEM_LAST]);
  TYPIFY `f_last L r` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[normal_list;Seq.allP]);
  REWRITE_TAC[f_last];
  TYPIFY `LAST p = LAST r` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_THEN kill;
  INTRO_TAC parts_next_last [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP];
  INTRO_TAC loop_list_f_or_ni [`L`;`r`;`LAST p`];
  ANTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[normal_list;Seq.allP]);
    BY(ASM_MESON_TAC[parts_flatten;Seq.allP;Seq2.mem_flatten;MEM_LAST]);
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let normal_list_parts_next_last_not = prove_by_refinement(
  `!L N r. good_list L /\ normal_list L N /\ MEM r N /\ MEM p (parts L r) /\
     is_edge_nondegenerate (hypermap_of_list L) ==>
     ~(next_el r (LAST p) = f_list L (e_list (LAST p)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (LAST p) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_darts;MEM_LAST]);
  BY(ASM_MESON_TAC[edge_nondeg_f_xor_ni;normal_list_parts_next_last])
  ]);;
  (* }}} *)

let is_node_going_last1 = prove_by_refinement(
  `!L N (r:(A#A)list) p d. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\ MEM p (parts L r) /\ MEM r N ==>
     (is_node_going (hypermap_of_list L) (loop_of_list r) (LAST p) d <=>
     d = LAST p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  ASM_SIMP_TAC[is_node_going_refl];
  REWRITE_TAC[is_node_going];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `k = 0` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[POWER_0;I_THM]);
  FIRST_X_ASSUM (C INTRO_TAC [`1`]);
  ASM_SIMP_TAC[arith `~(k=0) ==> 1 <=k`];
  REWRITE_TAC[POWER_1];
  GMATCH_SIMP_TAC loop_map_next_el;
  GMATCH_SIMP_TAC inverse_node_map_list;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (LAST p) (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_darts;MEM_LAST]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  BY(ASM_MESON_TAC[normal_list_parts_next_last_not])
  ]);;
  (* }}} *)

let last_in_dart_of_loop = prove_by_refinement(
  `!L N r p. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\ MEM p (parts L r) /\ MEM r N ==>
    atom (hypermap_of_list L) (loop_of_list r) (LAST p) SUBSET (set_of_list r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap.lemma_atom_sub_loop [`hypermap_of_list L`;`loop_of_list r`;`LAST p`];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_SIMP_TAC[in_dart_of_loop;dart_of_loop_of_list;IN_SET_OF_LIST];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_MESON_TAC[MEM_LAST;Seq2.mem_flatten;parts_flatten;Seq.allP])
  ]);;
  (* }}} *)

let mem_f_list = prove_by_refinement(
  `!L d. 
    MEM d (list_of_darts L) ==>
    MEM (f_list L d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.mem_f_list;List_hypermap.mem_find_face_imp_mem_darts])
  ]);;
  (* }}} *)

let inverse_node_map_list_power = prove_by_refinement(
  `!L k d.
            good_list L /\ MEM d (list_of_darts L)
            ==> 
    (inverse (node_map (hypermap_of_list L)) POWER k) d =
                ((f_list L o e_list) POWER k) d`,
  (* {{{ proof *)
  [
  GEN_TAC THEN INDUCT_TAC THEN ASM_REWRITE_TAC[POWER_0;o_THM;I_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[POWER;o_THM];
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC inverse_node_map_list;
  ASM_REWRITE_TAC[];
  INTRO_TAC good_list_e_list [`L`;`d`];
  ASM_REWRITE_TAC[];
  BY(ASM_SIMP_TAC[mem_f_list])
  ]);;
  (* }}} *)

let next_el_parts_power = prove_by_refinement(
  `!L r p i x.
     uniq r /\ ~(r = []) /\ MEM x p /\ MEM p (parts L r) /\
      indexl x p + i < sizel p ==>
     (next_el r POWER i) x = (next_el p POWER i) x`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  INDUCT_TAC;
    BY(REWRITE_TAC[POWER_0]);
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC next_el_parts_unlast;
  TYPIFY `p` EXISTS_TAC;
  REWRITE_TAC[LEFT_AND_EXISTS_THM];
  TYPIFY `L` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `uniq p /\ ~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC parts_all_nonnil [`L`;`r`];
    INTRO_TAC parts_uniq [`L`;`r`;`p`];
    BY(ASM_SIMP_TAC[GSYM Seq.allP]);
  INTRO_TAC indexl_LAST [`p`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  SUBCONJ_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `SUC` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  DISCH_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[Seq2.mem_next_el];
  ASM_SIMP_TAC[indexl_next_el];
  BY(COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_hd = prove_by_refinement(
  `!s d. MEM d p ==> indexf (HD p) d p = indexl d p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC indexf_cond;
  TYPIFY `~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  ASM_SIMP_TAC[index_hd0;MEM_HD;arith `0 <= n`];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let hd_eq_last = prove_by_refinement(
  `!x. ~(x = []) /\ uniq x /\ HD x = LAST x ==> x = [HD x]`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[]);
  REWRITE_TAC[HD;LAST];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[Seq.cons_uniq];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let indexl_flatten = prove_by_refinement(
  `!d p r. MEM d p /\ MEM p r /\ uniq (flatten r) /\ all (\l. ~(l = [])) r
   ==> indexl d p + indexl (HD p) (flatten r) = indexl d (flatten r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_from [`p`;`r`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC cat_to [`p`;`a`];
  TYPIFY `MEM p a` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Seq.flatten_cat];
  REWRITE_TAC[Seq.index_cat;Seq.mem_cat];
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "a";
  FULL_EXPAND_TAC "r";
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FIRST_X_ASSUM_ST `flatten` MP_TAC;
  REWRITE_TAC[Seq.flatten_cat];
  REWRITE_TAC[Seq.cat_uniq];
  FIRST_X_ASSUM_ST `LAST` MP_TAC;
  GMATCH_SIMP_TAC LAST_cat;
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[Seq.all_cat]);
  TYPIFY `uniq b'` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC List_hypermap.uniq_flatten;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `LAST (cat a' b') = LAST b'` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC LAST_cat;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `[p] = b'` (C SUBGOAL_THEN ASSUME_TAC);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    ASM_REWRITE_TAC[];
    MATCH_MP_TAC hd_eq_last;
    BY(ASM_REWRITE_TAC[]);
  FULL_EXPAND_TAC "b'";
  REWRITE_TAC[HD;Seq.flatten_cons;Seq.flatten0];
  TYPIFY `~(p = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  ASM_SIMP_TAC[HD;Seq.flatten_cons;Seq.flatten0;Seq.cats0;MEM_HD];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `has` kill;
    FIRST_X_ASSUM_ST `has` MP_TAC THEN REWRITE_TAC[GSYM Seq.hasP];
    REWRITE_TAC[Seq.flatten_cons;Seq.flatten0;NOT_EXISTS_THM;Seq.cats0];
    BY(ASM_MESON_TAC[MEM_HD]);
  ASM_SIMP_TAC[index_hd0];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `has` kill;
    FIRST_X_ASSUM_ST `has` MP_TAC THEN REWRITE_TAC[GSYM Seq.hasP];
    REWRITE_TAC[Seq.flatten_cons;Seq.flatten0;NOT_EXISTS_THM;Seq.cats0];
    BY(ASM_MESON_TAC[]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_flatten = prove_by_refinement(
  `!par p d1 d2. 
    MEM d1 p /\ MEM d2 p /\ indexl d1 p <= indexl d2 p /\ MEM p par /\
   uniq (flatten par) /\ all (\l. ~(l = [])) par ==>
   indexf d1 d2 p = indexf d1 d2 (flatten par)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (GMATCH_SIMP_TAC indexf_cond);
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq2.mem_flatten]);
  DISCH_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC indexl_flatten [`d1`;`p`;`par`];
  INTRO_TAC indexl_flatten [`d2`;`p`;`par`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  DISCH_THEN (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[arith `(a:num) + i <= b + i <=> a <= b`];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let is_node_going_last2_lemma = prove_by_refinement(
  `!L N (r:(A#A)list) p d. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\ MEM p (parts L r) /\ MEM r N /\ MEM d p ==>
     (is_node_going (hypermap_of_list L) (loop_of_list r) d (LAST p))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[is_node_going];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `indexf d (LAST p) r` EXISTS_TAC;
  ASM_SIMP_TAC[loop_map_next_el];
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC parts_darts;
    BY(ASM_MESON_TAC[]);
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  SUBCONJ_TAC;
    GMATCH_SIMP_TAC indexf_n;
    BY(ASM_SIMP_TAC[]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC parts_node_inverse_power;
  TYPIFY `p` EXISTS_TAC;
  REWRITE_TAC[LEFT_AND_EXISTS_THM];
  GEXISTL_TAC [`N`;`r`];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC next_el_parts_power;
  TYPIFY `p` EXISTS_TAC;
  REWRITE_TAC[LEFT_AND_EXISTS_THM];
  GEXISTL_TAC [`L`];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.next_el_power;
  TYPIFY `d` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  COMMENT "indexing";
  TYPIFY `indexl d p + i < sizel p` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    GMATCH_SIMP_TAC MOD_LT;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
    TYPIFY `i + indexl d p = indexl d p + i` ((C SUBGOAL_THEN SUBST1_TAC));
      BY(ARITH_TAC);
    BY(ASM_REWRITE_TAC[]);
  PROOF_BY_CONTR_TAC;
  TYPIFY `indexl d p + indexf d (LAST p) r < sizel p` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `MEM (HD p) p /\ MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_HD;MEM_LAST]);
  TYPIFY `indexl (HD p) p = 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[index_hd0]);
  TYPIFY `indexf d (LAST p) r = indexf d (LAST p) p` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    ASM_SIMP_TAC[GSYM indexf_hd];
    GMATCH_SIMP_TAC indexf_add_left;
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[ indexf_hd];
    REPEAT (GMATCH_SIMP_TAC indexl_LAST);
    ASM_REWRITE_TAC[];
    TYPIFY `~(sizel p = 0)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[Seq.size_eq0]);
    INTRO_TAC Seq.index_mem [`d`;`p`];
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  INTRO_TAC indexf_flatten [`parts L r`;`p`;`d`;`LAST p`];
  ASM_SIMP_TAC[parts_flatten];
  ANTS_TAC;
    CONJ_TAC;
      REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC);
      REWRITE_TAC[GSYM Seq.index_mem];
      ASM_SIMP_TAC[indexl_LAST];
      BY(ARITH_TAC);
    MATCH_MP_TAC parts_all_nonnil;
    BY(ASM_REWRITE_TAC[]);
  BY(SIMP_TAC[])
  ]);;
  (* }}} *)

let atom_subset_r = prove_by_refinement(
  `!L N r d.  
    normal_list L N /\ 
     MEM r N /\ MEM d r 
   ==>
  (atom (hypermap_of_list L) (loop_of_list r) d) SUBSET (set_of_list r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC lemma_atom_sub_loop [`hypermap_of_list L`;`loop_of_list r`;`d`];
  BY(ASM_SIMP_TAC[in_dart_of_loop;dart_of_loop_of_list;IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let atom_eq_last = prove_by_refinement(
  `!L N (r:(A#A)list) r' r'' p p'. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    MEM p (parts L r) /\ MEM r N /\ MEM d p
  ==>
  atom (hypermap_of_list L) (loop_of_list r) d = 
  atom (hypermap_of_list L) (loop_of_list r) (LAST p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC Hypermap.lemma_identity_atom;
  REWRITE_TAC[atom;IN_ELIM_THM];
  BY(ASM_MESON_TAC[is_node_going_last2_lemma])
  ]);;
  (* }}} *)

let atom_last_inj = prove_by_refinement(
  `!L N (r:(A#A)list) r' p p'. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    MEM p (parts L r) /\ MEM r N /\ 
    MEM p' (parts L r') /\ MEM r' N /\ 
    atom (hypermap_of_list L) (loop_of_list r) (LAST p) = 
  atom (hypermap_of_list L) (loop_of_list r') (LAST p')
  ==> (r = r') /\ (LAST p = LAST p')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `LAST p' IN atom (hypermap_of_list L) (loop_of_list r) (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.atom_reflect]);
  INTRO_TAC atom_subset_r [`L`;`N`;`r`;`LAST p`];
  ASM_REWRITE_TAC[];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  TYPIFY `MEM (LAST p) r` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_SIMP_TAC[];
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (LAST p') r` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[GSYM IN_SET_OF_LIST];
    BY(ASM_TAC THEN SET_TAC[]);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  TYPIFY `MEM (LAST p') r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `uniq (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[normal_list]);
  TYPIFY `r = r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.uniq_sublist_unique]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "r'";
  FIRST_X_ASSUM_ST `LAST p' IN a` MP_TAC;
  REWRITE_TAC[atom;IN_ELIM_THM];
  REPEAT (GMATCH_SIMP_TAC is_node_going_last1);
  REWRITE_TAC[LEFT_AND_EXISTS_THM];
  TYPIFY `N` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `N` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let atom_last_surj = prove_by_refinement(
  `!L N a. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\
    a IN atoms_of_family (hypermap_of_list L) (loop_family_of_list N) ==>
    (?r (p:(A#A)list). 
    MEM p (parts L r) /\ MEM r N /\ 
    a = atom (hypermap_of_list L) (loop_of_list r) (LAST p))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[atoms_of_family;IN_ELIM_THM;in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE[EQ_SYM_EQ]);
  FULL_EXPAND_TAC "L'";
  FIRST_X_ASSUM_ST `dart_of_loop` MP_TAC;
  GMATCH_SIMP_TAC dart_of_loop_of_list;
  RENAME_FREE_VAR (`x:(A#A)list`,"r");
  RENAME_FREE_VAR (`x:(A#A)`,"d");
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  DISCH_TAC;
  TYPIFY `MEM d (flatten (parts L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_flatten]);
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`r`;`l`];
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "a";
  MATCH_MP_TAC atom_eq_last;
  TYPIFY `N` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[upper_case])
  ]);;
  (* }}} *)

let atom_last_p = prove_by_refinement(
  `!L N (r:(A#A)list) p.  good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L /\ 
     MEM r N /\ MEM p (parts L r) ==>
   atom (hypermap_of_list L) (loop_of_list r) (LAST p) = set_of_list p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  REWRITE_TAC[EXTENSION;IN_SET_OF_LIST];
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[atom;IN_ELIM_THM];
    DISCH_TAC;
    GMATCH_SIMP_TAC is_node_going_last2_lemma;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC atom_subset_r [`L`;`N`;`r`;`LAST p`];
  ASM_SIMP_TAC[SUBSET;IN_SET_OF_LIST;MEM_LAST];
  DISCH_TAC;
  TYPIFY `MEM x r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY `?p'. MEM p' (parts L r) /\ MEM x p'` (C SUBGOAL_THEN MP_TAC);
    INTRO_TAC parts_flatten [`L`;`r`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC;
    BY(MESON_TAC[parts_flatten;Seq2.mem_flatten]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x IN atom (hypermap_of_list L) (loop_of_list r) (LAST p')` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[atom;IN_ELIM_THM];
    DISJ2_TAC;
    BY(ASM_MESON_TAC[is_node_going_last2_lemma]);
  TYPIFY `atom (hypermap_of_list L) (loop_of_list r) (LAST p) = atom (hypermap_of_list L) (loop_of_list r) (LAST p')` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_identity_atom]);
  INTRO_TAC atom_last_inj [`L`;`N`;`r`;`r`;`p`;`p'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p'`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p') p'` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[MEM_LAST]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `p = p'` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  GEXISTL_TAC [ `(parts L r)`;`LAST p`];
  BY(ASM_SIMP_TAC[parts_flatten])
  ]);;
  (* }}} *)

let find_atom_part = prove_by_refinement(
  `!L N r p.  normal_list L N /\ MEM r N /\ MEM p (parts L r) ==>
      find_atom L N (LAST p) = p`,
  (* {{{ proof *)
  [
  REWRITE_TAC[find_atom;atom_list];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  MATCH_MP_TAC find_list_uniq;
  TYPIFY `find_list N (LAST p) = r` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC find_list_uniq;
    ASM_SIMP_TAC[];
    BY(ASM_MESON_TAC[normal_list]);
  BY(ASM_SIMP_TAC[parts_flatten])
  ]);;
  (* }}} *)

let find_atom_part2 = prove_by_refinement(
  `!L N r p d.  normal_list L N /\ MEM r N /\ MEM p (parts L r) /\
      MEM d p ==>
      find_atom L N d = p`,
  (* {{{ proof *)
  [
  REWRITE_TAC[find_atom;atom_list];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC find_list_uniq;
  TYPIFY `find_list N d = r` (C SUBGOAL_THEN SUBST1_TAC);
    MATCH_MP_TAC find_list_uniq;
    ASM_SIMP_TAC[];
    BY(ASM_MESON_TAC[normal_list]);
  BY(ASM_SIMP_TAC[parts_flatten])
  ]);;
  (* }}} *)

let head_of_atom_parts = prove_by_refinement(
  `!L N r p d:A#A. is_restricted (hypermap_of_list L) /\
     good_list L /\ good_list_nodes L /\ normal_list L N /\
    all uniq L /\ 
       MEM p (parts L r) /\ MEM r N /\ MEM d p
    ==> head_of_atom (hypermap_of_list L) (loop_family_of_list N) d = 
             LAST p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted]);
  GMATCH_SIMP_TAC Hypermap.lemma_unique_head_of_atom;
  TYPIFY `LAST p` EXISTS_TAC;
  REWRITE_TAC[];
  TYPIFY `loop_of_list r` EXISTS_TAC;
  ASM_SIMP_TAC[normal_list_normal];
  REWRITE_TAC[loop_family_of_list;in_dart_of_loop;IN_SET_OF_LIST];
  CONJ_TAC;
    REWRITE_TAC[upper_case;MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[in_dart_loop_of_list];
  ASM_SIMP_TAC[loop_map_next_el];
  GMATCH_SIMP_TAC inverse_node_map_list;
  CONJ_TAC;
    BY(ASM_MESON_TAC[parts_darts;MEM_LAST]);
  GMATCH_SIMP_TAC atom_eq_last;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Hypermap.atom_reflect];
  BY(ASM_MESON_TAC[normal_list_parts_next_last_not])
  ]);;
  (* }}} *)

let tail_of_atom_parts = prove_by_refinement(
  `!L N r p d:A#A. is_restricted (hypermap_of_list L) /\
     good_list L /\ good_list_nodes L /\ normal_list L N /\
    all uniq L /\ 
       MEM p (parts L r) /\ MEM r N /\ MEM d p
    ==> tail_of_atom (hypermap_of_list L) (loop_family_of_list N) d = 
             HD p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted]);
  GMATCH_SIMP_TAC Hypermap.lemma_tail_of_atom;
  TYPIFY `loop_of_list r` EXISTS_TAC;
  ASM_SIMP_TAC[normal_list_normal];
  REWRITE_TAC[loop_family_of_list;in_dart_of_loop;IN_SET_OF_LIST];
  nCONJ_TAC 0;
    REWRITE_TAC[upper_case;MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[in_dart_loop_of_list];
  GMATCH_SIMP_TAC atom_eq_last;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC atom_last_p;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[IN_SET_OF_LIST;MEM_HD];
  TYPIFY `?p'. MEM p' (parts L r) /\ next_el (parts L r) p' = p` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[uniq_parts;Seq2.next_prev_id;Seq2.mem_prev_el]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p'`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_el_parts_last [`L`;`r`;`p'`;`LAST p'`];
  ASM_SIMP_TAC[MEM_LAST];
  DISCH_TAC;
  TYPIFY `inv_loop_map (loop_of_list r) (HD p) = LAST p'` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    GMATCH_SIMP_TAC normal_list_parts_next_last;
    TYPIFY `L` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC face_map_list;
    BY(ASM_MESON_TAC[parts_darts;MEM_LAST]);
  TYPIFY `loop_map (loop_of_list r) (LAST p') = (HD p)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[Hypermap.lemma_inverse_evaluation]);
  BY(ASM_SIMP_TAC[loop_map_next_el])
  ]);;
  (* }}} *)

let atom_list_bij = prove_by_refinement(
  `!L N. good_list L /\ normal_list L N /\
       is_edge_nondegenerate (hypermap_of_list L) /\
    all uniq L ==>
   BIJ (set_of_list o (find_atom L N)) 
    (darts_of_list (quotient_list L N)) 
    (atoms_of_family (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[BIJ;INJ;SURJ;o_THM;IN_SET_OF_LIST;List_hypermap.darts_of_list];
  ASM_SIMP_TAC[mem_list_of_darts_quotient];
  SUBCONJ_TAC;
    SUBCONJ_TAC;
      REPEAT WEAKER_STRIP_TAC;
      INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
      ASM_REWRITE_TAC[];
      DISCH_TAC;
      TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
        BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
      ASM_SIMP_TAC[atoms_of_family;IN_ELIM_THM];
      GEXISTL_TAC [`loop_of_list r`;`LAST p`];
      ASM_SIMP_TAC[in_dart_of_loop;loop_family_of_list];
      GMATCH_SIMP_TAC find_atom_part;
      CONJ_TAC;
        BY(ASM_MESON_TAC[]);
      GMATCH_SIMP_TAC atom_last_p;
      CONJ_TAC;
        BY(ASM_MESON_TAC[]);
      REWRITE_TAC[IN_SET_OF_LIST];
      ASM_SIMP_TAC[in_dart_loop_of_list];
      REWRITE_TAC[upper_case;MEM_MAP];
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    COMMENT "inj";
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC;
    ASM_REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC find_atom_part);
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC;
    TYPIFY `MEM (LAST p') p /\ MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
      ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST];
      ASM_REWRITE_TAC[IN_SET_OF_LIST];
      BY(ASM_MESON_TAC[MEM_LAST;parts_uniq_nonnil]);
    TYPIFY `(r = r') /\ (LAST p = LAST p')` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    MATCH_MP_TAC atom_last_inj;
    GEXISTL_TAC [`L`;`N`];
    ASM_REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC atom_last_p);
    BY(ASM_MESON_TAC[]);
  COMMENT "surj";
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC atom_last_surj [`L`;`N`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `LAST p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC find_atom_part;
  GMATCH_SIMP_TAC atom_last_p;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let parts_last_inj = prove_by_refinement(
  `!L N r p p'. normal_list L N /\ MEM r N /\ MEM p (parts L r) /\ 
    MEM p' (parts L r) /\  
    LAST p  = LAST p' ==> p = p'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p'`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p) p /\ MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[MEM_LAST]);
  MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  GEXISTL_TAC [`(parts L r)`;`LAST p`];
  BY(ASM_MESON_TAC[parts_flatten])
  ]);;
  (* }}} *)

let next_el_map_last = prove_by_refinement(
  `!L N r p. normal_list L N /\ MEM r N /\ MEM p (parts L r) ==>
    next_el (MAP LAST (parts L r)) (LAST p) = LAST (next_el (parts L r) p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC next_el_MEM_map;
  ASM_REWRITE_TAC[];
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  ASM_SIMP_TAC[uniq_parts];
  BY(ASM_MESON_TAC[parts_last_inj])
  ]);;
  (* }}} *)

(* was
let find_face_parts = 0;;
*)

let find_pair_list_parts = prove_by_refinement(
  `!L N (r:(A#A)list) p.
     good_list L /\ 
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L /\
    MEM p (parts L r) /\ MEM r N 
  ==>
   (MAP (\x. FST (HD x)) (parts L r)) = 
 find_pair_list (MAP (\f. MAP (\x. FST (HD x)) f) (MAP (parts L) N)) (LAST p)
     `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  GMATCH_SIMP_TAC parts_list_pairs;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  nCONJ_TAC 2;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  nCONJ_TAC 1;
    REWRITE_TAC[GSYM MAP_o;o_THM];
    TYPIFY `(MAP (\x. FST (HD x)) (parts L r)) = ((\f. MAP (\x. FST (HD x)) f) o parts L) r` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REWRITE_TAC[o_THM]);
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC list_of_darts_quotient_uniq [`L`;`N`];
  ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[quotient_list;core_list;upper_case])
  ]);;
  (* }}} *)

let f_list_quotient = prove_by_refinement(
  `!L N (r:(A#A)list) p r' p'.
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         good_list L /\
         all uniq L /\
    MEM p (parts L r) /\ MEM r N /\ MEM p' (parts L r') /\ MEM r' N
  ==>
 ((f_list (quotient_list L N) (LAST p) = LAST p') <=>
   next_el (parts L r) p = p')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[quotient_list;core_list];
  TYPIFY `f_list (map (\f. map (\x. FST (HD x)) f) (map (parts L) N)) (LAST p) = next_el (MAP LAST (parts L r)) (LAST p)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    GMATCH_SIMP_TAC next_el_map_last;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    TYPIFY `MEM (next_el (parts L r) p) (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    TYPIFY `MEM p' (parts L r)` ASM_CASES_TAC;
      BY(ASM_MESON_TAC[parts_last_inj]);
    TYPIFY `MEM (next_el (parts L r) p) (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    TYPED_ABBREV_TAC `p'' = next_el (parts L r) p`;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p''`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `~(p' = p'')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[]);
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    ASM_REWRITE_TAC[] THEN DISCH_TAC;
    TYPIFY `r = r'` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
      GEXISTL_TAC [`N`;`LAST p'`];
      CONJ_TAC;
        BY(ASM_MESON_TAC[normal_list]);
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC [parts_last_inj]);
  REWRITE_TAC[List_hypermap.f_list];
  REPEAT ( AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[List_hypermap.find_face_alt;upper_case];
  GMATCH_SIMP_TAC (GSYM find_pair_list_parts);
  TYPIFY `r` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC parts_list_pairs;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let f_list_quotient_alt = prove_by_refinement(
  `!L N r r' p p'.
    normal_list L N /\
    MEM p (parts L r) /\
    MEM p' (parts L r') /\
       MEM r N /\
     MEM r' N ==>
    (next_el (parts L r) p = p' <=> MEM (f_list L (LAST p)) p')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_parts_next_last [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC next_el_flatten_last [`(parts L r)`;`p`];
  ASM_SIMP_TAC[parts_flatten;parts_all_nonnil];
  DISCH_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(ASM_MESON_TAC[MEM_HD;parts_uniq_nonnil]);
  TYPED_ABBREV_TAC `p'' = next_el (parts L r) p`;
  TYPIFY `MEM p'' (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq2.mem_next_el]);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p''`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (HD p'') p''` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC MEM_HD;
    BY(ASM_REWRITE_TAC[]);
  BY(ASM_MESON_TAC[ find_atom_part2])
  ]);;
  (* }}} *)

let atom_choice_part = prove_by_refinement(
  `!L N r p.
    is_restricted (hypermap_of_list L) /\
            good_list L /\
            good_list_nodes L /\
            normal_list L N /\
      is_edge_nondegenerate (hypermap_of_list L) /\
      all uniq L /\
     MEM r N /\ MEM p (parts L r) ==>
   atom_choice (hypermap_of_list L) (loop_family_of_list N) (LAST p) = 
    set_of_list p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Hypermap.unique_atom_choice;
  TYPIFY `loop_of_list r` EXISTS_TAC;
  GMATCH_SIMP_TAC atom_last_p;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[normal_list_normal];
  REWRITE_TAC[in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST];
  CONJ_TAC;
    REWRITE_TAC[upper_case];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[in_dart_loop_of_list];
  BY(ASM_MESON_TAC[MEM_LAST])
  ]);;
  (* }}} *)

let dart_of_exists = prove_by_refinement(
  `!L f (v:A). ?d. good_list L /\ MEM f L /\ MEM v f ==> 
    MEM d (list_of_darts L) /\  f = find_pair_list L d /\ FST d = v`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_darts_alt;List_hypermap.list_of_faces];
  REWRITE_TAC[RIGHT_EXISTS_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Seq2.mem_flatten];
  REWRITE_TAC[LEFT_AND_EXISTS_THM];
  ONCE_REWRITE_TAC[MESON [] `(?a b. P a b ) <=> (?b a. P a b)`];
  TYPIFY `list_pairs f` EXISTS_TAC;
  INTRO_TAC List_hypermap.mem_list_pairs_exists [`v`;`f`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[EXISTS_PAIR_THM];
  GEXISTL_TAC [`v`;`y`];
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.good_list])
  ]);;
  (* }}} *)

let dart_of = new_specification ["dart_of"] 
  (REWRITE_RULE[SKOLEM_THM] dart_of_exists);;

let dart_of_find_face = prove_by_refinement(
  `!L f v. good_list L /\ MEM f L /\ MEM v f ==>
      find_face L (dart_of L f v) = list_pairs f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.find_face_alt];
  BY(MESON_TAC[dart_of])
  ]);;
  (* }}} *)

let dart_of_card_face = prove_by_refinement(
  `!L f v. good_list L /\ MEM f L /\ MEM v f ==>
    CARD (face (hypermap_of_list L) (dart_of L f v)) = LENGTH f`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of [`L`;`f`;`v`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC List_hypermap.card_face_of_list;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC dart_of_find_face;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.size_list_pairs];
  BY(REWRITE_TAC[Seq.size])
  ]);;
  (* }}} *)

let dart_of_unique = prove_by_refinement(
  `!L f v d. good_list L /\ all uniq L /\ MEM f L /\ MEM v f /\
     MEM d (list_of_darts L) /\ find_pair_list L d = f /\
     FST d = v ==> (d = dart_of L f v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of [`L`;`f`;`v`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM d (list_pairs f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.find_face_alt]);
  MATCH_MP_TAC list_pairs_unique;
  TYPIFY `f` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_MESON_TAC[Seq.allP]);
  BY(ASM_MESON_TAC[List_hypermap.dart_in_face;List_hypermap.find_face_alt])
  ]);;
  (* }}} *)

let dart_of_node = prove_by_refinement(
  `!L x (v:A). 
    good_list L /\ good_list_nodes L /\ all uniq L /\
    MEM x (list_of_darts L) /\
    FST x = v ==> 
    BIJ (\f. dart_of L f v) (set_of_list (facesAt_list L v)) 
    (node (hypermap_of_list L) x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x IN darts_of_list L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[List_hypermap.darts_of_list;IN_SET_OF_LIST]);
  ASM_SIMP_TAC[List_hypermap.good_list_node];
  REWRITE_TAC[BIJ];
  SUBCONJ2_TAC;
    REWRITE_TAC[SURJ;IN_SET_OF_LIST;IN_ELIM_THM];
    CONJ_TAC;
      REPEAT WEAKER_STRIP_TAC;
      INTRO_TAC dart_of [`L`;`x'`;`v`];
      ASM_REWRITE_TAC[];
      ANTS_TAC;
        FIRST_X_ASSUM MP_TAC;
        REWRITE_TAC[facesAt_list];
        REWRITE_TAC[MEM_FILTER];
        BY(SIMP_TAC[]);
      REPEAT WEAKER_STRIP_TAC;
      TYPIFY `SND (dart_of L x' v)` EXISTS_TAC;
      SUBCONJ2_TAC;
        BY(ASM_MESON_TAC[FST;SND;PAIR]);
      DISCH_THEN (SUBST1_TAC o GSYM);
      BY(ASM_REWRITE_TAC[ List_hypermap.darts_of_list;IN_SET_OF_LIST]);
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[facesAt_list;MEM_FILTER];
    FIRST_X_ASSUM_ST `darts_of_list` MP_TAC;
    ASM_REWRITE_TAC[ List_hypermap.darts_of_list;IN_SET_OF_LIST;List_hypermap.list_of_darts_alt];
    REWRITE_TAC[Seq2.mem_flatten];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `list_of_faces` MP_TAC;
    REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x''` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs]);
    DISCH_TAC;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC dart_of_unique;
    ASM_REWRITE_TAC[];
    CONJ_TAC;
      REWRITE_TAC[List_hypermap.mem_list_of_darts];
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC List_hypermap.list_pairs_inj;
    REWRITE_TAC[GSYM List_hypermap.find_face_alt];
    REWRITE_TAC[GSYM List_hypermap.find_face_alt];
    GMATCH_SIMP_TAC List_hypermap.find_face_eq;
    ASM_REWRITE_TAC[List_hypermap.mem_list_of_darts];
    REPEAT CONJ_TAC;
          BY(ASM_MESON_TAC[List_hypermap.good_list]);
        BY(ASM_MESON_TAC[]);
      REWRITE_TAC[List_hypermap.list_of_faces];
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_MESON_TAC[]);
  COMMENT "INJ";
  REWRITE_TAC[SURJ;INJ] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[IN_SET_OF_LIST;facesAt_list;MEM_FILTER];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of [`L`;`x'`;`v`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of [`L`;`y`;`v`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let dart_of_card_node = prove_by_refinement(
  `!L x (v:A). 
    good_list L /\ good_list_nodes L /\ all uniq L /\
    MEM x (list_of_darts L) /\
    FST x = v ==> 
    CARD (node (hypermap_of_list L) x) = LENGTH (facesAt_list L v)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC dart_of_node [`L`;`x`;`v`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM (MP_TAC o MATCH_MP (REWRITE_RULE[MESON[] `( a /\ b ==> c) <=> (b ==> a ==> c)`]Misc_defs_and_lemmas.BIJ_CARD));
  REWRITE_TAC[FINITE_SET_OF_LIST];
  DISCH_THEN (SUBST1_TAC o GSYM);
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  REWRITE_TAC[Seq.size];
  REWRITE_TAC[facesAt_list;GSYM filter_FILTER];
  MATCH_MP_TAC Seq.filter_uniq;
  MATCH_MP_TAC List_hypermap.good_list_uniq;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let quotient_list_iso_quotient = prove_by_refinement(
  `!L N . 
  is_restricted (hypermap_of_list L) /\
    good_list_nodes L /\
  normal_list L N /\
  is_edge_nondegenerate (hypermap_of_list L) /\
  good_list L /\
  all uniq L
   ==>
    hyp_iso (set_of_list o (find_atom L N))
     (hypermap_of_list (quotient_list L N),
      quotient (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Hypermap_iso.hyp_iso_edge_face];
  INTRO_TAC good_list_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  ASM_SIMP_TAC[face_map_list];
  INTRO_TAC normal_list_normal [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  ASM_SIMP_TAC[Hypermap.lemma_quotient;List_hypermap.components_hypermap_of_list];
  ASM_SIMP_TAC[GSYM List_hypermap.darts_of_list;atom_list_bij];
  ASM_SIMP_TAC[mem_list_of_darts_quotient];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[o_THM];
  INTRO_TAC find_atom_part [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  INTRO_TAC (GSYM atom_last_p) [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC Hypermap.unique_f_quotient;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
  SUBCONJ_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST];
    CONJ_TAC;
      REWRITE_TAC[upper_case];
      MATCH_MP_TAC MEMf_MAP;
      BY(ASM_REWRITE_TAC[]);
    BY(ASM_SIMP_TAC[in_dart_loop_of_list]);
  REPEAT WEAKER_STRIP_TAC;
  COMMENT "f_quotient";
  CONJ2_TAC;
    GMATCH_SIMP_TAC head_of_atom_parts;
    TYPIFY `p` EXISTS_TAC;
    (CONJ_TAC);
      BY(ASM_MESON_TAC[]);
    TYPED_ABBREV_TAC `p' = next_el (parts L r) p`;
    TYPIFY `MEM p' (parts L r)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Seq2.mem_next_el]);
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p'`];
    ASM_REWRITE_TAC[] THEN DISCH_TAC;
    TYPIFY `MEM (LAST p') p'` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
    TYPIFY `f_list (quotient_list L N) (LAST p) = LAST p'` (C SUBGOAL_THEN SUBST1_TAC);
      GMATCH_SIMP_TAC f_list_quotient;
      TYPIFY `r` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC find_atom_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    GMATCH_SIMP_TAC face_map_list;
    ASM_REWRITE_TAC[];
    INTRO_TAC f_list_quotient_alt [`L`;`N`;`r`;`r`;`p`;`p'`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    GMATCH_SIMP_TAC atom_eq_last;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    SUBCONJ_TAC;
      BY(ASM_MESON_TAC[parts_darts]);
    DISCH_TAC;
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  COMMENT "e_quotient";
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  SUBCONJ_TAC;
    GMATCH_SIMP_TAC mem_list_of_darts_quotient;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  TYPIFY `MEM (e_list (LAST p)) (list_of_darts (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `good_list` MP_TAC;
    REWRITE_TAC[good_list];
    REWRITE_TAC[List_hypermap.e_list];
    BY(ASM_MESON_TAC[]);
  FIRST_ASSUM MP_TAC;
  GMATCH_SIMP_TAC mem_list_of_darts_quotient;
  CONJ_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC find_atom_part;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `atom (hypermap_of_list L) (loop_of_list r) (LAST p) = atom_choice (hypermap_of_list L) (loop_family_of_list N) (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC atom_choice_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap.e_quotient_via_atom_choice [`hypermap_of_list L`;`loop_family_of_list N`;`LAST p`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[darts_of_family;loop_family_of_list;IN_UNIONS;IN_ELIM_THM;IN_SET_OF_LIST];
    TYPIFY `dart_of_loop (loop_of_list r)` EXISTS_TAC;
    ASM_SIMP_TAC[in_dart_loop_of_list];
    TYPIFY `loop_of_list r` EXISTS_TAC;
    REWRITE_TAC[upper_case];
    MATCH_MP_TAC MEMf_MAP;
    BY(ASM_REWRITE_TAC[]);
  SIMP_TAC[];
  DISCH_THEN kill;
  GMATCH_SIMP_TAC head_of_atom_parts;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[parts_darts]);
  DISCH_TAC;
  TYPIFY `atom_choice (hypermap_of_list L) (loop_family_of_list N) (LAST p') = atom (hypermap_of_list L) (loop_of_list r') (LAST p')` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC atom_choice_part;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC atom_last_p;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC atom_last_p;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_EXTENSION = prove_by_refinement(
  `(a = b) ==> (!x. MEM x a <=> MEM x b)`,
  (* {{{ proof *)
  [
  MESON_TAC[]
  ]);;
  (* }}} *)

let loop_of_list_inj = prove_by_refinement(
  `!N r r'. uniq (flatten N) /\ all (\l. ~(l = [])) N /\
     MEM r N /\ MEM r' N /\ loop_of_list r = loop_of_list r' ==>
     r = r'`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(r = []) /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.allP]);
  TYPIFY `uniq r /\ uniq r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[uniq_flatten_uniq]);
  TYPIFY `set_of_list r = set_of_list r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[dart_of_loop_of_list]);
  TYPIFY `?x. MEM x r` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[List_hypermap.mem_not_nil]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x r'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[IN_SET_OF_LIST]);
  MATCH_MP_TAC List_hypermap.uniq_sublist_unique;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_condition_list_split = prove_by_refinement(
  `!L N r d. good_list L /\ good_list_nodes L /\ all uniq L /\
    split_condition_list L N r d ==> 
    is_split_condition (hypermap_of_list L)
     (loop_family_of_list N)
     (loop_of_list r) d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_condition_list;is_split_condition];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[normal_list_normal];
  REWRITE_TAC[in_dart_of_loop;loop_family_of_list;IN_SET_OF_LIST;upper_case];
  CONJ_TAC THENL [MATCH_MP_TAC MEMf_MAP THEN ASM_REWRITE_TAC[];ALL_TAC];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[in_dart_loop_of_list];
  REWRITE_TAC[GSYM loop_family_of_list;lower_case];
  GMATCH_SIMP_TAC head_of_atom_parts;
  TYPIFY `?p. MEM p (parts L r) /\ MEM d p` (C SUBGOAL_THEN MP_TAC);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP parts_flatten);
    DISCH_THEN (C INTRO_TAC [`L`]);
    DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `p` EXISTS_TAC;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[final_loops_list_eq];
  TYPIFY `find_list (parts L r) d = p` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC find_list_uniq;
    BY(ASM_SIMP_TAC[parts_flatten]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  REWRITE_TAC[MEM_MAP;Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC loop_of_list_inj [`N`;`r`;`x`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_m_min = prove_by_refinement(
  `!H NF L x. is_split_condition H NF L x ==>
      hyp'm H NF L x = min_num { m |
	~((loop_map L POWER (SUC (SUC m))) x = 
	    (face_map H POWER (SUC (SUC m))) x)}`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  REWRITE_TAC[TAUT `!a b. (~a ==> b) <=> (~b ==> a)`];
  REWRITE_TAC[arith `~(x <= c':num) <=> c' < x`];
  INTRO_TAC lemma_hyp_m [`H`;`NF`;`L`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`SUC (SUC c')`]);
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

(*
let min_num_eq = prove_by_refinement(
  `!X Y. (?m. X m /\ Y m /\ (!k. k < m ==> ~X m /\ ~Y m)) ==>
    min_num X = min_num Y `,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[min_num_unique;IN;arith `c <= d:num <=> ~(d < c)`])
  ]);;
  (* }}} *)
*)

(*
let min_num_lt = prove_by_refinement(
  `!X m. (!i. i < m ==> ~(i IN X)) /\ (~(X = {})) ==> m <= min_num X`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `~(m < n) ==> (n <= m:num)`);
  DISCH_TAC;
  TYPIFY `min_num X IN X` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[min_num_in]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let min_num_power = prove_by_refinement(
  `!f g x:A. 
    (?i. ~((f POWER i) x = (g POWER i) x)) ==>
    min_num {m | ~((g POWER (SUC m)) x = (f POWER (SUC m)) x )} =
     min_num { m | ~((g POWER (SUC m)) x = (f ((g POWER m) x )) ) }`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `X = {m | ~((g POWER SUC m) x = (f POWER SUC m) x)}`;
  TYPED_ABBREV_TAC `m = min_num X`;
  TYPIFY `!n. n IN X <=> ~((g POWER SUC n) x = (f POWER SUC n) x)` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "X";
    BY(REWRITE_TAC[IN_ELIM_THM]);
  TYPIFY `~(f x = g x) \/ (f x = g x)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[]);
  DISCH_THEN DISJ_CASES_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`0`]);
    ASM_REWRITE_TAC[POWER_1;arith `SUC 0 = 1`];
    DISCH_TAC;
    TYPIFY `min_num X = 0` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC min_num_unique;
      BY(ASM_REWRITE_TAC[arith `0 <= c'`]);
    TYPIFY `min_num {m | ~((g POWER SUC m) x = f ((g POWER m) x))} = 0` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC min_num_unique;
      BY(ASM_REWRITE_TAC[arith `0 <= c'`;arith `SUC 0 = 1`;POWER_0;POWER_1;IN_ELIM_THM;I_THM]);
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `~(0 IN X)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[arith `SUC 0 = 1`;POWER_1;I_THM]);
  TYPIFY `~(i = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[POWER_0]);
  TYPIFY `i = SUC (PRE i)` (C SUBGOAL_THEN MP_TAC);
    BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `m IN X` (C SUBGOAL_THEN ASSUME_TAC);
    FULL_EXPAND_TAC "m" THEN MATCH_MP_TAC min_num_in;
    ASM_REWRITE_TAC[EXTENSION;NOT_IN_EMPTY];
    ASM_REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
    TYPIFY `PRE i` EXISTS_TAC;
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    BY(ASM_MESON_TAC[]);
  TYPIFY `!k. k <= m ==> (g POWER k) x = (f POWER k) x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `k = 0` ASM_CASES_TAC;
      BY(ASM_REWRITE_TAC[POWER_0]);
    TYPIFY `?j. k = SUC (j)` (C SUBGOAL_THEN MP_TAC);
      BY(TYPIFY `PRE k` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
    PROOF_BY_CONTR_TAC;
    TYPIFY `(j IN X)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_REWRITE_TAC[]);
    FIRST_X_ASSUM (MP_TAC o MATCH_MP min_num_le);
    BY(ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `!k. k <= m ==> f ((g POWER k) x) = (f POWER (SUC k)) x` (C SUBGOAL_THEN ASSUME_TAC);
    REPEAT WEAKER_STRIP_TAC;
    ASM_SIMP_TAC[];
    BY(REWRITE_TAC[Hypermap.COM_POWER;o_THM]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  CONJ_TAC;
    FIRST_X_ASSUM GMATCH_SIMP_TAC;
    REWRITE_TAC[arith `m <= m`];
    ASM_SIMP_TAC[arith `m <= m:num`];
    FIRST_X_ASSUM_ST `IN` MP_TAC;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[arith `m <= c':num <=> ~(c' < m)`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `POWER` MP_TAC;
  REWRITE_TAC[];
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  BY(POP_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let f_list_ext_power_mem = prove_by_refinement(
  `!L d i. MEM d (list_of_darts L) /\ good_list L ==>
     MEM ((f_list_ext L POWER i) d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[GSYM List_hypermap.components_hypermap_of_list;GSYM IN_SET_OF_LIST];
  INTRO_TAC Hypermap.lemma_dart_invariant_power_face [`hypermap_of_list L`;`d`;`i`];
  ASM_SIMP_TAC[dart_hypermap_of_list];
  DISCH_THEN MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let f_list_ext_f_list_power = prove_by_refinement(
  `!L i d. MEM d (list_of_darts L) /\ good_list L ==>
   (f_list_ext L POWER i) d = (f_list L POWER i) d`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INDUCT_TAC;
    BY(REWRITE_TAC[POWER_0]);
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC f_list_ext_f_list;
  ASM_REWRITE_TAC[IN_SET_OF_LIST;List_hypermap.darts_of_list];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_SIMP_TAC[mem_f_list])
  ]);;
  (* }}} *)

let mem_f_list_power = prove_by_refinement(
  `!L i d. MEM d (list_of_darts L) ==>
     MEM ((f_list L POWER i) d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INDUCT_TAC;
    BY(REWRITE_TAC[POWER_0;I_THM]);
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[mem_f_list])
  ]);;
  (* }}} *)

let l_m_exists = prove_by_refinement(
  `!L N r d.
   split_condition_list L N r d /\ // ~final_list L r /\
      next_el r d = f_list L d 
   ==>
    (?m. ~(ITER (SUC (SUC m)) (next_el r) d = 
	 f_list L (ITER (SUC m) (next_el r) d)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~final_list L r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  FIRST_X_ASSUM_ST `final_list` MP_TAC;
  REWRITE_TAC[final_list;GSYM Seq.allP;NOT_FORALL_THM;NOT_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM;GSYM POWER_TO_ITER]);
  INTRO_TAC indexf_n [`d`;`x`;`r`];
  TYPIFY `normal_list L N /\ MEM d r /\ MEM r N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  ASM_REWRITE_TAC[];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM_ST `f_list L x =  next_el r x` MP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (SUBST1_TAC o GSYM);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf d x r = 0` ASM_CASES_TAC;
    ASM_REWRITE_TAC[];
    BY((ASM_REWRITE_TAC[POWER_0;arith `SUC 0 = 1`;POWER_1;I_THM]));
  TYPIFY `?j. indexf d x r = SUC j` (C SUBGOAL_THEN MP_TAC);
    BY(TYPIFY `PRE (indexf d x r)` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`j`]);
  DISCH_THEN (SUBST1_TAC o GSYM);
  BY(REWRITE_TAC[COM_POWER;o_THM])
  ]);;
  (* }}} *)

let l_m_lt = prove_by_refinement(
  `!L N r d i.    split_condition_list L N r d /\ 
      next_el r d = f_list L d /\
    i < l'm L r d ==> (ITER (SUC (SUC i)) (next_el r) d = 
	 f_list L (ITER (SUC i) (next_el r) d))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC min_num_le [`{m | ~(ITER (SUC (SUC m)) (next_el r) d = f_list L (ITER (SUC m) (next_el r) d))}`;`i`];
  REWRITE_TAC[IN_ELIM_THM;GSYM Tame_defs2.l_m];
  BY(ASM_SIMP_TAC[arith `i <= m:num <=> ~(m < i)`])
  ]);;
  (* }}} *)

let l_m_lt2 = prove_by_refinement(
  `!L N r d i.    split_condition_list L N r d /\ // ~final_list L r /\
      next_el r d = f_list L d /\
    i < l'm L r d ==> (ITER (SUC (SUC i)) (next_el r) d = 
	  (ITER (SUC (SUC i)) (f_list L) d))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN SPEC_TAC (`i:num`,`i:num`);
  INTRO_TAC l_m_lt [`L`;`N`;`r`;`d`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INDUCT_TAC;
    ASM_SIMP_TAC[arith `SUC 0 = 1`];
    REWRITE_TAC[ITER;ITER_1];
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `f_list L (ITER (SUC i) (next_el r) d)` GMATCH_SIMP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  REWRITE_TAC[ITER];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let hyp_m_l_m = prove_by_refinement(
`!L N r d.
   good_list L /\ good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'm (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'm L r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_split_condition (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_split]);
  ASM_SIMP_TAC[Tame_defs2.l_m;hyp_m_min];
  REWRITE_TAC[GSYM POWER_TO_ITER];
  TYPIFY `{m | ~((next_el r POWER SUC (SUC m)) d =        f_list L ((next_el r POWER SUC m) d))} = {m | ~((next_el r POWER (SUC m)) (next_el r d) =        f_list L ((next_el r POWER m) (next_el r d)))}` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[EXTENSION;IN_ELIM_THM;POWER;o_THM]);
  GMATCH_SIMP_TAC (GSYM min_num_power);
  ASM_REWRITE_TAC[ETA_AX];
  TYPIFY `{m | ~((next_el r POWER SUC m) (f_list L d) =        (f_list L POWER SUC m) (f_list L d))} = {m | ~((next_el r POWER (SUC (SUC m))) d =        (f_list L POWER SUC(SUC m)) ( d))}` (C SUBGOAL_THEN SUBST1_TAC);
    REWRITE_TAC[EXTENSION;IN_ELIM_THM;POWER;o_THM];
    BY(ASM_MESON_TAC[]);
  TYPIFY `(?i. ~((next_el r POWER i) (f_list L d) = (f_list L POWER i) (f_list L d))) /\ (!i. (loop_map (loop_of_list r) POWER i) d = (next_el r POWER i) d) /\ (!i. (face_map (hypermap_of_list L) POWER i) d = (f_list L POWER i) d)` ENOUGH_TO_SHOW_TAC;
    BY(DISCH_THEN (unlist REWRITE_TAC));
  FIRST_X_ASSUM_ST `split_condition_list` MP_TAC THEN REWRITE_TAC[split_condition_list] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[loop_map_next_el];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  COMMENT "final";
  CONJ_TAC;
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    REWRITE_TAC[final_list;GSYM Seq.allP;NOT_FORALL_THM;NOT_IMP_THM];
    REPEAT WEAKER_STRIP_TAC;
    PROOF_BY_CONTR_TAC;
    RULE_ASSUM_TAC (REWRITE_RULE[NOT_EXISTS_THM]);
    INTRO_TAC indexf_n [`d`;`x`;`r`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `~` MP_TAC;
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM (SUBST1_TAC o GSYM);
    TYPIFY_GOAL_THEN `!i. next_el r ((next_el r POWER i) d) = (next_el r POWER (SUC i)) d` (unlist REWRITE_TAC);
      BY(REWRITE_TAC[COM_POWER;o_THM]);
    TYPIFY `indexf d x r = 0` ASM_CASES_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_REWRITE_TAC[POWER_0;arith `SUC 0 = 1`;POWER_1;I_THM]);
    TYPIFY `?j. indexf d x r = SUC j` (C SUBGOAL_THEN MP_TAC);
      BY(TYPIFY `PRE (indexf d x r)` EXISTS_TAC THEN POP_ASSUM MP_TAC THEN ARITH_TAC);
    REPEAT WEAKER_STRIP_TAC;
    ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[POWER];
    ASM_REWRITE_TAC[o_THM];
    BY(REWRITE_TAC[COM_POWER;o_THM]);
  COMMENT "f_list";
  GEN_TAC;
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP normal_list_darts_of_list_mem);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let split_condition_list_of_darts = prove_by_refinement(
  `!L N r d. split_condition_list L N r d ==> MEM d (list_of_darts L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_condition_list];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP normal_list_darts_of_list_mem);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_y_l_y = prove_by_refinement(
`!L N r d.
   good_list L /\ good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'y (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'y L r d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.hyp_y;l_y];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[hyp_m_l_m];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[split_condition_list_of_darts])
  ]);;
  (* }}} *)

(* was  let hyp_m_min_num = 0;;  *)

let hyp_p_min_num = prove_by_refinement(
  `!H NF L x. is_split_condition H NF L x ==>
      hyp'p H NF L x = 
    min_num {p | (face_map H POWER SUC p) (hyp'y H NF L x) IN 
		 darts_of_family NF }`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC min_num_unique;
  REWRITE_TAC[IN_ELIM_THM];
  INTRO_TAC lemma_hyp_p [`H`;`NF`;`L`;`x`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`SUC c'`]);
  ASM_REWRITE_TAC[];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let darts_of_family_loop_family_of_list = prove_by_refinement(
  `!N L. normal_list L N ==>
    darts_of_family(loop_family_of_list N) = set_of_list (flatten N)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[darts_of_family;loop_family_of_list;EXTENSION;IN_UNIONS;IN_ELIM_THM;IN_SET_OF_LIST];
  REWRITE_TAC[upper_case;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM EXTENSION];
  REWRITE_TAC[MESON[] `(?t. (?L. (?x. MEM x N /\ L = loop_of_list x) /\ t = dart_of_loop L) /\      x IN t) <=> (?r. MEM r N /\ x IN (dart_of_loop(loop_of_list r)))`];
  REWRITE_TAC[Seq2.mem_flatten];
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[IN_SET_OF_LIST;dart_of_loop_of_list])
  ]);;
  (* }}} *)

let marked_list_split_condition_list = prove_by_refinement(
  `!L N r d. 
    good_list L /\
    marked_list L N r d /\ ~final_list L r 
     ==> split_condition_list L N r d`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  REWRITE_TAC[marked_list;split_condition_list];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted]);
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`;`r`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_flatten [`L`;`r`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
  REWRITE_TAC[Seq2.mem_flatten];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`d`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `find_list (parts L r) d = l` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC find_list_uniq;
    ASM_REWRITE_TAC[];
    BY(ASM_SIMP_TAC [parts_flatten]);
  ASM_REWRITE_TAC[];
  PROOF_BY_CONTR_TAC;
  INTRO_TAC parts_next_unlast [`L`;`r`];
  ASM_REWRITE_TAC[GSYM Seq.allP;NOT_FORALL_THM];
  TYPIFY `l` EXISTS_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC THEN FIRST_X_ASSUM (C INTRO_TAC [`d`]) THEN ASM_REWRITE_TAC[];
  INTRO_TAC edge_nondeg_f_xor_ni [`L`;`d`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[parts_darts]);
  BY(ASM_MESON_TAC[next_el_parts_unlast])
  ]);;
  (* }}} *)

let mem_l_y_dart = prove_by_refinement(
  `!L N r d. good_list L /\ split_condition_list L N r d ==> 
    MEM (l'y L r d) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[l_y;GSYM IN_SET_OF_LIST];
  TYPIFY `MEM d (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_of_darts]);
  REWRITE_TAC[IN_SET_OF_LIST];
  BY((ASM_SIMP_TAC[f_list_ext_power_mem;GSYM f_list_ext_f_list_power]))
  ]);;
  (* }}} *)

let hyp_p_l_p = prove_by_refinement(
`!L N r d.
   good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'p (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'p L N r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_split_condition (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d ` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list_split]);
  ASM_SIMP_TAC[hyp_p_min_num;l_p];
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  GMATCH_SIMP_TAC darts_of_family_loop_family_of_list;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  GMATCH_SIMP_TAC hyp_y_l_y;
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  AP_TERM_TAC THEN REWRITE_TAC[EXTENSION;IN_ELIM_THM];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GEN_TAC;
  AP_THM_TAC THEN AP_TERM_TAC;
  MATCH_MP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC mem_l_y_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_z_l_z = prove_by_refinement(
`!L N r d.
   good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    split_condition_list L N r d ==>
      hyp'z (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r) d = 
	l'z L N r d`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[hyp_z;l_z];
  GMATCH_SIMP_TAC hyp_p_l_p;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC hyp_y_l_y;
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
  GMATCH_SIMP_TAC f_list_ext_f_list_power;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC mem_l_y_dart;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hyp_q_l_q = prove_by_refinement(
   `!L n r d. 
   hyp'q (hypermap_of_list L) (loop_family_of_list N) 
     (loop_of_list r) d = 
	l'q L N r d`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[l_q])
  ]);;
  (* }}} *)

(* was let contour_list_nil= 0;; *)

let contour_list_cons = prove_by_refinement(
  `!L. contour_list L [] /\ 
     (contour_list L [h] <=> MEM h (list_of_darts L)) /\ 
     (contour_list L (h1::h2::s) <=> MEM h1 (list_of_darts L) /\
	one_step_list L h1 h2 /\ contour_list L (h2::s))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[contour_list];
  (REWRITE_TAC[Seq.size;LENGTH;arith `!i. ~(i < 0)`;Seq.all]);
  REWRITE_TAC[arith `SUC i < SUC j <=> i < j`;arith `~(i<0)`;EL;TL];
  GEN_TAC;
  TYPIFY `MEM h1 (list_of_darts L)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM h2 (list_of_darts L)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `all (\x. MEM x (list_of_darts L)) s` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[EQ_EXPAND];
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    PROOF_BY_CONTR_TAC;
    FIRST_ASSUM (C INTRO_TAC [`0`]);
    REWRITE_TAC[arith `0 < SUC l`;EL;HD];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `LENGTH` MP_TAC;
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`SUC i`]);
    BY(ASM_REWRITE_TAC[EL;TL;arith `SUC i < SUC j <=> i < j`]);
  TYPIFY `i = 0 \/ (?j. i = SUC (j))` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[arith `i = 0 \/ i = SUC (PRE i)`]);
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let contour_list_is_contour = prove_by_refinement(
  `!L s. good_list L /\ contour_list L s ==>
    is_contour (hypermap_of_list L) (\i. EL i s) (PRE (sizel s) )`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_def_contour;contour_list];
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Hypermap.one_step_contour];
  FIRST_X_ASSUM_ST `SUC` (C INTRO_TAC [`i`]);
  ASM_SIMP_TAC[arith `i < PRE s ==> SUC i < s`];
  REWRITE_TAC[one_step_list];
  TYPIFY `MEM (EL i s) s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC MEM_EL;
    BY(POP_ASSUM MP_TAC THEN REWRITE_TAC[lower_case] THEN ARITH_TAC);
  DISCH_THEN DISJ_CASES_TAC THEN ASM_REWRITE_TAC[];
    DISJ1_TAC;
    GMATCH_SIMP_TAC face_map_list;
    BY(ASM_MESON_TAC[]);
  DISJ2_TAC;
  GMATCH_SIMP_TAC inverse_node_map_list;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* *)

let face_map_list_power = prove_by_refinement(
  `!L i d. good_list L /\ MEM d (list_of_darts L) ==>
    (face_map (hypermap_of_list L) POWER i) d = 
      (f_list L POWER i) d`,
  (* {{{ proof *)
  [
 GEN_TAC;
  INDUCT_TAC THEN REWRITE_TAC[POWER_0;I_THM];
  REWRITE_TAC[POWER;o_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap.lemma_dart_invariant [`hypermap_of_list L`;`d`];
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  BY(ASM_SIMP_TAC[face_map_list])
  ]);;
  (* }}} *)

let hyp_S_list = prove_by_refinement(
  `!L n r d. 
       good_list L /\  good_list_nodes L /\ all uniq L /\
    next_el r d = f_list L d /\
    ~final_list L r /\
    split_condition_list L N r d ==>
    hyp'S (hypermap_of_list L) (loop_family_of_list N)
    (loop_of_list r) d = set_of_list (s_list L r d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[hyp_S;s_list;EXTENSION;IN_ELIM_THM;IN_SET_OF_LIST;GSYM POWER_TO_ITER];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  ASM_SIMP_TAC[hyp_m_l_m];
  TYPIFY `normal_list L N /\ MEM r N /\ MEM d r` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[Seq.mem_iota;arith `i < 1 + n <=> i <= n`];
  TYPIFY `!i. (face_map (hypermap_of_list L) POWER i) d = (f_list L POWER i) d` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  GEN_TAC;
  MATCH_MP_TAC face_map_list_power;
  BY(ASM_MESON_TAC[split_condition_list_of_darts])
  ]);;
  (* }}} *)

let marked_list_empty_flagged = prove_by_refinement(
  `!L N r d. good_list L /\ all uniq L /\ good_list_nodes L /\
    marked_list L N r d /\ final_list L r ==> 
    empty_flagged (hypermap_of_list L) (loop_family_of_list N)`,    
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.empty_flagged;marked_list;flag_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[darts_in_final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  COMMENT "edge symmetry";
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    GMATCH_SIMP_TAC head_of_atom_parts;
    ASM_REWRITE_TAC[];
    REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC);
    REWRITE_TAC[loop_family_of_list;upper_case;MEM_MAP;IN_SET_OF_LIST;MEM_FILTER];
    REWRITE_TAC[NOT_EXISTS_THM];
    FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `contour_list` kill;
    TYPIFY `x'` (RENAME_TAC "r'");
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN POP_ASSUM kill;
    REWRITE_TAC[in_dart_of_loop];
    TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC normal_list_uniq_nonnil THEN ASM_MESON_TAC[]);
    ASM_SIMP_TAC[in_dart_loop_of_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `?p'. MEM x p' /\ MEM p' (parts L r')` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC parts_flatten [`L`;`r'`];
      ASM_REWRITE_TAC[] THEN DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
      REWRITE_TAC[Seq2.mem_flatten];
      BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`r'`;`p'`;`LAST p'`]);
    ASM_REWRITE_TAC[];
    ANTS_TAC;
      BY(ASM_MESON_TAC[]);
    TYPIFY `edge_map (hypermap_of_list L) (LAST p') = e_list (LAST p')` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[]);
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    MATCH_MP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    MATCH_MP_TAC parts_darts;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    BY(ASM_MESON_TAC[MEM_LAST]);
  COMMENT "support condition";
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM (C INTRO_TAC [`x`;`y`]);
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`\i. EL i s`;`PRE (sizel s)`];
  nCONJ_TAC 2;
    MATCH_MP_TAC contour_list_is_contour;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC support_of_sequence_list;
  ASM_REWRITE_TAC[EL];
  COMMENT "next step not needed";
  TYPIFY `~(s = [])` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `PRE (sizel s) = (LENGTH s - 1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[LAST_EL]);
    REWRITE_TAC[lower_case];
    MATCH_MP_TAC (arith `~(n = 0) ==> PRE n = n - 1`);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[]
  ]);;
  (* }}} *)

let marked_list_s_flagged = prove_by_refinement(
  `!L N r d. good_list L /\ all uniq L /\ good_list_nodes L /\
    marked_list L N r d /\ ~final_list L r ==> 
    s_flagged (hypermap_of_list L) 
    (loop_family_of_list N) (loop_of_list r) d`,    
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_list_split_condition_list [`L`;`N`;`r`;`d`];
  ASM_REWRITE_TAC[];
  REPEAT (POP_ASSUM MP_TAC);
  REWRITE_TAC[Hypermap.s_flagged;marked_list;s_flag_list];
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[darts_in_final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST];
  ASM_SIMP_TAC[hyp_S_list];
  COMMENT "edge symmetry";
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MP_TAC;
    REPEAT (GMATCH_SIMP_TAC head_of_atom_parts);
    ASM_REWRITE_TAC[];
    REPLICATE_TAC 3 (FIRST_X_ASSUM MP_TAC);
    REWRITE_TAC[loop_family_of_list;upper_case;MEM_MAP;IN_SET_OF_LIST;MEM_FILTER];
    REWRITE_TAC[NOT_EXISTS_THM];
    FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `contour_list` kill;
    TYPIFY `x` (RENAME_TAC "r'");
    REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[] THEN POP_ASSUM kill;
    REWRITE_TAC[in_dart_of_loop];
    TYPIFY `uniq r' /\ ~(r' = [])` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC normal_list_uniq_nonnil THEN ASM_MESON_TAC[]);
    ASM_SIMP_TAC[in_dart_loop_of_list];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `?p'. MEM y p' /\ MEM p' (parts L r')` (C SUBGOAL_THEN MP_TAC);
      INTRO_TAC parts_flatten [`L`;`r'`];
      ASM_REWRITE_TAC[] THEN DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
      REWRITE_TAC[Seq2.mem_flatten];
      BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[]);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `p'` EXISTS_TAC;
    CONJ_TAC;
      BY(ASM_MESON_TAC[]);
    FIRST_X_ASSUM (C INTRO_TAC [`r'`;`p'`;`LAST p'`]);
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `final_list` MP_TAC;
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq.mem_cat;IN_SET_OF_LIST;IN_UNION];
    TYPIFY `edge_map (hypermap_of_list L) (LAST p') = e_list (LAST p')` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN SUBST1_TAC THEN MESON_TAC[]);
    ASM_SIMP_TAC[List_hypermap.components_hypermap_of_list];
    MATCH_MP_TAC Lp_gen_theory.e_list_ext_eq_e_list;
    MATCH_MP_TAC parts_darts;
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    BY(ASM_MESON_TAC[MEM_LAST]);
  COMMENT "support condition";
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `contour_list` MP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM kill;
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`]);
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  GEXISTL_TAC [`\i. EL i s`;`PRE (sizel s)`];
  nCONJ_TAC 2;
    MATCH_MP_TAC contour_list_is_contour;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC support_of_sequence_list;
  ASM_REWRITE_TAC[EL];
  COMMENT "next step not needed";
  TYPIFY `~(s = [])` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    TYPIFY `PRE (sizel s) = (LENGTH s - 1)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[LAST_EL]);
    REWRITE_TAC[lower_case];
    MATCH_MP_TAC (arith `~(n = 0) ==> PRE n = n - 1`);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let simple_hypermap_list = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L /\ all uniq L ==>
     simple_hypermap (hypermap_of_list L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[simple_hypermap];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC SUBSET_ANTISYM;
  CONJ2_TAC;
    REWRITE_TAC[SUBSET;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
    BY(MESON_TAC[node_refl;face_refl]);
  REWRITE_TAC[SUBSET;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
  TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[dart_hypermap_of_list;IN_SET_OF_LIST]);
  ASM_SIMP_TAC[List_hypermap.face_of_list];
  ASM_SIMP_TAC[MEM_hypermap_of_list_node;IN_SET_OF_LIST];
  TYPED_ABBREV_TAC `f = find_pair_list L x`;
  TYPED_ABBREV_TAC `v = FST x`;
  TYPIFY `MEM f L /\ MEM v f` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "f";
    SUBCONJ_TAC;
      BY(ASM_SIMP_TAC[List_hypermap.mem_find_pair_list]);
    DISCH_TAC;
    INTRO_TAC List_hypermap.dart_in_face [`x`;`L`];
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[List_hypermap.find_face_alt];
    TYPIFY `x = (v,SND x)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_REWRITE_TAC[PAIR_EQ2]);
    BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs_exists]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC (* Wmlnymd. *) dart_of_unique [`L`;`f`;`v`;`x'`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    FIRST_X_ASSUM MP_TAC;
    ASM_REWRITE_TAC[List_hypermap.find_face_alt];
    REPEAT WEAKER_STRIP_TAC;
    ONCE_REWRITE_TAC[EQ_SYM_EQ];
    MATCH_MP_TAC List_hypermap.find_pair_list_unique;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[List_hypermap.good_list]);
  INTRO_TAC (* Wmlnymd. *) dart_of_unique [`L`;`f`;`v`;`x`];
  ASM_REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let list_pairs_not_uniq = prove_by_refinement(
  `!s. ~uniq s /\ uniq (list_pairs s) ==> (?x:A#A x'. MEM x (list_pairs s) /\
   MEM x' (list_pairs s) /\ ~(x = x') /\ (FST x = FST x'))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq2.uniq_nthP;NOT_FORALL_THM;NOT_IMP_THM];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`i`;`j`]);
  ASM_REWRITE_TAC[];
  INTRO_TAC List_hypermap.size_list_pairs [`s`];
  DISCH_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPED_ABBREV_TAC `x = nth x0 (list_pairs s) i`;
  TYPED_ABBREV_TAC `x' = nth x0 (list_pairs s) j`;
  GEXISTL_TAC [`x`;`x'`];
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    EXPAND_TAC "x";
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  CONJ_TAC;
    EXPAND_TAC "x'";
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_TAC THEN ARITH_TAC);
  RENAME_TAC "a" `x0:A`;
  REPLICATE_TAC 2 (POP_ASSUM MP_TAC);
  TYPIFY_GOAL_THEN `nth (x0:A#A) (list_pairs s) i = nth (a,a) (list_pairs s) i /\ nth x0 (list_pairs s) j = nth (a,a) (list_pairs s) j` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[Seq.set_nth_default;arith `i < j /\ j < s ==> i < s:num`]);
  REPEAT WEAKER_STRIP_TAC;
  FULL_EXPAND_TAC "x";
  FULL_EXPAND_TAC "x'";
  REPEAT (GMATCH_SIMP_TAC List_hypermap.nth_list_pairs);
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let simple_hypermap_all_uniq = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L /\ 
     simple_hypermap (hypermap_of_list L) ==> all uniq L`,
  (* {{{ proof *)
  [
  REWRITE_TAC[simple_hypermap];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x` (RENAME_TAC "l");
  PROOF_BY_CONTR_TAC;
  INTRO_TAC list_pairs_not_uniq [`l`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[List_hypermap.list_of_darts_alt];
  DISCH_TAC THEN INTRO_TAC uniq_flatten_uniq [`list_of_faces L`;`list_pairs l`];
  ASM_REWRITE_TAC[];
  REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC THEN ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM x (list_of_darts L) /\ MEM x' (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.list_of_darts_alt];
    REWRITE_TAC[List_hypermap.list_of_faces;MEM_MAP;Seq2.mem_flatten];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  REWRITE_TAC[EXTENSION;IN_INSERT;NOT_IN_EMPTY;IN_INTER];
  DISCH_THEN (C INTRO_TAC [`x'`]);
  ASM_SIMP_TAC[List_hypermap.face_of_list];
  ASM_SIMP_TAC[MEM_hypermap_of_list_node;IN_SET_OF_LIST];
  TYPIFY `find_face L x = list_pairs l` ENOUGH_TO_SHOW_TAC;
    BY(ASM_SIMP_TAC[]);
  REWRITE_TAC[List_hypermap.find_face_alt];
  AP_TERM_TAC;
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  MATCH_MP_TAC List_hypermap.find_pair_list_unique;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[good_list])
  ]);;
  (* }}} *)

let simple_hypermap_uniq = prove_by_refinement(
  `!L. good_list L /\ good_list_nodes L ==>
     (simple_hypermap (hypermap_of_list L) <=> all uniq L)`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[simple_hypermap_all_uniq;simple_hypermap_list])
  ]);;
  (* }}} *)

let iso_is_node_nondegenerate = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ is_node_nondegenerate H ==> is_node_nondegenerate K`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.lemma_node_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`f x`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let iso_is_no_double_joins = prove_by_refinement(
 `!f H K. hyp_iso f (K,H) /\ is_no_double_joins H ==> is_no_double_joins K`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Hypermap.is_no_double_joins];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `y IN dart K` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_node_subset;SUBSET]);
  TYPIFY `f x = f y` ENOUGH_TO_SHOW_TAC;
    FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.hyp_iso_bij);
    REWRITE_TAC[BIJ;INJ];
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Hypermap_iso.hyp_iso_dart);
  ASM_SIMP_TAC[];
  INTRO_TAC Hypermap_iso.hyp_iso_edge_node [`H`;`f`;`K`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  FIRST_ASSUM (MP_TAC o MATCH_MP Lp_gen_theory.components_iso_image);
  TYPIFY `edge_map K y IN dart K /\ edge_map K x IN dart K` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.lemma_dart_invariant]);
  ASM_SIMP_TAC[];
  BY(ASM_MESON_TAC[FUN_IN_IMAGE])
  ]);;
  (* }}} *)

(* was let is_card_dart = 0;; *)

let iso_card_face = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ 
    (!x. x IN dart H ==> 3 <= CARD (face H x)) ==>
    (!x. x IN dart K ==> 3 <= CARD (face K x))
   `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`f x`]);
  ANTS_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_dart]);
  BY(ASM_MESON_TAC[Hypermap_iso.hyp_iso_card_components])
  ]);;
  (* }}} *)

let hyp_iso_restricted = prove_by_refinement(
  `!f H K. hyp_iso f (K,H) /\ is_restricted H ==>
     is_restricted K
 `,
  (* {{{ proof *)
  [
  REWRITE_TAC[is_restricted];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap_iso.iso_planar_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_plain_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_connected_imp [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_simple_imp [`f`;`H`;`K`];
  INTRO_TAC iso_is_no_double_joins [`f`;`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_edge_nondegenerate_imp [`f`;`H`;`K`];
  INTRO_TAC iso_is_node_nondegenerate [`f`;`H`;`K`];
  INTRO_TAC iso_card_face [`f`;`H`;`K`];
  ASM_SIMP_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  RULE_ASSUM_TAC (REWRITE_RULE[ Local_lemmas.EXISTS_IN]);
  FIRST_X_ASSUM_ST `?` MP_TAC THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `{}` MP_TAC THEN REWRITE_TAC[Local_lemmas.EXISTS_IN];
  FIRST_ASSUM (MP_TAC o MATCH_MP Hypermap_iso.hyp_iso_bij);
  REWRITE_TAC[BIJ;SURJ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let iso_restricted = prove_by_refinement(
  `!H K. iso H K ==> (is_restricted H <=> is_restricted K)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `iso K H` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Hypermap.iso_sym]);
  INTRO_TAC Hypermap_iso.iso_imp_hyp_iso [`H`;`K`];
  INTRO_TAC Hypermap_iso.iso_imp_hyp_iso [`K`;`H`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[hyp_iso_restricted])
  ]);;
  (* }}} *)

let DAKEFCC = iso_restricted;;

let marked_list_is_node_nondegenerate = prove_by_refinement(
  `!L N r d. 
    good_list L /\  good_list_nodes L /\
    good_list_nodes (quotient_list L N) /\
    marked_list L N r d  ==> 
    is_node_nondegenerate (quotient (hypermap_of_list L) (loop_family_of_list N))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[marked_list;LET_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `is_restricted (hypermap_of_list L) /\ is_edge_nondegenerate (hypermap_of_list L) /\ all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    REPLICATE_TAC 6 (POP_ASSUM kill);
    BY(ASM_MESON_TAC[simple_hypermap_all_uniq;is_restricted;marked_list]);
  INTRO_TAC quotient_list_iso_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  TYPED_ABBREV_TAC `ql = hypermap_of_list (quotient_list L N)`;
  TYPED_ABBREV_TAC `q = quotient (hypermap_of_list L) (loop_family_of_list N)`;
  DISCH_TAC;
  TYPIFY `?g. hyp_iso g (q,ql)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Hypermap_iso.iso_imp_hyp_iso;Hypermap_iso.hyp_iso_imp_iso;Hypermap.iso_sym]);
  TYPIFY `is_node_nondegenerate ql` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[iso_is_node_nondegenerate]);
  FULL_EXPAND_TAC "ql";
  REWRITE_TAC[Hypermap.lemma_node_nondegenerate];
  TYPIFY `good_list (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC good_list_quotient;
    BY(ASM_REWRITE_TAC[]);
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC  dart_of_card_node;
  TYPED_ABBREV_TAC `v = FST x`;
  TYPIFY `v` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[lower_case;arith `2 <= n <=> n > 1`];
  FIRST_X_ASSUM_ST `1` MP_TAC THEN REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`v`]);
  REWRITE_TAC[  facesAt_list;lower_case];
  DISCH_THEN MATCH_MP_TAC;
  COMMENT "try 1";
  REWRITE_TAC[Seq2.mem_flatten];
  TYPIFY `?l. MEM l (quotient_list L N) /\ MEM x (list_pairs l)` ENOUGH_TO_SHOW_TAC;
    TYPIFY `x = (v,SND x)` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_REWRITE_TAC[PAIR_EQ2]);
    BY(MESON_TAC[List_hypermap.mem_list_pairs_exists]);
  FIRST_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[List_hypermap.dart_in_face];
  REWRITE_TAC[List_hypermap.find_face_alt];
  BY(ASM_MESON_TAC[List_hypermap.mem_find_pair_list])
  ]);;
  (* }}} *)

let lemma_yz_in_face_list = prove_by_refinement(
  `!L N r x.
     good_list L /\ good_list_nodes L /\
    all uniq L /\
  next_el r x = f_list L x /\
  split_condition_list L N r x
     ==>
     MEM (l'y L r x) (find_face L x) /\
     MEM (l'z L N r x) (find_face L x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap.lemma_yz_in_face [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  GMATCH_SIMP_TAC hyp_y_l_y;
  GMATCH_SIMP_TAC hyp_z_l_z;
  REPEAT ( GMATCH_SIMP_TAC List_hypermap.face_of_list);
  ASM_SIMP_TAC[IN_SET_OF_LIST];
  BY(ASM_MESON_TAC[split_condition_list_of_darts])
  ]);;
  (* }}} *)

let lemma_node_outside_darts_of_family_list = prove_by_refinement(
  `!L N r x y i.
    good_list L /\ good_list_nodes L /\
   all uniq L /\
    next_el r x = f_list L x /\
    split_condition_list L N r x /\
    1 <= i /\ i <= l'p L N r x /\
    MEM y (flatten N) ==>
    ~(FST y = FST ((f_list L POWER i) (l'y L r x)))
`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_node_outside_darts_of_family [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`;`i`];
  ASM_SIMP_TAC[hyp_y_l_y;split_condition_list_split;hyp_p_l_p];
  REWRITE_TAC[NOT_FORALL_THM];
  TYPIFY `y` EXISTS_TAC;
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[split_condition_list]);
  GMATCH_SIMP_TAC darts_of_family_loop_family_of_list;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  GMATCH_SIMP_TAC MEM_hypermap_of_list_node;
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC face_map_list_power);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC mem_f_list_power;
  INTRO_TAC normal_list_list_of_darts [`L`;`N`];
  ASM_SIMP_TAC[GSYM Seq.allP];
  DISCH_THEN kill;
  BY(ASM_MESON_TAC[lemma_yz_in_face_list;List_hypermap.dart_in_face;List_hypermap.mem_find_face_imp_mem_darts])
  ]);;
  (* }}} *)

let inverse_node_map_quotient = prove_by_refinement(
  `!L N r p r' p'.
    good_list_nodes L /\
    normal_list L N /\ 
     is_edge_nondegenerate (hypermap_of_list L) /\
    good_list L /\ 
    all uniq L /\
    MEM p (parts L r) /\ MEM r N /\
    MEM p' (parts L r') /\ MEM r' N ==>
   (inverse(node_map (hypermap_of_list 
			(quotient_list L N))) (LAST p) = LAST p' <=>
    MEM (f_list L (e_list (LAST p))) p')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `ql = (quotient_list L N)`;
  TYPIFY `MEM (LAST p) (list_of_darts ql)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[mem_list_of_darts_quotient]);
  TYPIFY `good_list ql` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list_quotient]);
  ASM_SIMP_TAC[inverse_node_map_list];
  TYPIFY `MEM (e_list (LAST p)) (list_of_darts ql)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[List_hypermap.e_list];
    BY(ASM_MESON_TAC[list_of_darts_quotient_sym]);
  INTRO_TAC mem_list_of_darts_quotient [`L`;`N`;`e_list (LAST p)`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "ql";
  INTRO_TAC f_list_quotient [`L`;`N`;`r''`;`p''`;`r'`;`p'`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  MATCH_MP_TAC f_list_quotient_alt;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexf_shiftdown = prove_by_refinement(
  `!f s k. (!u. indexl u s < sizel s /\ k <= indexl u s ==>
    indexl (f u) s + k = indexl u s) ==>
    (! i u. indexl u s < sizel s /\ k * i <= indexl u s ==>
     indexl ((f POWER i) u) s + k * i = indexl u s)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  DISCH_TAC;
  INDUCT_TAC;
    BY(ASM_REWRITE_TAC[POWER_0;I_THM;arith `i + 0 = i`;arith `i*0 = 0`]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[POWER;o_THM];
  REWRITE_TAC[arith `a + k * SUC i = (a + k * i) + k`];
  FIRST_X_ASSUM GMATCH_SIMP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`u`]);
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

(* let MEM_EL_INDEX=0;; *)

let mem_el_index = prove_by_refinement(
  `!i s. i < sizel s ==> MEM (EL i s) s`,
  (* {{{ proof *)
  [
  BY(ASM_MESON_TAC[Seq.mem_nth;Seq2.EL_nth])
  ]);;
  (* }}} *)

let index_el = prove_by_refinement(
  `!i. uniq s /\ i < sizel s ==> indexl (EL i s) s = i`,
  (* {{{ proof *)
  [
  ASM_MESON_TAC[Seq.index_uniq;Seq2.EL_nth]
  ]);;
  (* }}} *)

let parts_node_power = prove_by_refinement(
  `!L N r p k x.
         normal_list L N /\
         good_list L /\
         MEM r N /\
         MEM p (parts L r) /\
         MEM x p /\
         k <= indexl x p
         ==> ( (node_map (hypermap_of_list L)) POWER k) x =
             EL ( indexl x p - k) p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_node_inverse_power [`L`;`N`;`r`;`p`;`k`;`EL (indexl x p - k) p`];
  ASM_REWRITE_TAC[];
  TYPIFY `uniq p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[parts_uniq_nonnil]);
  TYPIFY `indexl x p < sizel p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.index_mem]);
  ANTS_TAC;
    GMATCH_SIMP_TAC mem_el_index;
    GMATCH_SIMP_TAC index_el;
    ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `node_map (hypermap_of_list L) permutes (dart (hypermap_of_list L))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[node_map_and_darts]);
  ONCE_REWRITE_TAC[EQ_SYM_EQ];
  TYPIFY `EL (k + indexl (EL (indexl x p - k) p) p) p = x` (C SUBGOAL_THEN SUBST1_TAC);
    GMATCH_SIMP_TAC index_el;
    TYPIFY `k+indexl x p - k = indexl x p` (C SUBGOAL_THEN SUBST1_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC Seq2.EL_index;
    BY(ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Hypermap.inverse_power_function])
  ]);;
  (* }}} *)

let parts_node_map_hd = prove_by_refinement(
  `!L N r p r' p'.
         normal_list L N /\
         good_list L /\
         MEM r N /\
         MEM p (parts L r) /\
    MEM r' N /\ MEM p' (parts L r') /\
   MEM (node_map (hypermap_of_list L) (HD p)) p' ==>
   inverse (node_map (hypermap_of_list L)) (LAST p') = HD p`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `x = node_map (hypermap_of_list L) (HD p)`;
  TYPIFY `x = LAST p'` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[PERMUTES_INVERSE_EQ;Hypermap.node_map_and_darts]);
  INTRO_TAC parts_node_inverse_power [`L`;`N`;`r'`;`p'`;`1`;`x`];
  ASM_REWRITE_TAC[POWER_1];
  TYPIFY `1 + indexl x p' < sizel p'` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Seq.index_mem [`x`;`p'`];
    ASM_REWRITE_TAC[];
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r'`;`p'`];
    ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC indexl_LAST [`p'`];
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    TYPIFY `~(indexl x p' = sizel p' - 1)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[index_uniq;MEM_LAST]);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPIFY ` inverse (node_map (hypermap_of_list L)) x = HD p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[PERMUTES_INVERSE_EQ;Hypermap.node_map_and_darts]);
  TYPIFY `MEM (EL (1 + indexl x p') p') p'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[mem_el_index]);
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY`MEM (HD p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC MEM_HD THEN ASM_REWRITE_TAC[]);
  TYPIFY `p' = p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC [find_atom_part2]);
  TYPIFY `indexl (HD p) p = 0` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC index_hd0 THEN ASM_REWRITE_TAC[]);
  TYPIFY `indexl (EL (1 + indexl x p') p') p' = 1 + indexl x p'` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC index_el;
    BY(ASM_REWRITE_TAC[]);
  BY(ASM_MESON_TAC[arith `~(1 + i = 0)`])
  ]);;
  (* }}} *)

let node_map_quotient = prove_by_refinement(
  `!L N r p.
         normal_list L N /\
         good_list L /\
         good_list_nodes L /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         all uniq L /\
         MEM r N /\
         MEM p (parts L r) 
         ==> node_map (hypermap_of_list (quotient_list L N)) (LAST p) =
             (node_map (hypermap_of_list L) POWER sizel p) (LAST p)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel p = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  TYPIFY `node_map (hypermap_of_list L) (HD p) = (node_map (hypermap_of_list L) POWER (sizel p)) (LAST p)` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY` sizel p = 1 + (sizel p - 1)` (C SUBGOAL_THEN SUBST1_TAC);
      BY(POP_ASSUM MP_TAC THEN ARITH_TAC);
    REWRITE_TAC[Hypermap.addition_exponents];
    REWRITE_TAC[POWER_1;o_THM];
    GMATCH_SIMP_TAC parts_node_power;
    TYPIFY `p` EXISTS_TAC;
    TYPIFY `indexl (LAST p) p = sizel p - 1` (C SUBGOAL_THEN ASSUME_TAC);
      MATCH_MP_TAC indexl_LAST;
      BY(ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[arith `n - n = 0`;EL];
    TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MATCH_MP_TAC MEM_LAST THEN ASM_REWRITE_TAC[]);
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[arith `n:num <= n`]);
  TYPIFY ` ((node_map (hypermap_of_list L) POWER sizel p) (LAST p)) IN (node (hypermap_of_list L) (LAST p))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Hypermap.lemma_in_node2]);
  TYPIFY `MEM (node_map (hypermap_of_list L) (HD p)) (flatten N)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `normal_list` MP_TAC THEN REWRITE_TAC[normal_list;SUBSET;IN_SET_OF_LIST];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM (LAST p) (flatten N)` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    REWRITE_TAC[Seq2.mem_flatten];
    BY(ASM_MESON_TAC[MEM_LAST]);
  POP_ASSUM MP_TAC THEN REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_flatten [`L`;`l`];
  INTRO_TAC normal_list_uniq_nonnil [`L`;`N`;`l`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
  DISCH_THEN (C INTRO_TAC [`node_map (hypermap_of_list L) (HD p)`]);
  ASM_REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_node_map_hd [`L`;`N`;`r`;`p`;`l`;`l'`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `node_map (hypermap_of_list L) (HD p) = (LAST l')` (C SUBGOAL_THEN ASSUME_TAC);
    POP_ASSUM MP_TAC;
    BY(MESON_TAC[PERMUTES_INVERSE_EQ;Hypermap.node_map_and_darts]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `POWER` MP_TAC);
  FIRST_X_ASSUM_ST `POWER` (MP_TAC o GSYM);
  ASM_SIMP_TAC[];
  REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN REPEAT (FIRST_X_ASSUM_ST `inverse` MP_TAC) THEN ASM_SIMP_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `inverse (node_map (hypermap_of_list (quotient_list L N))) (LAST l') = (LAST p)` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[PERMUTES_INVERSE_EQ;Hypermap.node_map_and_darts]);
  INTRO_TAC inverse_node_map_quotient [`L`;`N`;`l`;`l'`;`r`;`p`];
  ASM_REWRITE_TAC[];
  DISCH_THEN SUBST1_TAC;
  TYPIFY `f_list L (e_list (LAST l')) = HD p` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    MATCH_MP_TAC MEM_HD;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM_ST `HD` (SUBST1_TAC o GSYM);
  GMATCH_SIMP_TAC inverse_node_map_list;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[parts_darts])
  ]);;
  (* }}} *)

let quotient_node_lemma = prove_by_refinement(
  `!L N ivs nodq r1 p1 k i . 
     i <= k /\
     good_list L /\
     good_list_nodes L /\
    normal_list L N /\ 
     is_edge_nondegenerate (hypermap_of_list L) /\ all uniq L /\
     inverse (node_map (hypermap_of_list L)) = ivs /\
     MEM (LAST p1) p1 /\ MEM p1 (parts L r1) /\ MEM r1 N /\     
     node (hypermap_of_list (quotient_list L N)) (LAST p1) = nodq /\
     MEM ((ivs POWER i) (LAST p1)) (list_of_darts (quotient_list L N)) ==>
      ((ivs POWER i) (LAST p1)) IN nodq
   `,
  (* {{{ proof *)
  [
  REPLICATE_TAC 6 GEN_TAC;
  INDUCT_TAC;
    REWRITE_TAC[arith `i <= 0 <=> i = 0`];
    REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[POWER_0;I_THM];
    BY(ASM_MESON_TAC[node_refl]);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `( ==> )` MP_TAC;
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `i <= k:num` ASM_CASES_TAC;
    BY(FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
  TYPIFY `SUC k = i` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  FULL_EXPAND_TAC "i";
  REPLICATE_TAC 2 (POP_ASSUM kill);
  INTRO_TAC mem_list_of_darts_quotient [`L`;`N`;`(ivs POWER SUC k) (LAST p1)`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (LAST p) p` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM_LAST]);
  TYPIFY `indexl (LAST p) p = sizel p - 1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MATCH_MP_TAC indexl_LAST THEN ASM_REWRITE_TAC[]);
  TYPIFY `node_map (hypermap_of_list L) permutes (dart (hypermap_of_list L))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[node_map_and_darts]);
  COMMENT "small k branch";
  TYPIFY ` SUC k < sizel p` ASM_CASES_TAC;
    TYPIFY `p = p1` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[node_refl]);
    INTRO_TAC parts_node_power [`L`;`N`;`r`;`p`;`SUC k`;`(ivs POWER SUC k) (LAST p1)`];
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[arith `s < p ==> s <= p - 1`];
    FIRST_X_ASSUM_ST `POWER` (SUBST1_TAC o GSYM);
    FULL_EXPAND_TAC "ivs";
    INTRO_TAC Hypermap.lemma_power_inverse_map [`dart (hypermap_of_list L)`;`node_map (hypermap_of_list L)`;`SUC k`];
    ASM_SIMP_TAC[FUN_EQ_THM;o_THM;I_THM];
    DISCH_THEN kill;
    DISCH_TAC;
    TYPIFY `MEM (LAST p1) p` (C SUBGOAL_THEN ASSUME_TAC);
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC mem_el_index;
      BY(REPLICATE_TAC 2 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
    BY(ASM_MESON_TAC[find_atom_part2]);
  COMMENT "large k branch";
  INTRO_TAC good_list_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `MEM (node_map (hypermap_of_list (quotient_list L N)) (LAST p)) (list_of_darts (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    INTRO_TAC Hypermap.lemma_dart_invariant [`(hypermap_of_list (quotient_list L N))`;`LAST p`];
    ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
    BY(ASM_MESON_TAC[mem_list_of_darts_quotient]);
  INTRO_TAC node_map_quotient [`L`;`N`;`r`;`p`];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `node_map (hypermap_of_list (quotient_list L N)) (LAST p) IN nodq` ENOUGH_TO_SHOW_TAC;
    FULL_EXPAND_TAC "nodq";
    TYPIFY `(LAST p) = inverse (node_map (hypermap_of_list (quotient_list L N))) (node_map (hypermap_of_list (quotient_list L N)) (LAST p))` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MESON_TAC[PERMUTES_INVERSES;Hypermap.node_map_and_darts]);
    BY(FIRST_X_ASSUM MP_TAC THEN MESON_TAC[Hypermap.lemma_inverse_in_node;Hypermap.lemma_node_identity]);
  TYPIFY `SUC k = sizel p` ASM_CASES_TAC;
    REPLICATE_TAC 10 (POP_ASSUM MP_TAC);
    FIRST_X_ASSUM_ST `ivs POWER SUC k` (SUBST1_TAC o GSYM);
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `node_map (hypermap_of_list (quotient_list L N)) ((ivs POWER SUC k) (LAST p1)) = (LAST p1)` ENOUGH_TO_SHOW_TAC;
      DISCH_THEN SUBST1_TAC;
      FULL_EXPAND_TAC "nodq";
      BY(MESON_TAC[node_refl]);
    ASM_REWRITE_TAC[];
    FULL_EXPAND_TAC "ivs";
    BY(MESON_TAC[Hypermap.lemma_power_inverse_map;o_THM;I_THM;Hypermap.node_map_and_darts]);
  FIRST_X_ASSUM (C INTRO_TAC [`SUC k - sizel p`]);
  TYPIFY `~(sizel p = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[Seq.size_eq0]);
  TYPIFY `(ivs POWER (SUC k - sizel p)) (LAST p1) = node_map (hypermap_of_list (quotient_list L N)) (LAST p)` ENOUGH_TO_SHOW_TAC;
    ASM_SIMP_TAC[arith `~(s = 0) ==> SUC k - s <= k:num`];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  REPLICATE_TAC 10 (POP_ASSUM MP_TAC);
  FIRST_X_ASSUM_ST `ivs POWER SUC k` (SUBST1_TAC o GSYM);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `lhs = ivs POWER (SUC k - sizel p)`;
  TYPIFY `SUC k = sizel p + (SUC k - sizel p)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REPLICATE_TAC 15 (POP_ASSUM MP_TAC) THEN ARITH_TAC);
  REWRITE_TAC[Hypermap.addition_exponents];
  ASM_REWRITE_TAC[o_THM];
  FULL_EXPAND_TAC "ivs";
  BY(MESON_TAC[Hypermap.lemma_power_inverse_map;o_THM;I_THM;Hypermap.node_map_and_darts])
  ]);;
  (* }}} *)

let good_list_nodes_condition2 = prove_by_refinement(
  `!L. good_list L /\ (!(d:A#A) d'. MEM d (list_of_darts L) /\
    MEM d' (list_of_darts L) /\ FST d = FST d' ==>
     d' IN node (hypermap_of_list L) d) ==> good_list_nodes L`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[List_hypermap.good_list_nodes_condition];
  TYPIFY `!x. ?dt. MEM x (list_of_elements L) ==> MEM dt (list_of_darts L) /\ FST dt = x` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[EXISTS_PAIR_THM];
    BY(MESON_TAC[List_hypermap.mem_list_of_elements]);
  REWRITE_TAC[SKOLEM_THM];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `nd = \v. node (hypermap_of_list L) (dt v)`;
  TYPIFY `FINITE (set_of_list (list_of_elements L))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[FINITE_SET_OF_LIST]);
  TYPIFY `CARD (set_of_list (list_of_elements L)) = sizel (list_of_elements L)` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC Seq2.card_set_of_list_uniq;
    BY(REWRITE_TAC[List_hypermap.uniq_list_of_elements]);
  TYPIFY `BIJ nd (set_of_list (list_of_elements L)) (node_set (hypermap_of_list L))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Misc_defs_and_lemmas.BIJ_CARD]);
  REWRITE_TAC[BIJ;INJ];
  SUBCONJ_TAC;
    REWRITE_TAC[IN_SET_OF_LIST];
    SUBCONJ_TAC;
      REPEAT WEAKER_STRIP_TAC;
      FULL_EXPAND_TAC "nd";
      ASM_REWRITE_TAC[GSYM Hypermap.lemma_in_node_set];
      BY(ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST]);
    DISCH_TAC;
    FULL_EXPAND_TAC "nd";
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[List_hypermap.fst_node_hypermap_of_list;node_refl]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[SURJ];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (MP_TAC o MATCH_MP Hypermap.lemma_node_representation);
  ASM_SIMP_TAC[dart_hypermap_of_list;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `FST x'` EXISTS_TAC;
  SUBCONJ_TAC;
    TYPIFY `x' = (FST x',SND x')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(REWRITE_TAC[PAIR]);
    BY(ASM_MESON_TAC[List_hypermap.mem_list_of_elements]);
  DISCH_TAC;
  FIRST_X_ASSUM_ST `node` (C INTRO_TAC [`x'`;`dt (FST x')`]);
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  FULL_EXPAND_TAC "nd";
  BY(MESON_TAC[Hypermap.lemma_node_identity])
  ]);;
  (* }}} *)

let list_of_darts_quotient_darts = prove_by_refinement(
  `!L N d. normal_list L N /\ 
   is_edge_nondegenerate (hypermap_of_list L) /\
            good_list L /\
            all uniq L /\
    MEM d (list_of_darts (quotient_list L N)) ==>
    MEM d (list_of_darts L)
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[mem_list_of_darts_quotient];
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[parts_darts;MEM_LAST;parts_uniq_nonnil])
  ]);;
  (* }}} *)

let good_list_nodes_quotient = prove_by_refinement(
  `!L N. good_list L /\
         good_list_nodes L /\
         normal_list L N /\
         is_edge_nondegenerate (hypermap_of_list L) /\
         all uniq L ==>
    good_list_nodes (quotient_list L N) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC good_list_nodes_condition2;
  ASM_SIMP_TAC[good_list_quotient];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `d' IN node (hypermap_of_list L) d` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC List_hypermap.good_list_node;
    ASM_REWRITE_TAC[IN_ELIM_THM;List_hypermap.darts_of_list;IN_SET_OF_LIST];
    TYPIFY `d' = (FST d',SND d')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(MESON_TAC[PAIR]);
    BY(ASM_MESON_TAC[ list_of_darts_quotient_darts]);
  REPEAT (FIRST_X_ASSUM_ST `quotient_list` MP_TAC) THEN ASM_SIMP_TAC[mem_list_of_darts_quotient];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Hypermap.lemma_via_inverse_node_map [`hypermap_of_list L`;`d`;`d'`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC quotient_node_lemma [`L`;`N`;`inverse (node_map (hypermap_of_list L))`;`node (hypermap_of_list (quotient_list L N)) (LAST p)`;`r`;`p`;`j`;`j`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[arith `j <= j:num`];
    CONJ_TAC;
      MATCH_MP_TAC MEM_LAST;
      BY(ASM_MESON_TAC[parts_uniq_nonnil]);
    BY(ASM_MESON_TAC[mem_list_of_darts_quotient]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let PMBRINH = good_list_nodes_quotient;;

let marked_list_marked = prove_by_refinement(
  `!L N r x. 
  good_list L /\ good_list_nodes L /\ 
   marked_list L N r x ==>
   is_marked 
    ((hypermap_of_list L), (loop_family_of_list N), (loop_of_list r), x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[is_marked];
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_restricted]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_normal]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_mem_family]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_mem_loop]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[marked_list_loop_eq_face_map]);
  DISCH_TAC;
  TYPIFY `is_edge_nondegenerate (hypermap_of_list L)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted]);
  TYPIFY `all uniq L` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[is_restricted;simple_hypermap_all_uniq]);
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[marked_list_edge_map_final]);
  ASM_REWRITE_TAC[];
  TYPIFY `normal_list L N` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[marked_list]);
  TYPIFY `good_list (quotient_list L N)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[good_list_quotient]);
  INTRO_TAC good_list_nodes_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  nCONJ_TAC 2;
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC marked_list_empty_flagged;
    GEXISTL_TAC [`r`;`x`];
    ASM_REWRITE_TAC[];
    FIRST_X_ASSUM MP_TAC;
    GMATCH_SIMP_TAC final_loops_list_eq;
    ASM_REWRITE_TAC[IN_SET_OF_LIST;MEM_MAP;Seq.mem_filter];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `r =x'` ENOUGH_TO_SHOW_TAC;
      BY(ASM_MESON_TAC[]);
    MATCH_MP_TAC loop_of_list_inj;
    TYPIFY `N` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[normal_list;marked_list]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 2;
    REPEAT WEAKER_STRIP_TAC;
    MATCH_MP_TAC marked_list_s_flagged;
    ASM_REWRITE_TAC[];
    DISCH_TAC;
    FIRST_X_ASSUM_ST `IN` MP_TAC;
    REWRITE_TAC[];
    GMATCH_SIMP_TAC final_loops_list_eq;
    ASM_REWRITE_TAC[IN_SET_OF_LIST;MEM_MAP;Seq.mem_filter];
    TYPIFY `r` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[marked_list]);
  ASM_REWRITE_TAC[];
  CONJ2_TAC;
    BY(ASM_MESON_TAC[marked_list_is_node_nondegenerate]);
  INTRO_TAC quotient_all_uniq [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `simple_hypermap (hypermap_of_list (quotient_list L N))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC simple_hypermap_list;
    BY(ASM_REWRITE_TAC[]);
  TYPIFY `?f. hyp_iso f ((quotient (hypermap_of_list L) (loop_family_of_list N)),hypermap_of_list ((quotient_list L N)))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Hypermap_iso.iso_simple_imp]);
  INTRO_TAC quotient_list_iso_quotient [`L`;`N`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[Hypermap_iso.iso_imp_hyp_iso;Hypermap_iso.hyp_iso_imp_iso;Hypermap.iso_sym])
  ]);;
  (* }}} *)

let AQIUNPP1 = prove_by_refinement(
  `!L N r (x:A#A).
  transform_assumption_v2 L /\
   good_list L /\
   good_list_nodes L /\
    marked_list L N r x ==> 
       normal_list L (ntrans L N r x 1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[marked_list;transform_assumption])
  ]);;
  (* }}} *)

let AQIUNPP2 = prove_by_refinement(
  `!L N r (x:A#A).
    transform_assumption_v2 L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x ==> 
    marked_list L (ntrans L N r x 1) (rtrans L N r x 1) x`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  BY(ASM_MESON_TAC[marked_list;transform_assumption])
  ]);;
  (* }}} *)

let transform_list_pair = prove_by_refinement(
  `!L x N r. transform_list L x (N,r) = (ntrans L N r x 1,rtrans L N r x 1)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[ntrans;rtrans;PAIR;POWER_1])
  ]);;
  (* }}} *)

let AQIUNPP3 = prove_by_refinement(
  `!L i N r (x:A#A).
    transform_assumption_v2 L /\
    good_list L /\
    good_list_nodes L /\
    marked_list L N r x ==> 
    marked_list L (ntrans L N r x i) (rtrans L N r x i) x`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INDUCT_TAC THEN REWRITE_TAC[ntrans;rtrans;POWER_0;POWER;I_THM;o_THM];
    BY(MESON_TAC[]);
  REWRITE_TAC[transform_list_pair];
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `n' = ntrans L N r x 1`;
  TYPED_ABBREV_TAC `r' = rtrans L N r x 1`;
  TYPIFY `marked_list L n' r' x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[transform_assumption]);
  REWRITE_TAC[GSYM ntrans;GSYM rtrans];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let final_loops_list_iff = prove_by_refinement(
  `good_list L /\ MEM r N /\ normal_list L N ==>
   (loop_of_list r IN
                final_loops (hypermap_of_list L) (loop_family_of_list N) <=> final_list L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[EQ_EXPAND];
  ASM_SIMP_TAC[final_loops_list];
  ASM_SIMP_TAC[final_loops_list_eq];
  ASM_SIMP_TAC[final_loops_list_eq;IN_SET_OF_LIST;MEM_MAP;Seq.mem_filter];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `r = x` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  MATCH_MP_TAC loop_of_list_inj;
  TYPIFY `N` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[normal_list])
  ]);;
  (* }}} *)

let marked_conclusion = prove_by_refinement(
  `!L N r d:A#A.       good_list L /\
    good_list_nodes L /\
    marked_list L N r d /\
    ~final_list L r ==> 
  (
   	split_condition_list L N r d /\
	next_el r d = f_list L d /\
	normal_list L N /\
	is_restricted (hypermap_of_list L) /\
	MEM r N /\
	MEM d r /\
	MEM d (list_of_darts L) /\
	is_edge_nondegenerate (hypermap_of_list L) /\
               all uniq L 
  )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC normal_list_darts_of_list_mem [`L`;`N`];
  ASM_SIMP_TAC[marked_list_split_condition_list];
  FIRST_X_ASSUM_ST `marked_list` MP_TAC;
  REWRITE_TAC[marked_list;is_restricted];
  (ASM_SIMP_TAC[simple_hypermap_all_uniq]);
  REWRITE_TAC[GSYM Seq.allP;Seq2.mem_flatten];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let marked_translate = prove_by_refinement(
  `!L N r d:A#A.
    good_list L /\
    good_list_nodes L /\
    marked_list L N r d /\
    ~final_list L r ==> 
    (
	hyp'm (hypermap_of_list L) (loop_family_of_list N)
             (loop_of_list r) d = l'm L r d /\
       hyp'p (hypermap_of_list L) (loop_family_of_list N)
             (loop_of_list r)
             d =
             l'p L N r d /\
      hyp'q (hypermap_of_list L) (loop_family_of_list N) (loop_of_list r)
         d =
         l'q L N r d /\
	   hyp'y (hypermap_of_list L) (loop_family_of_list N)
             (loop_of_list r)
             d =
             l'y L r d /\
   hyp'z (hypermap_of_list L) (loop_family_of_list N)
             (loop_of_list r)
             d =
             l'z L N r d /\
	       is_marked (hypermap_of_list L,loop_family_of_list N,loop_of_list r,d) /\
~(loop_of_list r IN
    final_loops (hypermap_of_list L) (loop_family_of_list N)) /\
	       is_split_condition (hypermap_of_list L) (loop_family_of_list N)
   (loop_of_list r)
   d
    )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_conclusion [`L`;`N`;`r`;`d`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  (ASM_SIMP_TAC[hyp_m_l_m;hyp_p_l_p;hyp_q_l_q;hyp_y_l_y;hyp_z_l_z]);
  ASM_SIMP_TAC[marked_list_marked];
  ASM_SIMP_TAC[split_condition_list_split];
  BY(ASM_MESON_TAC[final_loops_list_iff])
  ]);;
  (* }}} *)

(* let marked_in_dart_of_loop = 0;; *)

let normal_list_in_dart_of_loop = prove_by_refinement(
  `!L N r d:A#A u.
    normal_list L N /\
      MEM r N 
   ==>
    (in_dart_of_loop u (loop_of_list r) <=> MEM u r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[in_dart_of_loop];
  TYPIFY `uniq r /\ ~(r = [])` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC normal_list_uniq_nonnil;
    BY(ASM_MESON_TAC[]);
  BY(ASM_SIMP_TAC[in_dart_loop_of_list])
  ]);;
  (* }}} *)

(* let HQYMRTX_list = 0;; *)

let HQYMRTX1_list = prove_by_refinement(
`!L N r x. good_list L /\
   good_list_nodes L /\ 
  marked_list L N r x /\ ~final_list L r
  ==> MEM (l'z L N r x) r /\
    (!i. 1 <= i /\ i <= SUC (l'm L r x) ==>
       ~(l'z L N r x = (f_list L POWER i) x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Hypermap.lemmaHQYMRTX [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_translate]);
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    TYPIFY `MEM x (list_of_darts L)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[marked_conclusion]);
    BY(ASM_MESON_TAC[face_map_list_power]);
  BY(ASM_MESON_TAC[normal_list_in_dart_of_loop;marked_conclusion])
  ]);;
  (* }}} *)

let HQYMRTX2_list = prove_by_refinement(
 `!L N r x. good_list L /\ good_list_nodes L /\
   marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'y L r x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_on_hyp_y [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate;marked_conclusion];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let HQYMRTX3_list = prove_by_refinement(
`!L N r x. 
      good_list L /\ good_list_nodes L /\ 
     marked_list L N r x /\ ~final_list L r
  ==> ~(l'y L r x= l'z L N r x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_on_hyp_z [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate;marked_conclusion];
  ]);;
  (* }}} *)

let marked_lemma_yz_in_face = prove_by_refinement(
  `!L N r x. 
      good_list L /\ good_list_nodes L /\ 
     marked_list L N r x /\ ~final_list L r ==>
    MEM (l'y L r x) (find_face L x) /\ MEM (l'z L N r x) (find_face L x) `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemma_yz_in_face [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate;marked_conclusion];
  ASM_SIMP_TAC[List_hypermap.face_of_list;IN_SET_OF_LIST];
  BY(ASM_MESON_TAC[List_hypermap.face_of_list;IN_SET_OF_LIST;marked_conclusion])
  ]);;
  (* }}} *)

let mem_l_z_dart = prove_by_refinement(
`!L N r x. 
      good_list L /\ good_list_nodes L /\ 
     marked_list L N r x /\ ~final_list L r
  ==> MEM (l'z L N r x) (list_of_darts L)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC marked_lemma_yz_in_face [`L`;`N`;`r`;`x`];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.mem_find_face_imp_mem_darts])
  ]);;
  (* }}} *)

let card_atoms_of_loop = prove_by_refinement(
  `!L N r x.
     good_list L /\ good_list_nodes L /\ normal_list L N /\
           is_edge_nondegenerate (hypermap_of_list L) /\
            all uniq L /\
     MEM r N ==>
     CARD (atoms_of_loop (hypermap_of_list L) (loop_of_list r))  =
	 sizel (parts L r)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `f = \p. atom (hypermap_of_list L) (loop_of_list r) (LAST p)`;
  TYPIFY `sizel (parts L r) = CARD (set_of_list (parts L r))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC (GSYM Seq2.card_set_of_list_uniq);
    MATCH_MP_TAC uniq_parts;
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  TYPIFY `FINITE (set_of_list (parts L r))` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[FINITE_SET_OF_LIST]);
  TYPIFY `BIJ f (set_of_list (parts L r)) (atoms_of_loop (hypermap_of_list L) (loop_of_list r))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Misc_defs_and_lemmas.BIJ_CARD]);
  REWRITE_TAC[BIJ;INJ;Hypermap.atoms_of_loop];
  SUBCONJ_TAC;
    REWRITE_TAC[IN_ELIM_THM;IN_SET_OF_LIST];
    CONJ2_TAC;
      FULL_EXPAND_TAC "f";
      REPEAT WEAKER_STRIP_TAC;
      INTRO_TAC atom_last_inj [`L`;`N`;`r`;`r`;`x`;`y`];
      ASM_SIMP_TAC[];
      BY(ASM_MESON_TAC[parts_last_inj]);
    FULL_EXPAND_TAC "f";
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x` (RENAME_TAC "p");
    TYPIFY `LAST p` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    INTRO_TAC parts_uniq_nonnil [`L`;`N`;`r`;`p`];
    ASM_REWRITE_TAC[];
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `MEM (LAST p) r` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[MEM_LAST]);
    BY(ASM_MESON_TAC[normal_list_in_dart_of_loop]);
  REWRITE_TAC[SURJ];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[IN_ELIM_THM;IN_SET_OF_LIST];
  FULL_EXPAND_TAC "f";
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (SUBST1_TAC);
  FIRST_X_ASSUM MP_TAC;
  GMATCH_SIMP_TAC normal_list_in_dart_of_loop;
  CONJ_TAC;
    BY(ASM_MESON_TAC[]);
  REPLICATE_TAC 2 (POP_ASSUM kill);
  DISCH_TAC;
  INTRO_TAC parts_flatten [`L`;`r`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[normal_list_uniq_nonnil]);
  DISCH_THEN (MP_TAC o MATCH_MP MEM_EXTENSION);
  REWRITE_TAC[Seq2.mem_flatten];
  DISCH_THEN (C INTRO_TAC [`x'`]) THEN ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `l` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[atom_eq_last;marked_conclusion])
  ]);;
  (* }}} *)

let QRDYXYJ_list = prove_by_refinement(
`!L N r x.
  good_list L /\
  good_list_nodes L /\
  marked_list L N r x /\ ~(final_list L r) ==>
  l'm L r x < l'q L N r x /\
  l'q L N r x < sizel (parts L r) /\
  SUC (l'm L r x) < l'p L N r x + l'q L N r x /\
  ~(FST (l'y L r x) = FST x) /\
  ~(FST (l'y L r x) = FST (l'z L N r x))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC lemmaParameters [`hypermap_of_list L`;`loop_family_of_list N`;`loop_of_list r`;`x`];
  ASM_SIMP_TAC[marked_translate;marked_conclusion];
  ANTS_TAC;
    BY(ASM_MESON_TAC[marked_translate]);
  ASM_SIMP_TAC[];
  GMATCH_SIMP_TAC card_atoms_of_loop;
  CONJ_TAC;
    BY(TYPIFY `N` EXISTS_TAC THEN ASM_MESON_TAC[marked_conclusion]);
  ASM_SIMP_TAC[];
  REPEAT (GMATCH_SIMP_TAC List_hypermap.good_list_node);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[EXTENSION;IN_ELIM_THM;List_hypermap.darts_of_list;IN_SET_OF_LIST];
  CONJ_TAC;
    MATCH_MP_TAC mem_l_z_dart;
    BY(ASM_REWRITE_TAC[]);
  CONJ_TAC;
    BY(ASM_MESON_TAC[marked_conclusion]);
  CONJ_TAC;
    MATCH_MP_TAC mem_l_y_dart;
    BY(ASM_MESON_TAC[marked_conclusion]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let iso_list_restricted = prove_by_refinement(
  `!L L'. good_list L' /\ 
   iso_list (L',[]) (L,[]) /\ is_restricted (hypermap_of_list L) ==>
    is_restricted (hypermap_of_list L')`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC DAKEFCC [`hypermap_of_list L'`;`hypermap_of_list L`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC GNBEVVU;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)


end;;
