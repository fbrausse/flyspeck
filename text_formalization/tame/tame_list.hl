(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Tame Hypermap                                           *)
(* Author:  Thomas Hales     *)
(* Date: February 9, 2014                                                 *)
(* ========================================================================== *)

(* general list processing results and small common lemmas. *)


module Tame_list  = struct

  open Hales_tactic;;
open Hypermap;;
open Tame_defs;;
open Tame_concl;;


let POWER_TO_ITER = Wrgcvdr_cizmrrh.POWER_TO_ITER;;

let nth_EL = prove_by_refinement(
  `!x xs n k.
    ((n = 0) ==> (\l n. EL n l) (x::xs) n = x) /\ 
     ((n = SUC k) ==> (\l n. EL n l) (x::xs) n = (\l n. EL n l) xs k)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[];
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[EL;HD;TL]
  ]);;
  (* }}} *)

let the_some = prove_by_refinement(
  `!(x:A). the (SOME x) = x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[the];
  GEN_TAC;
  SELECT_TAC;
    INTRO_TAC option_RECURSION [`x`;`I:A->A`];
    REWRITE_TAC[I_THM];
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let filter_rec = prove_by_refinement(
  `filter (f:A->bool) [] = [] /\
    filter f (x:: xs) = if (f x) then (x :: (filter f xs)) else (filter f xs)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[Seq.filter])
  ]);;
  (* }}} *)

let filter_FILTER = prove_by_refinement(
  `filter = FILTER`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  GEN_TAC;
  ONCE_REWRITE_TAC[FUN_EQ_THM];
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.filter;FILTER])
  ]);;
  (* }}} *)

let APPEND_cat = prove_by_refinement(
  `APPEND = cat`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[APPEND; Seq.cat0s]);
  BY(ASM_REWRITE_TAC[APPEND;Seq.cat_cons])
  ]);;
  (* }}} *)

let faces_graph = prove_by_refinement(
  `faces (Graph fs n f h) = fs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[faces;GRAPH]
  ]);;
  (* }}} *)

let fgraph_graph = prove_by_refinement(
  `!f n a b. fgraph (Graph f n a b) = MAP FST f`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[GRAPH;fgraph;faces;vertices])
  ]);;
  (* }}} *)

let final_SND = prove_by_refinement(
  `SND (Face vs f) = if (f = T) then T else F`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FACE];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let type_face_SND = prove_by_refinement(
  `SND (Face vs f) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FACE])
  ]);;
  (* }}} *)

let vertices_face_FST = prove_by_refinement(
  `FST (Face (vs:num list) (f:bool)) = (vs:num list)`,
  (* {{{ proof *)
  [
  (REWRITE_TAC[FACE])
  ]);;
  (* }}} *)

let setFinal_ALT = prove_by_refinement(
  `setFinal f = Face(FST f) T`,
  (* {{{ proof *)
  [
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[setFinal;vertices_set;FACE])
  ]);;
  (* }}} *)

let countVertices = prove_by_refinement(
  `countVertices (Graph fs n f h) = n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[GRAPH;countVertices_def;FST;SND]);
  ]);;
  (* }}} *)

let vertices_graph_alt = prove_by_refinement(
  `vertices_graph (Graph fs n f h) = upt 0 n`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[vertices_graph;GRAPH;countVertices_def])
  ]);;
  (* }}} *)

let FACE_LIST_AT = prove_by_refinement(
  `faceListAt (Graph fs n f h) = f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[faceListAt;GRAPH])
  ]);;
  (* }}} *)

let graph_ALT = prove_by_refinement(
  `graphl n = 
     (let vs = upt 0  n in
      let fs =  [Face vs T;Face (REVERSE vs) F] in
	(Graph fs  n (REPLICATE n fs) (REPLICATE n 0)))`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FACE;graphl])
  ]);;
  (* }}} *)

let MEMf_MAP = prove_by_refinement(
  `!f:A->B x u. MEM x u ==> MEM (f x) (MAP f u)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_HD = prove_by_refinement(
  `!xs:(A)list. ~(xs = []) ==> MEM (HD xs) xs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM EL];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC MEM_EL;
  BY(ASM_REWRITE_TAC[arith `0 < m <=> ~(m=0)`;LENGTH_EQ_NIL])
  ]);;
  (* }}} *)

let MEM_EQ_NIL = prove_by_refinement(
  `!s. s = [] <=> (!x. ~MEM x s)`,
  (* {{{ proof *)
  [
  BY(MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let fgraph_Faces = prove_by_refinement(
  `!g f. f IN Faces g ==> MEM (FST f) (fgraph g)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;FACES];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC MEMf_MAP;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST])
  ]);;
  (* }}} *)

let FST_setFinal = prove_by_refinement(
  `!vs f. MAP FST (replace f [setFinal f] vs) = MAP FST vs`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[replace]);
  REWRITE_TAC[replace];
  GEN_TAC;
  REWRITE_TAC[APPEND_SING];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MAP];
    BY(REWRITE_TAC[setFinal_ALT;vertices_face_FST]);
  BY(ASM_REWRITE_TAC[MAP])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!g f. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[makeFaceFinal;fgraph;GRAPH;faces;makeFaceFinalFaceList;setFinal];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

let concat_flatten = prove_by_refinement(
  `!x xs. flatten ([]:(A list)list) = [] /\
    flatten ( (x:A list) :: xs) = APPEND x (flatten xs)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[Seq.flatten0;Seq.flatten_cons;APPEND_cat])
  ]);;
  (* }}} *)

let min_num_single = prove_by_refinement(
  `!x. min_num {x} = x`,
  (* {{{ proof *)
  [
  GEN_TAC;
  TYPIFY `x IN {x} ==> min_num {x} IN {x}` (C SUBGOAL_THEN MP_TAC);
    REWRITE_TAC[IN];
    BY(MESON_TAC[Misc_defs_and_lemmas.min_least ]);
  BY(REWRITE_TAC[IN_SING])
  ]);;
  (* }}} *)

let min_num_in = prove_by_refinement(
  `!X. ~(X = {}) ==> min_num X IN X`,
  (* {{{ proof *)
  [
  REWRITE_TAC[EXTENSION;NOT_IN_EMPTY;NOT_FORALL_THM];
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_le = prove_by_refinement(
  `!X c. c IN X ==> min_num X <= c`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN];
  BY(MESON_TAC[Misc_defs_and_lemmas.min_least ])
  ]);;
  (* }}} *)

let min_num_unique = prove_by_refinement(
  `!X c. c IN X /\ (!c'. c' IN X ==> c <= c') ==> min_num X = c`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (arith `x <= (c:num) /\ c <= x ==> x = c`);
  CONJ_TAC;
    MATCH_MP_TAC min_num_le;
    BY(ASM_REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  MATCH_MP_TAC min_num_in;
  BY(FIRST_X_ASSUM MP_TAC THEN SET_TAC[])
  ]);;
  (* }}} *)

let min_num_insert = prove_by_refinement(
  `!x X. ~(X = {}) ==> min_num (x INSERT X) = MIN x (min_num X)`,
  (* {{{ proof *)
  [
  REPEAT GEN_TAC;
  TYPIFY `x IN x INSERT X` (C SUBGOAL_THEN ASSUME_TAC);
    BY(SET_TAC[]);
  DISCH_TAC;
  MATCH_MP_TAC min_num_unique;
  CONJ_TAC;
    REWRITE_TAC[MIN];
    COND_CASES_TAC;
      BY(SET_TAC[]);
    TYPIFY `min_num X IN X` ENOUGH_TO_SHOW_TAC;
      BY(SET_TAC[]);
    MATCH_MP_TAC min_num_in;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[IN_INSERT];
  REPEAT STRIP_TAC;
    ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC (arith `m <= min_num X /\ min_num X <= c' ==> m <= c'`);
  CONJ_TAC;
    BY(REWRITE_TAC[MIN] THEN ARITH_TAC);
  MATCH_MP_TAC min_num_le;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let minn_MIN = prove_by_refinement(
  `minn = MIN`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[MIN;Ssrnat.minn];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let min_list_cons = prove_by_refinement(
  `!x xs. min_list (x :: xs) = if (xs = []) then x else MIN x (min_list xs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[min_list;set_of_list];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[set_of_list;min_num_single]);
  MATCH_MP_TAC min_num_insert;
  BY(ASM_REWRITE_TAC[SET_OF_LIST_EQ_EMPTY])
  ]);;
  (* }}} *)

let ITER_o = prove_by_refinement(
  `(!f n. ITER 0 f = I /\ ITER (SUC n) f = f o ITER n f )`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FUN_EQ_THM;ITER;I_THM;o_THM])
  ]);;
  (* }}} *)

let rotate_rotate1 = prove_by_refinement(
  `rotate 1 = rotate1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  REWRITE_TAC[rotate];
  BY(REWRITE_TAC[rotate;ITER_1])
  ]);;
  (* }}} *)

let rotate1_rot1 = prove_by_refinement(
  `rotate1 = rot 1`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate1;Seq2.rot_nil]);
  REWRITE_TAC[rotate1;Seq.rot1_cons];
  BY(REWRITE_TAC[rotate1;Seq.rot1_cons;GSYM Seq.cats1;APPEND_cat])
  ]);;
  (* }}} *)

let rotate_rot = prove_by_refinement(
  `!n x. n <= LENGTH x ==> rotate n x = rot n x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(REWRITE_TAC[Seq.rot0;rotate;ITER]);
  REWRITE_TAC[arith `SUC n = n + 1`];
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.rot_addn;
  REWRITE_TAC[rotate;GSYM ITER_ADD;ITER_1];
  ASM_REWRITE_TAC[GSYM rotate;Seq.size;rotate1_rot1];
  FIRST_X_ASSUM MATCH_MP_TAC;
  POP_ASSUM MP_TAC;
  REWRITE_TAC[GSYM Seq.size;Seq.size_rot];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let rotate_add = prove_by_refinement(
  `!n m x. rotate (n+m) x = rotate n (rotate m x)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER_ADD])
  ]);;
  (* }}} *)

let rotate_nil = prove_by_refinement(
  `!n. rotate n [] = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate;ITER]);
  BY(ASM_REWRITE_TAC[arith `SUC n = n + 1`;rotate_add;rotate_rotate1;rotate1])
  ]);;
  (* }}} *)

let rotate_periodic = prove_by_refinement(
  `!n x. rotate (n + LENGTH x) x = rotate n x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[rotate_add];
  REPEAT WEAKER_STRIP_TAC;
  AP_TERM_TAC;
  GMATCH_SIMP_TAC rotate_rot;
  REWRITE_TAC[arith `x <= (x:num)`];
  BY(REWRITE_TAC[GSYM Seq.size;Seq.rot_size])
  ]);;
  (* }}} *)

let rotate_mod = prove_by_refinement(
  `!(x:(A)list) n. rotate n x = rotate (n MOD LENGTH x) x`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[rotate_nil]);
  INTRO_TAC Oxl_2012.periodic_mod1 [`\n. rotate n (h::t)`];
  REWRITE_TAC[];
  DISCH_THEN MATCH_MP_TAC;
  CONJ2_TAC;
    REWRITE_TAC[LENGTH];
    BY(ARITH_TAC);
  REWRITE_TAC[ Oxl_def.periodic];
  BY(REWRITE_TAC[rotate_periodic])
  ]);;
  (* }}} *)

let INSERT_alt = prove_by_refinement(
  `(INSERT) a B = {x | x = a \/ x IN B}`,
  (* {{{ proof *)
  [
  REWRITE_TAC[INSERT;EXTENSION;IN_ELIM_THM];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let congs_rot = prove_by_refinement(
  `!f1 f2. __cong f1  f2 <=> (?n. n <= LENGTH f1 /\ f2 = rot n f1)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC;
    REWRITE_TAC[cong;rotate_nil;Seq2.rot_nil;LENGTH];
    BY(MESON_TAC[arith `0 <= 0`]);
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REWRITE_TAC[cong];
  CONJ2_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `n` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC rotate_rot;
    BY(ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `n MOD (LENGTH (h::t))` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC (GSYM rotate_rot);
  REWRITE_TAC[GSYM rotate_mod];
  INTRO_TAC DIVISION [`n`;`LENGTH(h::t)`];
  ANTS_TAC;
    BY(REWRITE_TAC[LENGTH] THEN ARITH_TAC);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let inj_on_ALT = prove_by_refinement(
  `inj_on (f:A->B) A <=> (!x. x IN A ==> (!y. y IN A ==> (f x = f y) ==> (x = y)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;IN];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let INJ_inj_on = prove_by_refinement(
  `!f s. inj_on f s <=> INJ f s (:UNIV)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on;INJ;IN_UNIV];
  BY(REWRITE_TAC[IN])
  ]);;
  (* }}} *)

let nextElem_ALT = prove_by_refinement(
  `nextElem [] (b:A) x = b /\
   nextElem (a :: as) b x =     
    (if x=a then ((if (as = []) then (b ) else 
		     (let a_ = HD (as) in (let as_ = TL (as) in a_)))) else nextElem as b x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextElem];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(REWRITE_TAC[LET_THM])
  ]);;
  (* }}} *)

let nextVertex_ALT = prove_by_refinement(
  `nextVertex f = (let vs = FST f in nextElem vs (HD vs))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[LET_THM;nextVertex];
  INTRO_TAC PAIR_SURJECTIVE [`f`];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[nextVertex])
  ]);;
  (* }}} *)

let upt_rec = prove_by_refinement(
  `!i j. upt i 0 = [] /\ upt i (SUC j) = if (i <= j) then (APPEND (upt i j)  [j]) else []`,
  (* {{{ proof *)
  [
  REWRITE_TAC[upt;arith `0-i = 0`;Seq.iota];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_SIMP_TAC [arith `i <= j ==> SUC j - i =  (j - i) + 1`];
    REWRITE_TAC[Seq.iota_add;Seq2.APPEND_cat];
    AP_TERM_TAC;
    ASM_SIMP_TAC[arith `i <= j ==> i + j - (i:num) = j`;arith `1 = SUC 0`];
    BY(REWRITE_TAC[Seq.iota]);
  ASM_SIMP_TAC[arith `~(i<=j) ==> SUC j - i = 0`];
  BY(REWRITE_TAC[Seq.iota])
  ]);;
  (* }}} *)

let RTranCl_ALT = prove_by_refinement(
  `(g,g) IN RTranCl succs /\
    g' IN set_of_list (succs g) /\ (g',g'') IN RTranCl succs ==> (g,g'') IN RTranCl succs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[RTranCl;CURRY_DEF;UNCURRY_DEF;IN;RTC_REFL];
  INTRO_TAC RTC_RULES [`(\x y. MEM y (succs x))`];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  TYPIFY `g'` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[GSYM IN_SET_OF_LIST;IN])
  ]);;
  (* }}} *)

let RTranCl_REFL = prove_by_refinement(
  `!P x. (x,x) IN RTranCl P`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[RTranCl;IN;UNCURRY_DEF;RTC_REFL])
  ]);;
  (* }}} *)

let rotate_0 = prove_by_refinement(
  `!x n. rotate 0 x = x`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[rotate;ITER])
  ]);;
  (* }}} *)

let rotate_eq_nil = prove_by_refinement(
  `!n (x:(A) list). rotate n x = [] <=> x = []`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[rotate_0]);
  ASM_REWRITE_TAC[rotate_add;arith `SUC n = n + 1`];
  REWRITE_TAC[rotate;ITER_1];
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[rotate1;NOT_CONS_NIL;APPEND_EQ_NIL])
  ]);;
  (* }}} *)

let MEM_replace = prove_by_refinement(
  `!x f xs g. MEM x (replace f xs g) ==> (MEM x g \/ (MEM f g /\ (MEM x xs)))`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    REWRITE_TAC[replace];
    BY(MESON_TAC[]);
  REWRITE_TAC[replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REWRITE_TAC[MEM];
    REWRITE_TAC[MEM_APPEND];
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM2_replace = prove_by_refinement(
  `!x f xs g. MEM f g /\ MEM x xs ==> MEM x (replace f xs g)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM;replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM3_replace = prove_by_refinement(
  `!x f xs g. ~(x = f) /\ MEM x g ==> MEM x (replace f xs g)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 3 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM;replace];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    ASM_REWRITE_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let REVERSE_rev = prove_by_refinement(
  ` REVERSE = rev`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[REVERSE;Seq.rev;Seq.catrev]);
  ASM_REWRITE_TAC[REVERSE;Seq.rev];
  REWRITE_TAC[Seq.catrev];
  REWRITE_TAC[Seq.catrevE];
  BY(REWRITE_TAC[Seq.cats0;Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let upt0 = prove_by_refinement(
  `!i. upt 0 i = iota 0 i`,
  (* {{{ proof *)
  [
  REWRITE_TAC[upt];
  GEN_TAC;
  BY(REWRITE_TAC[arith `i - 0 = i`])
  ]);;
  (* }}} *)

let list_pairs_rev = prove_by_refinement(
  `!a. list_pairs (rev a) = rev (zip a (rotr 1 a))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs;GSYM Seq.rev_rotr];
  GEN_TAC;
  GMATCH_SIMP_TAC (GSYM Seq.rev_zip);
  BY(REWRITE_TAC[Seq.size_rotr])
  ]);;
  (* }}} *)

let nth_iota_nod = prove_by_refinement(
  `!x0 k i. i < k ==> nth x (iota 0 k) i = i`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC (GSYM Seq2.EL_nth);
  GMATCH_SIMP_TAC Seq2.EL_nth;
  TYPIFY `0` EXISTS_TAC;
  ASM_REWRITE_TAC[Seq.size_iota];
  GMATCH_SIMP_TAC Seq.nth_iota;
  BY(ASM_REWRITE_TAC[] THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota0 = prove_by_refinement(
  `!i' i j k x y. i' + 1 = k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',0)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ i' = k - 1` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zipr_iota0 = prove_by_refinement(
  `!i j k x y. 0 < k  ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) 0 = 0,k-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let nth_zip_iota = prove_by_refinement(
  `!i' i j k x y. i' + 1 < k ==> (nth (x,y) (zip(iota 0 k) (rot 1(iota 0 k))) i' = i',i'+1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i' < k /\ ~(i' = k-1)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nth_zipr_iota = prove_by_refinement(
  `!i' i j k x y. 0 < i' /\ i' < k ==> (nth (x,y) (zip(iota 0 k) (rotr 1(iota 0 k))) i' = i',i'-1)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.nth_zip;
  REWRITE_TAC[Seq.size_rotr];
  REWRITE_TAC[PAIR_EQ];
  GMATCH_SIMP_TAC nth_iota_nod;
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq2.nth_shift_right;
  REWRITE_TAC[Seq.size_iota];
  ASM_REWRITE_TAC[];
  TYPIFY_GOAL_THEN `~(i' = 0)` (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC nth_iota_nod;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_iota = prove_by_refinement(
  `!i j k.  (MEM (i,j) (list_pairs (iota 0 k)) <=> ((i+1 < k /\ j = i+1) \/ (i+1=k  /\ j=0)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC List_hypermap.size_list_pairs [`iota 0 k`];
  REWRITE_TAC[List_hypermap.list_pairs;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `i' + 1 < k \/ i' + 1 = k` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      GMATCH_SIMP_TAC nth_zip_iota;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zip_iota0;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    TYPIFY `i` EXISTS_TAC;
    GMATCH_SIMP_TAC nth_zip_iota;
    REWRITE_TAC[PAIR_EQ];
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY `i` EXISTS_TAC;
  GMATCH_SIMP_TAC nth_zip_iota0;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_rev_iota = prove_by_refinement(
  `!i j k.  0 < k ==> 
     (MEM (i,j) (list_pairs (rev (iota 0 k))) <=> ((i = 0 /\ j=k-1) \/ (0 < i /\ i < k /\ j = i-1)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[list_pairs_rev;Seq.mem_rev];
  INTRO_TAC List_hypermap.size_list_pairs [`rev (iota 0 k)`];
  REWRITE_TAC[list_pairs_rev;Seq.size_rev;Seq.size_iota];
  REWRITE_TAC[GSYM Seq.nthP];
  TYPIFY `?x y. x0 = (x,y)` (C SUBGOAL_THEN MP_TAC);
    BY(MESON_TAC[PAIR_SURJECTIVE]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `nth` MP_TAC;
    ASM_REWRITE_TAC[];
    TYPIFY `(i' =0 \/ 0 < i')` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    FIRST_X_ASSUM DISJ_CASES_TAC;
      ASM_REWRITE_TAC[];
      GMATCH_SIMP_TAC nth_zipr_iota0;
      BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC nth_zipr_iota;
    BY(ASM_REWRITE_TAC[PAIR_EQ] THEN ASM_TAC THEN ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `i` EXISTS_TAC;
  FIRST_X_ASSUM DISJ_CASES_TAC;
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC nth_zipr_iota0;
    BY(ASM_REWRITE_TAC[]);
  GMATCH_SIMP_TAC nth_zipr_iota;
  REWRITE_TAC[PAIR_EQ];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let mem_minimal_el = prove_by_refinement(
  `!f xs. ~(xs = []) ==> MEM (minimal_el f xs) xs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[minimal_el];
  GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[]);
  REWRITE_TAC[minimal_el];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[LET_THM];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let uniq_perm_eq_map  = prove_by_refinement(
  `! (x:(A)list) y. uniq x /\ uniq y /\ set_of_list  x = 
    set_of_list y ==> perm_eq x y`,
  (* {{{ proof *)
  [
  REWRITE_TAC[IN_SET_OF_LIST;EXTENSION];
  BY(MESON_TAC[ Seq.uniq_perm_eq])
  ]);;
  (* }}} *)

let o_nth = prove_by_refinement(
  `!f x0. f o nth x0 x = nth (f x0) (map f x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[o_THM;FUN_EQ_THM];
  X_GENv_TAC "i";
  TYPIFY `(i:num) < sizel x` ASM_CASES_TAC;
    GMATCH_SIMP_TAC Seq.nth_map;
    TYPIFY `x0` EXISTS_TAC;
    BY(ASM_REWRITE_TAC[]);
  REPEAT (GMATCH_SIMP_TAC Seq.nth_default);
  REWRITE_TAC[Seq.size_map];
  BY(FIRST_X_ASSUM MP_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let perm_eq_map = prove_by_refinement(
  `!x y. perm_eq (map f x) (map f y) ==> (?x'.
    perm_eq x' x /\ (map f x' = map f y))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  (FIRST_X_ASSUM (MP_TAC o (MATCH_MP Seq2.perm_eq_iota)));
  DISCH_THEN (C INTRO_TAC [`f (HD x)`]);
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `map (nth (HD x) x) l` EXISTS_TAC;
  REWRITE_TAC[GSYM Seq.map_comp];
  REWRITE_TAC[GSYM Seq.map_comp;o_nth];
  TYPIFY `perm_eq (map (nth (HD x) x) l) (map (nth (HD x) x) (iota 0 (sizel (map f x))))` ENOUGH_TO_SHOW_TAC;
    TYPIFY `(map (nth (HD x) x) (iota 0 (sizel (map f x)))) = x` ENOUGH_TO_SHOW_TAC;
      BY(MESON_TAC[]);
    REWRITE_TAC[Seq.size_map];
    REWRITE_TAC[GSYM Seq.mkseq];
    BY(MESON_TAC[Seq2.seq_eq_mkseq]);
  MATCH_MP_TAC Seq2.perm_eq_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let MAP_flatten = prove_by_refinement(
  `!f x. MAP f (flatten x) = flatten (MAP (MAP f) x)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[concat_flatten;MAP;MAP_APPEND])
  ]);;
  (* }}} *)

let zip_map = prove_by_refinement(
  `!f g x y. MAP (\ u. f(FST u),g(SND u)) (zip x y) = zip (MAP f x) (MAP g y)`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.zip;MAP;CONS_11];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let ONE_ONE_IMP_BIJ_IMAGE = prove_by_refinement(
  `!f:A->B S. (!x y. x IN S /\ y IN S /\ f x = f y ==> x = y) ==>
   BIJ f S (IMAGE f S)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (GEN_ALL Lunar_deform.INJ_IMP_BIJ_IMAGE);
  ASM_REWRITE_TAC[INJ];
  TYPIFY `(:B)` EXISTS_TAC;
  BY(REWRITE_TAC[IN_UNIV])
  ]);;
  (* }}} *)

let REVERSE_rev = prove_by_refinement(
  ` REVERSE = rev`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FUN_EQ_THM];
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[REVERSE;Seq.rev;Seq.catrev]);
  ASM_REWRITE_TAC[REVERSE;Seq.rev];
  REWRITE_TAC[Seq.catrev];
  REWRITE_TAC[Seq.catrevE];
  BY(REWRITE_TAC[Seq.cats0;Seq2.APPEND_cat])
  ]);;
  (* }}} *)

let zip_swap = prove_by_refinement(
  `!x y. MAP (\d. SND d,FST d) (zip x y) = zip y x`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.zip;MAP])
  ]);;
  (* }}} *)

let I_BIJ_EQ = prove_by_refinement(
  `!s t. BIJ I s t <=> s = t`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT WEAKER_STRIP_TAC THEN CONJ_TAC;
    REWRITE_TAC[BIJ;INJ;SURJ;EXTENSION;I_THM];
    BY(MESON_TAC[]);
  BY(MESON_TAC[Hypermap.I_BIJ])
  ]);;
  (* }}} *)

let indexl_uniq = prove_by_refinement(
  `!x0 y (d:A) i. uniq y /\ i < sizel y /\ nth x0 y i = d ==>
    indexl d y = i`,
  (* {{{ proof *)
  [
    BY(ASM_MESON_TAC[Seq.index_uniq])
  ]);;
  (* }}} *)

let prev_el_map = prove_by_refinement(
  `!y d f:A->B. (!x y. f x = f y ==> x = y) ==> 
	prev_el (MAP f y) (f d) = f (prev_el y d)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq2.prev_el];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (f d) (MAP f y) = MEM d y` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[GSYM Seq.map_MAP];
  FIRST_ASSUM (ASSUME_TAC o (MATCH_MP Seq.index_map));
  ASM_REWRITE_TAC[];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[Seq.last_map]);
  GMATCH_SIMP_TAC Seq.nth_map;
  TYPIFY `d` EXISTS_TAC;
  REWRITE_TAC[];
  BY(ASM_MESON_TAC[Seq.index_mem;arith `d < s ==> d - 1 < s`])
  ]);;
  (* }}} *)

let uniq_map = prove_by_refinement(
  `!y f:A->B. uniq y /\
     (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v) ==>
    uniq (MAP f y)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;MAP;Seq.uniq];
  REPEAT WEAKER_STRIP_TAC;
  CONJ2_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  REWRITE_TAC[MEM_MAP];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexl_map = prove_by_refinement(
  `!y d f:A->B. uniq y /\
    MEM d y /\ (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v)
  ==> indexl (f d) (MAP f y) = indexl d y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexl_uniq [`f(CHOICE (:A))`];
  DISCH_THEN MATCH_MP_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[uniq_map]);
  DISCH_TAC;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[Seq.index_mem;Seq.map_MAP;Seq.size_map]);
  DISCH_TAC;
  REWRITE_TAC[GSYM o_nth;Seq.map_MAP;o_THM];
  REWRITE_TAC[GSYM o_nth;GSYM Seq.map_MAP;o_THM];
  AP_TERM_TAC;
  MATCH_MP_TAC Seq.nth_index;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_el_MEM_map = prove_by_refinement(
  `!y d f:A->B. uniq y /\ MEM d y /\ (!u v. MEM u y /\ MEM v y /\ f u = f v ==> u = v) ==> 
	next_el (MAP f y) (f d) = f (next_el y d)`,
  (* {{{ proof *)
  [
  INTRO_TAC Seq2.next_el_alt [`CHOICE (:A)`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM (f d) (MAP f y)` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[MEM_MAP];
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[];
  INTRO_TAC Seq2.next_el_alt [`f (CHOICE (:A))`];
  ASM_SIMP_TAC[];
  DISCH_THEN kill;
  REPEAT (GMATCH_SIMP_TAC Seq2.nth_shift_left);
  ASM_REWRITE_TAC[Seq.index_mem];
  TYPIFY `indexl (f d) (MAP f y) = indexl d y` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (SUBST1_TAC);
    REWRITE_TAC[GSYM Seq.map_MAP];
    REWRITE_TAC[Seq.size_map];
    BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[GSYM o_nth;o_THM]);
  MATCH_MP_TAC indexl_map;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let map_list_pairs = prove_by_refinement(
  `!phi:A->B x. list_pairs (MAP phi x) =
     MAP (\u. phi (FST u),phi (SND u)) (list_pairs x)`,
  (* {{{ proof *)
  [
    GEN_TAC;
  X_GENv_TAC "a";
  REWRITE_TAC[List_hypermap.list_pairs];
  REWRITE_TAC[zip_map];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  BY(REWRITE_TAC[Seq.map_rot;GSYM Seq.map_MAP])
  ]);;
  (* }}} *)

let map_list_of_darts = prove_by_refinement(
  `!x phi. list_of_darts (MAP (MAP phi) x) = MAP (\ x. (phi (FST x),phi(SND x))) (list_of_darts x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_of_darts_alt];
  REWRITE_TAC[List_hypermap.list_of_faces];
  REWRITE_TAC[MAP_flatten];
  X_GENv_TAC "a";
  GEN_TAC;
  REWRITE_TAC[GSYM MAP_o];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[FUN_EQ_THM;o_THM;map_list_pairs];  
  ]);;
  (* }}} *)

let elements_of_list_unions = prove_by_refinement(
  `!L. elements_of_list L = (UNIONS (IMAGE (\f. set_of_list f) (set_of_list L)))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq2.set_of_list_undup];
  REWRITE_TAC[SET_OF_LIST_MAP];
  REWRITE_TAC[GSYM SET_OF_LIST_MAP];
  REWRITE_TAC[List_hypermap.set_of_list_flatten_map];
  REWRITE_TAC[Seq.map_MAP];
  GEN_TAC;
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  BY(REWRITE_TAC[FUN_EQ_THM])
  ]);;
  (* }}} *)

let mem_list_of_darts_imp_mem_list_of_elements_alt = prove_by_refinement(
	   `!L a b.
         MEM (a,b) (list_of_darts L)
         ==> MEM a (list_of_elements L) /\ MEM b (list_of_elements L)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.mem_list_of_darts];
  REWRITE_TAC[List_hypermap.elements_of_list;List_hypermap.list_of_elements];
  REWRITE_TAC[Seq.mem_undup];
  REWRITE_TAC[Seq2.mem_flatten];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (MESON[] `(?l. P l /\ Q l) ==> ((?l. P l) /\ (?l. Q l))`);
  TYPIFY `l` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[List_hypermap.mem_list_pairs])
  ]);;
  (* }}} *)

let inj_on_imp_inj_dart = prove_by_refinement(
  `!L phi. inj_on phi (elements_of_list L) ==>
   (!x y.
      MEM x (list_of_darts L)
      ==> MEM y (list_of_darts L)
      ==> phi (FST x) = phi (FST y) /\ phi (SND x) = phi (SND y)
      ==> x = y) `,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM (MP_TAC o MATCH_MP mem_list_of_darts_imp_mem_list_of_elements_alt));
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `inj_on` MP_TAC;
  REWRITE_TAC[inj_on];
  REWRITE_TAC[List_hypermap.elements_of_list];
  REPEAT (FIRST_X_ASSUM MP_TAC) THEN REWRITE_TAC[GSYM IN_SET_OF_LIST;IN];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let BIJ_IMAGE_darts_of_list = prove_by_refinement(
 `!x (phi:A->B). good_list x /\ inj_on phi (elements_of_list x) ==>
   BIJ (\u. phi (FST u),phi (SND u)) (darts_of_list x)
 (darts_of_list (MAP (MAP phi) x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.darts_of_list;];
  REWRITE_TAC[map_list_of_darts;SET_OF_LIST_MAP];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC ONE_ONE_IMP_BIJ_IMAGE;
  (FIRST_X_ASSUM (MP_TAC o MATCH_MP inj_on_imp_inj_dart));
  REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ];
  REWRITE_TAC[GSYM IN_SET_OF_LIST];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let f_list_ext_f_list = prove_by_refinement(
  `!L d. d IN darts_of_list L ==> f_list_ext L d = f_list L d`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.f_list_ext;Sphere.res];
  BY(REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let inj_on_subset = prove_by_refinement(
  `!phi:A->B U V. inj_on phi U /\ V SUBSET U ==> inj_on phi V`,
  (* {{{ proof *)
  [
  REWRITE_TAC[inj_on];
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let list_pairs2_rev = prove_by_refinement(
  `!x:(A)list.  (list_pairs (REVERSE x)) = (rot 1 (REVERSE (MAP (\d. SND d,FST d) (list_pairs x))))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.list_pairs;FORALL_PAIR_THM];
  GEN_TAC;
  MATCH_MP_TAC (REWRITE_RULE[MESON[] `(a ==> b ==> c) <=> (a /\ b ==> c)`] Seq.eq_from_nth);
  EXISTS_TAC `CHOICE (:A),CHOICE(:A)`;
  TYPED_ABBREV_TAC `c = CHOICE (:A)`;
  GMATCH_SIMP_TAC Seq.size2_zip;
  REWRITE_TAC[Seq.size_rot];
  REWRITE_TAC[arith `n:num <= n`];
  REWRITE_TAC[REVERSE_rev];
  TYPIFY `sizel (rot 1 x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Seq.size_rot]);
  TYPIFY `sizel (rev x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[Seq.size_rev]);
  TYPIFY `sizel (rot 1 (rev x)) = sizel ( x)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(MESON_TAC[Seq.size_rot;Seq.size_rev]);
  TYPIFY `sizel (zip (rev x) (rot 1 (rev x))) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  TYPIFY `sizel (rev (MAP (\d. SND d,FST d) (zip x (rot 1 x)))) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    REWRITE_TAC[Seq.size_rev;Seq.size_map;GSYM Seq.map_MAP];
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[];
  TYPIFY `sizel (zip (rot 1 x) x) = sizel x` (C SUBGOAL_THEN ASSUME_TAC);
    GMATCH_SIMP_TAC Seq.size2_zip;
    REWRITE_TAC[ Seq.size_rot;Seq.size_rev];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
  ASM_SIMP_TAC[Seq2.nth_shift_left];
  REWRITE_TAC[zip_swap];
  COND_CASES_TAC;
    ASM_REWRITE_TAC[];
    REPEAT (GMATCH_SIMP_TAC Seq.nth_rev);
    ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
    ASM_SIMP_TAC[Seq2.nth_shift_left];
    GMATCH_SIMP_TAC Seq2.nth_shift_left;
    NUM_REDUCE_TAC;
    TYPIFY `sizel x - SUC (sizel x - 1) = 0` (C SUBGOAL_THEN SUBST1_TAC);
      BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
    ASM_REWRITE_TAC[];
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  ASM_REWRITE_TAC[];
  REPEAT (GMATCH_SIMP_TAC Seq.nth_rev);
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[Seq.nth_zip;PAIR_EQ];
  GMATCH_SIMP_TAC Seq2.nth_shift_left;
  TYPIFY_GOAL_THEN `~(sizel x - SUC (i + 1) = sizel x - 1)` (unlist REWRITE_TAC);
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  TYPIFY_GOAL_THEN `sizel x - SUC (i+1) + 1 = sizel x - SUC i` (unlist REWRITE_TAC);
    BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  BY(REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let list_pairs_rev = prove_by_refinement(
  `!(x:(A)list) d. MEM d (list_pairs x) ==> MEM (SND d,FST d) (list_pairs ( REVERSE x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[list_pairs2_rev;Seq.mem_rot;REVERSE_rev;Seq.mem_rev;FORALL_PAIR_THM];
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[MEM_MAP;EXISTS_PAIR_THM;PAIR_EQ];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let list_pairs_rev_eq = prove_by_refinement(
  `!(x:(A)list) d. MEM d (list_pairs x) <=> MEM (SND d,FST d) (list_pairs ( REVERSE x))`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Geomdetail.EQ_EXPAND;list_pairs_rev];
  REWRITE_TAC[FORALL_PAIR_THM];
  BY(ASM_MESON_TAC[REVERSE_REVERSE;PAIR;FST;SND;list_pairs_rev])
  ]);;
  (* }}} *)

let list_of_darts_rev = prove_by_refinement(
  `!x d. MEM (p2,p1)
    (list_of_darts (MAP REVERSE x)) <=> MEM (p1,p2) (list_of_darts x)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[List_hypermap.mem_list_of_darts;MEM_MAP];
  BY(ASM_MESON_TAC[list_pairs_rev_eq;PAIR;FST;SND])
  ]);;
  (* }}} *)

let list_of_darts_rev_uniq = prove_by_refinement(
  `!x:((A)list)list. uniq (list_of_darts x) ==> uniq (map (\d. SND d,FST d) (list_of_darts (map REVERSE x)))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC (REWRITE_RULE[TAUT `(a ==> b==> c) <=> (a /\ b ==> c)`] Seq.leq_size_uniq);
  TYPIFY `list_of_darts x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  REWRITE_TAC[Seq.size_map];
  REWRITE_TAC[FORALL_PAIR_THM];
  REWRITE_TAC[Seq.mapP];
  CONJ_TAC;
    REWRITE_TAC[list_of_darts_rev;Seq.map_MAP;EXISTS_PAIR_THM];
    BY(MESON_TAC[]);
  REWRITE_TAC[List_hypermap.list_of_faces;GSYM Seq.map_MAP;List_hypermap.list_of_darts_alt;Seq.size_flatten;Seq.shape];
  REWRITE_TAC[GSYM Seq.map_comp];
  TYPIFY_GOAL_THEN `(sizel:(A#A)list -> num) o list_pairs = sizel` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[FUN_EQ_THM;o_THM;List_hypermap.size_list_pairs]);
  MATCH_MP_TAC (arith `(a:num = b) ==> (a <= b)`);
  REPEAT (AP_THM_TAC ORELSE AP_TERM_TAC);
  REWRITE_TAC[FUN_EQ_THM;o_THM;REVERSE_rev];
  BY(REWRITE_TAC[FUN_EQ_THM;o_THM;REVERSE_rev;Seq.size_rev])
  ]);;
  (* }}} *)

let FILTER_CONJ = prove_by_refinement(
  `!f g xs. FILTER f (FILTER g xs) = FILTER (\(x:A). f x /\ g x) xs`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  LIST_INDUCT_TAC;
    BY(REWRITE_TAC[FILTER]);
  REWRITE_TAC[FILTER];
  REPEAT COND_CASES_TAC THEN RULE_ASSUM_TAC(REWRITE_RULE[]) THEN ASM_REWRITE_TAC[FILTER];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let FILTER_NEGATE  = prove_by_refinement(
  `!f xs. FILTER f xs = xs <=> FILTER (\ (x:A). ~(f x)) xs = []`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[FILTER];
  BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FILTER;CONS_11;NOT_CONS_NIL] THEN ASM_MESON_TAC[MEM_FILTER;Seq.mem_head])
  ]);;
  (* }}} *)

let CARD_upt = prove_by_refinement(
  `!n. CARD (set_of_list (upt 0 n)) = n`,
  (* {{{ proof *)
  [
  GEN_TAC;
  GMATCH_SIMP_TAC Seq2.card_set_of_list_uniq;
  REWRITE_TAC[upt0];
  REWRITE_TAC[Seq.iota_uniq];
  BY(REWRITE_TAC[Seq.iota_uniq;Seq.size_iota])
  ]);;
  (* }}} *)

let undup_cat = prove_by_refinement(
  `!s t. (!x. MEM x s ==> MEM x t) ==> undup (cat s t) = undup t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.undup;Seq.cat0s;MEM;Seq.cat];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM h t'` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[]);
  TYPIFY_GOAL_THEN `MEM h (cat t t')` (unlist REWRITE_TAC);
    BY(ASM_REWRITE_TAC[Seq.mem_cat]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let EL_REPLICATE = prove_by_refinement(
  `!n i s. i < n ==> EL i (REPLICATE n s) = s`,
  (* {{{ proof *)
  [
  INDUCT_TAC THEN REWRITE_TAC[REPLICATE;EL_CONS];
    BY(ARITH_TAC);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let next_el1 = prove_by_refinement(
  `!h. next_el [h] h = h`,
  (* {{{ proof *)
  [
  GEN_TAC;
  INTRO_TAC Seq2.next_el_last [`h`;`[h]`];
  REWRITE_TAC[Seq.size;LENGTH;HD;Seq.uniq;MEM];
  NUM_REDUCE_TAC;
  TYPIFY `last h [h] = h` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  BY(REWRITE_TAC[Seq.last])
  ]);;
  (* }}} *)

let last_LAST = prove_by_refinement(
  `!s x0. ~(s = []) ==> last x0 s = LAST s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REWRITE_TAC[NOT_CONS_NIL;Seq.last;LAST];
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[Seq.last]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_LAST = prove_by_refinement(
  `!s. ~(s = []) ==> MEM (LAST s) s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.mem_last [`h`;`t`];
  REWRITE_TAC[LAST];
  COND_CASES_TAC;
    BY(REWRITE_TAC[MEM]);
  BY(ASM_MESON_TAC[last_LAST])
  ]);;
  (* }}} *)

let uniq_last = prove_by_refinement(
  `!h s. ~(MEM h s) /\ ~(s = []) ==> ~(LAST (h::s) = h)`,
  (* {{{ proof *)
  [
  GEN_TAC;
  LIST_INDUCT_TAC THEN REWRITE_TAC[NOT_CONS_NIL];
  FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[MEM;LAST;NOT_CONS_NIL];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let rev0 = prove_by_refinement(
  `rev [] = []`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[REVERSE;REVERSE_rev])
  ]);;
  (* }}} *)

let lower_case = end_itlist CONJ
 [GSYM Seq.map_MAP;GSYM Seq.size;GSYM filter_FILTER;
  REVERSE_rev;GSYM last_LAST;APPEND_cat;Seq2.ALL_all];;

let upper_case  = GSYM lower_case;;

(* QYHXIVZ *)

let PAIR_EQ2 = Wrgcvdr_cizmrrh.PAIR_EQ2;;

(*
let PAIR_EQ_EXPAND = prove_by_refinement(
  `!x a b. x = (a,b) <=> (FST x = a /\ SND x = b)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_PAIR_THM;PAIR_EQ])
  ]);;
  (* }}} *)
*)

let rcons_nonnil = prove_by_refinement(
  `!s x. ~(rcons s x = [])`,
  (* {{{ proof *)
  [
BY(LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.rcons;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let index_uniq = prove_by_refinement(
  `!x y. MEM x s /\ MEM y s /\ indexl x s = indexl y s ==> (x = y)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Seq.nth_index])
  ]);;
  (* }}} *)

let index0 = prove_by_refinement(
  `!s x. MEM x s /\ indexl x s = 0 ==> x = HD s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl (HD s) s = 0` ENOUGH_TO_SHOW_TAC;
    TYPIFY `MEM (HD s) s` (C SUBGOAL_THEN MP_TAC);
      MATCH_MP_TAC MEM_HD;
      BY(ASM_MESON_TAC[MEM]);
    DISCH_TAC;
    BY(ASM_MESON_TAC[index_uniq]);
  INTRO_TAC (GSYM Seq2.index_head) [`x`;`s`];
  DISCH_THEN (SUBST1_TAC);
  REPLICATE_TAC 2 (AP_TERM_TAC ORELSE AP_THM_TAC);
  GMATCH_SIMP_TAC Seq2.head_HD;
  REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
  BY(ASM_MESON_TAC[Seq.size_eq0;MEM])
  ]);;
  (* }}} *)

let index_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> SUC (indexl x (rot 1 s)) = indexl x s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[MEM;HD;Seq.index;Seq.find;Seq.rot1_cons;Seq.has_pred1];
  REWRITE_TAC[Seq.pred1];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  AP_TERM_TAC;
  REWRITE_TAC[Seq.find_cat;GSYM Seq.cats1];
  REWRITE_TAC[GSYM Seq.pred1];
  REWRITE_TAC[GSYM Seq.pred1;Seq.has_pred1];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexf = new_definition' `indexf (x:A) y s = 
  if (MEM x s /\ MEM y s) then (indexl y s + (sizel s - indexl x s)) MOD sizel s 
  else sizel s`;;

let indexf0 = prove_by_refinement(
  `!(x:A) y s. indexf x y [] = 0`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[indexf;MEM;Seq.size_nil])
  ]);;
  (* }}} *)

let indexf_mem1 = prove_by_refinement(
  `!(x:A) y s. ~MEM x s ==> indexf x y s = sizel s`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[indexf])
  ]);;
  (* }}} *)

let indexf2 = prove_by_refinement(
  `!(x:A) y s. ~MEM y s ==> indexf x y s = sizel s`,
  (* {{{ proof *)
  [
    BY(SIMP_TAC[indexf])
  ]);;
  (* }}} *)

let sizel0 = prove_by_refinement(
  `!s:A list. sizel s = 0 <=> ~(?x. MEM x s)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size;LENGTH_EQ_NIL;List_hypermap.mem_not_nil];
  BY(MESON_TAC[List_hypermap.mem_not_nil])
  ]);;
  (* }}} *)

let indexf_le_sizel = prove_by_refinement(
  `!s (x:A) y. indexf x y s <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[arith `n <= n:num`];
  TYPIFY `~(sizel s = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[DIVISION;arith `a < (b:num) ==> a <= b`]);
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf_lt_sizel = prove_by_refinement(
  `!s (x:A) y. MEM x s /\ MEM y s ==> indexf x y s < sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[indexf] THEN REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[];
  TYPIFY `~(sizel s = 0)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[DIVISION]);
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf_refl = prove_by_refinement(
  `!(x:A) s. MEM x s ==> indexf x x s = 0`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  ASM_SIMP_TAC[indexf];
  ASM_SIMP_TAC[arith `i < s ==> i + s - i = (s:num)`];
  MATCH_MP_TAC Oxl_2012.MOD_REFL;
  BY(ASM_MESON_TAC[sizel0])
  ]);;
  (* }}} *)

let indexf0 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ indexf x y s = 0 ==> (x = y)`,
  (* {{{ proof *)
  [
  SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC THEN FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl y s = indexl x s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[index_uniq]);
  FIRST_X_ASSUM MP_TAC;
  GMATCH_SIMP_TAC MOD_EQ_0;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[sizel0]);
  DISCH_TAC;
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`y`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `q = 1` ENOUGH_TO_SHOW_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `a = q* sizel s` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  REWRITE_TAC[arith `q = 1 <=> ~(q = 0) /\ (q < 2)`];
  SUBCONJ_TAC;
    DISCH_TAC;
    FIRST_X_ASSUM_ST `a = q* sizel s` MP_TAC;
    ASM_REWRITE_TAC[];
    BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `q * sizel s < 2 * sizel s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[LT_MULT_RCANCEL]);
  BY(REPEAT (FIRST_X_ASSUM MP_TAC) THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_antisym_wlog = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) /\ indexl x s < indexl y s 
    ==> indexf x y s + indexf y x s = sizel s`,
  (* {{{ proof *)
  [
  SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel s = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[sizel0]);
  INTRO_TAC Seq.index_mem [`y`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(indexl y s + sizel s - indexl x s) MOD sizel s = indexl y s - indexl x s /\ (indexl x s + sizel s - indexl y s) MOD sizel s = indexl x s + sizel s - indexl y s` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  CONJ2_TAC;
    MATCH_MP_TAC MOD_LT;
    BY(ASM_TAC THEN ARITH_TAC);
  TYPIFY_GOAL_THEN `indexl y s + sizel s - indexl x s = 1 * sizel s + (indexl y s - indexl x s)` (unlist REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  SIMP_TAC[MOD_MULT_ADD];
  MATCH_MP_TAC MOD_LT;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_antisym = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) 
    ==> indexf x y s + indexf y x s = sizel s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(indexl x s = indexl y s) \/ indexl x s < indexl y s \/ indexl y s < indexl x s` (C SUBGOAL_THEN MP_TAC);
    BY(ARITH_TAC);
  REPEAT STRIP_TAC;
      BY(ASM_MESON_TAC[index_uniq]);
    BY(ASM_MESON_TAC[indexf_antisym_wlog]);
  BY(ASM_MESON_TAC[indexf_antisym_wlog;arith `x + (y:num) = y + x`])
  ]);;
  (* }}} *)

let indexf_cond = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s ==>
    indexf x y s = if (indexl x s <= indexl y s) 
    then indexl y s - indexl x s 
    else indexl y s + (sizel s - indexl x s)`,
  (* {{{ proof *)
  [
  ASM_SIMP_TAC[indexf];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC;
    ASM_SIMP_TAC[arith `x <= y /\ x < n ==> (y + n -x = 1*n + (y - x))`];
    REWRITE_TAC[MOD_MULT_ADD];
    MATCH_MP_TAC MOD_LT;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC MOD_LT;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_left = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf x y s <= indexf x z s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_right = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf y z s <= indexf x z s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_sum = prove_by_refinement(
  `!(x:A) y z s. MEM x s /\ MEM y s /\ MEM z s /\
    indexf x y s + indexf y z s < sizel s ==>
    indexf x y s + indexf y z s = indexf x z s
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  INTRO_TAC Seq.index_mem [`z`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `indexf` MP_TAC;
  ASM_SIMP_TAC[indexf_cond];
  BY(REPEAT COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let sizel_gt_1 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ ~(x = y) ==>
    1 < sizel s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC LTE_TRANS;
  TYPIFY `CARD (set_of_list s)` EXISTS_TAC;
  REWRITE_TAC[CARD_SET_OF_LIST_LE;Seq.size];
  TYPIFY `FINITE (set_of_list s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(REWRITE_TAC[FINITE_SET_OF_LIST]);
  REWRITE_TAC[arith `1 < n <=> (1 <= n) /\ ~(n = 1)`];
  TYPIFY `x IN set_of_list s /\ y IN set_of_list s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_REWRITE_TAC[IN_SET_OF_LIST]);
  TYPIFY `~({x} = {y})` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN SET_TAC[]);
  CONJ_TAC THEN REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[Hypermap.CARD_ATLEAST_1]);
  BY(ASM_MESON_TAC[Hypermap.set_one_point])
  ]);;
  (* }}} *)

let indexf_rot = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s ==>
    indexf x y s = indexf x y (rot 1 s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`y`;`s`];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.mem_rot [`1`;`s`;`x`];
  INTRO_TAC Seq.mem_rot [`1`;`s`;`y`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[indexf_refl]);
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC sizel_gt_1;
    BY(ASM_MESON_TAC[]);
  ASM_SIMP_TAC[indexf_cond;];
  ASM_SIMP_TAC [Seq2.index_rot];
  REWRITE_TAC[Seq.size_rot];
  BY(REPEAT (COND_CASES_TAC THEN ASM_REWRITE_TAC[]) THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_rotn = prove_by_refinement(
  `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ n <= sizel s ==>
    indexf x y s = indexf x y (rot n s)`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    BY(REWRITE_TAC[Seq.rot0]);
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC Seq.rotS;
  CONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM (GMATCH_SIMP_TAC);
  ASM_REWRITE_TAC[];
  CONJ_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC indexf_rot;
  BY(ASM_REWRITE_TAC[Seq.mem_rot;Seq.rot_uniq])
  ]);;
  (* }}} *)

let indexf1 = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ indexf x y s = 1 ==>
    next_el s x = y`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. next_el (rot n s) x = y` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[Seq2.next_el_rot_eq]);
  INTRO_TAC Seq2.rot_to_index [`s`;`x`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl x s` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_rotn [`indexl x s`;`x`;`y`;`s`];
  ASM_SIMP_TAC[arith `i < (s:num) ==> i <= s`];
  TYPIFY `MEM x (x::t) /\ MEM y (x::t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.mem_rot]);
  ASM_SIMP_TAC[indexf_cond];
  REWRITE_TAC[Seq2.index_cons;arith `0 <= n`;arith `n - 0 = n`];
  COND_CASES_TAC THEN REWRITE_TAC[arith `~(1 = 0)`;arith `1 = SUC n <=> n = 0`];
  TYPIFY `MEM y t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[MEM]);
  DISCH_TAC;
  TYPIFY `y = HD t` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index0]);
  GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `sizel` MP_TAC THEN ASM_REWRITE_TAC[Seq.size_cons];
  INTRO_TAC sizel_gt_1 [`x`;`y`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `sizel s = sizel (x::t)` ENOUGH_TO_SHOW_TAC;
    BY(REWRITE_TAC[Seq.size_cons] THEN ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.size_rot])
  ]);;
  (* }}} *)

let next_el_indexf = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ next_el s x = y /\ 1 < sizel s ==>
    indexf x y s = 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `?n. n <= sizel s /\ indexf x y (rot n s) =1` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    BY(ASM_MESON_TAC[indexf_rotn]);
  INTRO_TAC Seq2.rot_to_index [`s`;`x`];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `indexl x s` EXISTS_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_SIMP_TAC[arith `i < (s:num) ==> i <= s`] THEN REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq2.next_el_rot_eq [`s`;`indexl x s`];
  ASM_REWRITE_TAC[FUN_EQ_THM] THEN DISCH_THEN (C INTRO_TAC [`x`]);
  DISCH_TAC;
  TYPIFY `MEM x (x::t) /\ MEM y (x::t)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.mem_rot]);
  ASM_SIMP_TAC[indexf_cond];
  REWRITE_TAC[Seq2.index_cons;arith `0 <= n`;arith `n - 0 = n`];
  INTRO_TAC Seq2.next_el_hd_cons [`x`;`t`];
  TYPIFY `0 < sizel t` (C SUBGOAL_THEN ASSUME_TAC);
    TYPIFY `sizel s = sizel (x::t)` ENOUGH_TO_SHOW_TAC;
      BY(REWRITE_TAC[Seq.size_cons] THEN ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[Seq.size_rot]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  TYPIFY `uniq (x:: t)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[Seq.rot_uniq]);
  COND_CASES_TAC THEN REWRITE_TAC[arith `~(1 = 0)`;arith `SUC n = 1 <=> n = 0`];
    REWRITE_TAC[Seq.cons_uniq];
    REWRITE_TAC[Seq.cons_uniq;DE_MORGAN_THM];
    DISJ1_TAC;
    ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[MEM_HD;Seq.size_eq0;arith `0 < s ==> ~(s = 0)`]);
  (DISCH_TAC);
  TYPIFY `headl y t = HD t` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq2.index_head]);
  MATCH_MP_TAC Seq2.head_HD;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let next_eln_indexf = prove_by_refinement(
  `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ 
    (next_el s POWER n) x = y /\ n < sizel s ==>
    indexf x y s = n`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    REWRITE_TAC[Hypermap.POWER;I_THM];
    BY(MESON_TAC[indexf_refl]);
  REPEAT WEAKER_STRIP_TAC;
  TYPED_ABBREV_TAC `yn = (next_el s POWER n) x`;
  FIRST_X_ASSUM (C INTRO_TAC [`x`;`yn`;`s`]);
  ASM_SIMP_TAC[arith `SUC n < s ==> n < s`];
  TYPIFY `MEM yn s` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "yn";
    FIRST_X_ASSUM kill;
    ASM_SIMP_TAC[Seq2.next_el_power];
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_MESON_TAC[DIVISION;arith `n < (s:num) ==> ~(s = 0)`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC indexf_add_sum [`x`;`yn`;`y`;`s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (GMATCH_SIMP_TAC o GSYM);
  TYPIFY `indexf yn y s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC next_el_indexf;
  ASM_SIMP_TAC[arith `SUC n < s ==> 1 < s`];
  CONJ2_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  FULL_EXPAND_TAC "y";
  FULL_EXPAND_TAC "yn";
  BY(REWRITE_TAC[Hypermap.COM_POWER;o_THM])
  ]);;
  (* }}} *)

let indexf_n = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s ==>
    ((next_el s) POWER (indexf x y s)) x = y`,
  (* {{{ proof *)
  [
  TYPIFY `!n (x:A) y s. MEM x s /\ MEM y s /\ uniq s /\ (indexf x y s = n) ==>    ((next_el s) POWER n) x = y` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INDUCT_TAC;
    REPEAT WEAKER_STRIP_TAC;
    TYPIFY `x = y` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[indexf0]);
    BY(ASM_REWRITE_TAC[Fan.POWER;I_THM]);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.index_mem [`x`;`s`];
  ASM_REWRITE_TAC[] THEN DISCH_TAC;
  TYPED_ABBREV_TAC `yn = (next_el s POWER n) x`;
  TYPIFY `MEM yn s` (C SUBGOAL_THEN ASSUME_TAC);
    EXPAND_TAC "yn";
    FIRST_X_ASSUM kill;
    ASM_SIMP_TAC[Seq2.next_el_power];
    MATCH_MP_TAC Seq.mem_nth;
    BY(ASM_MESON_TAC[DIVISION;arith `n < (s:num) ==> ~(s = 0)`]);
  INTRO_TAC indexf_lt_sizel [`s`;`x`;`yn`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC indexf_lt_sizel [`s`;`x`;`y`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC next_eln_indexf [`n`;`x`;`yn`;`s`];
  ASM_SIMP_TAC[arith `SUC n < s ==> n < s`];
  DISCH_TAC;
  INTRO_TAC indexf_add_left [`x`;`yn`;`y`;`s`];
  ANTS_TAC;
    ASM_REWRITE_TAC[];
    BY(ARITH_TAC);
  ASM_REWRITE_TAC[arith `n + i = SUC n <=> i = 1`];
  DISCH_TAC;
  INTRO_TAC indexf1 [`yn`;`y`;`s`];
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Hypermap.COM_POWER;o_THM])
  ]);;
  (* }}} *)

let nextElem_nonmem = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem s u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)


let nextElem_nonmem_rcons = prove_by_refinement(
  `!s x u. ~(MEM x s) ==> nextElem (rcons s a) u x = u`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_MESON_TAC[]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rcons = prove_by_refinement(
  `!s h x u. MEM x s ==> (nextElem s h x = nextElem (rcons s h) u x)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN SIMP_TAC[nextElem;MEM;Seq.rcons;rcons_nonnil];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~MEM x t` ASM_CASES_TAC;
    TYPIFY `x = h` (C SUBGOAL_THEN MP_TAC);
      BY(ASM_MESON_TAC[]);
    SIMP_TAC[];
    COND_CASES_TAC THEN REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[HD;Seq.rcons];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0]);
  RULE_ASSUM_TAC (REWRITE_RULE[]);
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    ONCE_REWRITE_TAC[Seq.headI];
    REWRITE_TAC[HD];
    GMATCH_SIMP_TAC Seq2.head_HD;
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`];
    BY(ASM_MESON_TAC[Seq.size_eq0;MEM]);
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let nextElem_rot = prove_by_refinement(
  `!s x. MEM x s /\ ~(x = HD s) ==> nextElem s (HD s) x = nextElem (rot 1 s) (HD (rot 1 s)) x `,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[nextElem;Seq.head;MEM;Seq.rot1_cons] THEN GEN_TAC;
  REWRITE_TAC[HD];
  DISCH_TAC;
  TYPIFY `MEM x t /\ ~(x = h)` (C SUBGOAL_THEN MP_TAC);
    BY(ASM_MESON_TAC[]);
  FIRST_X_ASSUM kill THEN DISCH_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[nextElem_rcons])
  ]);;
  (* }}} *)


let index_nextElem_next_el = prove_by_refinement(
  `!n s x. MEM x s /\ indexl x s = n ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
  INDUCT_TAC;
    LIST_INDUCT_TAC;
      BY(REWRITE_TAC[MEM]);
    REWRITE_TAC[HD;nextElem];
    REPEAT WEAKER_STRIP_TAC;
    INTRO_TAC index0 [`h::t`;`x`];
    ASM_REWRITE_TAC[HD];
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    COND_CASES_TAC;
      BY(ASM_REWRITE_TAC[next_el1]);
    GMATCH_SIMP_TAC Seq2.next_el_hd_cons;
    BY(ASM_MESON_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0]);
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC nextElem_rot;
  ASM_REWRITE_TAC[];
  SUBCONJ_TAC;
    DISCH_TAC;
    INTRO_TAC Seq2.head_HD [`x`;`s`];
    REWRITE_TAC[arith `0 < s <=> ~(s = 0)`;Seq.size_eq0];
    BY(ASM_MESON_TAC[MEM;arith `~(0=SUC n)`;Seq2.index_head]);
  DISCH_TAC;
  GMATCH_SIMP_TAC Seq2.next_el_alt;
  TYPIFY `x` EXISTS_TAC;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`rot 1 s`;`x`]);
  TYPIFY `MEM x (rot 1 s) /\ indexl x (rot 1 s) = n` (C SUBGOAL_THEN ASSUME_TAC);
    ASM_REWRITE_TAC[Seq.mem_rot];
    MATCH_MP_TAC (arith `SUC u = SUC v ==> u = v`);
    GMATCH_SIMP_TAC index_rot;
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC THEN ASM_REWRITE_TAC[];
  INTRO_TAC Seq2.next_el_mod [`x`];
  DISCH_THEN GMATCH_SIMP_TAC;
  ASM_REWRITE_TAC[];
  REPEAT (AP_TERM_TAC ORELSE AP_THM_TAC);
  REWRITE_TAC[arith `n+1 = SUC n`] THEN MATCH_MP_TAC MOD_LT;
  BY(ASM_MESON_TAC[Seq.index_mem;Seq.size_rot])
  ]);;
  (* }}} *)

let nextElem_next_el = prove_by_refinement(
  `!s x. MEM x s ==> nextElem s (HD s) x = next_el s x`,
  (* {{{ proof *)
  [
BY(MESON_TAC[index_nextElem_next_el])
  ]);;
  (* }}} *)

let nextVertex_next_el = prove_by_refinement(
  `!f x. MEM x (FST f) ==> nextVertex f x = next_el (FST f) x`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextVertex;FORALL_PAIR_THM];
  BY(SIMP_TAC[nextElem_next_el])
  ]);;
  (* }}} *)

let fgraph_makeFaceFinal = prove_by_refinement(
  `!f g. fgraph (makeFaceFinal f g) = fgraph g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[fgraph;makeFaceFinal;faces_graph;makeFaceFinalFaceList];
  BY(REWRITE_TAC[FST_setFinal])
  ]);;
  (* }}} *)

(*
let vertices_set2_makeFaceFinal = prove_by_refinement(
  `!f g. vertices_set2 (makeFaceFinal f' g) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;makeFaceFinal;(*bn_*)vertices_graph];
  BY(REWRITE_TAC[vertices_graph])
  ]);;
  (* }}} *)
*)

let vertices_set2_makeFaceFinal = prove_by_refinement(
  `!f g. vertices_set2 (makeFaceFinal f' g) = vertices_set2 g`,
  (* {{{ proof *)
  [
  REWRITE_TAC[vertices_set2;makeFaceFinal;(*bn_*)vertices_graph];
  BY(REWRITE_TAC[countVertices])
  ]);;
  (* }}} *)


let set_of_list_flatten_APPEND = prove_by_refinement(
  `!a b. set_of_list (flatten (APPEND a b)) = 
    set_of_list (flatten a) UNION set_of_list (flatten b)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[List_hypermap.set_of_list_flatten_map];
  REWRITE_TAC[upper_case;SET_OF_LIST_APPEND;MAP_APPEND];
  BY(SET_TAC[])
  ]);;
  (* }}} *)

let split_at_mem_fst = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (FST(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* replace with snd_split_at_acc.
let split_at_snd_acc = prove_by_refinement(
  `!f (u:A) v b. MEM v (SND (split_at_rec u [] f)) <=>
    MEM v (SND (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let snd_split_at_acc = prove_by_refinement(
  `!f (u:A) b.  (SND (split_at_rec u b f)) =
     (SND (split_at_rec u [] f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(*
let split_at_mem_snd = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (SND(split_at_rec u b f))) ==> MEM v f \/ MEM v b`,
  (* {{{ proof *)
  [
  REWRITE_TAC[split_at];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  REWRITE_TAC[MEM_APPEND];
  REWRITE_TAC[MEM];
  ASM_REWRITE_TAC[] THEN REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM v b` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM v t` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)
*)

let split_at_mem_snd = prove_by_refinement(
  `!f (u:A) v b. 
    (MEM v (SND(split_at_rec u b f))) ==> MEM v f`,
  (* {{{ proof *)
  [
  ONCE_REWRITE_TAC[snd_split_at_acc];
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[SND;MEM];
    BY(MESON_TAC[]);
  BY(ASM_MESON_TAC[snd_split_at_acc])
  ]);;
  (* }}} *)

(* was SPLIT_AT_ACC *)

let split_at_acc_fst = prove_by_refinement(
  `!f (u:A) v b. MEM v b ==>
    (MEM v (FST (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM];
  FIRST_X_ASSUM MATCH_MP_TAC;
  BY(ASM_REWRITE_TAC[MEM_APPEND])
  ]);;
  (* }}} *)

let split_at_both = prove_by_refinement(
  `!f (u:A) v b.  
    (MEM v f) /\ (v = u ==> MEM v b) ==>
    (MEM v (FST (split_at_rec u b f)) \/ MEM v (SND (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  COND_CASES_TAC;
    ASM_REWRITE_TAC[FST;MEM];
    BY(MESON_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `v = h` ASM_CASES_TAC;
    DISJ1_TAC;
    MATCH_MP_TAC split_at_acc_fst;
    BY(ASM_REWRITE_TAC[MEM_APPEND;MEM]);
  FIRST_X_ASSUM MATCH_MP_TAC;
  ASM_REWRITE_TAC[MEM_APPEND;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

(* replaced with fst_split_at_acc.
let split_at_fst_acc = prove_by_refinement(
  `!f (u:A) v b. MEM v (FST (split_at_rec u [] f)) \/ MEM v b <=>
    MEM v (FST (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM];
  FIRST_X_ASSUM_ST `MEM` (unlist ONCE_REWRITE_TAC o GSYM);
  REWRITE_TAC[MEM;MEM_APPEND];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)
*)

let fst_split_at_acc = prove_by_refinement(
  `!f (u:A) b. APPEND b (FST (split_at_rec u [] f)) = 
     (FST (split_at_rec u b f))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;APPEND_NIL];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[MEM;APPEND_NIL];
  FIRST_X_ASSUM_ST `APPEND` (unlist ONCE_REWRITE_TAC o GSYM);
  BY(MESON_TAC[APPEND_ASSOC])
  ]);;
  (* }}} *)

let split_at_fst_antirefl = prove_by_refinement(
  `!f (u:A) b. MEM u (FST (split_at_rec u b f)) ==> MEM u b`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_MESON_TAC[fst_split_at_acc;MEM_APPEND;MEM])
  ]);;
  (* }}} *)

let split_at_snd_antirefl = prove_by_refinement(
  `!f (u:A) b. uniq f ==> ~(MEM u (SND (split_at_rec u b f)))`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  TYPIFY `h = u` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(MESON_TAC[Seq.cons_uniq]);
  BY(ASM_MESON_TAC[Seq.cons_uniq])
  ]);;
  (* }}} *)

let split_at_fst_antisym = prove_by_refinement(
  `!f (u:A) v b. MEM v (FST (split_at_rec u b f)) /\ 
    MEM u (FST (split_at_rec v b f)) ==>
     (MEM u b \/ MEM v b)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
    REPEAT GEN_TAC;
    BY(MESON_TAC[]);
  REPEAT GEN_TAC;
  REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM];
        BY(MESON_TAC[]);
      BY(MESON_TAC[]);
    BY(MESON_TAC[]);
  FIRST_X_ASSUM (C INTRO_TAC [`u`;`v`;`APPEND b [h]`]);
  BY(ASM_REWRITE_TAC[MEM_APPEND;MEM])  
  ]);;
  (* }}} *)

let split_at_snd_antisym = prove_by_refinement(
  `!f (u:A) v b. uniq f /\ MEM v (SND (split_at_rec u b f)) /\ 
    MEM u (SND (split_at_rec v b f)) ==> F`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND];
  REPEAT GEN_TAC;
  BY(REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[FST;MEM;Seq.cons_uniq] THEN REPEAT WEAKER_STRIP_TAC THEN ASM_MESON_TAC[split_at_mem_snd;snd_split_at_acc])
  ]);;
  (* }}} *)

let snd_split_at_hd = prove_by_refinement(
  `!f (u:A) v b. ~(f=[]) ==> SND(split_at_rec (HD f) b f) = TL f`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL])
  ]);;
  (* }}} *)

let fst_split_at_hd = prove_by_refinement(
  `!f (u:A) v b.  FST(split_at_rec (HD f) b f) = b`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL])
  ]);;
  (* }}} *)

let fst_split_at_take = prove_by_refinement(
  `!f (u:A) b. 
     FST(split_at_rec u b f) = APPEND b (take (indexl u f) f)`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL;Seq.take;APPEND_NIL]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_head;Seq.take0;APPEND_NIL];
  ASM_SIMP_TAC[GSYM APPEND_ASSOC];
  AP_TERM_TAC;
  ASM_REWRITE_TAC[Seq2.index_cons;];
  ASM_REWRITE_TAC[Seq.take_cons];
  BY(ASM_REWRITE_TAC[Seq.take_cons;APPEND_SING])
  ]);;
  (* }}} *)

let snd_split_at_drop = prove_by_refinement(
  `!f (u:A) b.
    SND(split_at_rec u b f) = (dropl (SUC(indexl u f)) f)`,
  (* {{{ proof *)
  [
  (LIST_INDUCT_TAC THEN REWRITE_TAC[split_at_rec;MEM;APPEND;HD;TL;Seq.drop;APPEND_NIL]);
  REPEAT WEAKER_STRIP_TAC;
  COND_CASES_TAC THEN ASM_REWRITE_TAC[Seq.index_head;Seq.drop0;APPEND_NIL];
  ASM_REWRITE_TAC[Seq2.index_cons;];
  ]);;
  (* }}} *)

let split_at_take_drop = prove_by_refinement(
  `!f (u:A) b.
    split_at_rec u b f = (APPEND b (take (indexl u f) f)),dropl (SUC(indexl u f)) f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[fst_split_at_take;snd_split_at_drop;PAIR_EQ2])
  ]);;
  (* }}} *)

let split_at_nil_take_drop = prove_by_refinement(
  `!f (u:A).
    split_at_rec u [] f = take (indexl u f) f,dropl (SUC(indexl u f)) f`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[split_at_take_drop;APPEND])
  ]);;
  (* }}} *)


(* was BETWN_MEM *)

let betwn_mem = prove_by_refinement(
  `!f (u:A) v w. MEM w (betwn f u v) ==>
     MEM w f`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn;split_at;split_at_rec];
  REPEAT GEN_TAC;
  REPEAT (LET_TAC);
  ASM_REWRITE_TAC[IN_SET_OF_LIST];
  TYPIFY `MEM w post1 \/ MEM w pre2 \/ MEM w pre2' ==> MEM w f` ENOUGH_TO_SHOW_TAC;
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    FIRST_X_ASSUM MP_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC[MEM_APPEND];
    BY(MESON_TAC[]);
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN ASM_REWRITE_TAC[];
  BY(MESON_TAC[split_at_mem_snd;split_at_mem_fst;MEM])
  ]);;
  (* }}} *)

let mem_drop_index = prove_by_refinement(
  `!k (v:A) s. uniq s /\ MEM v s ==>
    (MEM v (dropl k s) <=> k <= indexl v s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT STRIP_TAC;
    ONCE_REWRITE_TAC[arith `k <= i <=> ~(i < k:num)`];
    DISCH_TAC;
    INTRO_TAC Seq.cat_take_drop [`k`;`s`];
    DISCH_TAC;
    INTRO_TAC Seq2.mem_imp_not_uniq_cat [`v`;`take k s`;`dropl k s`];
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      REWRITE_TAC[GSYM Seq.index_mem;Seq2.index_take];
      ASM_REWRITE_TAC[];
      GMATCH_SIMP_TAC Seq.size_takel;
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC (arith `~(s <= k:num) ==> (k <= s)`);
      DISCH_THEN (MP_TAC o MATCH_MP Seq.drop_oversize);
      BY(ASM_MESON_TAC[MEM]);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  DISCH_TAC;
  INTRO_TAC Seq.index_cat [`v`;`take k s`;`dropl k s`];
  COND_CASES_TAC;
    FIRST_X_ASSUM_ST `MEM` MP_TAC THEN REWRITE_TAC[GSYM Seq.index_mem];
    GMATCH_SIMP_TAC Seq.size_takel;
    SUBCONJ_TAC;
      MATCH_MP_TAC LE_TRANS;
      TYPIFY `indexl v s` EXISTS_TAC;
      ASM_REWRITE_TAC[];
      BY(REWRITE_TAC[Seq.index_size]);
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM_ST `x < k:num` MP_TAC THEN REWRITE_TAC[Seq2.index_take];
    COND_CASES_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ARITH_TAC);
  BY(ASM_MESON_TAC[Seq.mem_cat])
  ]);;
  (* }}} *)

let size_take_le = prove_by_refinement(
  `!k (v:A) s. sizel (take k s) <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_take];
  BY(REPEAT WEAKER_STRIP_TAC THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let size_drop_le = prove_by_refinement(
  `!k (v:A) s. sizel (dropl k s) <= sizel s`,
  (* {{{ proof *)
  [
  REWRITE_TAC[Seq.size_drop];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let mem_take_index = prove_by_refinement(
  `!k (v:A) s. uniq s /\ 
    MEM v s ==>
    (MEM v (take k s) <=>  indexl v s < k)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  REPEAT STRIP_TAC;
    ONCE_REWRITE_TAC[arith `k < i <=> ~(i <= k:num)`];
    DISCH_TAC;
    INTRO_TAC Seq.cat_take_drop [`k`;`s`];
    DISCH_TAC;
    INTRO_TAC Seq2.mem_imp_not_uniq_cat [`v`;`take k s`;`dropl k s`];
    ANTS_TAC;
      ASM_REWRITE_TAC[];
      BY(ASM_MESON_TAC[mem_drop_index]);
    BY(ASM_MESON_TAC[]);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  DISCH_TAC;
  INTRO_TAC Seq.index_cat [`v`;`take k s`;`dropl k s`];
  TYPIFY `sizel s <= k` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[Seq.take_oversize]);
  COND_CASES_TAC;
    BY(FIRST_X_ASSUM_ST `MEM` MP_TAC THEN REWRITE_TAC[GSYM Seq.index_mem]);
  ASM_REWRITE_TAC[];
  GMATCH_SIMP_TAC Seq.size_takel;
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let take_take = prove_by_refinement(
  `!i j s. i <= j ==> take i (take j s) = take i s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s <= j` ASM_CASES_TAC;
    BY(ASM_SIMP_TAC[Seq.take_oversize]);
  INTRO_TAC Seq.cat_take_drop [`j`;`s`];
  TYPIFY `i <= sizel (take j s)` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Seq.takel_cat]);
  REWRITE_TAC[Seq.size_take];
  BY(COND_CASES_TAC THEN ASM_TAC THEN TRY ARITH_TAC)
  ]);;
  (* }}} *)

let drop_drop = prove_by_refinement(
  `!(s:A list) j i. dropl i (dropl j s) = dropl (i+j) s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN REWRITE_TAC[Seq.drop];
  BY(INDUCT_TAC THEN ASM_REWRITE_TAC[Seq.drop;arith `i+0 = i`;arith `i + SUC j = SUC (i+j)`])
  ]);;
  (* }}} *)

let betwn_take_drop = prove_by_refinement(
  `!f (u:A) (v:A).  MEM v f /\ uniq f ==> betwn f u v = 
      if (indexl u f < indexl v f) 
      then take (PRE(indexl v f - indexl u f)) (dropl (SUC (indexl u f)) f)
      else APPEND (dropl (SUC (indexl u f)) f) (take (indexl v f) f)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[betwn;split_at_nil_take_drop;split_at;IN_SET_OF_LIST];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT LET_TAC;
  RULE_ASSUM_TAC(REWRITE_RULE[PAIR_EQ2]);
  RULE_ASSUM_TAC(ONCE_REWRITE_RULE[EQ_SYM_EQ]) THEN ASM_REWRITE_TAC[];
  REPLICATE_TAC 3 (FIRST_X_ASSUM kill);
  ASM_SIMP_TAC[mem_drop_index];
  REWRITE_TAC[arith `SUC n <= i <=> n < i`];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL [ALL_TAC;AP_TERM_TAC];
    TYPIFY `(indexl v (dropl (SUC (indexl u f)) f)) = (PRE (indexl v f - indexl u f))` ENOUGH_TO_SHOW_TAC;
      BY(DISCH_THEN (unlist REWRITE_TAC));
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    CONJ_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  GMATCH_SIMP_TAC take_take;
  TYPIFY `indexl v (take (indexl u f) f) = indexl v f` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist ASM_REWRITE_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq2.index_take];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let drop_take_commute = prove_by_refinement(
  `!(s:A list) k n. k <= n ==> dropl k (take n s) = take (n-k) (dropl k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `sizel s <= k` ASM_CASES_TAC;
    REPEAT (GMATCH_SIMP_TAC Seq.drop_oversize);
    ASM_REWRITE_TAC[Seq.take];
    MATCH_MP_TAC LE_TRANS;
    TYPIFY `sizel s` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    BY(REWRITE_TAC[Seq.size_take] THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  TYPIFY `take n s = take n (cat (take k s) (dropl k s))` (C SUBGOAL_THEN SUBST1_TAC);
    BY(MESON_TAC[ Seq.cat_take_drop]);
  REWRITE_TAC[Seq.take_cat];
  COND_CASES_TAC;
    FIRST_X_ASSUM MP_TAC THEN REWRITE_TAC[Seq.size_take];
    BY(COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[Seq.drop_cat];
  TYPIFY_GOAL_THEN `sizel (take k s) = k` (unlist REWRITE_TAC);
    BY(REWRITE_TAC[Seq.size_take] THEN COND_CASES_TAC THEN ASM_TAC THEN ARITH_TAC);
  BY(REWRITE_TAC[arith `~(k<k:num)`;arith `(k:num) - k = 0`;Seq.drop0])
  ]);;
  (* }}} *)

let take_drop_commute = prove_by_refinement(
  `!(s:A list) k n. take n (dropl k s) = dropl k (take (n+k) s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  GMATCH_SIMP_TAC drop_take_commute;
  BY(REWRITE_TAC[arith `(n + k) - (k:num) = n`;arith `(k:num) <= n+ k`])
  ]);;
  (* }}} *)

(*
let betwn_hd = prove_by_refinement(
  `!f (u:A) v x. MEM u f /\ MEM v f /\ ~(u = v) ==>
    betwn f u v = if (u = HD f) then take (indexl v f - 1) (TL f) else 
      betwn (rot 1 f) u v`,
  (* {{{ proof *)
  [
  st/r
  rt[betwn]
  repeat (LET_TAC)
  rule(rr[PAIR_EQ2])
  rule(orr[EQ_SYM_EQ])
  art[] then rep 6 (fxa kill)
  rt[IN_SET_OF_LIST]
  repeat condcse then art[]
  ...
  ]);;
  (* }}} *)
*)

let size_betwn = prove_by_refinement(
  `!x:A y s. uniq s /\ MEM x s /\  MEM y s /\ ~(x= y) ==>
    sizel (betwn s x y ) = PRE (indexf x y s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    GMATCH_SIMP_TAC Seq.size_takel;
    REWRITE_TAC[Seq.size_drop];
    REWRITE_TAC[arith `n - SUC u = PRE (n - u)`];
    CONJ_TAC;
      MATCH_MP_TAC (arith `n <= m ==> PRE n <= PRE m`);
      INTRO_TAC Seq.index_size [`y`;`s`];
      BY(ASM_TAC THEN ARITH_TAC);
    MATCH_MP_TAC (arith `n = m ==> PRE n = PRE m`);
    GMATCH_SIMP_TAC indexf_cond;
    BY(ASM_SIMP_TAC[arith `x < y ==> x <= (y:num)`]);
  REWRITE_TAC[lower_case];
  REWRITE_TAC[Seq.size_cat];
  GMATCH_SIMP_TAC Seq.size_takel;
  REWRITE_TAC[Seq.size_drop];
  SUBCONJ_TAC;
    BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.index_mem] THEN ARITH_TAC);
  DISCH_TAC;
  TYPIFY `~(indexl x s = indexl y s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  ASM_SIMP_TAC[indexf_cond];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_TAC THEN REWRITE_TAC[GSYM Seq.index_mem] THEN ARITH_TAC)
  ]);;
  (* }}} *)

let uniq_drop = prove_by_refinement(
  `!k v:A s. uniq s ==> uniq (dropl k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let uniq_take = prove_by_refinement(
  `!k v:A s. uniq s ==> uniq (take k s)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.cat_uniq])
  ]);;
  (* }}} *)

let not_betwn1 = prove_by_refinement(
  `!x:A z s. uniq s /\ MEM z s ==> ~(MEM x (betwn s x z))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  STRIP_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ARITH_TAC);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  FIRST_X_ASSUM_ST `take` MP_TAC;
  BY(ASM_SIMP_TAC[mem_take_index])
  ]);;
  (* }}} *)

let not_betwn2 = prove_by_refinement(
  `!x:A z s. uniq s ==> ~(MEM z (betwn s x z))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM z s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[betwn_mem]);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC;
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `take` MP_TAC;
    REWRITE_TAC[take_drop_commute];
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  STRIP_TAC;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `take` MP_TAC;
  (ASM_SIMP_TAC[mem_take_index]);
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let indexl_betwn = prove_by_refinement(
  `!x:A y z s. uniq s /\ MEM x s /\ MEM z s /\ MEM y (betwn s x z) ==>
    SUC (indexl y (betwn s x z)) = indexf x y s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(x = y)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_betwn1]);
  REPEAT (FIRST_X_ASSUM_ST `MEM` MP_TAC) THEN REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[Seq2.index_take];
    DISCH_TAC;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    FIRST_X_ASSUM_ST `take` MP_TAC;
    GMATCH_SIMP_TAC mem_take_index;
    ASM_SIMP_TAC[uniq_drop];
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    GMATCH_SIMP_TAC mem_drop_index;
    ASM_REWRITE_TAC[];
    REPEAT STRIP_TAC;
      BY(ASM_TAC THEN ARITH_TAC);
    GMATCH_SIMP_TAC indexf_cond;
    ASM_SIMP_TAC[arith `SUC i <= j ==> i <= j`];
    BY(ASM_TAC THEN ARITH_TAC);
  REWRITE_TAC[MEM_APPEND];
  COMMENT "cases";
  DISCH_TAC;
  TYPIFY `MEM y (dropl (SUC (indexl x s)) s)` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `take` kill;
    FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_drop);
    REWRITE_TAC[Seq2.APPEND_cat];
    REWRITE_TAC[Seq.index_cat];
    ASM_REWRITE_TAC[];
    GMATCH_SIMP_TAC Seq2.index_drop_le;
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    GMATCH_SIMP_TAC mem_drop_index;
    ASM_REWRITE_TAC[];
    SIMP_TAC[];
    DISCH_TAC;
    GMATCH_SIMP_TAC indexf_cond;
    ASM_SIMP_TAC[arith `SUC i <= j ==> i <= j`];
    BY(ASM_TAC THEN ARITH_TAC);
  FIRST_X_ASSUM_ST `take` MP_TAC THEN ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  REWRITE_TAC[Seq2.APPEND_cat];
  ASM_REWRITE_TAC[Seq.index_cat];
  REWRITE_TAC[ Seq.size_drop];
  REWRITE_TAC[Seq2.index_take];
  FIRST_X_ASSUM_ST `take` MP_TAC;
  GMATCH_SIMP_TAC mem_take_index;
  ASM_REWRITE_TAC[];
  SIMP_TAC[];
  DISCH_TAC;
  GMATCH_SIMP_TAC indexf_cond;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `dropl` MP_TAC;
  GMATCH_SIMP_TAC mem_drop_index;
  ASM_SIMP_TAC[];
  DISCH_TAC THEN COND_CASES_TAC;
    TYPIFY `indexl x s = indexl y s` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_TAC THEN ARITH_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  TYPIFY `indexl x s < sizel s` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  BY(ASM_REWRITE_TAC[Seq.index_mem])
  ]);;
  (* }}} *)

let indexf_betwn = prove_by_refinement(
  `!s x:A y z. ~(x = z) /\ uniq s /\ MEM x s /\
     MEM z s /\ MEM y (betwn s x z) ==>
    0 < indexf x y s /\ indexf x y s < indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexl_betwn [`x`;`y`;`z`;`s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (SUBST1_TAC o GSYM);
  CONJ_TAC;
    BY(ARITH_TAC);
  MATCH_MP_TAC (arith (`u < PRE i ==> SUC u < i`));
  GMATCH_SIMP_TAC (GSYM size_betwn);
  ASM_REWRITE_TAC[];
  BY(ASM_REWRITE_TAC[Seq.index_mem])
  ]);;
  (* }}} *)

let not_take_drop = prove_by_refinement(
  `!s x:A k. uniq s ==>  ~(MEM x (take k s) /\ MEM x (dropl k s))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq.mem_take);
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq2.mem_imp_not_uniq_cat])
  ]);;
  (* }}} *)

let take_or_drop = prove_by_refinement(
  `!s x:A k. uniq s /\ MEM x s ==>  (MEM x (take k s) \/ MEM x (dropl k s))`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Seq.cat_take_drop [`k`;`s`];
  BY(ASM_MESON_TAC[Seq.mem_cat])
  ]);;
  (* }}} *)

let betwn_cases = prove_by_refinement(
  `!s x:A y z. ~(x = z) /\ uniq s /\ 
    MEM x s /\ MEM y s /\ MEM z s ==>
      (y = x) \/ (y = z) \/ (MEM y (betwn s x z)) \/ MEM y (betwn s z x)`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `(y = x)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `(y = z)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `MEM y (betwn s x z)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
  TYPIFY `~(indexl x s =indexl z s) /\ ~(indexl x s = indexl y s) /\ ~(indexl y s = indexl z s)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[index_uniq]);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  ASM_SIMP_TAC[betwn_take_drop];
  COND_CASES_TAC THEN ASM_SIMP_TAC[arith `x < z:num ==> ~(z < x:num)`;arith `~(x < z:num) /\ ~(x = z) ==> (z < x)`;Seq2.APPEND_cat;Seq.mem_cat];
    DISCH_TAC;
    TYPIFY `MEM y (take (indexl x s) s)` ASM_CASES_TAC THEN ASM_REWRITE_TAC[];
    FIRST_X_ASSUM_ST `PRE` MP_TAC;
    REWRITE_TAC[ take_drop_commute];
    ASM_SIMP_TAC[arith `x < z:num ==> (PRE( z - x) + SUC x = z)`];
    FIRST_X_ASSUM MP_TAC;
    TYPIFY `MEM y (take(indexl z s) s)` ASM_CASES_TAC;
      ASM_SIMP_TAC[mem_take_index];
      ASM_SIMP_TAC[uniq_take;mem_drop_index];
      REWRITE_TAC[Seq2.index_take];
      TYPIFY `indexl y s < indexl z s` (C SUBGOAL_THEN ASSUME_TAC);
        BY(ASM_MESON_TAC[mem_take_index]);
      ASM_REWRITE_TAC[];
      BY(ASM_TAC THEN ARITH_TAC);
    REPLICATE_TAC 2 (DISCH_THEN kill);
    FIRST_X_ASSUM MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    ASM_SIMP_TAC[uniq_take;mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  COMMENT "last case";
  REWRITE_TAC[DE_MORGAN_THM];
  REWRITE_TAC[ take_drop_commute];
  TYPIFY `indexl z s < indexl x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  ASM_SIMP_TAC[arith `x < z:num ==> (PRE( z - x) + SUC x = z)`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y (take(indexl x s) s)` (C SUBGOAL_THEN ASSUME_TAC);
    FIRST_X_ASSUM_ST `dropl` MP_TAC;
    ASM_SIMP_TAC[mem_take_index];
    ASM_SIMP_TAC[uniq_take;mem_drop_index];
    BY(ASM_TAC THEN ARITH_TAC);
  REPLICATE_TAC 2 (FIRST_X_ASSUM_ST `( ~)` MP_TAC);
  ASM_SIMP_TAC[mem_take_index];
  ASM_SIMP_TAC[uniq_take;mem_drop_index];
  REWRITE_TAC[Seq2.index_take];
  REPEAT WEAKER_STRIP_TAC;
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_betwn_eq = prove_by_refinement(
  `!s x:A y z.
    ~(x = z) /\ uniq s /\ MEM x s /\ MEM z s ==>
    (MEM y (betwn s x z) <=>
    0 < indexf x y s /\ indexf x y s < indexf x z s
    )`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  REWRITE_TAC[Geomdetail.EQ_EXPAND];
  CONJ_TAC;
    DISCH_TAC;
    MATCH_MP_TAC indexf_betwn;
    BY(ASM_REWRITE_TAC[]);
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MEM y s` (C SUBGOAL_THEN ASSUME_TAC);
    PROOF_BY_CONTR_TAC;
    FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP indexf2);
    BY(ASM_MESON_TAC[indexf_lt_sizel;arith `~(a < b:num /\ b < a)`]);
  INTRO_TAC betwn_cases [`s`;`x`;`y`;`z`];
  ASM_REWRITE_TAC[];
  TYPIFY `y = x` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[indexf_refl;arith `~(x < x:num)`]);
  TYPIFY `y = z` ASM_CASES_TAC;
    BY(ASM_MESON_TAC[arith `~(x < x:num)`]);
  TYPIFY `~(MEM y (betwn s z x))` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  INTRO_TAC indexf_betwn [`s`;`z`;`y`;`x`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC indexf_add_left [`z`;`y`;`x`;`s`];
  ASM_SIMP_TAC[arith `x < (y:num) ==> x <= y`];
  DISCH_TAC;
  TYPIFY `indexf y x s <= indexf z x s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC indexf_antisym [`y`;`x`;`s`];
  INTRO_TAC indexf_antisym [`z`;`x`;`s`];
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let indexf_add_betwn = prove_by_refinement(
  `!x y z s. ~(x = z) /\ uniq s /\ MEM x s /\ MEM y (betwn s x z) /\ MEM z s ==>
   indexf x y s + indexf y z s = indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC indexf_add_left;
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP betwn_mem);
  ASM_REWRITE_TAC[];
  MATCH_MP_TAC (arith `x < y:num ==> x <= y`);
  FIRST_X_ASSUM_ST `betwn` MP_TAC;
  GMATCH_SIMP_TAC indexf_betwn_eq;
  ASM_REWRITE_TAC[];
  BY(MESON_TAC[])
  ]);;
  (* }}} *)

let indexf_add_not_betwn = prove_by_refinement(
  `!x y z s. ~(x = z) /\ uniq s /\ MEM x s /\ MEM y s /\
    ~MEM y (betwn s z x) /\ MEM z s ==>
   indexf x y s + indexf y z s = indexf x z s`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC betwn_cases [`s`;`x`;`y`;`z`];
  ASM_REWRITE_TAC[];
  BY(REPEAT STRIP_TAC THEN ASM_SIMP_TAC[indexf_add_betwn;indexf_refl;arith `n +0 = n /\ 0 + n = n`])
  ]);;
  (* }}} *)

let next_el_refl = prove_by_refinement(
  `!(x:A) s. MEM x s /\ next_el s x = x /\ uniq s ==> s = [x]`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `~(sizel s = 0)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.size_eq0;MEM]);
  TYPIFY `indexl x s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(INTRO_TAC Seq.index_mem [`x`;`s`] THEN ASM_MESON_TAC[]);
  TYPIFY `sizel s = 1` ENOUGH_TO_SHOW_TAC;
    REWRITE_TAC[Seq2.size1_eq];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_ASSUM_ST `MEM` MP_TAC;
    BY(ASM_MESON_TAC[MEM]);
  FIRST_ASSUM (ASSUME_TAC o MATCH_MP Seq2.next_el_mod);
  PROOF_BY_CONTR_TAC;
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_TAC THEN ARITH_TAC);
  INTRO_TAC (GEN_ALL Qknvmlb.SUC_MOD_NOT_EQ) [`sizel s`];
  ASM_REWRITE_TAC[];
  DISCH_THEN (C INTRO_TAC [`indexl x s`]);
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`x`]);
  DISCH_TAC;
  INTRO_TAC Seq.nth_uniq [`x`;`s`;`indexl x s`;`SUC (indexl x s) MOD sizel s`];
  TYPIFY `SUC (indexl x s) MOD sizel s < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[DIVISION]);
  TYPIFY_GOAL_THEN `~(indexl x s = SUC (indexl x s) MOD sizel s)` (unlist ASM_REWRITE_TAC);
    BY(ASM_MESON_TAC[MOD_LT]);
  (ASM_SIMP_TAC[Seq.nth_index]);
  BY(ASM_MESON_TAC[arith `SUC x = x + 1`])
  ]);;
  (* }}} *)

(* FWDDPHY: *)

let indexf_prev = prove_by_refinement(
  `!(x:A) y s. MEM x s /\ MEM y s /\ uniq s /\  
   next_el s x = y ==> indexf y x s = 
      sizel s - 1`,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x = y` ASM_CASES_TAC;
    INTRO_TAC next_el_refl [`x`;`s`];
    ANTS_TAC;
      BY(ASM_MESON_TAC[]);
    DISCH_TAC THEN ASM_REWRITE_TAC[];
    BY(ASM_MESON_TAC[indexf_refl;Seq2.size1;arith `0 = 1 - 1`]);
  TYPIFY `1 < sizel s` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC sizel_gt_1;
    BY(ASM_MESON_TAC[]);
  INTRO_TAC indexf_antisym [`x`;`y`;`s`];
  ASM_REWRITE_TAC[];
  TYPIFY `indexf x y s = 1` ENOUGH_TO_SHOW_TAC;
    BY(ASM_TAC THEN ARITH_TAC);
  MATCH_MP_TAC next_el_indexf;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


let not_some_none = prove_by_refinement(
  `!x:A. ~(SOME x = NONE)`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[Ssrbool.isSome])
  ]);;
  (* }}} *)

(* was show_HideDups *)

let show_hideDups = prove_by_refinement(
  `!s. showDups (hideDups s) = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups;hideDups;showDups0;the_some;not_some_none];
  AP_TERM_TAC;
  REWRITE_TAC[hideDupsRec];
  FIRST_X_ASSUM MP_TAC;
  TYPIFY `t` (fun t -> SPEC_TAC (t,t));
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups;hideDups;hideDupsRec;showDups0;the_some;not_some_none;CONS_11];
  COND_CASES_TAC;
    BY(ASM_REWRITE_TAC[showDups0;CONS_11]);
  BY(ASM_REWRITE_TAC[showDups0;not_some_none;the_some;CONS_11])
  ]);;
  (* }}} *)

let some_the = prove_by_refinement(
  `!(x:(A)option). ~(x = NONE) ==> SOME (the x) = x`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[FORALL_OPTION;the_some])
  ]);;
  (* }}} *)

(*
let hideDupsRec_showDups0 = prove_by_refinement(
  `!s b a c. 
     hideDupsRec c (showDups0 b []) = [] /\
     hideDupsRec c (showDups0 b (SOME a :: s)) = (if (c=a) then NONE else SOME a) :: s /\
    hideDupsRec c (showDups0 b (NONE :: s)) = g`,
  (* {{{ proof *)
  [
  rt[showDups0;the_some;not_some_none;hideDupsRec]

  LIST_INDUCT_TAC then art[hideDupsRec;showDups0;not_some_none;the_some]
  st/r then condcase then art[hideDupsRec]
  asimp[some_the]
  ]);;
  (* }}} *)
*)


let unadj = new_recursive_definition list_RECURSION
  `(unadj (([]:(A)list)) = T) /\
   unadj ((h:A) ::t) = if (t = []) then T else (~((h:A) = HD t) /\ unadj t)`;;

(* deleted image_hide1 *)

let image_hideDups = new_definition
  `image_hideDups s = 
    (s = [] \/ (unadj (filter isSome s) /\ isSome (HD s)))`;;

(*
let image_hideDups_alt = prove_by_refinement(
  `image_hideDups s = 
     ((s = []) \/ (~(s = []) /\ (unadj (filter isSome s) /\ isSome (HD s))))`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[image_hideDups])
  ]);;
  (* }}} *)
*)

let some_inj = prove_by_refinement(
  `!x y. SOME x = SOME y <=> x = y`,
  (* {{{ proof *)
  [
    BY(MESON_TAC[the_some])
  ]);;
  (* }}} *)

let hideDups_eq_nil = prove_by_refinement(
  `!s. hideDups s = [] <=> s = []`,
  (* {{{ proof *)
  [
  BY(LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[hideDups;hideDupsRec;NOT_CONS_NIL])
  ]);;
  (* }}} *)

let image_hideDups2 = prove_by_refinement(
  `!s. image_hideDups (hideDups s)`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[hideDups;hideDupsRec;image_hideDups;NOT_CONS_NIL;HD;Ssrbool.isSome];
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[image_hideDups];
  REWRITE_TAC[Seq.filter_cons;Ssrbool.isSome;unadj;hideDups_eq_nil];
  COND_CASES_TAC;
    BY(REWRITE_TAC[]);
  TYPIFY `t = []` ASM_CASES_TAC;
    FIRST_X_ASSUM_ST `filter` MP_TAC;
    BY(ASM_REWRITE_TAC[hideDups;hideDupsRec;Seq.filter_nil]);
  ASM_REWRITE_TAC[];
  INTRO_TAC list_CASES [`t`] THEN ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  REPEAT (FIRST_X_ASSUM_ST `isSome` MP_TAC) THEN ASM_REWRITE_TAC[];
  REWRITE_TAC[hideDups;hideDupsRec;NOT_CONS_NIL;unadj;HD;Ssrbool.isSome];
  REPEAT (FIRST_X_ASSUM kill);
  REWRITE_TAC[Seq.filter];
  TYPIFY `h = h'` ASM_CASES_TAC THEN ASM_REWRITE_TAC[Ssrbool.isSome;Seq.filter;unadj;HD];
    BY(SIMP_TAC[]);
  BY(COND_CASES_TAC THEN ASM_REWRITE_TAC[some_inj])
  ]);;
  (* }}} *)

let the_inj = prove_by_refinement(
  `!a b. isSome a /\ isSome b ==> (the a = the b <=> a = b)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[FORALL_OPTION;Ssrbool.isSome;the_some];
  BY(MESON_TAC[some_inj])
  ]);;
  (* }}} *)

let hideDupsRec_show = prove_by_refinement(
  `!t a. (~(filter isSome t = []) ==> ~(a = HD (filter isSome t)) /\ unadj (filter isSome t)) /\ isSome a ==> hideDupsRec (the a) (showDups0 (the a) t) = t`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[showDups0;hideDupsRec;Seq.filter;unadj];
  GEN_TAC;
  COND_CASES_TAC;
    TYPIFY `~(h = NONE)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[Ssrbool.isSome]);
    ASM_REWRITE_TAC[hideDupsRec;HD];
    ASM_SIMP_TAC[the_inj;NOT_CONS_NIL;some_the;CONS_11;unadj];
    REPEAT WEAKER_STRIP_TAC;
    FIRST_X_ASSUM MATCH_MP_TAC;
    BY(ASM_MESON_TAC[]);
  TYPIFY `h = NONE` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Ssrbool.isSome;some_the]);
  ASM_REWRITE_TAC[];
  REWRITE_TAC[hideDupsRec;CONS_11];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let hideDups_show = prove_by_refinement(
  `!s. image_hideDups s ==> hideDups (showDups s) = s`,
  (* {{{ proof *)
  [
  LIST_INDUCT_TAC THEN ASM_REWRITE_TAC[image_hideDups;showDups;hideDups;showDups0;the_some;not_some_none;HD;NOT_CONS_NIL];
  SIMP_TAC[];
  REWRITE_TAC[Seq.filter];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM_ST `unadj` MP_TAC;
  ASM_REWRITE_TAC[unadj];
  DISCH_TAC;
  COND_CASES_TAC;
    BY(ASM_MESON_TAC[Ssrbool.isSome]);
  REWRITE_TAC[hideDups];
  ASM_SIMP_TAC[hideDups;some_the;CONS_11];
  MATCH_MP_TAC hideDupsRec_show;
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_nextVertices = prove_by_refinement(
  `!v f n. MEM v (FST f) ==> MEM (nextVertices f n v) (FST f)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[nextVertices];
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC THEN REWRITE_TAC[ITER];
  DISCH_TAC;
  GMATCH_SIMP_TAC nextVertex_next_el;
  SUBCONJ_TAC;
    BY(ASM_MESON_TAC[]);
  DISCH_TAC;
  BY(ASM_MESON_TAC[Seq2.mem_next_el])
  ]);;
  (* }}} *)

let nextVertices0 = prove_by_refinement(
  `!f v. nextVertices f 0 v = v`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[nextVertices;ITER])
  ]);;
  (* }}} *)

let nextVertices1 = prove_by_refinement(
  `!f v. nextVertices f 1 v = nextVertex f v`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[nextVertices;ITER_1])  
  ]);;
  (* }}} *)



(*
let indexToVertexList_lt = prove_by_refinement(
  `!e f v n. MEM v (FST f) ==> 
    indexf v (nextVertices f v n) (FST f) < sizel (FST f)`,
  (* {{{ proof *)
  [
  #
  ]);;
  (* }}} *)
*)

let indexf_nextVertices = prove_by_refinement(
  `!f v n. MEM v (FST f) /\ (uniq (FST f)) /\ n < sizel (FST f) 
     ==> indexf v (nextVertices f n v) (FST f) = n`,
  (* {{{ proof *)
  [
  REPLICATE_TAC 2 GEN_TAC;
  INDUCT_TAC THEN DISCH_TAC;
    REWRITE_TAC[nextVertices0];
    MATCH_MP_TAC indexf_refl;
    BY(ASM_REWRITE_TAC[]);
  REWRITE_TAC[nextVertices;ITER];
  REWRITE_TAC[GSYM nextVertices];
  INTRO_TAC MEM_nextVertices [`v`;`f`;`n`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[nextVertex_next_el];
  DISCH_TAC;
  INTRO_TAC indexf_add_sum [`v`;`nextVertices f n v`;`next_el (FST f) (nextVertices f n v)`;`FST f`];
  ASM_REWRITE_TAC[];
  TYPIFY `MEM (next_el (FST f) (nextVertices f n v)) (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_SIMP_TAC[Seq2.mem_next_el]);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf v (nextVertices f n v) (FST f) = n` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[arith `SUC n < s ==> n < s`]);
  ASM_REWRITE_TAC[];
  TYPIFY `indexf (nextVertices f n v) (next_el (FST f) (nextVertices f n v)) (FST f) = 1` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[arith `SUC n = n+1`]);
  MATCH_MP_TAC next_el_indexf;
  ASM_REWRITE_TAC[];
  BY(ASM_TAC THEN ARITH_TAC)
  ]);;
  (* }}} *)

let enum_indexToVertexList = prove_by_refinement(
  `!e f v. MEM v (FST f) /\ (uniq (FST f)) /\ (all (\n. n < sizel (FST f)) e) ==>
    enum_of_VertexList (FST f) v (indexToVertexList f v e) = e`,
  (* {{{ proof *)
  [
  REWRITE_TAC[More_tame_concl.enum_of_VertexList;indexToVertexList];
  REWRITE_TAC[show_hideDups];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\u. indexf v u (FST f)) o (\k. nextVertices f k v)) e = MAP I e` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[I_THM;o_THM;Seq2.ALL_all;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `x < sizel (FST f)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[Seq.allP]);
  MATCH_MP_TAC indexf_nextVertices;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)

let nextVertices_indexf = prove_by_refinement(
  `!f v w. uniq (FST f) /\ MEM v (FST f) /\ MEM w (FST f) ==> 
    nextVertices f (indexf v w (FST f)) v = w`,
  (* {{{ proof *)
  [
  TYPIFY `!n f v w. uniq (FST f) /\ MEM v (FST f) /\ MEM w (FST f) /\ indexf v w (FST f)= n ==> nextVertices f n v = w` ENOUGH_TO_SHOW_TAC;
    BY(MESON_TAC[]);
  INDUCT_TAC THEN REWRITE_TAC[nextVertices0];
    BY(MESON_TAC[indexf0]);
  REWRITE_TAC[nextVertices;ITER];
  REWRITE_TAC[GSYM nextVertices];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC MEM_nextVertices [`v`;`f`;`n`];
  ASM_REWRITE_TAC[];
  ASM_SIMP_TAC[nextVertex_next_el];
  DISCH_TAC;
  MATCH_MP_TAC indexf1;
  ASM_REWRITE_TAC[];
  INTRO_TAC indexf_add_left [`v`;`nextVertices f n v`;`w`;`FST f`];
  ASM_REWRITE_TAC[];
  INTRO_TAC indexf_nextVertices [`f`;`v`;`n`];
  ASM_REWRITE_TAC[];
  ANTS_TAC;
    BY(ASM_MESON_TAC[indexf_lt_sizel;arith `SUC n < m ==> n < m`]);
  DISCH_TAC THEN ASM_REWRITE_TAC[arith `n <= SUC n`];
  BY(ARITH_TAC)
  ]);;
  (* }}} *)

let not_isSome_NONE = prove_by_refinement(
  `!x. isSome x <=> ~(x = NONE)`,
  (* {{{ proof *)
  [
  BY(REWRITE_TAC[FORALL_OPTION;Ssrbool.isSome;not_some_none])
  ]);;
  (* }}} *)

let MEM_showDups0 = prove_by_refinement(
  `!vs a. 
    all (\t. (t=a)\/ MEM t (MAP the (filter isSome vs))) (showDups0 a vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM Seq.allP];
  LIST_INDUCT_TAC THEN REWRITE_TAC[showDups;GSYM Seq.allP;MEM;Seq.filter;showDups0];
  REPEAT GEN_TAC;
  TYPIFY `isSome h` ASM_CASES_TAC THEN ASM_SIMP_TAC[MEM;not_isSome_NONE];
    TYPIFY `~(h=NONE)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_MESON_TAC[not_isSome_NONE]);
    ASM_REWRITE_TAC[MEM;MAP];
    BY(ASM_MESON_TAC[]);
  TYPIFY `(h=NONE)` (C SUBGOAL_THEN ASSUME_TAC);
    BY(ASM_MESON_TAC[not_isSome_NONE]);
  ASM_REWRITE_TAC[];
  ASM_REWRITE_TAC[MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let MEM_showDups = prove_by_refinement(
  `!vs. (~(vs = []) ==> (isSome (HD vs))) ==>
    all (\t. MEM t (MAP the (filter isSome vs))) (showDups vs)`,
  (* {{{ proof *)
  [
  REWRITE_TAC[GSYM Seq.allP];
  GEN_TAC;
  INTRO_TAC list_CASES [`vs`];
  REPEAT STRIP_TAC;
    BY(FIRST_X_ASSUM MP_TAC THEN ASM_REWRITE_TAC[Seq.filter;MAP;MEM;showDups;showDups0]);
  REPLICATE_TAC 2 (FIRST_X_ASSUM MP_TAC) THEN ASM_REWRITE_TAC[MEM;showDups;MAP;HD;NOT_CONS_NIL;Seq.filter];
  REPEAT WEAKER_STRIP_TAC;
  ASM_REWRITE_TAC[MAP;MEM];
  INTRO_TAC MEM_showDups0 [`h::t`;`the h`];
  ASM_REWRITE_TAC[GSYM Seq.allP;Seq.filter;MAP;MEM];
  BY(ASM_MESON_TAC[])
  ]);;
  (* }}} *)

let indexToVertexList_enum = prove_by_refinement(
  `!vs f v. uniq (FST f) /\ MEM v (FST f) /\ 
    image_hideDups vs /\
    all (\t.  MEM (the t) (FST f)) (filter isSome vs) ==>
    indexToVertexList f v (enum_of_VertexList (FST f) v vs) = vs`,
  (* {{{ proof *)
  [
  REWRITE_TAC[More_tame_concl.enum_of_VertexList;indexToVertexList];
  REWRITE_TAC[GSYM MAP_o];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `MAP ((\k. nextVertices f k v) o (\u. indexf v u (FST f))) (showDups vs) = MAP I (showDups vs)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN (unlist REWRITE_TAC);
    REWRITE_TAC[MAP_I;I_THM];
    MATCH_MP_TAC hideDups_show;
    BY(ASM_REWRITE_TAC[]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;I_THM;o_THM;GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  MATCH_MP_TAC nextVertices_indexf;
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `all` MP_TAC;
  REWRITE_TAC[GSYM Seq.allP];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC MEM_showDups [`vs`];
  ANTS_TAC;
    BY(ASM_MESON_TAC[image_hideDups]);
  REWRITE_TAC[GSYM Seq.allP];
  DISCH_THEN (C INTRO_TAC [`x`]);
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM (C INTRO_TAC [`SOME x`]);
  REWRITE_TAC[the_some];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM MATCH_MP_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `MAP` MP_TAC;
  TYPIFY `x = the (SOME x)` (C SUBGOAL_THEN SUBST1_TAC);
    BY(REWRITE_TAC[the_some]);
  DISCH_TAC;
  INTRO_TAC MEMf_MAP [`SOME:num->(num)option`];
  DISCH_THEN (fun t -> (FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP t)));
  FIRST_X_ASSUM MP_TAC;
  REWRITE_TAC[the_some;GSYM MAP_o];
  TYPIFY `(MAP (SOME o the) (filter isSome vs)) = MAP I (filter isSome vs)` ENOUGH_TO_SHOW_TAC;
    DISCH_THEN SUBST1_TAC;
    BY(ASM_REWRITE_TAC[MAP_I;I_THM]);
  MATCH_MP_TAC MAP_EQ;
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP;o_THM;I_THM];
  REPEAT WEAKER_STRIP_TAC THEN MATCH_MP_TAC some_the;
  DISCH_TAC;
  FIRST_X_ASSUM_ST `MEM` MP_TAC;
  REWRITE_TAC[Seq.mem_filter];
  BY(ASM_MESON_TAC[not_isSome_NONE])
  ]);;
  (* }}} *)



end;;
