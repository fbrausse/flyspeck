(* 
parse_as_infix("in_dart_of_loop",(11,"right"));; 
make_overloadable "vertices" `:B -> (num list)`;;
overload_interface ("vertices",`FST:num list # bool -> num list`);;
Import_tame_classification.notation();;
*)

(* isop_list not used

let iso_list_isop_list = `!L N L' N'. iso_list (L,N) (L',N') <=> 
  (?phi. isop_list phi (L,N) (L',N'))`;;

*)

(* compare Elllnyz.hypermap_of_list_map *)


(* isop_list not used:
let isop_append = `!L N L' N' phi.
   (isop_list phi (L,APPEND N1 N2) (L',APPEND N1' N2') /\ 
      sizel N1 = sizel N1' ) <=>
   (isop_list phi (L,N1) (L',N1') /\ isop_list phi (L,N2) (L',N2'))`;;

let isop_cons = `!L N L' N' r r' phi.
    (isop_list phi (L,(r::N)) (L',(r'::N'))) <=>
    (isop_list phi (L,N) (L',N') /\ r' = 
	MAP (\u. (phi (FST u),phi(SND u))) r)`;;
*)

(* typo March 10, 2014.
let HQYMRTX3_list = `!L N r x. marked_list L N r x /\ ~final_list L r
  ==> ~(x = l'z L N r x)`;;
*)


(* all these are done:
let TAGYMW_concl = 
  `!p. good_list_nodes (fgraph (Seed p))`;;

let ENWCUED_concl = 
  `!p.  dih2k_list ( (fgraph (Seed p)))`;;

let DLWOJBB_concl = 
  `!L. dih2k_list L ==> 
    dih2k (hypermap_of_list L) (sizel (HD L))`;;

let KUKASGD_concl = 
  `!L. dih2k_list L /\ dih2k_list L' /\
     sizel (HD L) = sizel (HD L') ==> iso_list (L,[]) (L',[])`;;

let UNHQYQM_concl = 
  `!L L'. iso_list (L,[]) (L',[]) /\ dih2k_list L
    ==> dih2k_list L'`;;
*)

(*			
let ADACDYF_concl = `!H NF L MF M (x:A).  is_marked(H,NF,L,x) /\
   ~(L IN final_loops H NF) /\
   (MF,M) = transform H x (NF,L) ==>
  CARD (dart (quotient H NF)) < CARD (dart (quotient H MF))`;;
*)

(* renamed XBXFJPH... -> KWBPBHQ... *)

(*
let XBXFJPH_concl = `!L N r (x:A#A).
   marked_list L N r x ==>
   (let f = find_face L x in
   (set_of_list (filter (\d. MEM d f) (flatten N))) SUBSET
   (set_of_list r))`;;

let RYIUUVK_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'z L (N' i) (r' i) x) r <
      indexf x (l'y L (r' (SUC i)) x) r)`;; 

let CESHTIN1_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'z L (N' i) (r' i) x) r)`;;

let CESHTIN2_concl = `!L N r (x:A#A) N' r'.
  marked_list L N r x /\
  (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      MEM (l'y L (r' i) x) r)`;;

let CESHTIN3_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' (SUC i)) ==>
      indexf x (l'z L (N' i) (r' i) x) (find_face L x) <=
      indexf x (l'y L (r' (SUC i)) x) (find_face L x))`;;

let CESHTIN4_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
      indexf x (l'y L (r' i) x) (find_face L x) <
      indexf x (l'z L (N' i) (r' i) x) (find_face L x))`;;

let CESHTIN5_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let y = l'y L (r' i) x in
     let z' = l'z L (N' i) (r' i) x in
     let y' = f_list L (e_list y) in 
     let z = n_list L z' in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r y' z = betwn ri y' z)))`;;


let CESHTIN6_concl = `!L N r N' r' (x:A#A).
   marked_list L N r x /\
   (!i. (N' i,r' i) = (transform_list L x POWER i) (N,r)) ==>
   (!i. ~final_list L (r' i) ==>
    (let z = l'z L (N' i) (r' i) x in
     let ri = find_list (N' i) y' in 
     let j = indexf niy (node_map H z) r in
       (betwn r z x = betwn ri z x)))`;;
*)

(* primary reduction.  

   Termination guaranteed by the
   strictly increasing quantity sizel(flatten(finals g)).

 *)

(*
let more_concl = `!L.  
  is_restricted (hypermap_of_list L) /\
  good_list L /\
  good_list_nodes L /\
  all uniq L /\
  (!N g. premarked_list g L N /\ planegraph g /\ (~(nonFinals g = [])) 
   ==>
     (?L' N' g'. iso_list (L,[]) (L',[]) /\
	premarked_list g' L' N' /\ planegraph g' /\
	sizel (flatten (MAP FST (finals g'))) > sizel (flatten (MAP FST (finals g)))))
  ==>
   (?g. PlaneGraphs g /\ 
     iso (hypermap_of_list L) (hypermap_of_list (fgraph g)))`;;
*)

(* explicit powers of transform list *)
(*
let more_concl = `!g L N i. hypotheses ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let f = find_face L x in
      (!i. i <= k ==>
	 (ntrans L N r x i,rtrans L N r x i) = FST (ITER i
	   (\ Nrz. 
	      (let (N,r) = FST Nrz in
	       let zs = SND Nrz in
               let (y,z,b) = HD zs in
	       let ram2 = prev_el r z in
	       let split = split_normal_list L r f y ram2 in
	       let N' = APPEND (replace r [SND split] N) [FST split] in
		 if (final_list L r) 
		 then ((N,r),[]) else ((N', SND split),TL zs))) 
	      ((N,r),triple_data g L N))))`;;
*)

(* explicit powers on core_list *)

(*
let more_concl = `!g L N i. hypotheses /\ i <= transform_count L N r x 
  ==>
  (let (r,x) = loop_choice g L N in
   let triples = core_triple g L N in
   let mf = (FST (minimalFace (nonFinals g))) in
     quotient_list L (ntrans L N r x i) = part1 (ITER i (\ t.
	(let oldF,L',zs = t in
	 let ram1,ram2,n = HD zs in
	 let newVs = betwn mf ram1 ram2 in
	 let f1,f2,L'' = splitFace_list L' ram1 ram2 oldF newVs in
	   (f2,L'',TL zs)))
			      (mf,(fgraph g),triples)
					      ))`;;
*)

(* transform and subdiv both recover the face f.
   Needed to match up finals g at rk'. *)

(*
let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let f = find_face L x in
      (f = rtrans L N r x k))`;;

let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let f = find_face L x in
    let mf = minimalFace (nonFinals g) in
    let triples = triple_data g L N in
    let uvns = MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) triples in
    let (f',g') = subdivFace0_alt2 g mf (countVertices g) uvns in
      FST f' = MAP FST f)`;;

(* main matching result of transform^k with subdivFaceFinal2 *)

let more_concl = `!g L N r x k.
   match_list g L N /\
   ~(nonFinals g = []) ==>
   (let (r,x) = loop_choice g L N in
    let k = transform_count L N r x in
    let mf = minimalFace (nonFinals g) in
    let triples = triple_data g L N in
    let uvns = MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) triples in
    let g' = subdivFaceFinal2 g mf uvns in
      match_list g' L (ntrans L N r x k))`;;

*)

(* XX Now we just need to show that uvns comes from an enumeration
   and we are home. *)

(*
let SHXWKXQ_concl = 
  `!L:((num)list)list N x. 
     (
       let f = find_face L x in
       let r = find_list N x in
	 MEM x (flatten N) /\
	 uniq (MAP FST f) /\ 
	   set_of_list (flatten N) SUBSET (set_of_list (list_of_darts L)) ==>
	 (?L' N' x'.
	   iso_list (L,([x]::N)) (L',([x']::N')) /\
	   (let f' = find_face L' x' in
	    let r' = find_list N' x' in
	    let extra' = MAP FST (filter (\d. ~MEM d r') (rotate_to f' x')) in
	      ordered_list (set_of_list(MAP FST (flatten N'))) extra')))`;;
*)

(* ********************************************************************** *)
(* cut from tame_defs2.hl on July 5, 2014 *)
(* ********************************************************************** *)


(*
open Hales_tactic;;
open Hypermap;;
open Import_tame_classification;;
*)


(*
let good_graph = new_definition'
 `!g. good_graph g <=>
            good_list (fgraph g) /\
            good_list_nodes (fgraph g) /\
            finalGraph g /\
            all uniq (fgraph g) /\
            (!v. v IN vertices_set2 g
                 ==> facesAt g v = FILTER (\f. MEM v (FST f)) (faces g)) /\
            vertices_set2 g = elements_of_list (fgraph g)`;;
*)



(*
let indexf = new_definition' `!s x y. indexf (x:A) y s = 
   (indexl y s + (sizel s - indexl x s) MOD (sizel s))`;;
*)


(* March 9, 2014. Def. no good.  next_el requires uniq s
let contour_list = new_definition'
  `contour_list L (s:(A#A) list) <=>
    (all (\x. MEM x (list_of_darts L) /\ 
       (x = LAST s \/ one_step_list L x (next_el s x))) s)`;;
*)

(* old:
let parts = new_definition `parts L r = 
  (let H = hypermap_of_list L in
     partition_into_atom (inverse (node_map H)) r)`;;
*)

(* next_el_permutes...
let loop_of_list = new_definition' `loop_of_list (r:(A)list) = 
  loop(set_of_list r, res (next_el r) (set_of_list r) )`;;
*)

(* 1/2014 problem with this definition.  For there to be dart-uniqueness,
   which is a property of good_lists, we must filter out the duplicate
   edges.  So this doesn't work. *)

(* deprecated: 
let generatePolygon_relaxed = new_definition' 
  `generatePolygon_relaxed n v (f:(num)list#bool) g = 
  (let enumeration = enumerator n (LENGTH (vertices f)) in
   let vertexLists = MAP (\is. indexToVertexList f v is) enumeration in
     MAP (\vs. subdivFace g f vs) vertexLists)`;;
*)


(*
let next_plane_relaxed = new_definition'
  `next_plane_relaxed p g = 
  (let fs = nonFinals g in
     if (fs = []) then [] else
       (let f = minimalFace fs in
	let v = minimalVertex g f in
	  (flatten (MAP (\i. generatePolygon_relaxed i v f g) 
		      (upt 3 (SUC (maxGon p))) ))))`;;
*)



(* hyp'm: l'm *) (* was l'm *)

(*
let l_m = new_definition' `!L r (x:A#A). l'm L r x = 
  (let r' = rotate_to r x in
     min_num 
       { m | ~(ITER (SUC(SUC m)) (next_el r') x = 
	     f_list L (ITER (SUC m) (next_el r') x))  })`;;
2/28/2014 changed.
*)


(* changed March 9, 2014.
   hypermap.hl defines hyp'q by an existence theorem and never establishes
   its minimality.  To be compatible with hypermap.hl, we do the same here.

   Then we prove a theorem about its range of values.

let l_q = new_definition' `!L N r (x:A#A). l'q L N r x = 
  (let x' = find_list (parts L r) x in
   let z' = find_list (parts L r) (l'z L N r x) in
  min_num { q | l'm L r x < q /\ 
		(next_el (parts L r) POWER (SUC q)) x' = z' })`;;

*)



(* hyp'S: *)

(* March 9, 2014.  
let s_list = new_definition' `!L r (x:A#A). s_list L r x =
  (let r' = rotate_to r x in
     betwn r x (ITER (SUC (l'm L r x)) (next_el r') x))`;;

let s_list = new_definition' `!L r (x:A#A). s_list L r x =
     betwn r x (ITER (SUC (l'm L r x)) (next_el r) x)`;;

This has size l'm:  f^1 x... f^(m) x
*)



(* s_flag_list feb 28 2014 HD p -> LAST p, mar 10 2014 ~(s=[]) *)

(* flag_list was empty_flag_list, feb 28 2014 HD p -> LAST p, mar 10 2014 ~(s=[]) *)


(* match_quotient_list was respect_final_exact.  The set of finals in g can
   lag behind the set of finals in L//N. 

  March 14, 2014. Definition updated. 
  Was match_core_list.
  *)

(* loop_choice replaced with loop_choice2, Jul 2, 2014
let loop_choice = new_definition'
 `!g L N. loop_choice g (L:((num)list)list) N =
  (let f = minimalFace (nonFinals g) in
   let v = minimalVertex g f in
   let w = nextVertex f v in
   let d = (v,w) in
   let r = find_list N d in
   let p = parts L r in
     (r,LAST (find_list p d)))`;;
*)


(* Feb 9, 2014
   triple_data
  rotate_to w not x.  It puts ys and zs in increasing order. *)

(*
let triple_data = new_definition'
  `!g L N. triple_data g L N = 
    (
      let (r,x) = loop_choice g L N in
      let k = transform_count L N r x in
      let w = next_el r x in
      let f = rotate_to (find_face L x) w in
      let ys = filter (\x. MEM x r /\ ~(next_el f x = next_el r x)) f in
      let zs = filter (\x. MEM x r /\ ~(prev_el f x = prev_el r x)) f in
      let zp = zip ys zs in
	(MAP (\ (y,z). (y,z,betwn f y z)) zp))`;;


let core_triple = new_definition'
  `core_triple g L N = 
  MAP (\ (u,v,ns). (FST u,FST v,sizel ns)) (triple_data g L N)`;;

*)

(* mk_triple0 was mk_triples0, mk_triples *)

(* dest_triple0 was dest_triples0, dest_triple *)




(*
let dest_triple = new_definition'
  `dest_triple f uvns = dest_triple0 (f:(A)list) [] uvns`;;
*)

(*
let good_graph = new_definition `good_graph g <=> 
   good_list (fgraph g) /\
   good_list_nodes (fgraph g) /\
   finalGraph g /\ 
   all uniq (fgraph g) /\
   (!v. v IN vertices_set2 g
     ==> facesAt g v = FILTER (\f. MEM v (  FST f)) (faces g)) /\
   (vertices_set2 g = elements_of_list (fgraph g)) `;;
*)

(* 2014-04-07 planegraph -> planegraphP p, p-> p - 3,
   2014-04-09 remove planegraphP from concl, add marked_list hyp. 
   2014-05-04, added ~final_list L r to hyp. *)

(*
let generatePolygon_reduction = new_definition'
  `generatePolygon_reduction_v6 <=> (!L:((num)list)list N N' g p fs f v k r x.  
      good_list L /\
      good_list_nodes L /\
      is_restricted (hypermap_of_list L) /\
      newvertex_prepped L N r x /\
      marked_list L N r x /\
      ~final_list L r /\
      match_quotient_list g L N /\ 
      ~(finalGraph g) /\
      planegraphP p g /\
      good_faces_v3 g /\
      vertices_set2 g = elements_of_list (fgraph g) /\
      p = foldr maxn 0 (MAP sizel L) -3 /\
      fs = nonFinals g /\
      f = minimalFace fs /\
      v = minimalVertex g f /\
      (r,x) = loop_choice g L N   /\
      k = transform_count L N r x /\
      N' = ntrans L N r x k 
    ==>
      (?g' i. 
	 match_quotient_list g' L N' /\
	 // planegraphP p g' /\
	 3 <= i /\ i <= maxGon p /\
	 good_faces_v3 g' /\
         vertices_set2 g' = elements_of_list (fgraph g') /\
       MEM g' (generatePolygon i v f g)
  ))`;;
*)

(*
let triple_data2 = new_definition'
  `!g L N. triple_data2 g L N = 
    (
      let (r,x) = loop_choice2 g L N in
      let k = transform_count L N r x in
      let w = next_el r x in
      let f = rotate_to (find_face L x) w in
      let ys = filter (\x. MEM x r /\ ~(next_el f x = next_el r x)) f in
      let zs = filter (\x. MEM x r /\ ~(prev_el f x = prev_el r x)) f in
      let zp = zip ys zs in
	(MAP (\ (y,z). (y,z,betwn f y z)) zp))`;;
*)



