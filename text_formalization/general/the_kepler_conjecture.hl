(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(*                                                                            *)
(* Chapter:  Final Conclusion                                           *)
(* Date: March 12, 2014                                                 *)
(* ========================================================================== *)

flyspeck_needs "../formal_lp/hypermap/ineqs/lp_ineqs.hl";;

module The_kepler_conjecture = struct


open Hales_tactic;;
open Tame_defs;;
open Tame_defs2;;
open Tame_list;;
open Hypermap;;

let the_kepler_conjecture_def = new_definition'
  `the_kepler_conjecture <=>
     (!V. packing V
            ==> (?c. !r. &1 <= r
                         ==> &(CARD(V INTER ball(vec 0,r))) <=
                             pi * r pow 3 / sqrt(&18) + c * r pow 2))`;;

let good_linear_programming_results = new_definition'
  `good_linear_programming_results a <=>
      ((ALL good_list a) /\
      (!V. lp_ineqs /\ lp_main_estimate /\
	 (?L. MEM (L:((A)list)list) a /\ 
	    iso (hypermap_of_fan (V,ESTD V)) (hypermap_of_list L)) ==>
	 ~(contravening V)))`;;

let the_nonlinear_inequalities = new_definition'
  `the_nonlinear_inequalities <=>
  (pack_nonlinear_non_ox3q1h /\ ox3q1h /\ 
     main_nonlinear_terminal_v11 /\ lp_ineqs /\ pack_ineq_def_a /\
    kcblrqc_ineq_def)`;;

let tame_classification = new_definition' 
  `!(a:(((A)list)list)list). tame_classification a = 
  (!g. PlaneGraphs g /\ tame g ==> 
     (?y. y IN set_of_list a /\ iso_fgraph (fgraph g) y))`;;

(*
let import_tame_classification = 
  Import_tame_classification.import_tame_classification;;
*)

let restricted_hypermaps_are_planegraphs = new_definition'
  `restricted_hypermaps_are_planegraphs_v4 <=>
  (!Ln:((num)list)list. 
  good_list Ln /\ good_list_nodes Ln /\
  is_restricted (hypermap_of_list Ln) ==>
  (?gn. PlaneGraphs gn /\ 
     good_graph_v4 gn /\
     iso (hypermap_of_list Ln) (hypermap_of_list (fgraph gn))))`;;

(* ..........  END NEW DEFS *)

let kc_imp_the_kc = prove_by_refinement(
  `kepler_conjecture ==> the_kepler_conjecture`,
  (* {{{ proof *)
  [
  REWRITE_TAC[the_kepler_conjecture_def;Pack_defs.kepler_conjecture];
  DISCH_TAC;
  FIRST_X_ASSUM (ASSUME_TAC o MATCH_MP Flyspeck_devol.FLYSPECK_DEVOLUTION);
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Flyspeck_devol.CPNKNXN [`V`];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`V'`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY` c` EXISTS_TAC;
  REPEAT WEAKER_STRIP_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`r`]);
  ASM_REWRITE_TAC[];
  TYPIFY `&(CARD (V INTER ball (vec 0,r))) <= &(CARD (V' INTER ball (vec 0,r)))` ENOUGH_TO_SHOW_TAC;
    BY(REAL_ARITH_TAC);
  REWRITE_TAC[ REAL_OF_NUM_LE];
  MATCH_MP_TAC CARD_SUBSET;
  CONJ_TAC;
    BY(FIRST_X_ASSUM_ST `SUBSET` MP_TAC THEN SET_TAC[]);
  BY(ASM_MESON_TAC[Pack2.KIUMVTC])
  ]);;
  (* }}} *)

let contravening_tame_hypermap = Mqmsmab.MQMSMAB;;

(*
let is_no_double_joins_joins = prove_by_refinement(
  `is_no_double_joins = is_no_double_joins`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[is_no_double_joins;Hypermap.is_no_double_joins;FUN_EQ_THM])
  ]);;
  (* }}} *)
*)

let tame_hypermap_restricted = prove_by_refinement(
  `!H. tame_hypermap H ==> is_restricted H`,
  (* {{{ proof *)
  [
  REWRITE_TAC[tame_hypermap;Hypermap.is_restricted;(* is_no_double_joins_joins; *) tame_1;tame_2;tame_3;tame_4;tame_5a;tame_8];
  SIMP_TAC[Hypermap.lemma_node_nondegenerate];
  REPEAT WEAKER_STRIP_TAC;
  nCONJ_TAC 2;
    BY(ASM_MESON_TAC[tame_9a;arith `n >= 3 <=> 3 <= n`]);
  nCONJ_TAC 1;
    BY(ASM_MESON_TAC[tame_11a;arith `n >= 3 ==> 2 <= n`]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Hypermap.lemma_card_face_collection [`H`];
  REPEAT WEAKER_STRIP_TAC;
  TYPIFY `( (face_collection H) = {})` ENOUGH_TO_SHOW_TAC;
    BY(ASM_MESON_TAC[Oxl_2012.CARD_EMPTY;arith `~(0 >= 3)`]);
  ASM_REWRITE_TAC[Hypermap.face_collection];
  BY(REWRITE_TAC[EXTENSION;IN_ELIM_THM;NOT_IN_EMPTY])
  ]);;
  (* }}} *)

let kepler_conjecture_with_assumptions = prove_by_refinement(
  `!a. tame_classification a /\
    good_linear_programming_results a /\ 
    the_nonlinear_inequalities
    ==> the_kepler_conjecture
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  ASSUME_TAC Reduction5.restricted_hypermaps_are_planegraphs_thm; 
  MATCH_MP_TAC kc_imp_the_kc;
  REPEAT (POP_ASSUM MP_TAC);
  REWRITE_TAC[good_linear_programming_results;the_nonlinear_inequalities;tame_classification;restricted_hypermaps_are_planegraphs;IN_SET_OF_LIST;];
  REPEAT WEAKER_STRIP_TAC;
  PROOF_BY_CONTR_TAC;
  FIRST_X_ASSUM_ST `lp_ineqs /\ u` MP_TAC;
  ASM_SIMP_TAC[Jejtvgb.nonlinear_imp_lp_main_estimate];
  DISCH_TAC;
  INTRO_TAC Oxlzlez.PACKING_CHAPTER_MAIN_CONCLUSION [];
  ASM_REWRITE_TAC[Fnjlbxs.lmfun_ineq_center_scriptL;arith `~(x <= &12) <=> x > &12`];
  DISCH_TAC;
  INTRO_TAC Fnjlbxs.FCDJDOT [];
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  MP_TAC contravening_tame_hypermap;
  ASM_SIMP_TAC[Jejtvgb.nonlinear_imp_lp_main_estimate];
  DISCH_THEN (C INTRO_TAC [`V`]) THEN ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY `is_restricted (hypermap_of_fan (V,ESTD V))` (C SUBGOAL_THEN ASSUME_TAC);
    MATCH_MP_TAC tame_hypermap_restricted;
    BY(ASM_REWRITE_TAC[]);
  MP_TAC (INST_TYPE [`:real^3#real^3`,`:A`] Jcajydu.JCAJYDU);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`hypermap_of_fan (V,ESTD V)`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Wmlnymd.tame_correspondence_iso [`gH`;`hypermap_of_fan (V,ESTD V)`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`gH`]);
  ASM_REWRITE_TAC[];
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC Elllnyz.ELLLNYZ [`fgraph gH`;`y`];
  ASM_REWRITE_TAC[];
  FIRST_X_ASSUM_ST `ALL` MP_TAC;
(*  MP_TAC Good_list_archive.good_list_archive; *)
  REWRITE_TAC[Seq2.ALL_all;GSYM Seq.allP];
  ASM_SIMP_TAC[];
  DISCH_TAC;
  TYPIFY_GOAL_THEN `good_list (fgraph gH)` (unlist REWRITE_TAC);
    BY(ASM_MESON_TAC[good_graph]);
  TYPIFY `iso (hypermap_of_list (fgraph gH)) (hypermap_of_list y)` ASM_CASES_TAC;
    FIRST_X_ASSUM (C INTRO_TAC [`V`]);
    ANTS_TAC;
      TYPIFY `y` EXISTS_TAC;
      INTRO_TAC Hypermap.iso_trans [`hypermap_of_fan (V,ESTD V)`;`hypermap_of_list (fgraph gH)`;`hypermap_of_list y`];
      BY(ASM_SIMP_TAC[]);
    BY(ASM_REWRITE_TAC[]);
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  INTRO_TAC Asfutbf.hypermap_of_fan_neg [`V`];
  ASM_REWRITE_TAC[];
  DISCH_TAC;
  FIRST_X_ASSUM (C INTRO_TAC [`IMAGE (--) (V:real^3->bool)`]);
  ANTS_TAC;
    TYPIFY `y` EXISTS_TAC;
    ASM_REWRITE_TAC[];
    TYPED_ABBREV_TAC `hneg = hypermap_of_fan (IMAGE (--) V,ESTD (IMAGE (--) V))`;
    TYPED_ABBREV_TAC `h = (hypermap_of_fan (V,ESTD V))`;
    TYPED_ABBREV_TAC `hgH = hypermap_of_list (fgraph gH)`;
    TYPED_ABBREV_TAC `hy = hypermap_of_list y`;
    TYPIFY `iso (opposite_hypermap h) (opposite_hypermap hgH)` (C SUBGOAL_THEN ASSUME_TAC);
      BY(ASM_REWRITE_TAC[GSYM Asfutbf.iso_opposite_eq]);
    TYPIFY `iso (opposite_hypermap h) (hy)` (C SUBGOAL_THEN ASSUME_TAC);
      INTRO_TAC Hypermap.iso_trans [`opposite_hypermap h`;`opposite_hypermap hgH`;`hy`];
      BY(ASM_SIMP_TAC[]);
    INTRO_TAC Hypermap.iso_trans [`hneg`;`opposite_hypermap h`;`hy`];
    BY(ASM_SIMP_TAC[]);
  REWRITE_TAC[] THEN MATCH_MP_TAC Asfutbf.contravening_negative;
  BY(ASM_REWRITE_TAC[])
  ]);;
  (* }}} *)


(* The remaining results add in the archive *)

let linear_programming_results = new_definition
  `linear_programming_results <=>
      (!V. lp_ineqs /\ lp_main_estimate /\
	 (?L. MEM L tame_archive_lists /\ 
	    iso (hypermap_of_fan (V,ESTD V)) (hypermap_of_list L)) ==>
	 ~(contravening V))`;;

(*
let good_linear_programming_results_lpr = prove_by_refinement(
  `good_linear_programming_results tame_archive_lists <=> 
    ALL good_list tame_archive_lists /\
    linear_programming_results`,
  (* {{{ proof *)
  [
  REWRITE_TAC[good_linear_programming_results;linear_programming_results];
  ]);;
  (* }}} *)
*)

let archive = new_definition' `archive = set_of_list tame_archive_lists`;;

let import_tame_classification = new_definition' 
  `import_tame_classification = 
  (!g. PlaneGraphs g /\ tame g ==> (?y. y IN archive /\ iso_fgraph (fgraph g) y))`;;

let import_tame_classification_tame = prove_by_refinement(
  `import_tame_classification = tame_classification tame_archive_lists`,
  (* {{{ proof *)
  [
  REWRITE_TAC[archive;import_tame_classification;tame_classification];
  ]);;
  (* }}} *)

parse_as_infix ("IN_simeq", (11, "right"));;

let IN_SIMEQ = new_definition'
  `!A (x:((A)list)list). 
  x IN_simeq A <=> (?(y:((B)list)list). y IN A /\ iso_fgraph x y)`;;

let import_tame_classification_alt = prove_by_refinement(
  `import_tame_classification <=> 
  (!g. g IN PlaneGraphs /\ tame g ==> fgraph g IN_simeq archive)`,
  (* {{{ proof *)
  [
    BY(REWRITE_TAC[import_tame_classification;IN_SIMEQ;IN])
  ]);;
  (* }}} *)

let kepler_conjecture_with_assumptions_and_archive = prove_by_refinement(
  `import_tame_classification /\
    linear_programming_results /\ 
    the_nonlinear_inequalities
    ==> the_kepler_conjecture
    `,
  (* {{{ proof *)
  [
  REPEAT WEAKER_STRIP_TAC;
  INTRO_TAC kepler_conjecture_with_assumptions [`tame_archive_lists`];
  DISCH_THEN MATCH_MP_TAC;
  ASM_REWRITE_TAC[good_linear_programming_results;GSYM linear_programming_results];
  ASM_REWRITE_TAC[GSYM import_tame_classification_tame];
  MP_TAC Good_list_archive.good_list_archive;
  BY(REWRITE_TAC[Good_list_archive.good_list_archive])
  ]);;
  (* }}} *)

(* final result *)

let tame_nonlinear_imp_kepler_conjecture = 
  REWRITE_RULE[Linear_programming_results.linear_programming_results_th]
    kepler_conjecture_with_assumptions_and_archive;;

(* simple -> full corrected Sep 9, 2014 *)

let check_md5 c md5 = 
  let imp = mk_imp (c,c) in
  let _ = is_const c or failwith "constant expected in check_md5" in
  let th' = Serialization.canonize_thm (MESON[] imp) in
  let md5' = Serialization.full_digest_thm th' in
  let check = (md5' = md5) in
  let _ = if (not check) then 
    report ("FAILED MD5 CHECK "^(string_of_term c)^" "^md5') in 
    check;;

let check_nonlinear_md5 = 
  check_md5 `the_nonlinear_inequalities` "a4a27fe9b050b585a81af8414db2f340";;
   (* simple: "1f054717131cf915bd8cc95ab7b645c3" *)

let check_linear_md5 = 
  check_md5 `linear_programming_results` "0";;
   (* simple: "ff5f953dece7d2a4bb712303d0a7a179";; *)

let check_graph_md5 = 
  check_md5 `import_tame_classification` "0";;
   (* simple: "921b44e90681ed302d31b4f9ce93ddad";; *)

let check_kepler_conjecture_md5 = 
    check_md5 `the_kepler_conjecture` "0";;
   (* simple: "0fb2a76af8f8c13cbb7ea0d4e2ab4149";; *)

let check_all_md5 = 
  check_nonlinear_md5 &&
    check_linear_md5 &&
    check_graph_md5 &&
    check_kepler_conjecture_md5 ;;

   (*  
       The file "nonlinear/mk_all_ineq.hl" uses 
       the "serialization" version of HOL Light to prove
       |- the_nonlinear_inequalities
   *)


 end;;
