#load "str.cma";;


module Searching = struct


(* 

    Different search results.
   search: Theorem list
   constant list
   index: Help index list
   help: help doc.

   All the searches with the same return type should be combined.


*)


(* quicksilver style search for name matching.
    ignore case and look for nonconsecutive letters. *)

let unsplit d f = function
  | (x::xs) ->  List.fold_left (fun s t -> s^d^(f t)) (f x) xs
  | [] -> "";;

let match_sparse s u = 
  let re = Str.regexp_case_fold (".*"^(unsplit ".*" I (   explode s))) in
    Str.string_match re u 0;;


(* ========================================================================== *)
(* HELP                                              *)


let hollight_dir = 
  (try Sys.getenv "HOLLIGHT_DIR" with Not_found -> Sys.getcwd());;

(* hol-light help path *)

let helpdirs = ref [
  Filename.concat flyspeck_dir "../help";
  Filename.concat hollight_dir "Help"
 ];;

help_path := !helpdirs @ (!help_path);; (* hol-light help *)

(* let help_h = ref [];; *)
let help_grep_h = ref[];;
let search_h = ref[];;

let update i h = (h:= i:: !h);;
let history n h = fst(chop_list n h);;

let help_grep pat = 
  let _ = update pat help_grep_h in
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; ls | sed 's/.doc$//g' | grep '" ^pat^ "')") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

(*
if pat starts with - then it should be taken as a flags command.
*)

let help_grep_flags pat flags = 
  let _ = update pat help_grep_h in
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; ls | sed 's/.doc$//g' | grep -"^flags^" '" ^pat^ "')") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

help_grep_flags "r.*w" "i";;

(*  
Example:
help_grep "ASM.*REWRITE";;
help_grep "^ASM_";;
help_grep "help";;
help_grep "RULE";;
help_grep "ARITH";;
help_grep "_TAC$";;
List.length (help_grep ".*");;
*)


(* ========================================================================== *)
(* SEARCH *)




(* grab a definition, or anything vaguely similar to a definition. *)

let constant_of_regexp ss = 
  let re = Str.regexp_case_fold (".*"^ss) in
  let c = map fst (constants()) in
   filter (fun s -> Str.string_match re s 0) c;;

(* examples:

constant_of_regexp ".*contin";;
constant_of_regexp ".*integr";;
constant_of_regexp ".*auchy";;
constant_of_regexp "at.*[ng]$";;

*)

let searcht n pat = 
  let raw = search pat in
  let len = List.length raw in
(*  let _ =  (len <= !search_limit) or 
    failwith (string_of_int len^" matches, reset Searching.search_limit") in *)
  let m = min n (List.length raw) in
  let s = sortlength_thml raw in
    fst (chop_list m s);;


let nsearch,select  = 
  let selection = ref [] in
  let nsearch v = 
    let u = search v in
    let _ = selection := u in
    let r = List.length u in
      map (fun (n,(s,th)) -> (n,s,th)) (zip (0--(r-1)) u) in
  let select n = fst(List.nth !selection n) in
    nsearch,select;;


(* ========================================================================== *)
(* STATS *)


(* get all word counts in HOL LIGHT and FLYSPECK *)

let wc_tmpfile = Filename.temp_file "tmp_" ".txt";;

let int_tmpfile = 
  let ss1 = process_to_string ("ls /Users/thomashales/Desktop/googlecode/flyspeck/text_formalization/*/*.hl") in
  let ss2 = Str.split (Str.regexp "\n") ss1 in
  let ss1 = process_to_string ("ls /Users/thomashales/Desktop/googlecode/hol_light/*/*.ml") in
  let ss2 =  Str.split (Str.regexp "\n") ss1 @ ss2 in
  let tmpfile =  wc_tmpfile in
  let _ =     Sys.command("touch "^tmpfile) in
  let _ =     map (fun s -> Sys.command("cat "^ s^ " >> " ^ tmpfile)) ss2 in
    ();;

let word_counts() = 
  let sout = Str.split (Str.regexp "\n") (process_to_string("cat "^wc_tmpfile^" | tr -C 'A-Z:a-z0-9_' '\n' | sort | uniq -c | sed 's/^ *//'")) in
  let sout1 = map (Str.split (Str.regexp " ")) sout in
  let sout2 = filter (fun t -> List.length t = 2) sout1 in
  let sout3 = map (function | [a;b]-> (b,int_of_string a) | _ -> ("?",0)) sout2 in
    sout3;;

let word_count_list = word_counts();;


(* word counts of theorems *)

(* word counts of tactic following repeat.

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/^[^a-zA-Z].*$//g' | sed 's/ .*$//g' | tr -C 'A-Za-z_' '\n' | sed 's/ //g' | sort | uniq -c | sed 's/^ *//'



*)

(* stats of the word immediately following another word *)

let word_successor_counts word_successor = 
  let sed_pipe = Printf.sprintf "grep '%s ' %s | sed 's/^.*%s *//'  | sed 's/^[^a-z.A-Z]*//g' | sed 's/ .*$//g' | tr -C 'A-Z.a-z_0-9' '\n' | sed 's/ //g' | sort | uniq -c | sed 's/^ *//'" 
    word_successor wc_tmpfile word_successor in 
  let sout = Str.split (Str.regexp "\n") 
    (process_to_string(sed_pipe )) in
  let sout1 = map (Str.split (Str.regexp " ")) sout in
  let sout2 = filter (fun t -> List.length t = 2) sout1 in
  let sout3 = map (function | [a;b]-> (b,int_of_string a) | _ -> ("?",0)) sout2 in
    sort (fun (_,a) (_,b) -> (a > b)) sout3;;

(*
map (fun s -> (s,word_successor_counts s)) ["REPEAT";"GSYM";"MATCH_MP_TAC";" MP_TAC";"REWRITE_TAC"];;

map (fun s -> (s,word_successor_counts s)) ["POP_ASSUM";"ALL_THEN"; "ANTE_RES_THEN"; 
   " CHOOSE_THEN"; "CONJUNCTS_THEN";
   "CONJUNCTS_THEN2"; "DISCH_THEN"; "DISJ_CASES_THEN"; "DISJ_CASES_THEN2";
   "FREEZE_THEN"; "IMP_RES_THEN"; "NO_THEN"; "REFUTE_THEN"; "REMOVE_THEN";
   "STRIP_GOAL_THEN"; "STRIP_THM_THEN"; "SUBGOAL_THEN"; "THEN"; "THENC";
   "THENL"; "THEN_TCL"; "UNDISCH_THEN"; "USE_THEN"; "X_CHOOSE_THEN"];;

word_successor_counts "MATCH_MP_TAC";;
word_successor_counts "REWRITE_RULE";;
word_successor_counts " CHOOSE_THEN";;
word_successor_counts " POP_ASSUM";;
help "X_CHOOSE_THEN";;
*)

(* inaccurate because constants and theorems with the same name are overcounted *)

let thm_count_list = 
  let alpha_thm = sort (<) (map fst !theorems) in
  let rec build buff ats bts = match (ats,bts) with
    | ([],_) -> buff
    | (_,[]) -> buff
    | (a::atss,(b,n)::btss) -> if (a=b) then build ((b,n)::buff) atss btss
      else if (a>b) then build buff ats btss else build buff atss bts in
  sort (fun (_,a) (_,b) -> (a > b)) (build [] (alpha_thm) word_count_list);;

let tactic_list =  (help_grep "TAC$");;

let then_list =  (help_grep "THEN");;

let tactic_counts = sort (fun (_,a) (_,b) -> (a > b)) 
  (filter (fun (a,_) -> mem a  (["REPEAT";"POP_ASSUM";"FIRST_X_ASSUM";"FIRST_ASSUM"] @ tactic_list @ then_list)) word_count_list);;


(* ========================================================================== *)
(* EVAL *)

(*
eval_command comes from

http://solaria.dimino.org/cgi-bin/darcsweb.cgi?r=peps;a=headblob;f=/src/core/peps_top.ml
License: BSD3

If the expression is syntactically correct 
and the evaluation raises an exception, then the return value is true.
*)


let eval_command ?(silent=false) command =
   let buffer = Buffer.create 512 in
   let pp = Format.formatter_of_buffer buffer in
   Format.pp_set_margin pp max_int;
   try
     let _ =
       Toploop.execute_phrase (not silent) pp
         (!Toploop.parse_toplevel_phrase (Lexing.from_string (command ^ ";;")))
     in
     (true, Buffer.contents buffer)
   with exn ->
     let save = !Toploop.parse_use_file in
     Toploop.parse_use_file := (fun _ -> raise exn);
     ignore (Toploop.use_silently pp "/dev/null");
     Toploop.parse_use_file := save;
     (false,  Buffer.contents buffer);;

(* eval_command ~silent:false "g `x=y`";; *)

type proof_record = Tax of string*tactic | Bax | Gax of term;;

let proof_record  =ref [];;
let tactic_cache = ref (fun () -> ALL_TAC);;

(* we evaluate the tactic outside eval_command, so that we can catch exceptions *)

let eval_tactic  = 
  fun s ->
    let (b,r) = eval_command ~silent:false 
      ("tactic_cache := (fun () -> ("^s^"));;") in
    let _ = b or (print_string (r^"\n"^s^"\n"); failwith "bad input string") in
    let t= (!tactic_cache)() in
    let v = Hol_pervasives.e(t) in
    let _ = proof_record := Tax (s,t)::!proof_record in
      v;;

let eval_goal t = 
  let _ = proof_record := Gax t::!proof_record in
    print_goalstack (Hol_pervasives.g(t));;

let eval_back () = 
  let _ = proof_record := Bax::!proof_record in Hol_pervasives.b();;

(*
eval_goal `1 + 1 = 2`;;
eval_tactic "REPEAT STRIP_TAC";;
eval_back();;
eval_tactic "ARITH_TAC";;
eval_tactic "REWRITE_TAC[TRUTH]";;
*)

let rec strs_of_proof_records skip buf  = function
    [] -> buf
  | Gax _ :: xs -> buf
  | Tax (s,_) :: xs -> if (skip=0) then strs_of_proof_records skip (s::buf) xs
    else strs_of_proof_records (skip-1) buf xs
  | Bax :: xs -> strs_of_proof_records (skip+1) buf xs;;

let string_of_proof () = 
  let ss = strs_of_proof_records 0 [] !proof_record in
    "\n[\n"^unsplit ";\n" I (ss) ^"\n]\n";;

(*
print_string (string_of_proof());;
*)   



(* ========================================================================== *)
(* DEPTH FUNCTIONS *)
(* each constant is defined in terms of other constants.
   The depth of a constant is the length of its longest chain down to the primitives *)

let rec c_of buf = function
  | Const _ as t  -> t:: buf
  | Comb (r,s)  -> c_of (c_of buf r) s
  | Abs (x,t) -> c_of buf t
  | _ -> buf;;

let nub = Parse_ineq.nub;;

let def_assoc = 
  let r =  (map (dest_eq o concl) (definitions())) in
  let s = fst o dest_const in 
    map (fun (x,y) -> ( s x,nub (map s (c_of [] y)))) r;;

let stm_depth = 
  let cache = ref [] in
  let maxl0 xs = try (end_itlist max xs) with _ -> 0 in
  let rec s_depth t = 
    try (assoc t !cache)
    with _ -> 
      let rs = try (assoc t def_assoc)
      with _ -> [] in
      let _ = not(mem t rs) or failwith t in
      let u = 1 + maxl0 (map s_depth rs) in
      let _ = cache:= (t,u)::!cache in
	u in
    s_depth;;

let tm_depth t =
  let c = map (fst o dest_const )(c_of [] t) in
  let u = map (fun x -> (x,stm_depth x)) c in
  let s = nub (sort (fun (_,a) (_,b) -> a > b) u) in
    s;;

let thm_depth = tm_depth o concl;;



(* ========================================================================== *)
(* TACTIC                                              *)

let FORCE_EQ = REPEAT (CHANGED_TAC (AP_TERM_TAC ORELSE AP_THM_TAC ORELSE BINOP_TAC)) ;;

let FORCE_MATCH = (MATCH_MP_TAC (TAUT `(a = b) ==> (a ==> b)`)) THEN FORCE_EQ ;;

let FORCE_MATCH_MP_TAC th = 
  MP_TAC th THEN ANTS_TAC THENL[ALL_TAC;FORCE_MATCH
      ];;

let HYP_CONJ_TAC = 
  let th = TAUT `(a ==> b==> c) ==> (a /\ b ==> c)`  in
    FIRST_X_ASSUM (fun t-> MP_TAC t THEN MATCH_MP_TAC th THEN DISCH_TAC THEN DISCH_TAC);;

let SELECT_TAC = Tactics.SELECT_TAC;;


(*
let ASM_REAL_ARITH_TAC t = 
  REPEAT (POP_ASSUM MP_TAC) THEN MP_TAC (itlist CONJ t TRUTH) THEN
    REAL_ARITH_TAC;;

let MP_LIST t = EVERY (map MP_TAC t);;
*)



(* Gonthier's script organizational tactics. *)

let BY (t:tactic) (asl,w) = 
  let (a,b,c)  = t (asl,w) in
  let _ = (b = []) or failwith "by failed to finish goal" in
    (a,b,c);;

let BRANCH_A (t::tl) = t THENL [EVERY tl;ALL_TAC];;

let BRANCH_B (t::tl) = t THENL [ALL_TAC;EVERY tl];;

(* a few from Jordan *)

let X_IN = Tactics_jordan.un;;

let SUBCONJ_TAC = Tactics_jordan.SUBCONJ_TAC;;

let PROOF_BY_CONTR_TAC = Tactics_jordan.PROOF_BY_CONTR_TAC;;

let UNDISCH_FIND_TAC = Tactics_jordan.UNDISCH_FIND_TAC;;

let TYPE_THEN = Tactics_jordan.TYPE_THEN;;

let TYPEL_THEN = Tactics_jordan.TYPEL_THEN;;




(* working with hashed assumptions *)

let hash_of_term = Hash_term.hash_of_term;;

let HASH_UNDISCH_TAC h = 
  FIRST_X_ASSUM (fun t-> 
		   let _ = (hash_of_term  (concl t) = h) or failwith "bad hash" in
		     MP_TAC t);;

let HASH_RULE_TAC h r = HASH_UNDISCH_TAC h THEN DISCH_THEN (fun t -> MP_TAC (r t));;

let HASH_KILL_TAC h = HASH_UNDISCH_TAC h THEN (DISCH_THEN (fun t -> ALL_TAC));;

let HASH_CHOOSE_TAC h = HASH_UNDISCH_TAC h THEN (DISCH_THEN CHOOSE_TAC);;

let HASH_X_CHOOSE_TAC h t = HASH_UNDISCH_TAC h THEN (DISCH_THEN (X_CHOOSE_TAC t));;
   
let HASH_ASM_REWRITE_TAC h (asl,w)  = 
  let (asl2) = filter (fun t -> not(hash_of_term (concl (snd t)) = h)) asl in
    (HASH_UNDISCH_TAC h THEN 
       DISCH_THEN (fun t-> ASSUME_TAC(REWRITE_RULE (map snd asl2) t))) (asl,w);;

(* working with numbered assumptions, 
    Follow HOL Light's reverse numbering convention on assumptions. *)

let el_hash  i  (asl,w)   = 
   hash_of_term (el i (map (concl o snd) (List.rev asl)));;

let use_el i ttac (asl,w) = 
  let h = el_hash i (asl,w) in
    (HASH_UNDISCH_TAC h THEN (DISCH_THEN ttac)) (asl,w);;

(*

let hashify0 i f  (asl,w) = f (el_hash i (asl,w)) (asl,w);;

let hashify1 i f r  (asl,w) = f (el_hash i (asl,w)) r (asl,w);;

let EL_UNDISCH_TAC i = hashify0 i HASH_UNDISCH_TAC;;

let EL_RULE_TAC i r =hashify1 i r HASH_RULE_TAC;;

let EL_KILL_TAC i = hashify0 i HASH_KILL_TAC;;

let EL_CHOOSE_TAC i =  hashify0 i HASH_CHOOSE_TAC;;

let EL_X_CHOOSE_TAC i t = hashify1 i t HASH_X_CHOOSE_TAC;;

let EL_ASM_REWRITE_TAC i = hashify0 i HASH_ASM_REWRITE_TAC;;

*)




(* ========================================================================== *)
(* TACTIC                                              *)

(* searching for relevant tactics *)


let tachy  s = 
  filter (match_sparse s) (map fst tactic_counts);;


(* term matching without higher order matches *)


let term_match_no_ho pat u = 
  let (_,b,c) = (term_match[] pat u) in
  let v = instantiate ([],b,c) pat in 
    aconv v u  or failwith "no match";;

let match_g_no_ho pat (_,w) = not(search_thml term_match_no_ho pat [("", ASSUME w)] = []);;

let match_g pat (_,w) = not(search_thml (term_match[]) pat [("", ASSUME w)] = []);;

let match_asm pat (asl,_) = not(search_thml term_match_no_ho pat asl = []);;




(* let assum t = mk_comb(mk_var("<assum>",W mk_fun_ty (type_of t)),t);; *)

(* 

trigger pattern;
English text;
prompt;
tactic;

*)

let rrrrr = (match_g[`let x = (y:A) in (z:B)`],"LET_TAC","let elimination",fun t -> LET_TAC);;



let tactic_patterns  = [
(match_g[`(@):(A->bool)->A`],"SELECT_ELIM_TAC","remove @",fun t-> SELECT_ELIM_TAC);
(match_g[`(@):(A->bool)->A`],"SELECT_TAC","remove @ with subgoals depending satisfiability",fun t-> SELECT_TAC);
(match_g[full `(\x. f x = \x. g x)`],"ABS_TAC","strip abstractions from equality",fun t-> ABS_TAC);
(match_g[full ` ((p ==> q) ==> r)`],"ANTS_TAC","split off the antecdent of the antecedent",fun t-> ANTS_TAC);
(match_g_no_ho[full ` (f x = g x)`],"AP_THM_TAC","drop the function argument",fun t-> AP_THM_TAC);
(match_g_no_ho[full ` (f x y = f x' y)`],"AP_THM_TAC THEN AP_TERM_TAC","show first args of a binary function are equal",fun t-> AP_THM_TAC THEN AP_TERM_TAC);
(match_g[`(\x. f) y`],"BETA_TAC","beta reduce",fun t-> BETA_TAC);
(match_g[full ` (f x y = f x' y')`],"BINOP_TAC","show binary function args equal",fun t-> BINOP_TAC);
(match_g[full ` (f x  = f x' )`],"AP_TERM_TAC","show function args equal",fun t-> AP_TERM_TAC);
(match_g[full `(a /\ b)`],"CONJ_TAC","split into two subgoals",fun t-> CONJ_TAC);
(match_g[full `(a ==>b)`],"DISCH_TAC","discharge antecedent",fun t -> DISCH_TAC);
(match_g[full `(a <=> b)`],"EQ_TAC","split <=> into two conditionals",fun t -> EQ_TAC);
(match_g[full `(?x. t)`],"EXISTS_TAC","specify existence",fun t -> failwith "syntax: EXISTS_TAC `u`");
(match_g[full `(!x. t)`],"GEN_TAC","remove universal",fun t-> GEN_TAC);
(match_g[full `((f:A->B) = g)`],"ONCE_REWRITE_TAC[FUN_EQ_THM]","apply to arg",fun t-> ONCE_REWRITE_TAC[FUN_EQ_THM]);
(match_g[full `(!(x:num). t)`],"INDUCT_TAC","induction",fun t->INDUCT_TAC);
(match_g[full `(!(n:A list). P)`],"LIST_INDUCT_TAC","structure induction on lists",fun t->LIST_INDUCT_TAC);
(match_g[full `(f x = g y)`],"MK_COMB_TAC","show equality of functions and args",fun t->MK_COMB_TAC);
(* (match_g[full `(u:bool)`],"REFUTE_THEN ASSUME_TAC","proof by contradiction",fun t-> REFUTE_THEN ASSUME_TAC); *)
(match_g[`!(p:A#B). P p`],"REWRITE_TAC[FORALL_PAIR_THM]","unpair",fun t->REWRITE_TAC[FORALL_PAIR_THM]);
(match_g[`(?(x,y). P x y)`],"REWRITE_TAC[ EXISTS_PAIRED_THM]"," ",fun t->REWRITE_TAC[ EXISTS_PAIRED_THM]);
(match_g[`(?x y. P x y)`],"REWRITE_TAC[GSYM EXISTS_PAIRED_THM]"," ",fun t->REWRITE_TAC[GSYM EXISTS_PAIRED_THM]);
(match_g[full`x <= (z:real)`],"MATCH_MP_TAC REAL_LE_TRANS","x <= y /\ y <= z ",fun t -> MATCH_MP_TAC REAL_LE_TRANS);
(match_g[full`x < (z:real)`],"MATCH_MP_TAC REAL_LET_TRANS","x <= y /\ y < z ",fun t -> MATCH_MP_TAC REAL_LET_TRANS);
(match_g[full`x < (z:real)`],"MATCH_MP_TAC REAL_LTE_TRANS","x < y /\ y <= z",fun t -> MATCH_MP_TAC REAL_LTE_TRANS);
(match_asm[ full `x \/ y`],"FIRST_X_ASSUM DISJ_CASES_TAC","split x \/ y assumption",fun t -> FIRST_X_ASSUM DISJ_CASES_TAC);
(match_asm[full `?(x:A). y`],"FIRST_X_ASSUM CHOOSE_TAC","choose existential quant in assumption list",fun t-> FIRST_X_ASSUM CHOOSE_TAC);
(match_asm[full `x /\ y`],"FIRST_X_ASSUM (CONJUNCTS_THEN ASSUME_TAC)","split asumption conjunction",fun t->FIRST_X_ASSUM (CONJUNCTS_THEN ASSUME_TAC));
rrrrr
];;

let suggest _ = 
  let s = filter (fun (a,_,_,_) -> a (top_realgoal())) tactic_patterns in
  zip (0-- (List.length s  -1) ) s;;

let print_suggest sg = 
  let print_one (i,(_,_,s,_)) = (print_int i; print_string (": "^s)) in
  map (print_one) sg;;

let s () = let sg = suggest() in ignore(print_suggest sg);;


let eh n = let (_,(_,_,_,tac)) = List.nth (suggest()) n in e(tac());;


let rewrite_suggest = [
 ([`x IN {y}`],"IN_SING",IN_SING);
];;

let rewrites _ =
  let s = filter (fun (a,_,_) -> match_g a (top_realgoal())) rewrite_suggest in
    zip (0-- (List.length s  -1) ) s;;


(* ========================================================================== *)
(* TACTIC ABBREVIATIONS                                              *)



let tactic_abbreviations = ref [
  ("se","SELECT_TAC");
  ("@","SELECT_TAC");
  ("if","COND_CASES_TAC");
  ("cc","COND_CASES_TAC");
  ("r","REWRITE_TAC");
  ("mp","MP_TAC");
("ar","ASM_REWRITE_TAC");
("hc","HYP_CONJ_TAC");
("rt/a","ASM_REWRITE_TAC");
("r/a","ASM_REWRITE_TAC");
("r/o","ONCE_REWRITE_TAC");
("rt/o","ONCE_REWRITE_TAC");
("mmp","MATCH_MP_TAC");
("st","STRIP_TAC");
("st/r","REPEAT STRIP_TAC");
("e","EXISTS_TAC");
("m","MESON_TAC");
("mt/a","ASM_MESON_TAC");
("m/a","ASM_MESON_TAC");
("am","ASM_MESON_TAC");
("c","CONJ_TAC");
("a","ASSUME_TAC");
("g","GEN_TAC");
("g/r","REPEAT GEN_TAC");
("!","GEN_TAC");
("?","EXISTS_TAC");
("/\\","CONJ_TAC");
("sc","SUBCONJ_TAC");
("su","SUBST1_TAC");
("si","SIMP_TAC");
("si/a","ASM_SIMP_TAC");
("asi","ASM_SIMP_TAC");
("sg","SUBGOAL_THEN");
("d","DISCH_TAC");
("an","ANTS_TAC");
("le","LET_TAC");
("l","LET_TAC");
("ra","REAL_ARITH_TAC");
("p","POP_ASSUM");
("p/r","REPEAT POP_ASSUM");
];;

let break_init init s = 
  let l_init = String.length init  in
  let _ = (String.sub s 0 l_init = init) or failwith "mismatch break_init" in
    String.sub s (l_init) (String.length s - l_init);;

let el_to_hash s i = 
  let el_assoc = [
    ("u","HASH_UNDISCH_TAC");
    ("r","HASH_RULE_TAC");
    ("k","HASH_KILL_TAC");
    ("c","HASH_CHOOSE_TAC");
    ("x","HASH_X_CHOOSE_TAC");
    ("a","HASH_ASM_REWRITE_TAC")] in
  let tac = assoc s el_assoc in
  let h = el_hash i (top_realgoal()) in
    tac ^ " " ^ (string_of_int h);;

let unabbrev_tactic  = 
  let alpha_num = Str.regexp "[a-z_A-Z]+" in
  fun s->
  let assoc_u s = assoc s !tactic_abbreviations in
  let assoc_ut s = 
    let len = String.length s in
    let _ = (s.[len-1]= 't') or failwith "final char t" in
      assoc_u (String.sub s 0 (len -1)) in
  let sg s = 
    let n = int_of_string (break_init "sg" s) in 
    let (_,(_,u,_,_)) = el n (suggest()) in
      u in
  let hash s = 
    let rest = break_init "el" s in
    let c = String.sub rest 0 1 in
    let n = int_of_string (String.sub rest 1 (String.length rest - 1)) in
      el_to_hash c n in
  let tachit s = 
    let _ = Str.string_match alpha_num s 0 or failwith "tachit" in
    let m = Str.matched_string s in
    let br =  (break_init m s) in
    let n = if (String.length br > 0) then int_of_string br else 0 in
      el n (tachy m)   in
  let literal s = 
    let rest = break_init "-l" s in
      rest in
    tryfind (fun f -> f s) [assoc_u;assoc_ut;sg;hash;literal;tachit];; 

(*
let escape s = 
  let ss = Str.split (Str.regexp "\"") s in
  let s = unsplit "\\\"" I ss in
  let ss = Str.split (Str.regexp "\\ ") s in
  let s = unsplit "\\\\ " I ss in
    s;;
*)

let p() = 
  let _ = print_string (string_of_proof()) in
    if (!current_goalstack=[]) then print_string "There is no current goal." 
    else 
      let _ = Print_types.print_goal_var_overload() in
      let _ = print_goalstack (!current_goalstack) in
	();;

let eval_tactic_abbrev s = 
  let expand_s = 
    try(
      let i = String.index s ',' in
      let pre = String.sub s 0 i in
      let post = String.sub s (i+1) (String.length s - (i+1)) in
	((unabbrev_tactic pre)^" "^post) 
    )
    with _ -> s in
 (* let _ = print_string (String.escaped expand_s) in *)
  let _ = eval_tactic (expand_s) in
    p();;

let e_abbrev = eval_tactic_abbrev;;

let g = eval_goal;;

let b() = 
  let _ = eval_back() in p();;


(*
let directive_abbreviations= ref[
  ("-b",eval_back);
  ("-?",fun () ->
     let s = map snd tactic_counts in
     let s1 = unsplit ": " 
];;
*)


(* ========================================================================== *)
(* APROPOS *)


let apropos_alist = ref [];;

let apropos_a t = 
  let _ = (apropos_alist:= t::!apropos_alist) in ();;

let apropos_keys = map fst !apropos_alist;;

let apropos s = 
  let re = Str.regexp s in
     filter (fun (u,_) -> Str.string_match re u 0) !apropos_alist;;

let docstring = ref [];;
let doc () = !docstring;;
let doc_a s = docstring := s::!docstring;;


(* ========================================================================== *)
(* TYPES *)


let types_of = Print_types.print_term_types;;
let type_of_thm = Print_types.print_thm_types;;
let type_of_goal = Print_types.print_goal_types;;


end;;  
