#load "str.cma";;


module Searching = struct


(* 

    Different search results.
   search: Theorem list
   constant list
   index: Help index list
   help: help doc.

   All the searches with the same return type should be combined.


*)


(* quicksilver style search for name matching.
    ignore case and look for nonconsecutive letters. *)

let unsplit d f = function
  | (x::xs) ->  List.fold_left (fun s t -> s^d^(f t)) (f x) xs
  | [] -> "";;

let match_sparse s u = 
  let re = Str.regexp_case_fold (".*"^(unsplit ".*" I (   explode s))) in
    Str.string_match re u 0;;


(* ========================================================================== *)
(* HELP                                              *)


let hollight_dir = 
  (try Sys.getenv "HOLLIGHT_DIR" with Not_found -> Sys.getcwd());;

(* hol-light help path *)

let helpdirs = ref [
  Filename.concat flyspeck_dir "../help";
  Filename.concat hollight_dir "Help"
 ];;

help_path := !helpdirs @ (!help_path);; (* hol-light help *)

(* let help_h = ref [];; *)
let help_grep_h = ref[];;
let search_h = ref[];;

let update i h = (h:= i:: !h);;
let history n h = fst(chop_list n h);;

let help_grep pat = 
  let _ = update pat help_grep_h in
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; ls | sed 's/.doc$//g' | grep '" ^pat^ "')") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

(*
if pat starts with - then it should be taken as a flags command.
*)

let help_grep_flags pat flags = 
  let _ = update pat help_grep_h in
  let split =   Str.split (Str.regexp "\n") in
  let cmd s = process_to_string ("(cd "  ^s^  "; ls | sed 's/.doc$//g' | grep -"^flags^" '" ^pat^ "')") in
  List.flatten (map ( split o cmd ) (!helpdirs));;

help_grep_flags "r.*w" "i";;

(*  
Example:
help_grep "ASM.*REWRITE";;
help_grep "^ASM_";;
help_grep "help";;
help_grep "RULE";;
help_grep "ARITH";;
help_grep "_TAC$";;
List.length (help_grep ".*");;
*)


(* ========================================================================== *)
(* SEARCH *)




(* grab a definition, or anything vaguely similar to a definition. *)

let constant_of_regexp ss = 
  let re = Str.regexp_case_fold (".*"^ss) in
  let c = map fst (constants()) in
   filter (fun s -> Str.string_match re s 0) c;;

(* examples:

constant_of_regexp ".*contin";;
constant_of_regexp ".*integr";;
constant_of_regexp ".*auchy";;
constant_of_regexp "at.*[ng]$";;

*)

let searcht n pat = 
  let raw = search pat in
  let len = List.length raw in
(*  let _ =  (len <= !search_limit) or 
    failwith (string_of_int len^" matches, reset Searching.search_limit") in *)
  let m = min n (List.length raw) in
  let s = sortlength_thml raw in
    fst (chop_list m s);;


let nsearch,select  = 
  let selection = ref [] in
  let nsearch v = 
    let u = search v in
    let _ = selection := u in
    let r = List.length u in
      map (fun (n,(s,th)) -> (n,s,th)) (zip (0--(r-1)) u) in
  let select n = fst(List.nth !selection n) in
    nsearch,select;;

(* ========================================================================== *)
(* EVAL *)

(*
eval_command comes from

http://solaria.dimino.org/cgi-bin/darcsweb.cgi?r=peps;a=headblob;f=/src/core/peps_top.ml
License: BSD3
*)


let eval_command ?(silent=false) command =
   let buffer = Buffer.create 512 in
   let pp = Format.formatter_of_buffer buffer in
   Format.pp_set_margin pp max_int;
   try
     let _ =
       Toploop.execute_phrase (not silent) pp
         (!Toploop.parse_toplevel_phrase (Lexing.from_string (command ^ ";;")))
     in
     (true, Buffer.contents buffer)
   with exn ->
     let save = !Toploop.parse_use_file in
     Toploop.parse_use_file := (fun _ -> raise exn);
     ignore (Toploop.use_silently pp "/dev/null");
     Toploop.parse_use_file := save;
     (false,  Buffer.contents buffer);;

(* eval_command ~silent:false "g `x=y`";; *)

type proof_record = Tax of string*tactic | Bax | Gax of term;;

let proof_record  =ref [];;
let tactic_cache = ref ALL_TAC;;

let eval_tactic  = 
  fun s ->
    let (b,r) = eval_command ~silent:true ("tactic_cache := "^s^";;") in
    let _ = b or failwith r in
    let t= !tactic_cache in
    let v = e(t) in
    let _ = proof_record := Tax (s,t)::!proof_record in
      v;;

let eval_goal t = 
  let _ = proof_record := Gax t::!proof_record in
    g(t);;

let eval_back () = 
  let _ = proof_record := Bax::!proof_record in
    b();;

(*
eval_goal `1 + 1 = 2`;;
eval_tactic "REPEAT STRIP_TAC";;
eval_back();;
eval_tactic "ARITH_TAC";;
eval_tactic "REWRITE_TAC[TRUTH]";;
*)

let rec strs_of_proof_records skip buf  = function
    [] -> buf
  | Gax _ :: xs -> buf
  | Tax (s,_) :: xs -> if (skip=0) then strs_of_proof_records skip (s::buf) xs
    else strs_of_proof_records (skip-1) buf xs
  | Bax :: xs -> strs_of_proof_records (skip+1) buf xs;;

let string_of_proof () = 
  let ss = strs_of_proof_records 0 [] !proof_record in
    "\n[\n"^unsplit ";\n" I (List.rev ss) ^"\n]\n";;

(*
print_string (string_of_proof());;
*)   

(* ========================================================================== *)
(* STATS *)


(* get all word counts in HOL LIGHT and FLYSPECK *)

let wc_tmpfile = Filename.temp_file "tmp_" ".txt";;

let int_tmpfile = 
  let ss1 = process_to_string ("ls /Users/thomashales/Desktop/googlecode/flyspeck/text_formalization/*/*.hl") in
  let ss2 = Str.split (Str.regexp "\n") ss1 in
  let ss1 = process_to_string ("ls /Users/thomashales/Desktop/googlecode/hol_light/*/*.ml") in
  let ss2 =  Str.split (Str.regexp "\n") ss1 @ ss2 in
  let tmpfile =  wc_tmpfile in
  let _ =     Sys.command("touch "^tmpfile) in
  let _ =     map (fun s -> Sys.command("cat "^ s^ " >> " ^ tmpfile)) ss2 in
    ();;

let word_counts() = 
  let sout = Str.split (Str.regexp "\n") (process_to_string("cat "^wc_tmpfile^" | tr -C 'A-Z:a-z0-9_' '\n' | sort | uniq -c | sed 's/^ *//'")) in
  let sout1 = map (Str.split (Str.regexp " ")) sout in
  let sout2 = filter (fun t -> List.length t = 2) sout1 in
  let sout3 = map (function | [a;b]-> (b,int_of_string a) | _ -> ("?",0)) sout2 in
    sout3;;

let word_count_list = word_counts();;


(* word counts of theorems *)

(* word counts of tactic following repeat.

grep -r "\bREPEAT\b" . | grep -v svn | sed 's/^.*REPEAT *//' | sed 's/^[^a-zA-Z].*$//g' | sed 's/ .*$//g' | tr -C 'A-Za-z_' '\n' | sed 's/ //g' | sort | uniq -c | sed 's/^ *//'



*)

(* stats of the word immediately following another word *)

let trigger_counts trigger = 
  let sed_pipe = Printf.sprintf "grep '%s ' %s | sed 's/^.*%s *//'  | sed 's/^[^a-z.A-Z]*//g' | sed 's/ .*$//g' | tr -C 'A-Z.a-z_0-9' '\n' | sed 's/ //g' | sort | uniq -c | sed 's/^ *//'" 
    trigger wc_tmpfile trigger in 
  let sout = Str.split (Str.regexp "\n") 
    (process_to_string(sed_pipe )) in
  let sout1 = map (Str.split (Str.regexp " ")) sout in
  let sout2 = filter (fun t -> List.length t = 2) sout1 in
  let sout3 = map (function | [a;b]-> (b,int_of_string a) | _ -> ("?",0)) sout2 in
    sort (fun (_,a) (_,b) -> (a > b)) sout3;;

(*
map (fun s -> (s,trigger_counts s)) ["REPEAT";"GSYM";"MATCH_MP_TAC";" MP_TAC";"REWRITE_TAC"];;

map (fun s -> (s,trigger_counts s)) ["POP_ASSUM";"ALL_THEN"; "ANTE_RES_THEN"; 
   " CHOOSE_THEN"; "CONJUNCTS_THEN";
   "CONJUNCTS_THEN2"; "DISCH_THEN"; "DISJ_CASES_THEN"; "DISJ_CASES_THEN2";
   "FREEZE_THEN"; "IMP_RES_THEN"; "NO_THEN"; "REFUTE_THEN"; "REMOVE_THEN";
   "STRIP_GOAL_THEN"; "STRIP_THM_THEN"; "SUBGOAL_THEN"; "THEN"; "THENC";
   "THENL"; "THEN_TCL"; "UNDISCH_THEN"; "USE_THEN"; "X_CHOOSE_THEN"];;

trigger_counts "MATCH_MP_TAC";;
trigger_counts "REWRITE_RULE";;
trigger_counts " CHOOSE_THEN";;
trigger_counts " POP_ASSUM";;
help "X_CHOOSE_THEN";;
*)

(* inaccurate because constants and theorems with the same name are overcounted *)

let thm_count_list = 
  let alpha_thm = sort (<) (map fst !theorems) in
  let rec build buff ats bts = match (ats,bts) with
    | ([],_) -> buff
    | (_,[]) -> buff
    | (a::atss,(b,n)::btss) -> if (a=b) then build ((b,n)::buff) atss btss
      else if (a>b) then build buff ats btss else build buff atss bts in
  sort (fun (_,a) (_,b) -> (a > b)) (build [] (alpha_thm) word_count_list);;

let tactic_list =  (help_grep "TAC$");;

let then_list =  (help_grep "THEN");;

let tactic_counts = sort (fun (_,a) (_,b) -> (a > b)) 
  (filter (fun (a,_) -> mem a  (["REPEAT";"POP_ASSUM";"FIRST_X_ASSUM";"FIRST_ASSUM"] @ tactic_list @ then_list)) word_count_list);;


  
(* ========================================================================== *)
(* TACTIC                                              *)

(* searching for relevant tactics *)


let tachy  s = 
  filter (match_sparse s) (map fst tactic_counts);;


(* term matching without higher order matches *)

  let SELECT_TAC = Tactics.SELECT_TAC;;

let term_match_no_ho pat u = 
  let (_,b,c) = (term_match[] pat u) in
  let v = instantiate ([],b,c) pat in 
    aconv v u  or failwith "no match";;

let match_g_no_ho pat (_,w) = not(search_thml term_match_no_ho pat [("", ASSUME w)] = []);;

let match_g pat (_,w) = not(search_thml (term_match[]) pat [("", ASSUME w)] = []);;

let match_asm pat (asl,_) = not(search_thml term_match_no_ho pat asl = []);;




(* let assum t = mk_comb(mk_var("<assum>",W mk_fun_ty (type_of t)),t);; *)

(* 

trigger pattern;
English text;
prompt;
tactic;

*)

let rrrrr = (match_g[`let x = (y:A) in (z:B)`],"LET_TAC","let elimination",fun t -> LET_TAC);;



let tactic_patterns  = [
(match_g[`(@):(A->bool)->A`],"SELECT_ELIM_TAC","remove @",fun t-> SELECT_ELIM_TAC);
(match_g[`(@):(A->bool)->A`],"SELECT_TAC","remove @ with subgoals depending satisfiability",fun t-> SELECT_TAC);
(match_g[full `(\x. f x = \x. g x)`],"ABS_TAC","strip abstractions from equality",fun t-> ABS_TAC);
(match_g[full ` ((p ==> q) ==> r)`],"ANTS_TAC","split off the antecdent of the antecedent",fun t-> ANTS_TAC);
(match_g_no_ho[full ` (f x = g x)`],"AP_THM_TAC","drop the function argument",fun t-> AP_THM_TAC);
(match_g_no_ho[full ` (f x y = f x' y)`],"AP_THM_TAC THEN AP_TERM_TAC","show first args of a binary function are equal",fun t-> AP_THM_TAC THEN AP_TERM_TAC);
(match_g[`(\x. f) y`],"BETA_TAC","beta reduce",fun t-> BETA_TAC);
(match_g[full ` (f x y = f x' y')`],"BINOP_TAC","show binary function args equal",fun t-> BINOP_TAC);
(match_g[full ` (f x  = f x' )`],"AP_TERM_TAC","show function args equal",fun t-> AP_TERM_TAC);
(match_g[full `(a /\ b)`],"CONJ_TAC","split into two subgoals",fun t-> CONJ_TAC);
(match_g[full `(a ==>b)`],"DISCH_TAC","discharge antecedent",fun t -> DISCH_TAC);
(match_g[full `(a <=> b)`],"EQ_TAC","split biconditional into two conditionals",fun t -> EQ_TAC);
(match_g[full `(?x. t)`],"EXISTS_TAC","specify existence",fun t -> failwith "syntax: EXISTS_TAC `u`");
(match_g[full `(!x. t)`],"GEN_TAC","remove universal",fun t-> GEN_TAC);
(match_g[full `((f:A->B) = g)`],"ONCE_REWRITE_TAC[FUN_EQ_THM]","apply to arg",fun t-> ONCE_REWRITE_TAC[FUN_EQ_THM]);
(match_g[full `(!(x:num). t)`],"INDUCT_TAC","induction",fun t->INDUCT_TAC);
(match_g[full `(!(n:A list). P)`],"LIST_INDUCT_TAC","structure induction on lists",fun t->LIST_INDUCT_TAC);
(match_g[full `(f x = g y)`],"MK_COMB_TAC","show equality of functions and args",fun t->MK_COMB_TAC);
(* (match_g[full `(u:bool)`],"REFUTE_THEN ASSUME_TAC","proof by contradiction",fun t-> REFUTE_THEN ASSUME_TAC); *)
(match_g[`!(p:A#B). P p`],"REWRITE_TAC[FORALL_PAIR_THM]","unpair",fun t->REWRITE_TAC[FORALL_PAIR_THM]);
(match_g[`(?(x,y). P x y)`],"REWRITE_TAC[ EXISTS_PAIRED_THM]"," ",fun t->REWRITE_TAC[ EXISTS_PAIRED_THM]);
(match_g[`(?x y. P x y)`],"REWRITE_TAC[GSYM EXISTS_PAIRED_THM]"," ",fun t->REWRITE_TAC[GSYM EXISTS_PAIRED_THM]);
(match_g[full`x <= (z:real)`],"MATCH_MP_TAC REAL_LE_TRANS","x <= y /\ y <= z ",fun t -> MATCH_MP_TAC REAL_LE_TRANS);
(match_g[full`x < (z:real)`],"MATCH_MP_TAC REAL_LET_TRANS","x <= y /\ y < z ",fun t -> MATCH_MP_TAC REAL_LET_TRANS);
(match_g[full`x < (z:real)`],"MATCH_MP_TAC REAL_LTE_TRANS","x < y /\ y <= z",fun t -> MATCH_MP_TAC REAL_LTE_TRANS);
(match_asm[ full `x \/ y`],"FIRST_X_ASSUM DISJ_CASES_TAC","split x \/ y assumption",fun t -> FIRST_X_ASSUM DISJ_CASES_TAC);
(match_asm[full `?(x:A). y`],"FIRST_X_ASSUM CHOOSE_TAC","choose existential quant in assumption list",fun t-> FIRST_X_ASSUM CHOOSE_TAC);
(match_asm[full `x /\ y`],"FIRST_X_ASSUM (CONJUNCTS_THEN ASSUME_TAC)","split asumption conjunction",fun t->FIRST_X_ASSUM (CONJUNCTS_THEN ASSUME_TAC));
rrrrr
];;

let suggest _ = 
  let s = filter (fun (a,_,_,_) -> a (top_realgoal())) tactic_patterns in
  zip (0-- (List.length s  -1) ) s;;

let s _ = suggest();;

let eh n = let (_,(_,_,_,tac)) = List.nth (suggest()) n in e(tac());;


let rewrite_suggest = [
 ([`x IN {y}`],"IN_SING",IN_SING);
];;

let rewrites _ =
  let s = filter (fun (a,_,_) -> match_g a (top_realgoal())) rewrite_suggest in
    zip (0-- (List.length s  -1) ) s;;


(* ========================================================================== *)
(* APROPOS *)


let apropos_alist = ref [];;

let apropos_a t = 
  let _ = (apropos_alist:= t::!apropos_alist) in ();;

let apropos_keys = map fst !apropos_alist;;

let apropos s = 
  let re = Str.regexp s in
     filter (fun (u,_) -> Str.string_match re u 0) !apropos_alist;;

let docstring = ref [];;
let doc () = !docstring;;
let doc_a s = docstring := s::!docstring;;


(* ========================================================================== *)
(* TYPES *)


let types_of = Print_types.print_term_types;;
let type_of_thm = Print_types.print_thm_types;;
let type_of_goal = Print_types.print_goal_types;;



end;;  
