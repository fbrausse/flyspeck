(* ========================================================================== *)
(* FLYSPECK - BOOK FORMALIZATION                                              *)
(* Author: Thomas C. Hales                                                    *)
(* Date: 2011-06-18                                                           *)
(* ========================================================================== *)


(* Tactics used by Hales.  Warning: These are subject to change.   *)

module Hales_tactic = struct

(* GSYM theorems explicit *)

let GSYM_EXISTS_PAIRED_THM = GSYM EXISTS_PAIRED_THM;;


let has_stv t =
  let typ = (type_vars_in_term t) in
  can (find (fun ty -> (is_vartype ty) && ((dest_vartype ty).[0] = '?'))) typ;;

let frees_of_goal (asl,w) = 
  let tms = w::(map (concl o snd) asl)  in
  let varl = List.flatten (map frees tms) in
    map (fun t -> (fst (dest_var t), t)) varl;;

let env (asl,w) tm = 
  let gls = frees_of_goal (asl,w) in
  let varl = filter has_stv (setify(frees tm)) in
  let svarl = map (fun t-> (fst(dest_var t),t)) varl in
  let fn = fun buff (s,t) -> try (let (_,_,m)= term_match [] t (assoc s gls) in m @ buff)
  with _ -> failwith ("not found: "^s) in
  let tyassoc = List.fold_left fn [] svarl in
     (instantiate ([],[],tyassoc)) tm ;;

let envl (asl,w) tml = 
  let gls = frees_of_goal (asl,w) in
  let varl = filter has_stv (setify (List.flatten(map frees tml))) in
  let svarl = setify(map (fun t-> (fst(dest_var t),t)) varl) in
  let fn = fun buff (s,t) -> try (let (_,_,m)= term_match [] t (assoc s gls) in m @ buff)
  with _ -> failwith ("not found: "^s) in
  let tyassoc = List.fold_left fn [] svarl in
     map (instantiate ([],[],tyassoc)) tml ;;

let gtyp (ttac:term->tactic) tm (asl,w) = ttac (env (asl,w) tm) (asl,w);;

let gtypl (ttacl:term list -> tactic) tml (asl,w) =   
   ttacl (map (env (asl,w)) tml) (asl,w);;


let GEXISTS_TAC = gtyp EXISTS_TAC;;

let GSUBGOAL_THEN t ttac (asl,w) = SUBGOAL_THEN (env (asl,w) t) ttac (asl,w);;

let argthen ttac tac t = (ttac t) THEN tac;;

let unlist tac t = tac [t];;

let CONJ2_TAC = let t = (TAUT `a /\ b ==> b /\ a`) in MATCH_MP_TAC t THEN CONJ_TAC;;


(* ========================================================================== *)
(* TACTIC                                              *)

let FORCE_EQ = REPEAT (CHANGED_TAC (AP_TERM_TAC ORELSE AP_THM_TAC ORELSE BINOP_TAC)) ;;

let FORCE_MATCH = (MATCH_MP_TAC (TAUT `(a = b) ==> (a ==> b)`)) THEN FORCE_EQ ;;

let FORCE_MATCH_MP_TAC th = 
  MP_TAC th THEN ANTS_TAC THENL[ALL_TAC;FORCE_MATCH
      ];;

let HYP_CONJ_TAC = 
  let th = TAUT `(a ==> b==> c) ==> (a /\ b ==> c)`  in
    FIRST_X_ASSUM (fun t-> MP_TAC t THEN MATCH_MP_TAC th THEN DISCH_TAC THEN DISCH_TAC);;

(* ******************************
UNSORTED
****************************** *)

let SELECT_TAC = Tactics.SELECT_TAC;;

let COMMENT _ = ALL_TAC;;

let NAME _ = ALL_TAC;;

let ROT_TAC =  (* permute conjuncts *)
  let     t1 = TAUT `b /\ a ==> a /\ b` in
  let t2 = TAUT `((b /\ c) /\ a) = (b /\ c /\ a)` in
    MATCH_MP_TAC t1 THEN PURE_REWRITE_TAC[t2];;

let ENOUGH_TO_SHOW_TAC t = 
  let u = INST [(t,`A:bool`)] (TAUT ` ((A ==> B) /\ A) ==> B`) in
    MATCH_MP_TAC u THEN CONJ_TAC;;

(* like FIRST_X_ASSUM, except some subterm has to match t *)

let FIRST_X_ASSUM_ST t x = 
  FIRST_X_ASSUM (fun u -> 
    let _ = find_term (can(term_match[] t)) (concl u) in x u);;

let BURY_TAC t (asl,w) = 
  let n = List.length asl in
    (REPEAT (FIRST_X_ASSUM MP_TAC) THEN ASSUME_TAC t THEN 
      REPLICATE_TAC n DISCH_TAC)(asl,w);;

(* out of load sequence. Moved to Calc_derivative module.
let CALC_ID_TAC (asl,t) =  (MATCH_MP_TAC (Calc_derivative.rational_identity t) (asl,t));;
*)

let GOAL_TERM ttac g = (ttac g) g;;


(* puts the hypotheses of a conditional rewrite as a conjunct, rather than 
   trying to prove them 
  thm should have the form a ==> (b = c)  or the form  a ==> b.
   Doesn't do matching on bound variables.
  *)

let GMATCH_SIMP_TAC thm (asl,w) = 
  let lift_eq_thm = MESON[]   `! a b c. (a ==> ((b:B) = c)) ==> (!P. a /\ P c ==> P b)` in
  let lift_eq thm = GEN_ALL (MATCH_MP lift_eq_thm (SPEC_ALL thm)) in
  let thm' = hd (mk_rewrites true thm []) in
  let t1 = fst (dest_eq(snd (dest_imp(concl(thm'))))) in
  let matcher u t = 
    let m = term_match [] t1 t in
    let _ = subset (frees t) (frees u) or failwith "" in
      m in
  let w' = find_term (can (matcher w)) w in
  let var1 = mk_var("v",type_of w') in
  let vv = variant (frees w) var1 in
  let athm = REWRITE_CONV[ ASSUME (mk_eq (w',vv))] w in
  let bthm = (ISPECL [mk_abs(vv,rhs (concl athm));w'] BETA_THM) in
  let betx = SYM(TRANS bthm (BETA_CONV (rhs (concl bthm)))) in
   (ONCE_REWRITE_TAC[betx] THEN MATCH_MP_TAC (lift_eq thm') THEN 
      BETA_TAC THEN REWRITE_TAC[]) (asl,w);;


(*
let ASM_REAL_ARITH_TAC t = 
  REPEAT (POP_ASSUM MP_TAC) THEN MP_TAC (itlist CONJ t TRUTH) THEN
    REAL_ARITH_TAC;;

let MP_LIST t = EVERY (map MP_TAC t);;
*)



(* Gonthier's script organizational tactics. *)

let BY (t:tactic) (asl,w) = 
  let (a,b,c)  = t (asl,w) in
  let _ = (b = []) or failwith "by failed to finish goal" in
    (a,b,c);;

let BRANCH_A (t::tl) = t THENL [EVERY tl;ALL_TAC];;

let BRANCH_B (t::tl) = t THENL [ALL_TAC;EVERY tl];;

(* a few from Jordan *)

let X_IN = Tactics_jordan.un;;

let SUBCONJ_TAC = Tactics_jordan.SUBCONJ_TAC;;

let PROOF_BY_CONTR_TAC = Tactics_jordan.PROOF_BY_CONTR_TAC;;

let UNDISCH_FIND_TAC = Tactics_jordan.UNDISCH_FIND_TAC;;

let TYPE_THEN = Tactics_jordan.TYPE_THEN;;

let TYPEL_THEN = Tactics_jordan.TYPEL_THEN;;

let (EXISTSv_TAC :string -> tactic) = 
   fun s (asl,g) ->
     let (v,_) = dest_binder "?" g in 
     let (_,ty) = dest_var v in
       EXISTS_TAC (mk_var(s,ty)) (asl,g);;

let (X_GENv_TAC:string ->tactic) = 
   fun s (asl,g) ->
     let (v,_) = dest_binder "!" g in 
     let (_,ty) = dest_var v in
       X_GEN_TAC (mk_var(s,ty)) (asl,g);;

(* weak version doesn't do conj *)

let (WEAK_STRIP_TAC: tactic) =
  fun g ->
    try (fun ttac -> FIRST [GEN_TAC; DISCH_THEN ttac]) STRIP_ASSUME_TAC g
    with Failure _ -> failwith "STRIP_TAC";;




(* working with hashed assumptions *)

let hash_of_term = Hash_term.hash_of_term;;

let HASH_UNDISCH_TAC h = 
  FIRST_X_ASSUM (fun t-> 
		   let _ = (hash_of_term  (concl t) = h) or failwith "bad hash" in
		     MP_TAC t);;

let HASH_COPY_TAC h = HASH_UNDISCH_TAC h THEN (DISCH_THEN (fun t -> ASSUME_TAC t THEN ASSUME_TAC t));;

let HASH_RULE_TAC h r = HASH_UNDISCH_TAC h THEN DISCH_THEN (fun t -> MP_TAC (r t));;

let HASH_KILL_TAC h = HASH_UNDISCH_TAC h THEN (DISCH_THEN (fun t -> ALL_TAC));;

let HASH_CHOOSE_TAC h = HASH_UNDISCH_TAC h THEN (DISCH_THEN CHOOSE_TAC);;

let HASH_X_CHOOSE_TAC h t = HASH_UNDISCH_TAC h THEN (DISCH_THEN (X_CHOOSE_TAC t));;
   
let HASH_ASM_REWRITE_TAC h (asl,w)  = 
  let (asl2) = filter (fun t -> not(hash_of_term (concl (snd t)) = h)) asl in
    (HASH_UNDISCH_TAC h THEN 
       DISCH_THEN (fun t-> ASSUME_TAC(REWRITE_RULE (map snd asl2) t))) (asl,w);;

(* working with numbered assumptions, 
    Follow HOL Light's reverse numbering convention on assumptions. *)

let el_hash  i  (asl,w)   = 
   hash_of_term (el i (map (concl o snd) (List.rev asl)));;

let use_el i ttac (asl,w) = 
  let h = el_hash i (asl,w) in
    (HASH_UNDISCH_TAC h THEN (DISCH_THEN ttac)) (asl,w);;

(*

let hashify0 i f  (asl,w) = f (el_hash i (asl,w)) (asl,w);;

let hashify1 i f r  (asl,w) = f (el_hash i (asl,w)) r (asl,w);;

let EL_UNDISCH_TAC i = hashify0 i HASH_UNDISCH_TAC;;

let EL_RULE_TAC i r =hashify1 i r HASH_RULE_TAC;;

let EL_KILL_TAC i = hashify0 i HASH_KILL_TAC;;

let EL_CHOOSE_TAC i =  hashify0 i HASH_CHOOSE_TAC;;

let EL_X_CHOOSE_TAC i t = hashify1 i t HASH_X_CHOOSE_TAC;;

let EL_ASM_REWRITE_TAC i = hashify0 i HASH_ASM_REWRITE_TAC;;

*)

let hold_def = new_definition `(hold:A->A) = I`;;

let hold = MATCH_MP_TAC (prove_by_refinement(
  `!a. hold a ==> a`,  [REWRITE_TAC [hold_def;I_DEF]  ]));;

let unhold = MATCH_MP_TAC (prove_by_refinement(
  `!a. a ==> hold a`,  [REWRITE_TAC [hold_def;I_DEF]  ]));;

let MP_ASM_THEN = 
  fun tac -> hold THEN 
    (REPEAT (POP_ASSUM MP_TAC)) THEN 
    tac THEN REPEAT DISCH_TAC 
    THEN unhold;;

let FULL_EXPAND_TAC s = FIRST_ASSUM (fun t -> 
  let _ = (s = fst(dest_var(rhs(concl t)))) or failwith "" in
    (MP_ASM_THEN (SUBST1_TAC (SYM t) THEN BETA_TAC)));;

let RENAME_VAR (t,s) = 
  let svar = mk_var (s,snd(dest_var t)) in
    MP_ASM_THEN (SPEC_TAC (t,svar) THEN GEN_TAC);;

(* UNDISCHARGE BY SEARCH *)

let FIRST_SEARCH pat (asl,w) = 
  let asl' = map (concl o snd) (search_thml (term_match[]) pat asl) in
    FIRST (map UNDISCH_TAC asl') (asl,w);;

let ALL_SEARCH pat (asl,w) = 
  let asl' = map (concl o snd) (search_thml (term_match[]) pat asl) in
    EVERY (map UNDISCH_TAC asl') (asl,w);;

(* MISCELL. *)

let arith tm  = 
  let v = [ARITH_RULE;REAL_ARITH;(fun t -> prove(t,SIMPLE_COMPLEX_ARITH_TAC));REAL_RING;VECTOR_ARITH] in
    tryfind (fun h -> h tm) v;;

let varith = VECTOR_ARITH;;

let COMMENT _ = ALL_TAC;;

let INTRO_TAC th1 tml = 
   GOAL_TERM (fun w -> (MP_TAC (ISPECL ( envl w tml) th1)));;

  let kill th = ALL_TAC;;
  
end;;
