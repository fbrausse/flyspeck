needs "../formal_lp/hypermap/main/lp_certificate.hl";;
needs "../formal_lp/hypermap/computations/informal_computations.hl";;
needs "../formal_lp/glpk/lpproc.hl";;

let mem_stat () =
  let stat = Gc.stat() in
  let word = float_of_int (Sys.word_size / 8) in
  let free = float_of_int stat.Gc.free_words *. word /. 1024.0 in
  let total = float_of_int stat.Gc.heap_words *. word /. 1024.0 in
  let allocated = total -. free in
  let str = sprintf "allocated = %f (free = %f; total_size = %f; %f)\n" 
    allocated free total (free /. total) in
    print_string str;;

(*
mem_stat();;

Gc.set { (Gc.get()) with Gc.verbose = 0x05 };;
Gc.compact();;

mem_stat();;
*)

let empty_constraints : (Lp_certificate.constraint_type list) = [];;

let hypermap_string = ref "" and
    precision = ref 0 and
    constraints = ref empty_constraints and
    variable_bounds = ref empty_constraints and
    target_variables = ref empty_constraints;;


open Glpk_link;;
open Lp_informal_computations;;
open Lpproc;;
open List;;
open Lp_certificate;;

let run_command dir com =
  let cur_dir = Sys.getcwd() in
  let _ = Sys.chdir dir in
  let result = Sys.command com in
  let _ = Sys.chdir cur_dir in
    result;;


(* make_model();; *)
let com = sprintf "sed -e 's/maximize objective:.*/maximize objective: sum{i in node} ln[i];/' -e 's/lnsum_def:.*//' %s > model2.mod" model;;
run_command tame_dir com;;

let model2 = tame_dir ^ "/model2.mod";;


let out_dir = flyspeck_dir ^ "/../formal_lp/glpk/tmp";;
let binary_dir = flyspeck_dir ^ "/../formal_lp/glpk/binary";;
let lp_hl_dir = flyspeck_dir ^ "/../formal_lp/LP-HL/LP-HL/bin/Release";;

let ampl_of_bb' fname bb =
  let out = open_out fname in
  let _ = ampl_of_bb out bb in
    close_out out;;


let save_string fname str =
  let out = open_out fname in
  let _ = Printf.fprintf out "%s" str in
    close_out out;;


let find_index p list = fst (find (fun _,x -> p x) (Glpk_link.enumerate list));;

let find_face_index fs f =
  let rots = Glpk_link.rotation [f] in
  let rec find fs =
    match fs with
      | [] -> failwith "find_face_index"
      | h :: t ->
	  let eq = fold_right (or) (map ((=) h) rots) false in
	    if eq then 0 else find t + 1 in
    find fs;;


let build_permutation fs0 fs = map (fun f -> find_face_index fs f) fs0;;


let gen_splits list face =
  let pairs = list_pairs face in
    if length face = 4 then
      let darts = [nth pairs 0; nth pairs 1] in
      let splits = map (split_list list) darts in
	([], list) :: zip (map (fun x -> [x]) darts) splits
    else
      failwith "gen_splits: length face <> 4";;


let save_info out_dir name hyp_list bb =
  let f2 = faces bb in
  let perm = build_permutation hyp_list f2 in
  let _ = ampl_of_bb' (sprintf "%s/%s_pars.txt" out_dir name) bb in
  let perm_str = unsplit ", " string_of_int perm in
  let hyp_str = unsplit ";" (unsplit "," string_of_int) hyp_list in
  let p = sprintf in
  let lines = [
    p "name: %s" name;
    p "hypermap: %s" hyp_str;
    p "faces: %s" perm_str;
  ] in
    save_string (out_dir ^ "/flyspeck-" ^ name ^ ".txt") (join_lines lines);;



let clean_out_dir =
  let permanent_files = [
    "000.txt";
    "string_archive.txt";
  ] in
    fun () ->
      let files = Array.to_list (Sys.readdir out_dir) in
      let files' = filter (fun name -> not (mem name permanent_files)) files in
      let _ = map (fun name -> Sys.remove (sprintf "%s/%s" out_dir name)) files' in
	();;
	


(* Builds a terminal case from the given hypermap *)
let build_terminal_case hyp_list bb =
  let _ = clean_out_dir() in
  let out_name = "out" in
  let _ = save_info out_dir out_name hyp_list bb in
  let data_file = sprintf "%s_pars.txt" out_name in
  let solve_com = sprintf "glpsol -m %s -d %s -w %s.txt --wcpxlp %s.lp > /dev/null"  model2 data_file out_name out_name in
  let result = run_command out_dir solve_com in
    if result <> 0 then
      failwith (sprintf "build_terminal_case: glpsol failed for %s" bb.hypermap_id)
    else
      let com = sprintf "mono %s/LP-HL.exe %s" lp_hl_dir (sprintf "flyspeck-%s.txt" out_name) in
      let _ = run_command out_dir com in
      let _ = hypermap_string := "";
	precision := 0;
	constraints := empty_constraints;
	variable_bounds := empty_constraints;
	target_variables := empty_constraints in
      let _ = use_file (sprintf "%s/%s_out.hl" out_dir out_name) in
	if !precision = 0 then
	  failwith (sprintf "build_terminal_case failed for %s" bb.hypermap_id)
	else
	  let certificate = {
	    precision = !precision;
	    constraints = !constraints;
	    target_variables = !target_variables;
	    variable_bounds = !variable_bounds;
	  } in
	    certificate;;
  

(* Builds an std certificate *)
let build_std bb =
  let hyp_list = (snd o convert_to_list) bb.string_rep in
  let terminal = build_terminal_case hyp_list bb in
  let root = Lp_terminal terminal in
  let certificate = {hypermap_string = bb.string_rep; root_case = root} in
    certificate;;


let build_and_save_all_std =
  let counter = ref 0 and
      total = ref 0 in
  let buf = ref [] and
      file_counter = ref 0 in
  let report s =
    Format.print_string s; Format.print_newline(); Format.print_flush() in

  let save_buf () =
    if length !buf > 0 then
      let _ = file_counter := !file_counter + 1 in
      let fname = sprintf "%s/std_%d.dat" binary_dir !file_counter in
      let _ = write_lp_certificates fname !buf in
	buf := []
    else
      () in

  let process max bb =
    let _ = counter := !counter + 1 in
    let _ = report (sprintf "%d/%d" !counter !total) in
    let _ = buf := build_std bb :: !buf in
      if length !buf >= max then
	save_buf()
      else
	() in

    fun max bbs ->
      let _ = total := length bbs and
	  _ = counter := 0 and
	  _ = file_counter := 0 and
	  _ = buf := [] in
      let _ = map (process max) bbs in
	save_buf ();;



(****************************)
needs "../formal_lp/glpk/feasible.hl";;

let take n = fst o chop_list n;;
let drop n = snd o chop_list n;;

let tame = Glpk_link.strip_archive (!archiveraw);;
let test_tame = fst (chop_list 100 tame);;
let test_tame = tame;;
let test_list = map mk_bb test_tame;;
(* let test_feas = filter_feas (map solve test_list);; *)
let feas_bbs = filter (fun bb -> mem bb.hypermap_id feasible_ids) test_list;;
(* 477 *)
length feas_bbs;;

let std_bbs = subtract test_list feas_bbs;;
(* 19001 *)
length std_bbs;;

let test_bbs = take 3000 (drop 5000 std_bbs);;

(* build_and_save_all_std 100 test_bbs;; *)


(*************************************)

let rec build (hyp_list, bb) =
  let result = solve bb in
    if not (is_feas result) then
      (* terminal case *)
      let terminal = build_terminal_case hyp_list bb in
	Lp_terminal terminal
    else
      (* split case *)
      let n = length (hd bb.std_faces_not_super) in
	if n = 3 then
	  split3 hyp_list bb
	else if n = 4 then
	  split4 hyp_list bb
	else if n = 5 then
	  split5 hyp_list bb
	else if n = 6 then
	  split6 hyp_list bb
	else
	  failwith (sprintf "build: incorrect face size - %d" n) and

    (* split3 *)
    split3 hyp_list bb =
  failwith "split3: not implemented" and

    (* split4 *)
    split4 hyp_list bb =
  let split_face = hd bb.std_faces_not_super in
  let _ = assert (length split_face = 4) in
  let bbs = switch4 bb in
  let dart13 = nth split_face 1, nth split_face 2 and
      dart24 = nth split_face 0, nth split_face 1 in
  let split13 = split_list hyp_list dart13 and
      split24 = split_list hyp_list dart24 in
  let case_args = zip [split13; split24; split13; split24; hyp_list] bbs in
  let cases = map build case_args in
  let info = {split_type = Quad_split; split_face = split_face} in
    Lp_split (info, cases) and

    (* split5 *)
    split5 hyp_list bb =
  failwith "split5: not implemented" and

    (* split6 *)
    split6 hyp_list bb =
  let split_face = hd bb.std_faces_not_super in
  let _ = assert (length split_face = 6) in
  let bbs = switch6 bb in
  let darts = Glpk_link.rotateL 1 (list_pairs split_face) in
  let splits = map (split_list hyp_list) darts in
  let case_args = zip (hyp_list :: splits) bbs in
  let cases = map build case_args in
  let info = {split_type = Hex_split; split_face = split_face} in
    Lp_split (info, cases);;


(* Builds an lp certificate *)
let build_certificate bb =
  let hyp_list = (snd o convert_to_list) bb.string_rep in
  let root = build (hyp_list, bb) in
  let certificate = {hypermap_string = bb.string_rep; root_case = root} in
    certificate;;
  


(************************)


let test = map (hd o map length o faces) feas_bbs;;
let bb = nth feas_bbs 470;;

let hyp_list = (snd o convert_to_list) bb.string_rep;;

let certificate = build_certificate bb;;


write_lp_certificates (sprintf "%s/c6.dat" binary_dir) [certificate];;


(***************************)

let split_face = hd bb.std_faces_not_super;;
let _ = assert (length split_face = 6);;
let bbs = switch6 bb;;

drop 5 (map faces bbs);;

let bb' = nth bbs 1;;
ampl_of_bb' (sprintf "%s/x.txt" out_dir) bb';;

  
(* Quad case *)
let rec split4 hyp_list bb =
  failwith "not implemented";;
let split_face = hd bb.std_faces_not_super;;
let _ = assert (length split_face = 4);;
let bbs = switch4 bb;;
let dart13 = nth split_face 1, nth split_face 2 and
    dart24 = nth split_face 0, nth split_face 1;;
let split13 = split_list hyp_list dart13 and
    split24 = split_list hyp_list dart24;;




let case_args = zip [split13; split24; split13; split24; hyp_list] bbs;;
let cases = map build case_args;;
let info = {split_type = Quad_split; split_face = split_face} in
  Lp_split (info, cases);;

let _ = clean_out_dir();;




onepass [bb];;

let bb = hd bbs;;
onepass [bb];;

faces bb;;
let bbs = switch_face bb;;
drop 3 (map faces bbs);;

let x = 2;;


(**********************************)


needs "../formal_lp/glpk/onepass.hl";;

let onepass_bbs = filter (fun bb -> mem bb.hypermap_id onepass_ids) test_feas;;
(* 276 *)
length onepass_bbs;;

let test = map (hd o map length o faces) onepass_bbs;;
drop 200 test;;

let bb = nth test_feas 470;;

let pass1 = onepass [bb];;

let pass1_1 = nth pass1 0 and
    pass1_2 = nth pass1 1;;

onepass [pass1_1];;
let pass2 = hd (onepass [pass1_2]);;
Ineq.getexact "181212899 5";;
Ineq.apexff5;;
onepass [pass2];;

pass1_2;;
faces pass1_2;;
ampl_of_bb' "out.test" pass1_2;;
