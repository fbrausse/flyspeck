needs "../formal_lp/formal_interval/m_taylor.hl";;
needs "../formal_lp/formal_interval/interval_m/verifier.hl";;


let m_cell_pass = new_definition `m_cell_pass f domain <=> (!x. x IN interval [domain] ==> f x < &0)`;;

let dest_m_cell_pass pass_tm =
  let ltm, domain = dest_comb pass_tm in
    rand ltm, domain;;


(*********************************)

let M_CELL_PASS_LEMMA' = (MY_RULE o prove)(`(!x. x IN interval [domain] ==> f x <= hi) /\ (hi < &0 <=> T) ==>
					     m_cell_pass f domain`,
					   REWRITE_TAC[m_cell_pass] THEN REPEAT STRIP_TAC THEN
					     MATCH_MP_TAC REAL_LET_TRANS THEN
					     EXISTS_TAC `hi:real` THEN ASM_REWRITE_TAC[] THEN
					     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;

let m_taylor_cell_pass n pp m_taylor_th =
  let upper_th = eval_m_taylor_upper_bound n pp m_taylor_th in
  let tm0 = (snd o dest_forall o concl) upper_th in
  let int_tm, concl_tm = dest_comb tm0 in
  let domain_tm = (rand o rator o rand o rand o rand) int_tm in
  let ltm, hi_tm = dest_comb concl_tm in
  let f_tm = (rator o rand) ltm in
  let f_var = mk_var ("f", type_of f_tm) and
      domain_var = mk_var ("domain", type_of domain_tm) in

  let hi_lt0_th = float_lt0 hi_tm in
    if (fst o dest_const o rand o concl) hi_lt0_th = "F" then
      failwith "m_taylor_cell_pass: hi < &0 <=> F"
    else
      (MY_PROVE_HYP upper_th o MY_PROVE_HYP hi_lt0_th o
	 INST[f_tm, f_var; domain_tm, domain_var; hi_tm, hi_var_real] o 
	 inst_first_type_var n_type_array.(n)) M_CELL_PASS_LEMMA';;


(******************************)

let M_CELL_PASS_GLUE_LEMMA = prove(`!j x z v u f. 
				     (!i. 1 <= i /\ i <= dimindex (:N) ==> ~(i = j) ==> 
					u$i = x$i /\ v$i = z$i) ==>
				     v$j = u$j ==>
					 m_cell_pass f (x,v) ==> 
					 m_cell_pass f (u,z) ==>
					 m_cell_pass f (x,z:real^N)`,
   REWRITE_TAC[m_cell_pass; IN_INTERVAL] THEN REPEAT GEN_TAC THEN
     move ["eq1"; "eq_vu"; "cell1"; "cell2"; "y"; "ineq"] THEN
     ASM_CASES_TAC `(y:real^N)$j <= (v:real^N)$j` THENL
     [
       REMOVE_THEN "cell1" MATCH_MP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
	 ASM_CASES_TAC `i = j:num` THENL
	 [
	   REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN SIMP_TAC[];
	   ALL_TAC
	 ] THEN
	 USE_THEN "eq1" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
	 USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN

     POP_ASSUM (ASSUME_TAC o MATCH_MP (REAL_ARITH `~(a <= b) ==> b <= a:real`)) THEN
     REMOVE_THEN "cell2" MATCH_MP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
     ASM_CASES_TAC `i = j:num` THENL
     [
       ASM_REWRITE_TAC[] THEN USE_THEN "eq_vu" (fun th -> REWRITE_TAC[SYM th]) THEN
	 REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN SIMP_TAC[];
       ALL_TAC
     ] THEN
     USE_THEN "eq1" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
     USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[]);;


let gen_glue_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      t_var = mk_var ("t", real_ty) and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      v_tm = mk_vector_list (map (fun i -> if i = j then t_var else List.nth zs (i - 1)) (1--n)) and
      u_tm = mk_vector_list (map (fun i -> if i = j then t_var else List.nth xs (i - 1)) (1--n)) in

  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; v_tm; u_tm]) M_CELL_PASS_GLUE_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
    MY_RULE th2;;


let glue_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_glue_lemma n j));;



(***************************************)

let M_CELL_SUP = prove(`!f x z. lift o f continuous_on interval [x,z:real^N] /\ m_cell_pass f (x,z) ==>
			 ?a. a < &0 /\ !y. y IN interval [x,z] ==> f y <= a`,
   REWRITE_TAC[m_cell_pass] THEN REPEAT STRIP_TAC THEN
     ASM_CASES_TAC `interval [x:real^N,z] = {}` THENL
     [
       EXISTS_TAC `-- &1` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     MP_TAC (SPECL [`f:real^N->real`; `interval [x,z:real^N]`] CONTINUOUS_ATTAINS_SUP) THEN
     ASM_REWRITE_TAC[COMPACT_INTERVAL] THEN
     DISCH_THEN (X_CHOOSE_THEN `y:real^N` STRIP_ASSUME_TAC) THEN
     EXISTS_TAC `(f:real^N->real) y` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;


let DIFF2_DOMAIN_IMP_CONTINUOUS_ON = prove(`!(f:real^N->real) domain. diff2_domain domain f ==>
					     lift o f continuous_on interval [domain]`,
   REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC DIFFERENTIABLE_IMP_CONTINUOUS_AT THEN
     MATCH_MP_TAC diff2_imp_diff THEN
     ASM_SIMP_TAC[]);;
     


let M_CELL_INCREASING_PASS_LEMMA = prove(`!j x z u lo f. diff2_domain (x,z) f ==>
					   (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = x$i) ==>
					   u$j = z$j ==>
					       &0 <= lo ==>
					       (!y. y IN interval [x,z] ==> lo <= partial j f y) ==>
					       m_cell_pass f (u,z) ==>
					       m_cell_pass f (x,z:real^N)`,
   REPEAT STRIP_TAC THEN REWRITE_TAC[m_cell_pass] THEN X_GEN_TAC `y:real^N` THEN
     ASM_CASES_TAC `~(!i. i IN 1..dimindex (:N) ==> (x:real^N)$i <= (z:real^N)$i)` THENL
     [
       POP_ASSUM MP_TAC THEN REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; IN_INTERVAL; GSYM IN_NUMSEG] THEN
	 DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN
	 DISCH_THEN (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     POP_ASSUM MP_TAC THEN REWRITE_TAC[negbK] THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `u:real^N`; `z:real^N`] M_CELL_SUP) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC DIFF2_DOMAIN_IMP_CONTINUOUS_ON THEN
	 UNDISCH_TAC `diff2_domain (x:real^N,z) f` THEN
	 REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN
	 POP_ASSUM MP_TAC THEN
	 REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[IN_NUMSEG] THEN
	 ASM_CASES_TAC `i = j:num` THENL [ ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC; ALL_TAC] THEN
	 FIRST_X_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[IN_NUMSEG];
       ALL_TAC
     ] THEN
     DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `j:num`; `u:real^N`; `x:real^N`; `z:real^N`; `a:real`] partial_increasing_right) THEN
     ASM_REWRITE_TAC[] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN
	 MATCH_MP_TAC diff2_imp_diff THEN
	 UNDISCH_TAC `diff2_domain (x:real^N,z) f` THEN REWRITE_TAC[diff2_domain] THEN
	 DISCH_THEN MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `lo:real` THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
     EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;



let M_CELL_DECREASING_PASS_LEMMA = prove(`!j x z u hi f. diff2_domain (x,z) f ==>
					   (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = z$i) ==>
					   u$j = x$j ==>
					       hi <= &0 ==>
					       (!y. y IN interval [x,z] ==> partial j f y <= hi) ==>
					       m_cell_pass f (x,u) ==>
					       m_cell_pass f (x,z:real^N)`,
   REPEAT STRIP_TAC THEN REWRITE_TAC[m_cell_pass] THEN X_GEN_TAC `y:real^N` THEN
     ASM_CASES_TAC `~(!i. i IN 1..dimindex (:N) ==> (x:real^N)$i <= (z:real^N)$i)` THENL
     [
       POP_ASSUM MP_TAC THEN REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; IN_INTERVAL; GSYM IN_NUMSEG] THEN
	 DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN
	 DISCH_THEN (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     POP_ASSUM MP_TAC THEN REWRITE_TAC[negbK] THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `x:real^N`; `u:real^N`] M_CELL_SUP) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC DIFF2_DOMAIN_IMP_CONTINUOUS_ON THEN
	 UNDISCH_TAC `diff2_domain (x:real^N,z) f` THEN
	 REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN
	 POP_ASSUM MP_TAC THEN
	 REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[IN_NUMSEG] THEN
	 ASM_CASES_TAC `i = j:num` THENL [ ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC; ALL_TAC] THEN
	 FIRST_X_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[IN_NUMSEG];
       ALL_TAC
     ] THEN
     DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `j:num`; `u:real^N`; `x:real^N`; `z:real^N`; `a:real`] partial_decreasing_left) THEN
     ASM_REWRITE_TAC[] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN
	 MATCH_MP_TAC diff2_imp_diff THEN
	 UNDISCH_TAC `diff2_domain (x:real^N,z) f` THEN REWRITE_TAC[diff2_domain] THEN
	 DISCH_THEN MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `hi:real` THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
     EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;

	

let gen_increasing_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      u_tm = mk_vector_list (map (fun i -> List.nth (if i = j then zs else xs) (i - 1)) (1--n)) in
  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; u_tm]) M_CELL_INCREASING_PASS_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
  let th3 = MY_RULE_NUM th2 in
    (UNDISCH_ALL o ONCE_REWRITE_RULE[GSYM ZERO_EQ_ZERO_CONST] o DISCH (last (hyp th3))) th3;;


let incr_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_increasing_lemma n j));;


let gen_decreasing_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      u_tm = mk_vector_list (map (fun i -> List.nth (if i = j then xs else zs) (i - 1)) (1--n)) in
  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; u_tm]) M_CELL_DECREASING_PASS_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
  let th3 = MY_RULE_NUM th2 in
    (UNDISCH_ALL o ONCE_REWRITE_RULE[GSYM ZERO_EQ_ZERO_CONST] o DISCH (last (hyp th3))) th3;;


let decr_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_decreasing_lemma n j));;


(******************************************)

let m_glue_cells n j pass_th1 pass_th2 =
  let f_tm, domain1 = dest_m_cell_pass (concl pass_th1) and
      domain2 = rand (concl pass_th2) in
  let x1, z1 = dest_pair domain1 and
      x2, z2 = dest_pair domain2 in

  let x1s = dest_vector x1 and
      x2s = dest_vector x2 and
      z2s = dest_vector z2 in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) and
      t_tm = List.nth x2s (j - 1) in
    
  let th0 = (INST[t_tm, t_var_real; f_tm, f_var] o 
	       INST (zip z2s z_vars) o INST (zip x1s x_vars)) glue_thms_array.(n).(j) in
    (MY_PROVE_HYP pass_th1 o MY_PROVE_HYP pass_th2) th0;;


(**********************)

(* m_incr_pass *)
let m_incr_pass n pp j m_taylor_th pass_th0 =
  let _, diff2_th, _, _ = dest_m_taylor_thms n m_taylor_th in
  let partial_bound = eval_m_taylor_lower_partial n pp j m_taylor_th in

  let f_tm, domain0 = dest_m_cell_pass (concl pass_th0) and
      domain = (rand o rator o concl) diff2_th and
      lo_tm = (lhand o rand o snd o dest_forall o concl) partial_bound in
  let lo_ge0_th = EQT_ELIM (float_ge0 lo_tm) in

  let x_tm, z_tm = dest_pair domain in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) in
  let th0 = (INST[f_tm, f_var; lo_tm, lo_var_real] o 
	       INST (zip zs z_vars) o INST (zip xs x_vars)) incr_thms_array.(n).(j) in
    (MY_PROVE_HYP lo_ge0_th o MY_PROVE_HYP pass_th0 o 
       MY_PROVE_HYP diff2_th o MY_PROVE_HYP partial_bound) th0;;


(* m_decr_pass *)
let m_decr_pass n pp j m_taylor_th pass_th0 =
  let _, diff2_th, _, _ = dest_m_taylor_thms n m_taylor_th in
  let partial_bound = eval_m_taylor_upper_partial n pp j m_taylor_th in

  let f_tm, domain0 = dest_m_cell_pass (concl pass_th0) and
      domain = (rand o rator o concl) diff2_th and
      hi_tm = (rand o rand o snd o dest_forall o concl) partial_bound in
  let hi_le0_th = EQT_ELIM (float_le0 hi_tm) in

  let x_tm, z_tm = dest_pair domain in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) in
  let th0 = (INST[f_tm, f_var; hi_tm, hi_var_real] o 
	       INST (zip zs z_vars) o INST (zip xs x_vars)) decr_thms_array.(n).(j) in
    (MY_PROVE_HYP hi_le0_th o MY_PROVE_HYP pass_th0 o 
       MY_PROVE_HYP diff2_th o MY_PROVE_HYP partial_bound) th0;;


(***********************)


let mk_verification_functions pp poly_tm min_flag value_tm =
  let x_tm, body_tm = dest_abs poly_tm in
  let new_expr =
    uncurry (mk_binop sub_op_real) (if min_flag then value_tm, body_tm else body_tm, value_tm) in
  let new_f = mk_abs (x_tm, new_expr) in
  let eval_f = eval_m_taylor_poly pp new_f and
      taylor_f = build_taylor pp new_f in
    eval_f, taylor_f;;



let split_domain n pp j domain_th = 
  let domain_tm, y_tm, _ = dest_m_cell_domain (concl domain_th) in
  let x_tm, z_tm = dest_pair domain_tm in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm and
      t = List.nth (dest_vector y_tm) (j - 1) in

  let vv = map (fun i -> if i = j then t else List.nth zs (i - 1)) (1--n) and
      uu = map (fun i -> if i = j then t else List.nth xs (i - 1)) (1--n) in

  let domain1_th = mk_m_center_domain n pp (rand x_tm) (mk_list (vv, real_ty)) and
      domain2_th = mk_m_center_domain n pp (mk_list (uu, real_ty)) (rand z_tm) in
    domain1_th, domain2_th;;


let restrict_domain n pp j left_flag domain_th = 
  let domain_tm, _, _ = dest_m_cell_domain (concl domain_th) in
  let x_tm, z_tm = dest_pair domain_tm in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let a, b = if left_flag then xs, zs else zs, xs in
  let uu = map (fun i -> List.nth (if i = j then a else b) (i - 1)) (1--n) in
    if left_flag then
      mk_m_center_domain n pp (rand x_tm) (mk_list (uu, real_ty))
    else
      mk_m_center_domain n pp (mk_list (uu, real_ty)) (rand z_tm);;


let convert_to_float_list pp lo_flag list_tm =
  let tms = dest_list list_tm in
  let i_funs = map build_interval_fun tms in
  let ints = map (fun f -> eval_interval_fun pp f []) i_funs in
  let extract = (if lo_flag then fst else snd) o dest_pair o rand o concl in
    mk_list (map extract ints, real_ty);;





(*****************************)
let m_verify_raw n pp eval_taylor certificate xx zz =
  let r_size = result_size certificate in
  let k = ref 0 in
  let domain_th = mk_m_center_domain n pp xx zz in

  let rec rec_verify pp domain_th certificate =
    match certificate with
      | Result_pass (mono, xx, zz) -> 
	  let taylor_th = eval_taylor domain_th in
	    if mono = [] then
	      let _ = k := !k + 1 in
	      let _ = report (sprintf "Verifying: %d/%d" !k r_size) in
		m_taylor_cell_pass n pp taylor_th	    
	    else
	      let j = hd mono in
	      let _ = report (sprintf "Mono: %d" j) in
	      let j, left_flag = if j < 0 then -j, true else j, false in
	      let domain1_th = restrict_domain n pp j left_flag domain_th in
	      let r1 = Result_pass (tl mono, xx, zz) in
	      let th1 = rec_verify pp domain1_th r1 in
	      let pass_f = if left_flag then m_decr_pass else m_incr_pass in
		pass_f n pp j taylor_th th1

      | Result_glue (mono, i, r1, r2) ->
	  if mono = [] then
	    let domain1_th, domain2_th = split_domain n pp (i + 1) domain_th in
	    let th1 = rec_verify pp domain1_th r1 and
		th2 = rec_verify pp domain2_th r2 in
	      m_glue_cells n (i + 1) th1 th2
	  else
	    let taylor_th = eval_taylor domain_th in
	    let j = hd mono in
	    let _ = report (sprintf "GlueMono: %d" j) in
	    let j, left_flag = if j < 0 then -j, true else j, false in
	    let domain1_th = restrict_domain n pp j left_flag domain_th in
	    let r = Result_glue (tl mono, i, r1, r2) in
	    let th1 = rec_verify pp domain1_th r in
	    let pass_f = if left_flag then m_decr_pass else m_incr_pass in
	      pass_f n pp j taylor_th th1

      | _ -> failwith "False result" in

    rec_verify pp domain_th certificate;;




(******)

let pp = 5;;

let n = 2;;
let poly_tm = expr_to_vector_fun `x1 pow 3 + x2 pow 3 - &100`;;

let xx = `[&1; &1]` and zz = `[&3; &2]`;;
let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_taylor, tf = mk_verification_functions pp poly_tm false `-- #88.9`;;
let certificate = run_test tf xx_float zz_float false 0.0 true;;
m_verify_raw n pp eval_taylor certificate xx1 zz1;;


(****************)
let delta_x_poly = 
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x in
    expr_to_vector_fun tm;;

let delta_y_poly =
  let tm = (rand o concl o SPEC_ALL o REWRITE_RULE[Sphere.delta_x]) Sphere.delta_y in
    expr_to_vector_fun tm;;

let delta_x4_poly =
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x4 in
    expr_to_vector_fun tm;;


(****)
(* delta_x4 *)
let pp = 10;;
let n = 6;;
let xx = `[&4;&4;&4;&4;&4;&8]` and
    zz = `[#6.3504;#6.3504;#6.3504;#6.3504;#6.3504;#25.4016]`;;
let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;


let eval_delta_x4, tf_delta_x4 = mk_verification_functions pp delta_x4_poly true `#6.02525`;;
let certificate = run_test tf_delta_x4 xx_float zz_float false 0.0 true;;

m_verify_raw n pp eval_delta_x4 certificate xx1 zz1;;


(***)
(* delta_x *)

let pp = 10;;
let n = 6;;
let xx = `[&4;&4;&4;&4;&4;&4]` and
    zz = `[#6.3504;#6.3504;#6.3504;#6.3504;#6.3504;#6.3504]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_delta_x, tf_delta_x = mk_verification_functions pp delta_x_poly true `#127.999`;;
let certificate = run_test tf_delta_x xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_delta_x certificate xx1 zz1;;


(***)
(* delta_y *)
let pp = 10;;
let n = 6;;
let xx = `[&2;&2;&2;&2;&2;&2]` and
    zz = `[#2.52;#2.52;#2.52;#2.52;#2.52;#2.52]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_delta_y, tf_delta_y = mk_verification_functions pp delta_y_poly true `#127.999`;;
let certificate = run_test tf_delta_y xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_delta_y certificate xx1 zz1;;



(***)
(* schwefel *)
let pp = 12;;
let n = 3;;
let xx = `[-- &10; -- &10; -- &10]` and
    zz = `[&10; &10; &10]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_schwefel, tf_schwefel = mk_verification_functions pp schwefel_poly true schwefel_min;;
let certificate = run_test tf_schwefel xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_schwefel certificate xx1 zz1;;


(***)
(* rd *)

let pp = 12;;
let n = 3;;
let xx = `[-- &5; -- &5; -- &5]` and
    zz = `[&5; &5; &5]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_rd, tf_rd = mk_verification_functions pp rd_poly true rd_min;;
let certificate = run_test tf_rd xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_rd certificate xx1 zz1;;

(***)
(* caprasse *)

let pp = 8;;
let n = 4;;
let xx = `[-- #0.5; -- #0.5; -- #0.5; -- #0.5]` and
    zz = `[#0.5; #0.5; #0.5; #0.5]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_caprasse, tf_caprasse = mk_verification_functions pp caprasse_poly true caprasse_min;;
let certificate = run_test tf_caprasse xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_caprasse certificate xx1 zz1;;


(***)
(* lv *)

let pp = 5;;
let n = 4;;
let xx = `[-- &2; -- &2; -- &2; -- &2]` and
    zz = `[&2; &2; &2; &2]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_lv, tf_lv = mk_verification_functions pp lv_poly true lv_min;;
let certificate = run_test tf_lv xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_lv certificate xx1 zz1;;


(***)
(* butcher *)

let pp = 5;;
let n = 6;;
let xx = `[-- &1; -- #0.1; -- #0.1; -- &1; -- #0.1; -- #0.1]` and
    zz = `[&0; #0.9; #0.5; -- #0.1; -- #0.05; -- #0.03]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_butcher, tf_butcher = mk_verification_functions pp butcher_poly true butcher_min;;
let certificate = run_test tf_butcher xx_float zz_float false 0.0 false;;
result_size certificate;;
m_verify_raw n pp eval_butcher certificate xx1 zz1;;


(***)
(* magnetism *)

let pp = 8;;
let n = 7;;
let xx = `[-- &1; -- &1; -- &1; -- &1; -- &1; -- &1; -- &1]` and
    zz = `[&1; &1; &1; &1; &1; &1; &1]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_magnetism, tf_magnetism = mk_verification_functions pp magnetism_poly true magnetism_min;;
let certificate = run_test tf_magnetism xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_magnetism certificate xx1 zz1;;


let eval_poly = build_taylor pp magnetism_poly;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) false;;
(* 759936 *)
result_size sample;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) true;;
(* 77 *)
result_size sample;;


(***)
(* heart *)

let pp = 10;;
let n = 8;;
let xx = `[-- #0.1; #0.4; -- #0.7; -- #0.7; #0.1; -- #0.1; -- #0.3; -- #1.1]` and
    zz = `[#0.4; &1; -- #0.4; #0.4; #0.2; #0.2; #1.1; -- #0.3]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_heart, tf_heart = mk_verification_functions pp heart_poly true heart_min;;
let certificate = run_test tf_heart xx_float zz_float false 0.0 true;;
result_size certificate;;
m_verify_raw n pp eval_heart certificate xx1 zz1;;

