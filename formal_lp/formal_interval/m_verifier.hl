needs "../formal_lp/formal_interval/m_taylor.hl";;
needs "../formal_lp/formal_interval/interval_m/verifier.hl";;

let mk_real_vars n name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n);;


(*************************************)

let BOUNDED_INTERVAL_ARITH_IMP_HI' = (MY_RULE o prove)
  (`(!x. x IN interval [domain] ==> interval_arith (f x) (lo, hi)) ==>
     (!x. x IN interval [domain] ==> f x <= hi)`, SIMP_TAC[interval_arith]);;

let BOUNDED_INTERVAL_ARITH_IMP_LO' = (MY_RULE o prove)
  (`(!x. x IN interval [domain] ==> interval_arith (f x) (lo, hi)) ==>
     (!x. x IN interval [domain] ==> lo <= f x)`, SIMP_TAC[interval_arith]);;


let eval_interval_arith_hi n bound_th =
  let tm0 = (snd o dest_forall o concl) bound_th in
  let int_tm, concl_tm = dest_comb tm0 in
  let domain_tm = (rand o rator o rand o rand o rand) int_tm in
  let ltm, bounds_tm = dest_interval_arith concl_tm in
  let f_tm, (lo_tm, hi_tm) = rator ltm, dest_pair bounds_tm in
  let f_var = mk_var ("f", type_of f_tm) and
      domain_var = mk_var ("domain", type_of domain_tm) in
    (MY_PROVE_HYP bound_th o
       INST[f_tm, f_var; domain_tm, domain_var; hi_tm, hi_var_real; lo_tm, lo_var_real] o
       inst_first_type_var n_type_array.(n)) BOUNDED_INTERVAL_ARITH_IMP_HI';;


let eval_interval_arith_lo n bound_th =
  let tm0 = (snd o dest_forall o concl) bound_th in
  let int_tm, concl_tm = dest_comb tm0 in
  let domain_tm = (rand o rator o rand o rand o rand) int_tm in
  let ltm, bounds_tm = dest_interval_arith concl_tm in
  let f_tm, (lo_tm, hi_tm) = rator ltm, dest_pair bounds_tm in
  let f_var = mk_var ("f", type_of f_tm) and
      domain_var = mk_var ("domain", type_of domain_tm) in
    (MY_PROVE_HYP bound_th o
       INST[f_tm, f_var; domain_tm, domain_var; hi_tm, hi_var_real; lo_tm, lo_var_real] o
       inst_first_type_var n_type_array.(n)) BOUNDED_INTERVAL_ARITH_IMP_LO';;



(*************************************)
(* subdomains *)

let eval_subset_trans =
  let SUBSET_TRANS' = MY_RULE SUBSET_TRANS in
    fun st_th tu_th ->
      let ltm, t_tm = dest_comb (concl st_th) in
      let s_tm = rand ltm and
	  u_tm = rand (concl tu_th) in
      let ty = (hd o snd o dest_type o type_of) s_tm and
	  s_var = mk_var ("s", type_of s_tm) and
	  t_var = mk_var ("t", type_of t_tm) and
	  u_var = mk_var ("u", type_of u_tm) in
	(MY_PROVE_HYP st_th o MY_PROVE_HYP tu_th o 
	   INST[s_tm, s_var; t_tm, t_var; u_tm, u_var] o inst_first_type_var ty) SUBSET_TRANS';;

let eval_subset_refl =
  let SUBSET_REFL' = MY_RULE SUBSET_REFL in
    fun s_tm ->
      let ty = (hd o snd o dest_type o type_of) s_tm and
	  s_var = mk_var ("s", type_of s_tm) in
	(INST[s_tm, s_var] o inst_first_type_var ty) SUBSET_REFL';;
    


let SUBSET_INTERVAL_IMP = prove(`!a b c d. (!i. i IN 1..dimindex (:N) ==> a$i <= c$i /\ d$i <= b$i) ==>
				  interval [c:real^N,d] SUBSET interval [a,b]`,
				SIMP_TAC[SUBSET_INTERVAL; GSYM IN_NUMSEG]);;


let gen_subset_interval_lemma n =
  let a_vars = mk_real_vars n "a" and
      b_vars = mk_real_vars n "b" and
      c_vars = mk_real_vars n "c" and
      d_vars = mk_real_vars n "d" in

  let a_tm = mk_vector_list a_vars and
      b_tm = mk_vector_list b_vars and
      c_tm = mk_vector_list c_vars and
      d_tm = mk_vector_list d_vars in

  let th0 = (SPEC_ALL o ISPECL [a_tm; b_tm; c_tm; d_tm]) SUBSET_INTERVAL_IMP in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
    MY_RULE th2;;


let subset_interval_thms_array = Array.init (max_dim + 1) 
  (fun n -> if n < 1 then TRUTH else gen_subset_interval_lemma n);;



let m_subset_interval n a_tm b_tm c_tm d_tm =
  let a_vars = mk_real_vars n "a" and
      b_vars = mk_real_vars n "b" and
      c_vars = mk_real_vars n "c" and
      d_vars = mk_real_vars n "d" in

  let a_s = dest_vector a_tm and
      b_s = dest_vector b_tm and
      c_s = dest_vector c_tm and
      d_s = dest_vector d_tm in

  let th0 = (INST (zip a_s a_vars) o INST (zip b_s b_vars) o 
	       INST (zip c_s c_vars) o INST (zip d_s d_vars)) subset_interval_thms_array.(n) in
  let prove_le tm =
    let ltm, rtm = dest_binop le_op_real tm in
      EQT_ELIM (float_le ltm rtm) in
  let hyp_ths = map prove_le (hyp th0) in
    itlist (fun hyp_th th -> MY_PROVE_HYP hyp_th th) hyp_ths th0;;


(*
let pp = 5;;
let n = 2;;

let aa = `[&1; &1]` and bb = `[&3; &2]` and
    cc = `[#1.5; &1]` and dd = `[&3; #1.6]`;;
let a_tm = mk_vector (convert_to_float_list pp true aa) and
    b_tm = mk_vector (convert_to_float_list pp false bb) and
    c_tm = mk_vector (convert_to_float_list pp true cc) and
    d_tm = mk_vector (convert_to_float_list pp false dd);;


m_subset_interval n a_tm b_tm c_tm d_tm;;
(* 10: 0.704 *)
test 1000 (m_subset_interval n a_tm b_tm c_tm) d_tm;;
*)

(*************************************)

let M_RESTRICT_RIGHT_LEMMA = prove(`!j x z y w u y' w'. m_cell_domain (x:real^N,z) y w /\
				    (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> 
				       u$i = x$i /\ y'$i = y$i /\ w'$i = w$i) /\
				    u$j = z$j /\ y'$j = z$j /\ w'$j = &0 ==>  
    m_cell_domain (u,z) y' w' /\ interval [u,z] SUBSET interval [x,z]`,
   REWRITE_TAC[m_cell_domain; SUBSET_INTERVAL; GSYM IN_NUMSEG] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
     CONJ_TAC THENL
     [
       GEN_TAC THEN DISCH_TAC THEN
	 ASM_CASES_TAC `i = j:num` THENL
	 [
	   ASM_REWRITE_TAC[REAL_LE_REFL; REAL_SUB_REFL; real_max];
	   ALL_TAC
	 ] THEN
	 REPEAT (FIRST_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[]);
       ALL_TAC
     ] THEN
     DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     ASM_CASES_TAC `i = j:num` THENL
     [
       ASM_REWRITE_TAC[REAL_LE_REFL] THEN
	 REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `j:num`)) THEN
	 POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
	 ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REPEAT (FIRST_ASSUM (new_rewrite [] [])) THEN ASM_REWRITE_TAC[REAL_LE_REFL]);;



let M_RESTRICT_LEFT_LEMMA = prove(`!j x z y w u y' w'. m_cell_domain (x:real^N,z) y w /\
				    (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> 
				       u$i = z$i /\ y'$i = y$i /\ w'$i = w$i) /\
				    u$j = x$j /\ y'$j = x$j /\ w'$j = &0 ==> 
    m_cell_domain (x,u) y' w' /\ interval [x,u] SUBSET interval [x,z]`,
   REWRITE_TAC[m_cell_domain; SUBSET_INTERVAL; GSYM IN_NUMSEG] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
     CONJ_TAC THENL
     [
       GEN_TAC THEN DISCH_TAC THEN
	 ASM_CASES_TAC `i = j:num` THENL
	 [
	   ASM_REWRITE_TAC[REAL_LE_REFL; REAL_SUB_REFL; real_max];
	   ALL_TAC
	 ] THEN
	 REPEAT (FIRST_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[]);
       ALL_TAC
     ] THEN
     DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     ASM_CASES_TAC `i = j:num` THENL
     [
       ASM_REWRITE_TAC[REAL_LE_REFL] THEN
	 REPEAT (FIRST_X_ASSUM (MP_TAC o SPEC `j:num`)) THEN
	 POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
	 ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     REPEAT (FIRST_ASSUM (new_rewrite [] [])) THEN ASM_REWRITE_TAC[REAL_LE_REFL]);;


let gen_restrict_lemma n j left_flag =
  let xs = mk_real_vars n "x" and
      zs = mk_real_vars n "z" and
      ys = mk_real_vars n "y" and
      ws = mk_real_vars n "w" and
      j_tm = mk_small_numeral j in
  let a, b = if left_flag then zs, xs else xs, zs in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      y_tm = mk_vector_list ys and
      w_tm = mk_vector_list ws and
      u_tm = mk_vector_list (map (fun i -> List.nth (if i = j then b else a) (i - 1)) (1--n)) and
      y'_tm = mk_vector_list (map (fun i -> List.nth (if i = j then b else ys) (i - 1)) (1--n)) and
      w'_tm = mk_vector_list (map (fun i -> if i = j then `&0` else List.nth ws (i - 1)) (1--n)) in

  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; y_tm; w_tm; u_tm; y'_tm; w'_tm]) 
    (if left_flag then M_RESTRICT_LEFT_LEMMA else M_RESTRICT_RIGHT_LEMMA) in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
    MY_RULE_FLOAT th2;;


let left_restrict_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_restrict_lemma n j true));;


let right_restrict_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_restrict_lemma n j false));;




(******************************)
(* m_cell_pass *)



let m_cell_pass = new_definition `m_cell_pass f domain <=> (!x. x IN interval [domain] ==> f x < &0)`;;

let dest_m_cell_pass pass_tm =
  let ltm, domain = dest_comb pass_tm in
    rand ltm, domain;;


(*********************************)

let M_CELL_PASS_LEMMA = prove(`(!x. x IN interval [domain] ==> f x <= hi) /\ (hi < &0 <=> T) ==>
				m_cell_pass f domain`,
			      REWRITE_TAC[m_cell_pass] THEN REPEAT STRIP_TAC THEN
				MATCH_MP_TAC REAL_LET_TRANS THEN
				EXISTS_TAC `hi:real` THEN ASM_REWRITE_TAC[] THEN
				FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;

let M_CELL_PASS_LEMMA' = MY_RULE M_CELL_PASS_LEMMA;;

let M_CELL_PASS_INTERVAL_LEMMA' = (MY_RULE o prove)
  (`(!x. x IN interval [domain] ==> interval_arith (f x) (lo, hi)) /\ hi < &0 ==> m_cell_pass f domain`,
   REWRITE_TAC[interval_arith] THEN STRIP_TAC THEN MATCH_MP_TAC M_CELL_PASS_LEMMA THEN
     ASM_SIMP_TAC[]);;

let M_CELL_PASS_SUBSET' = (MY_RULE o prove)(`m_cell_pass f domain /\ 
					      interval [domain2] SUBSET interval [domain] ==>
					      m_cell_pass f domain2`,
					    REWRITE_TAC[m_cell_pass; SUBSET] THEN REPEAT STRIP_TAC THEN
					      REPEAT (FIRST_X_ASSUM MATCH_MP_TAC) THEN ASM_REWRITE_TAC[]);;


let m_taylor_cell_pass n pp m_taylor_th =
  let upper_th = eval_m_taylor_upper_bound n pp m_taylor_th in
  let tm0 = (snd o dest_forall o concl) upper_th in
  let int_tm, concl_tm = dest_comb tm0 in
  let domain_tm = (rand o rator o rand o rand o rand) int_tm in
  let ltm, hi_tm = dest_comb concl_tm in
  let f_tm = (rator o rand) ltm in
  let f_var = mk_var ("f", type_of f_tm) and
      domain_var = mk_var ("domain", type_of domain_tm) in

  let hi_lt0_th = float_lt0 hi_tm in
    if (fst o dest_const o rand o concl) hi_lt0_th = "F" then
      failwith "m_taylor_cell_pass: hi < &0 <=> F"
    else
      (MY_PROVE_HYP upper_th o MY_PROVE_HYP hi_lt0_th o
	 INST[f_tm, f_var; domain_tm, domain_var; hi_tm, hi_var_real] o 
	 inst_first_type_var n_type_array.(n)) M_CELL_PASS_LEMMA';;


let m_taylor_cell_pass0 n bound_th =
  let tm0 = (snd o dest_forall o concl) bound_th in
  let int_tm, concl_tm = dest_comb tm0 in
  let domain_tm = (rand o rator o rand o rand o rand) int_tm in
  let ltm, bounds_tm = dest_interval_arith concl_tm in
  let f_tm, (lo_tm, hi_tm) = rator ltm, dest_pair bounds_tm in
  let f_var = mk_var ("f", type_of f_tm) and
      domain_var = mk_var ("domain", type_of domain_tm) in
  let hi_lt0_th = try EQT_ELIM (float_lt0 hi_tm) with Failure _ -> failwith "m_taylor_cell_pass0" in
    (MY_PROVE_HYP bound_th o MY_PROVE_HYP hi_lt0_th o
       INST[f_tm, f_var; domain_tm, domain_var; hi_tm, hi_var_real; lo_tm, lo_var_real] o
       inst_first_type_var n_type_array.(n)) M_CELL_PASS_INTERVAL_LEMMA';;



(******************************)

let M_CELL_PASS_GLUE_LEMMA = prove(`!j x z v u f. 
				     (!i. 1 <= i /\ i <= dimindex (:N) ==> ~(i = j) ==> 
					u$i = x$i /\ v$i = z$i) ==>
				     v$j = u$j ==>
					 m_cell_pass f (x,v) ==> 
					 m_cell_pass f (u,z) ==>
					 m_cell_pass f (x,z:real^N)`,
   REWRITE_TAC[m_cell_pass; IN_INTERVAL] THEN REPEAT GEN_TAC THEN
     move ["eq1"; "eq_vu"; "cell1"; "cell2"; "y"; "ineq"] THEN
     ASM_CASES_TAC `(y:real^N)$j <= (v:real^N)$j` THENL
     [
       REMOVE_THEN "cell1" MATCH_MP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
	 ASM_CASES_TAC `i = j:num` THENL
	 [
	   REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN SIMP_TAC[];
	   ALL_TAC
	 ] THEN
	 USE_THEN "eq1" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
	 USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN

     POP_ASSUM (ASSUME_TAC o MATCH_MP (REAL_ARITH `~(a <= b) ==> b <= a:real`)) THEN
     REMOVE_THEN "cell2" MATCH_MP_TAC THEN GEN_TAC THEN DISCH_TAC THEN
     USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
     ASM_CASES_TAC `i = j:num` THENL
     [
       ASM_REWRITE_TAC[] THEN USE_THEN "eq_vu" (fun th -> REWRITE_TAC[SYM th]) THEN
	 REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN SIMP_TAC[];
       ALL_TAC
     ] THEN
     USE_THEN "eq1" (new_rewrite [] []) THEN ASM_REWRITE_TAC[] THEN
     USE_THEN "ineq" (new_rewrite [] []) THEN ASM_REWRITE_TAC[]);;


let gen_glue_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      t_var = mk_var ("t", real_ty) and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      v_tm = mk_vector_list (map (fun i -> if i = j then t_var else List.nth zs (i - 1)) (1--n)) and
      u_tm = mk_vector_list (map (fun i -> if i = j then t_var else List.nth xs (i - 1)) (1--n)) in

  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; v_tm; u_tm]) M_CELL_PASS_GLUE_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
    MY_RULE th2;;


let glue_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_glue_lemma n j));;



(***************************************)

let M_CELL_SUP = prove(`!f x z. lift o f continuous_on interval [x,z:real^N] /\ m_cell_pass f (x,z) ==>
			 ?a. a < &0 /\ !y. y IN interval [x,z] ==> f y <= a`,
   REWRITE_TAC[m_cell_pass] THEN REPEAT STRIP_TAC THEN
     ASM_CASES_TAC `interval [x:real^N,z] = {}` THENL
     [
       EXISTS_TAC `-- &1` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     MP_TAC (SPECL [`f:real^N->real`; `interval [x,z:real^N]`] CONTINUOUS_ATTAINS_SUP) THEN
     ASM_REWRITE_TAC[COMPACT_INTERVAL] THEN
     DISCH_THEN (X_CHOOSE_THEN `y:real^N` STRIP_ASSUME_TAC) THEN
     EXISTS_TAC `(f:real^N->real) y` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;


let DIFF2_DOMAIN_IMP_CONTINUOUS_ON = prove(`!(f:real^N->real) domain. diff2_domain domain f ==>
					     lift o f continuous_on interval [domain]`,
   REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN REPEAT STRIP_TAC THEN
     MATCH_MP_TAC DIFFERENTIABLE_IMP_CONTINUOUS_AT THEN
     MATCH_MP_TAC diff2_imp_diff THEN
     ASM_SIMP_TAC[]);;



let M_CELL_INCREASING_PASS_LEMMA = prove(`!j x z u domain lo f. 
					   interval [x,z] SUBSET interval [domain] ==>
					   diff2_domain domain f ==>
					   (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = x$i) ==>
					   u$j = z$j ==>
					       &0 <= lo ==>
					       (!y. y IN interval [domain] ==> lo <= partial j f y) ==>
					       m_cell_pass f (u,z) ==>
					       m_cell_pass f (x,z:real^N)`,
   REWRITE_TAC[SUBSET] THEN REPEAT STRIP_TAC THEN REWRITE_TAC[m_cell_pass] THEN
     X_GEN_TAC `y:real^N` THEN
     ASM_CASES_TAC `~(!i. i IN 1..dimindex (:N) ==> (x:real^N)$i <= (z:real^N)$i)` THENL
     [
       POP_ASSUM MP_TAC THEN REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; IN_INTERVAL; GSYM IN_NUMSEG] THEN
	 DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN
	 DISCH_THEN (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     POP_ASSUM MP_TAC THEN REWRITE_TAC[negbK] THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `u:real^N`; `z:real^N`] M_CELL_SUP) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC DIFF2_DOMAIN_IMP_CONTINUOUS_ON THEN
	 UNDISCH_TAC `diff2_domain domain (f:real^N->real)` THEN
	 REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
	 REPEAT (FIRST_X_ASSUM MATCH_MP_TAC) THEN
	 POP_ASSUM MP_TAC THEN
	 REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[IN_NUMSEG] THEN
	 ASM_CASES_TAC `i = j:num` THENL [ ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC; ALL_TAC] THEN
	 FIRST_X_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[IN_NUMSEG];
       ALL_TAC
     ] THEN
     DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `j:num`; `u:real^N`; `x:real^N`; `z:real^N`; `a:real`] partial_increasing_right) THEN
     ASM_REWRITE_TAC[] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN
	 MATCH_MP_TAC diff2_imp_diff THEN
	 UNDISCH_TAC `diff2_domain domain (f:real^N->real)` THEN REWRITE_TAC[diff2_domain] THEN
	 DISCH_THEN MATCH_MP_TAC THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `lo:real` THEN ASM_REWRITE_TAC[] THEN
	 REPEAT (FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
       ALL_TAC
     ] THEN
     DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
     EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;



let M_CELL_DECREASING_PASS_LEMMA = prove(`!j x z u domain hi f. 
					   interval [x,z] SUBSET interval [domain] ==>
					   diff2_domain domain f ==>
					   (!i. i IN 1..dimindex (:N) ==> ~(i = j) ==> u$i = z$i) ==>
					   u$j = x$j ==>
					       hi <= &0 ==>
					       (!y. y IN interval [domain] ==> partial j f y <= hi) ==>
					       m_cell_pass f (x,u) ==>
					       m_cell_pass f (x,z:real^N)`,
   REWRITE_TAC[SUBSET] THEN REPEAT STRIP_TAC THEN REWRITE_TAC[m_cell_pass] THEN X_GEN_TAC `y:real^N` THEN
     ASM_CASES_TAC `~(!i. i IN 1..dimindex (:N) ==> (x:real^N)$i <= (z:real^N)$i)` THENL
     [
       POP_ASSUM MP_TAC THEN REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; IN_INTERVAL; GSYM IN_NUMSEG] THEN
	 DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN
	 DISCH_THEN (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 POP_ASSUM MP_TAC THEN REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     POP_ASSUM MP_TAC THEN REWRITE_TAC[negbK] THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `x:real^N`; `u:real^N`] M_CELL_SUP) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC DIFF2_DOMAIN_IMP_CONTINUOUS_ON THEN
	 UNDISCH_TAC `diff2_domain domain (f:real^N->real)` THEN
	 REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN
	 REPEAT (FIRST_X_ASSUM MATCH_MP_TAC) THEN
	 POP_ASSUM MP_TAC THEN
	 REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN GEN_TAC THEN DISCH_TAC THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM (MP_TAC o SPEC `i:num`) THEN ASM_REWRITE_TAC[IN_NUMSEG] THEN
	 ASM_CASES_TAC `i = j:num` THENL [ ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC; ALL_TAC] THEN
	 FIRST_X_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[IN_NUMSEG];
       ALL_TAC
     ] THEN
     DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
     MP_TAC (SPECL [`f:real^N->real`; `j:num`; `u:real^N`; `x:real^N`; `z:real^N`; `a:real`] partial_decreasing_left) THEN
     ASM_REWRITE_TAC[] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN
	 MATCH_MP_TAC diff2_imp_diff THEN
	 UNDISCH_TAC `diff2_domain domain (f:real^N->real)` THEN REWRITE_TAC[diff2_domain] THEN
	 DISCH_THEN MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
	 FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN
     ANTS_TAC THENL
     [
       REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `hi:real` THEN ASM_REWRITE_TAC[] THEN
	 REPEAT (FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);
       ALL_TAC
     ] THEN
     DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
     EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[] THEN
     FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;


(*********************)
	

let gen_increasing_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      u_tm = mk_vector_list (map (fun i -> List.nth (if i = j then zs else xs) (i - 1)) (1--n)) in
  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; u_tm]) M_CELL_INCREASING_PASS_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
  let th3 = MY_RULE_NUM th2 in
    (UNDISCH_ALL o ONCE_REWRITE_RULE[GSYM ZERO_EQ_ZERO_CONST] o DISCH (last (hyp th3))) th3;;


let gen_mono_lemma0 th =
  let h2 = List.nth (hyp th) 1 in
  let domain_tm = (lhand o rand o lhand) h2 in
  let domain_var = mk_var ("domain", type_of domain_tm) in
    (UNDISCH_ALL o REWRITE_RULE[SUBSET_REFL] o DISCH_ALL o INST[domain_tm, domain_var]) th;;

let incr_gen_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_increasing_lemma n j));;

let incr_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_mono_lemma0 incr_gen_thms_array.(n).(j)));;



let gen_decreasing_lemma n j =
  let mk_vars name = map (fun i -> mk_var (sprintf "%s%d" name i, real_ty)) (1--n) in
  let xs = mk_vars "x" and
      zs = mk_vars "z" and
      j_tm = mk_small_numeral j in
  let x_tm = mk_vector_list xs and
      z_tm = mk_vector_list zs and
      u_tm = mk_vector_list (map (fun i -> List.nth (if i = j then xs else zs) (i - 1)) (1--n)) in
  let th0 = (SPEC_ALL o ISPECL [j_tm; x_tm; z_tm; u_tm]) M_CELL_DECREASING_PASS_LEMMA in
  let th1 = REWRITE_RULE[dimindex_array.(n); IN_NUMSEG; gen_in_interval n; ARITH] th0 in
  let th2 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th1 in
  let th3 = MY_RULE_NUM th2 in
    (UNDISCH_ALL o ONCE_REWRITE_RULE[GSYM ZERO_EQ_ZERO_CONST] o DISCH (last (hyp th3))) th3;;


let decr_gen_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_decreasing_lemma n j));;

let decr_thms_array = Array.init (max_dim + 1) 
  (fun n -> Array.init (n + 1)
     (fun j -> if j < 1 then TRUTH else gen_mono_lemma0 decr_gen_thms_array.(n).(j)));;



(******************************************)

let m_glue_cells n j pass_th1 pass_th2 =
  let f_tm, domain1 = dest_m_cell_pass (concl pass_th1) and
      domain2 = rand (concl pass_th2) in
  let x1, z1 = dest_pair domain1 and
      x2, z2 = dest_pair domain2 in

  let x1s = dest_vector x1 and
      x2s = dest_vector x2 and
      z2s = dest_vector z2 in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) and
      t_tm = List.nth x2s (j - 1) in
    
  let th0 = (INST[t_tm, t_var_real; f_tm, f_var] o 
	       INST (zip z2s z_vars) o INST (zip x1s x_vars)) glue_thms_array.(n).(j) in
    (MY_PROVE_HYP pass_th1 o MY_PROVE_HYP pass_th2) th0;;


(**********************)

let m_mono_pass_gen n j decr_flag diff2_th partial_mono_th sub_th pass_th =
  let f_tm, domain0 = dest_m_cell_pass (concl pass_th) and
      domain = (rand o rator o concl) diff2_th and
      xv, zv = (dest_pair o lhand o rand o lhand o concl) sub_th and
      bound_tm = ((if decr_flag then rand else lhand) o rand o snd o dest_forall o concl) partial_mono_th in

  let xs = dest_vector xv and
      zs = dest_vector zv in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      domain_var = mk_var ("domain", type_of domain) and
      f_var = mk_var ("f", type_of f_tm) and
      bound_var = mk_var ((if decr_flag then "hi" else "lo"), real_ty) in

  let le_th0 = (if decr_flag then float_le0 else float_ge0) bound_tm in
  let le_th = try EQT_ELIM le_th0 with Failure _ -> failwith ("Wrong inequality: "^string_of_thm le_th0) in

  let th0 = (INST[f_tm, f_var; bound_tm, bound_var; domain, domain_var] o
	  INST (zip xs x_vars) o INST (zip zs z_vars)) 
    (if decr_flag then decr_gen_thms_array.(n).(j) else incr_gen_thms_array.(n).(j)) in
    (MY_PROVE_HYP le_th o MY_PROVE_HYP pass_th o MY_PROVE_HYP diff2_th o 
       MY_PROVE_HYP sub_th o MY_PROVE_HYP partial_mono_th) th0;;



(* m_incr_pass *)
let m_incr_pass n pp j m_taylor_th pass_th0 =
  let _, diff2_th, _, _ = dest_m_taylor_thms n m_taylor_th in
  let partial_bound = eval_m_taylor_lower_partial n pp j m_taylor_th in

  let f_tm, domain0 = dest_m_cell_pass (concl pass_th0) and
      domain = (rand o rator o concl) diff2_th and
      lo_tm = (lhand o rand o snd o dest_forall o concl) partial_bound in
  let lo_ge0_th = EQT_ELIM (float_ge0 lo_tm) in

  let x_tm, z_tm = dest_pair domain in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) in
  let th0 = (INST[f_tm, f_var; lo_tm, lo_var_real] o 
	       INST (zip zs z_vars) o INST (zip xs x_vars)) incr_thms_array.(n).(j) in
    (MY_PROVE_HYP lo_ge0_th o MY_PROVE_HYP pass_th0 o 
       MY_PROVE_HYP diff2_th o MY_PROVE_HYP partial_bound) th0;;


(* m_decr_pass *)
let m_decr_pass n pp j m_taylor_th pass_th0 =
  let _, diff2_th, _, _ = dest_m_taylor_thms n m_taylor_th in
  let partial_bound = eval_m_taylor_upper_partial n pp j m_taylor_th in

  let f_tm, domain0 = dest_m_cell_pass (concl pass_th0) and
      domain = (rand o rator o concl) diff2_th and
      hi_tm = (rand o rand o snd o dest_forall o concl) partial_bound in
  let hi_le0_th = EQT_ELIM (float_le0 hi_tm) in

  let x_tm, z_tm = dest_pair domain in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let x_vars = map (fun i -> x_vars_array.(i)) (1--n) and
      z_vars = map (fun i -> z_vars_array.(i)) (1--n) and
      f_var = mk_var ("f", type_of f_tm) in
  let th0 = (INST[f_tm, f_var; hi_tm, hi_var_real] o 
	       INST (zip zs z_vars) o INST (zip xs x_vars)) decr_thms_array.(n).(j) in
    (MY_PROVE_HYP hi_le0_th o MY_PROVE_HYP pass_th0 o 
       MY_PROVE_HYP diff2_th o MY_PROVE_HYP partial_bound) th0;;


(***********************)


let mk_verification_functions pp poly_tm min_flag value_tm =
  let x_tm, body_tm = dest_abs poly_tm in
  let new_expr =
    uncurry (mk_binop sub_op_real) (if min_flag then value_tm, body_tm else body_tm, value_tm) in
  let new_f = mk_abs (x_tm, new_expr) in
  let n = get_dim x_tm in
  let eval0 = map (fun i -> 
		     if i = 0 then mk_eval_function pp new_f
		     else 
		       let num_eq = (REWRITE_RULE[NUM_THM] o NUMERAL_TO_NUM_CONV) (mk_small_numeral i) in
		       let d_th = gen_partial_poly i new_f in
		       let eq_th = GEN_REWRITE_RULE (LAND_CONV o LAND_CONV o DEPTH_CONV) [num_eq] d_th in
			 mk_eval_function_eq pp eq_th) (0--n) and
      eval_f = eval_m_taylor_poly pp new_f and
      taylor_f = build_taylor pp new_f in
    (fun i -> List.nth eval0 i), eval_f, taylor_f;;



let split_domain n pp j domain_th = 
  let domain_tm, y_tm, _ = dest_m_cell_domain (concl domain_th) in
  let x_tm, z_tm = dest_pair domain_tm in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm and
      t = List.nth (dest_vector y_tm) (j - 1) in

  let vv = map (fun i -> if i = j then t else List.nth zs (i - 1)) (1--n) and
      uu = map (fun i -> if i = j then t else List.nth xs (i - 1)) (1--n) in

  let domain1_th = mk_m_center_domain n pp (rand x_tm) (mk_list (vv, real_ty)) and
      domain2_th = mk_m_center_domain n pp (mk_list (uu, real_ty)) (rand z_tm) in
    domain1_th, domain2_th;;


(*
let restrict_domain_old n pp j left_flag domain_th = 
  let domain_tm, _, _ = dest_m_cell_domain (concl domain_th) in
  let x_tm, z_tm = dest_pair domain_tm in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm in

  let a, b = if left_flag then xs, zs else zs, xs in
  let uu = map (fun i -> List.nth (if i = j then a else b) (i - 1)) (1--n) in
    if left_flag then
      mk_m_center_domain n pp (rand x_tm) (mk_list (uu, real_ty))
    else
      mk_m_center_domain n pp (mk_list (uu, real_ty)) (rand z_tm);;
*)


let restrict_domain n j left_flag domain_th =
  let domain_tm, y_tm, w_tm = dest_m_cell_domain (concl domain_th) in
  let x_tm, z_tm = dest_pair domain_tm in
  let xs = dest_vector x_tm and
      zs = dest_vector z_tm and
      ys = dest_vector y_tm and
      ws = dest_vector w_tm in

  let th0 = (INST (zip xs (mk_real_vars n "x")) o INST (zip zs (mk_real_vars n "z")) o
	       INST (zip ys (mk_real_vars n "y")) o INST (zip ws (mk_real_vars n "w")))
    (if left_flag then left_restrict_thms_array.(n).(j) else right_restrict_thms_array.(n).(j)) in
  let ths = CONJUNCTS (MY_PROVE_HYP domain_th th0) in
    hd ths, hd (tl ths);;
  

let convert_to_float_list pp lo_flag list_tm =
  let tms = dest_list list_tm in
  let i_funs = map build_interval_fun tms in
  let ints = map (fun f -> eval_interval_fun pp f []) i_funs in
  let extract = (if lo_flag then fst else snd) o dest_pair o rand o concl in
    mk_list (map extract ints, real_ty);;





(*****************************)

(*
let m_verify_raw_old n pp eval_taylor certificate xx zz =
  let r_size = result_size certificate in
  let k = ref 0 in
  let domain_th = mk_m_center_domain n pp xx zz in

  let rec rec_verify pp domain_th certificate =
    match certificate with
      | Result_pass (mono, xx, zz) ->
	  let mono = List.concat mono in
	  let taylor_th = eval_taylor domain_th in
	    if mono = [] then
	      let _ = k := !k + 1 in
	      let _ = report (sprintf "Verifying: %d/%d" !k r_size) in
		m_taylor_cell_pass n pp taylor_th	    
	    else
	      let j = hd mono in
	      let _ = report (sprintf "Mono: %d" j) in
	      let j, left_flag = if j < 0 then -j, true else j, false in
	      let domain1_th, _ = restrict_domain n j left_flag domain_th in
	      let r1 = Result_pass ([tl mono], xx, zz) in
	      let th1 = rec_verify pp domain1_th r1 in
	      let pass_f = if left_flag then m_decr_pass else m_incr_pass in
		pass_f n pp j taylor_th th1

      | Result_glue (mono, i, r1, r2) ->
	  let mono = List.concat mono in
	  if mono = [] then
	    let domain1_th, domain2_th = split_domain n pp (i + 1) domain_th in
	    let th1 = rec_verify pp domain1_th r1 and
		th2 = rec_verify pp domain2_th r2 in
	      m_glue_cells n (i + 1) th1 th2
	  else
	    let taylor_th = eval_taylor domain_th in
	    let j = hd mono in
	    let _ = report (sprintf "GlueMono: %d" j) in
	    let j, left_flag = if j < 0 then -j, true else j, false in
	    let domain1_th, _ = restrict_domain n j left_flag domain_th in
	    let r = Result_glue ([tl mono], i, r1, r2) in
	    let th1 = rec_verify pp domain1_th r in
	    let pass_f = if left_flag then m_decr_pass else m_incr_pass in
	      pass_f n pp j taylor_th th1

      | _ -> failwith "False result" in

    rec_verify pp domain_th certificate;;
*)


(***************************)

let m_verify_raw n pp eval_f eval_taylor certificate xx zz =
  let r_size = result_size certificate in
  let k = ref 0 in
  let domain_th = mk_m_center_domain n pp xx zz in

  let rec rec_verify =
    let rec apply_trans sub_ths th0 acc =
      match sub_ths with
	| [] -> rev acc
	| th :: ths -> 
	    let th' = eval_subset_trans th th0 in
	      apply_trans ths th' (th' :: acc) in

    let rec mk_domains mono th0 acc =
      match mono with
	| [] -> rev acc
	| m :: ms ->
	    let j, flag = m.variable, m.decr_flag in
	    let ths = restrict_domain n j flag th0 in
	      mk_domains ms (fst ths) (ths :: acc) in

    let verify_mono mono domain_th certificate =
      let taylor_th = eval_taylor domain_th in
      let _, diff2_th, _, _ = dest_m_taylor_thms n taylor_th in
      let domain_ths = mk_domains mono domain_th [] in
      let domain, _, _ = (dest_m_cell_domain o concl) domain_th in
      let xx, zz = dest_pair domain in

(*      let domains = domain_th :: map fst (butlast domain_ths) in *)

(*      let gen_mono (m, domain_th) = *)
      let gen_mono m =
	if m.df0_flag then
	  if m.decr_flag then
	    eval_interval_arith_hi n (eval_f m.variable xx zz)
	  else
	    eval_interval_arith_lo n (eval_f m.variable xx zz)
	else
	  if m.decr_flag then
	    eval_m_taylor_upper_partial n pp m.variable taylor_th
	  else
	    eval_m_taylor_lower_partial n pp m.variable taylor_th in

(*      let mono_ths = map gen_mono (zip mono domains) in *)
      let mono_ths = map gen_mono mono in
      let pass_th0 = rec_verify ((fst o last) domain_ths) certificate in
      let sub_th0 = (eval_subset_refl o rand o concl o snd o hd) domain_ths in
      let sub_ths = apply_trans (sub_th0 :: map snd (butlast domain_ths)) sub_th0 [] in
      let th = rev_itlist (fun ((m, mono_th), sub_th) pass_th ->
			     let j, flag = m.variable, m.decr_flag in
			       m_mono_pass_gen n j flag diff2_th mono_th sub_th pass_th)
	(rev (zip (zip mono mono_ths) sub_ths)) pass_th0 in
	if hyp th <> [] then failwith ("hyp <> []: "^string_of_thm th) else th in

	

      fun domain_th certificate ->
	match certificate with
	  | Result_mono (mono, r1) ->
	      let mono_strs = 
		map (fun m -> sprintf "%s%d (%b)" (if m.decr_flag then "-" else "") 
		       m.variable m.df0_flag) mono in
	      let _ = report (sprintf "Mono: [%s]" (String.concat ";" mono_strs)) in
		verify_mono mono domain_th r1

	  | Result_pass (f0_flag, xx, zz) -> 
	      let _ = k := !k + 1 in
	      let _ = report (sprintf "Verifying: %d/%d (f0_flag = %b)" !k r_size f0_flag) in
		if f0_flag then
		  let domain, _, _ = (dest_m_cell_domain o concl) domain_th in
		  let xx, zz = dest_pair domain in
		    m_taylor_cell_pass0 n (eval_f 0 xx zz)
		else
		  let taylor_th = eval_taylor domain_th in
		    m_taylor_cell_pass n pp taylor_th  
		  
	  | Result_glue (i, convex_flag, r1, r2) ->
	      let domain1_th, domain2_th = split_domain n pp (i + 1) domain_th in
	      let th1 = rec_verify domain1_th r1 and
		  th2 = rec_verify domain2_th r2 in
		m_glue_cells n (i + 1) th1 th2
		    
	  | _ -> failwith "False result" in
    
    rec_verify domain_th certificate;;




(* time test for domain computations *)
let m_verify_domain_test n pp eval_taylor certificate xx zz =
  let r_size = result_size certificate in
  let k = ref 0 in
  let domain_th = mk_m_center_domain n pp xx zz in

  let rec rec_verify domain_th certificate =
    match certificate with
      | Result_mono (mono, r1) ->
	  let m = hd mono in
	  let _ = report (sprintf "Mono: %d (%b)" m.variable m.decr_flag) in
	  let j, left_flag = m.variable, m.decr_flag in
	  let domain1_th, _ = restrict_domain n j left_flag domain_th in
	  let r = if tl mono = [] then r1 else Result_mono (tl mono, r1) in
	    rec_verify domain1_th r

      | Result_pass (f0_flag, xx, zz) -> 
	  let _ = k := !k + 1 in
	  let _ = report (sprintf "Verifying: %d/%d" !k r_size) in ()

      | Result_glue (i, convex_flag, r1, r2) ->
	  let domain1_th, domain2_th = split_domain n pp (i + 1) domain_th in
	  let _ = rec_verify domain1_th r1 and
	      _ = rec_verify domain2_th r2 in ()

      | _ -> failwith "False result" in

    rec_verify domain_th certificate;;




(******)

let pp = 5;;

let n = 2;;
let poly_tm = expr_to_vector_fun `x1 pow 2 + x2 pow 3`;;

let xx = `[-- &1; &1]` and zz = `[&3; &2]`;;
let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_f, eval_taylor, tf = mk_verification_functions pp poly_tm true `-- #0.01`;;
let certificate = run_test tf xx_float zz_float false 0.0 true true false;;
m_verify_raw n pp eval_f eval_taylor certificate xx1 zz1;;

let c0 = run_test0 tf xx_float zz_float false 0.0 false false false;;
result_size c0;;


(****************)
let delta_x_poly = 
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x in
    expr_to_vector_fun tm;;

let delta_y_poly =
  let tm = (rand o concl o SPEC_ALL o REWRITE_RULE[Sphere.delta_x]) Sphere.delta_y in
    expr_to_vector_fun tm;;

let delta_x4_poly =
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x4 in
    expr_to_vector_fun tm;;


(****)
(* delta_x4 *)
let pp = 10;;
let n = 6;;
let xx = `[&4;&4;&4;&4;&4;&8]` and
    zz = `[#6.3504;#6.3504;#6.3504;#6.3504;#6.3504;#25.4016]`;;
let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;


let eval0_delta_x4, eval_delta_x4, tf_delta_x4 = mk_verification_functions pp delta_x4_poly true `#6.02525`;;
let certificate = run_test tf_delta_x4 xx_float zz_float false 0.0 true true false;;
m_verify_raw n pp eval0_delta_x4 eval_delta_x4 certificate xx1 zz1;;
result_size certificate;;

let c0 = run_test0 tf_delta_x4 xx_float zz_float false 0.0 true false false;;
(* 12 (true false false) 2 (true true false) *)
result_size c0;;
m_verify_raw n pp eval0_delta_x4 eval_delta_x4 c0 xx1 zz1;;





(*
let domain0 = mk_m_center_domain n pp xx1 zz1;;
let domain1, _ = restrict_domain n 2 true domain0;;
let domain2, _ = restrict_domain n 3 true domain1;;
let domain3, sub_th3 = restrict_domain n 4 false domain2;;
let domain4, _ = restrict_domain n 6 true domain3;;

let taylor_th3 = eval_delta_x4 domain3;;
let taylor_th4 = eval_delta_x4 domain4;;
let pass_th = m_taylor_cell_pass n pp taylor_th4;;

m_decr_pass n pp 6 taylor_th3 pass_th;;
(* 0.624 *)
test 100 (m_decr_pass n pp 6 taylor_th3) pass_th;;

let domain, _, _ = dest_m_cell_domain (concl domain3);;
let x, z = dest_pair domain;;
let _, diff2_th, _, _ = dest_m_taylor_thms n taylor_th3;;
let sub_th = eval_subset_refl ((lhand o concl) sub_th3);;

let p_int_th = eval0_delta_x4 6 x z;;
let mono_th = eval_interval_arith_hi n p_int_th;;
m_mono_pass_gen n 6 true diff2_th mono_th sub_th pass_th;;


(* 0.328 *)
test 100 (eval0_delta_x4 6 x) z;;
(* 0.028 *)
test 100 (eval_interval_arith_hi n) p_int_th;;
(* 0.068 *)
test 100 (m_mono_pass_gen n 6 true diff2_th mono_th sub_th) pass_th;;
*)



(***)
(* delta_x *)

let pp = 10;;
let n = 6;;
let xx = `[&4;&4;&4;&4;&4;&4]` and
    zz = `[#6.3504;#6.3504;#6.3504;#6.3504;#6.3504;#6.3504]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_delta_x, eval_delta_x, tf_delta_x = mk_verification_functions pp delta_x_poly true `#127.999`;;
let certificate = run_test tf_delta_x xx_float zz_float false 0.0 true true false;;
(* 46 (true false false) 10 (true true false) *)
result_size certificate;;
m_verify_raw n pp eval0_delta_x eval_delta_x certificate xx1 zz1;;

let c0 = run_test0 tf_delta_x xx_float zz_float false 0.0 true true true;;
(* 4873 (true false true) 32 (true true true) *)
result_size c0;;




(* 10: 65 *)
test 1 (m_verify_raw_old n pp eval_delta_x certificate xx1) zz1;;
(* 10: 41.33 *)
test 1 (m_verify_raw n pp eval0_delta_x eval_delta_x certificate xx1) zz1;;
(* 10: 4.228 (2.408, new restrict_domain) *)
test 1 (m_verify_domain_test n pp eval_delta_x certificate xx1) zz1;;



(***)
(* delta_y *)
let pp = 10;;
let n = 6;;
let xx = `[&2;&2;&2;&2;&2;&2]` and
    zz = `[#2.52;#2.52;#2.52;#2.52;#2.52;#2.52]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_delta_y, eval_delta_y, tf_delta_y = mk_verification_functions pp delta_y_poly true `#127.999`;;
let certificate = run_test tf_delta_y xx_float zz_float false 0.0 true true false;;
(* 134 (true true false) *)
result_size certificate;;
m_verify_raw n pp eval0_delta_y eval_delta_y certificate xx1 zz1;;
(* 10: 494 *)
test 1 (m_verify_raw n pp eval0_delta_y eval_delta_y certificate xx1) zz1;;


let c0 = run_test0 tf_delta_y xx_float zz_float false 0.0 true true true;;
(* 24671 (true false true) 1785 (true true true) *)
result_size c0;;



(***)
(* schwefel *)
let pp = 12;;
let n = 3;;
let xx = `[-- &10; -- &10; -- &10]` and
    zz = `[&10; &10; &10]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_schwefel,eval_schwefel,tf_schwefel = mk_verification_functions pp schwefel_poly true schwefel_min;;
let certificate = run_test tf_schwefel xx_float zz_float false 0.0 true false false;;
(* 1922 *)
result_size certificate;;
m_verify_raw n pp eval0_schwefel eval_schwefel certificate xx1 zz1;;
(* 10: 698 (f0_flag: 133) *)
test 1 (m_verify_raw n pp eval0_schwefel eval_schwefel certificate xx1) zz1;;

let c0 = run_test0 tf_schwefel xx_float zz_float false 0.0 true false false;;
(* 2152 *)
result_size c0;;



(***)
(* rd *)

let pp = 12;;
let n = 3;;
let xx = `[-- &5; -- &5; -- &5]` and
    zz = `[&5; &5; &5]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_rd, eval_rd, tf_rd = mk_verification_functions pp rd_poly true rd_min;;
let certificate = run_test tf_rd xx_float zz_float false 0.0 true true false;;
result_size certificate;;
m_verify_raw n pp eval0_rd eval_rd certificate xx1 zz1;;

(***)
(* caprasse *)

let pp = 8;;
let n = 4;;
let xx = `[-- #0.5; -- #0.5; -- #0.5; -- #0.5]` and
    zz = `[#0.5; #0.5; #0.5; #0.5]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_caprasse,eval_caprasse,tf_caprasse = mk_verification_functions pp caprasse_poly true caprasse_min;;
let certificate = run_test tf_caprasse xx_float zz_float false 0.0 true false false;;
(* 48 (true true false) 80 (true false false) *)
result_size certificate;;
m_verify_raw n pp eval0_caprasse eval_caprasse certificate xx1 zz1;;
(* 10: 30.826 (f0_flag: 17.625) *)
test 1 (m_verify_raw n pp eval0_caprasse eval_caprasse certificate xx1) zz1;;

let c0 = run_test0 tf_caprasse xx_float zz_float false 0.0 true false false;;
(* 128 (true false false) 88 (true true false) *)
result_size c0;;
m_verify_raw n pp eval0_caprasse eval_caprasse c0 xx1 zz1;;


(***)
(* lv *)

let pp = 5;;
let n = 4;;
let xx = `[-- &2; -- &2; -- &2; -- &2]` and
    zz = `[&2; &2; &2; &2]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_lv, eval_lv, tf_lv = mk_verification_functions pp lv_poly true lv_min;;
let certificate = run_test tf_lv xx_float zz_float false 0.0 true false false;;
(* 3 (true true false) 11 (true false false) *)
result_size certificate;;
m_verify_raw n pp eval0_lv eval_lv certificate xx1 zz1;;
(* 10: 2.688 (f0_flag: 1.216) (df0_flag: 0.564) *)
test 1 (m_verify_raw n pp eval0_lv eval_lv certificate xx1) zz1;;


let c0 = run_test0 tf_lv xx_float zz_float false 0.0 true true false;;
(* 11 (true false false) 3 (true true false) *)
result_size c0;;

(***)
(* butcher *)

let pp = 5;;
let n = 6;;
let xx = `[-- &1; -- #0.1; -- #0.1; -- &1; -- #0.1; -- #0.1]` and
    zz = `[&0; #0.9; #0.5; -- #0.1; -- #0.05; -- #0.03]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_butcher, eval_butcher, tf_butcher = mk_verification_functions pp butcher_poly true butcher_min;;
let certificate = run_test tf_butcher xx_float zz_float false 0.0 true true false;;
result_size certificate;;
m_verify_raw n pp eval0_butcher eval_butcher certificate xx1 zz1;;


(***)
(* magnetism *)

let pp = 8;;
let n = 7;;
let xx = `[-- &1; -- &1; -- &1; -- &1; -- &1; -- &1; -- &1]` and
    zz = `[&1; &1; &1; &1; &1; &1; &1]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_magnetism, eval_magnetism, tf_magnetism = 
  mk_verification_functions pp magnetism_poly true magnetism_min;;
let certificate = run_test tf_magnetism xx_float zz_float false 0.0 true false false;;
(* 8732 (true false false) 77 (true false true) *)
result_size certificate;;
m_verify_raw n pp eval0_magnetism eval_magnetism certificate xx1 zz1;;

let c0 = run_test0 tf_magnetism xx_float zz_float false 0.0 true false true;;
(* 121 (true false true) *)
result_size c0;;



let rec n_mono res =
  match res with
    | Result_pass_mono _ -> 1
    | Result_glue (_, _, r1, r2) -> n_mono r1 + n_mono r2
    | _ -> 0;;

n_mono certificate;;
let rec print_pass res =
  match res with
    | Result_pass (_, x, z) -> report (string3 (x,z,""))
    | Result_glue (_, _, r1, r2) -> print_pass r1; print_pass r2
    | _ -> ();;
print_pass certificate;;

let eval_poly = build_taylor pp magnetism_poly;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) false;;
(* 759936 *)
result_size sample;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) true;;
(* 77 *)
result_size sample;;


(***)
(* heart *)

let pp = 10;;
let n = 8;;
let xx = `[-- #0.1; #0.4; -- #0.7; -- #0.7; #0.1; -- #0.1; -- #0.3; -- #1.1]` and
    zz = `[#0.4; &1; -- #0.4; #0.4; #0.2; #0.2; #1.1; -- #0.3]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval0_heart, eval_heart, tf_heart = mk_verification_functions pp heart_poly true heart_min;;
let certificate = run_test tf_heart xx_float zz_float false 0.0 true false false;;
(* 42 (true true false) 50 (true false false) 42 (true true true) *)
result_size certificate;;
m_verify_raw n pp eval0_heart eval_heart certificate xx1 zz1;;

let c0 = run_test0 tf_heart xx_float zz_float false 0.0 true false false;;
(* 50 (true true false) 61 (true false false) 50 (true true true) *)
result_size c0;;
m_verify_raw n pp eval0_heart eval_heart c0 xx1 zz1;;


(* 10: 109 *)
test 1 (m_verify_raw_old n pp eval_heart certificate xx1) zz1;;
(* 10: 94 (f0_flag: 22.929) (df0_flag: 14.377) *)
test 1 (m_verify_raw n pp eval0_heart eval_heart certificate xx1) zz1;;
(* 10: 13 (10.625, new restrict_domain) (f0_flag: 5.3) (df0_flag: 2.264) *)
test 1 (m_verify_domain_test n pp eval_heart certificate xx1) zz1;;
