needs "../formal_lp/formal_interval/m_taylor_arith.hl";;
needs "../formal_lp/formal_interval/m_verifier.hl";;


let pp = 10;;
let n = 2;;

let poly1 = expr_to_vector_fun `x1 * x2`;;
let poly2 = expr_to_vector_fun `x2 + x1 * x2`;;

let (_, _, _, eval1), tf1 = mk_verification_functions pp poly1 false `&0` and
    (_, _, _, eval2), tf2 = mk_verification_functions pp poly2 false `&0`;;


let xx = `[&1; &1]` and
    zz = `[&2; &2]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float, zz_float =
  let pad = replicate 0.0 (8 - length (dest_list xx1)) in
    map float_of_float_tm (dest_list xx1) @ pad,
    map float_of_float_tm (dest_list zz1) @ pad;;

let domain_th = mk_m_center_domain n pp xx1 zz1;;

evalf (Uni_compose (uatan, tf2)) xx_float zz_float;;
eval_m_taylor_mul n pp (eval1 domain_th) (eval2 domain_th);;
evalf (Product (tf1, tf2)) xx_float zz_float;;



(******************************)

(* dummy functions *)

let eval_d0 i t1 t2 = failwith "eval_d0";;
let eval_dd0 i j t1 t2 = failwith "eval_dd0";;
let eval_0 t1 t2 = failwith "eval_0";;


(******************************)


(* 1d test *)

let n = 1;;
let pp = 5;;

let eval_x = eval_m_taylor_poly0 pp `\x:real^1. x$1`;;

let f_eval th =
  let x = eval_x th in
  let ( - ), ( * ), atn = eval_m_taylor_sub n pp, eval_m_taylor_mul n pp, eval_m_taylor_atn n pp in
    x * x - atn x;;

let tf = Plus (Product (x1, x1), Scale (Uni_compose (uatan, x1), ineg one));;


let xx = `[#0.01]` and
    zz = `[#0.8]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float, zz_float =
  let pad = replicate 0.0 (8 - length (dest_list xx1)) in
    map float_of_float_tm (dest_list xx1) @ pad,
    map float_of_float_tm (dest_list zz1) @ pad;;

let domain_th = mk_m_center_domain n pp xx1 zz1;;
f_eval domain_th;;
evalf tf xx_float zz_float;;

let certificate = run_test tf xx_float zz_float false 0.0 true false true false 0.0;;
let c1 = transform_result xx_float zz_float certificate;;

m_verify_list n pp (eval_d0, eval_dd0, eval_0, f_eval) c1 xx1 zz1;;



(* 2d test *)

let n = 2;;
let pp = 10;;

let eval_x = eval_m_taylor_poly0 pp `\x:real^2. x$1` and
    eval_y = eval_m_taylor_poly0 pp `\x:real^2. x$2`;;

let eval_xy = eval_m_taylor_poly0 pp `\x:real^2. x$1 * x$2`;;

let f_eval th =
  let x = eval_x th in
  let y = eval_y th in
  let ( - ), ( * ), atn = eval_m_taylor_sub n pp, eval_m_taylor_mul n pp, eval_m_taylor_atn n pp in
    atn (x * y) - x * y;;

let f_eval2 th =
  let xy = eval_xy th in
  let ( - ), ( * ), atn = eval_m_taylor_sub n pp, eval_m_taylor_mul n pp, eval_m_taylor_atn n pp in
    atn xy - xy;;


let tf = Plus (Uni_compose (uatan, Product (x1, x2)), Scale (Product (x1, x2), ineg one));;


let xx = `[#0.1; #0.1]` and
    zz = `[#0.6; #0.6]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float, zz_float =
  let pad = replicate 0.0 (8 - length (dest_list xx1)) in
    map float_of_float_tm (dest_list xx1) @ pad,
    map float_of_float_tm (dest_list zz1) @ pad;;

let domain_th = mk_m_center_domain n pp xx1 zz1;;

let certificate = run_test tf xx_float zz_float false 0.0 true false true false 0.0;;
let c1 = transform_result xx_float zz_float certificate;;

(* 10: 33.926 *)
test 1 (m_verify_list n pp (eval_d0, eval_dd0, eval_0, f_eval) c1 xx1) zz1;;
(* 10: 25.089 *)
test 1 (m_verify_list n pp (eval_d0, eval_dd0, eval_0, f_eval2) c1 xx1) zz1;;



(* 6d tests *)

let n = 6;;
let pp = 10;;

let (_, _, _, eval_xy), tf0 = 
  mk_verification_functions pp `\x:real^6. x$1 * x$2 + x$3 * x$4 + x$5 * x$6` false `&0`;;

let f_eval_sqrt th =
  let xy = eval_xy th in
  let ( - ), ( * ), sqrt = eval_m_taylor_sub n pp, eval_m_taylor_mul n pp, eval_m_taylor_sqrt n pp in
    xy - sqrt xy;;

let f_eval_atn th =
  let xy = eval_xy th in
  let ( - ), ( * ), atn = eval_m_taylor_sub n pp, eval_m_taylor_mul n pp, eval_m_taylor_atn n pp in
    atn xy - xy;;


let tf_sqrt = Plus (tf0, Scale (Uni_compose (usqrt, tf0), ineg one));;
let tf_atn = Plus (Uni_compose (uatan, tf0), Scale (tf0, ineg one));;


let xx = `[#0.1; #0.1; #0.1; #0.1; #0.1; #0.1]` and
    zz = `[#0.2; #0.2; #0.2; #0.2; #0.2; #0.2]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx_float, zz_float =
  let pad = replicate 0.0 (8 - length (dest_list xx1)) in
    map float_of_float_tm (dest_list xx1) @ pad,
    map float_of_float_tm (dest_list zz1) @ pad;;


let certificate_sqrt = run_test tf_sqrt xx_float zz_float false 0.0 true false true false 0.0;;
let c1_sqrt = transform_result xx_float zz_float certificate_sqrt;;

let certificate_atn = run_test tf_atn xx_float zz_float false 0.0 true false true false 0.0;;
let c1_atn = transform_result xx_float zz_float certificate_atn;;

m_verify_list n pp (eval_d0, eval_dd0, eval_0, f_eval_sqrt) c1_sqrt xx1 zz1;;
m_verify_list n pp (eval_d0, eval_dd0, eval_0, f_eval_atn) c1_atn xx1 zz1;;



(*********************************)

(* real tests *)

let n = 6;;
let pp = 15;;
(* let pp = 8;; *)

(* delta_y *)
let delta_y_poly =
  let tm = (rand o concl o SPEC_ALL o REWRITE_RULE[Sphere.delta_x]) Sphere.delta_y in
    expr_to_vector_fun tm;;

(* delta_y4 *)
let delta_y4_poly =
  let tm = (rand o concl o SPECL[`y1*y1`; `y2*y2`; `y3*y3`; `y4*y4`; `y5*y5`; `y6*y6`]) Sphere.delta_x4 in
    expr_to_vector_fun tm;;

(* 4 * y1 * delta_y *)
let four_y1_delta_y_poly = 
  let x_var, tm = dest_abs delta_y_poly in
    mk_abs (x_var, mk_binop mul_op_real `&4` (mk_binop mul_op_real `(x:real^6)$1 * x$1` tm));;

(* - delta_y4 *)
let neg_delta_y4_poly =
  let x_var, tm = dest_abs delta_y4_poly in
    mk_abs (x_var, mk_comb (neg_op_real, tm));;


let (_, _, _, eval_neg_delta_y4), tf_neg_delta_y4 = 
  mk_verification_functions pp neg_delta_y4_poly false `&0`;;

let (_, _, _, eval_4y1_delta_y), tf_4y1_delta_y = 
  mk_verification_functions pp four_y1_delta_y_poly false `&0`;;


let (_, _, _, eval_pi2_plus), tf_pi2_plus = 
  mk_verification_functions pp `\x:real^6. pi / &2 - #1.893` false `&0`;;


Sphere.dih_x;;

(* dih_y *)
let tf_dih_y =
  let denom = Uni_compose (uinv, Uni_compose (usqrt, tf_4y1_delta_y)) in
    Plus (tf_pi2_plus, Uni_compose (uatan, Product (tf_neg_delta_y4, denom)));;

let eval_dih_y th =
  let inv, atn, sqrt, ( * ), ( + ) = 
    eval_m_taylor_inv n pp, eval_m_taylor_atn n pp, eval_m_taylor_sqrt n pp, 
    eval_m_taylor_mul n pp, eval_m_taylor_add n pp in
  let poly1 = eval_4y1_delta_y th and
      poly2 = eval_neg_delta_y4 th and
      pi2 = eval_pi2_plus th in
    pi2 + atn (poly2 * inv (sqrt (poly1)));;
    


(************)

let xx = `[&2; &2; &2; &2; &2; &2]` and
    zz = `[#2.52; #2.52; #2.52; #2.52; #2.52; #2.52]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;


(* Small domain *)
let xx_s = `[&2; &2; &2; &2; &2; &2]` and
    zz_s = `[#2.1; #2.1; #2.1; #2.1; #2.1; #2.1]`;;

let domain_th =
  let xx1_s = convert_to_float_list pp true xx_s and
      zz1_s = convert_to_float_list pp false zz_s in
    mk_m_center_domain n pp xx1_s zz1_s;;

(* 10: 9.121; 300: 5.5 (pp = 8) *)
test 1 eval_dih_y domain_th;;


(***)

let xx_s = `[&2; &2; &2; &2; &2; &2]` and
    zz_s = `[#2.52; #2.1; #2.1; #2.1; #2.1; #2.1]`;;

let xx1_s = convert_to_float_list pp true xx_s and
    zz1_s = convert_to_float_list pp false zz_s;;


let xx_float, zz_float, xx_s_float, zz_s_float =
  let pad = replicate 0.0 (8 - length (dest_list xx1)) in
    map float_of_float_tm (dest_list xx1) @ pad,
    map float_of_float_tm (dest_list zz1) @ pad,
    map float_of_float_tm (dest_list xx1_s) @ pad,
    map float_of_float_tm (dest_list zz1_s) @ pad;;



(***)

let c_dih_y_s = run_test tf_dih_y xx_s_float zz_s_float false 0.0 true false true false 0.0;;
let c_dih_y = run_test tf_dih_y xx_float zz_float false 0.0 true false true false 0.0;;
let c_dih_y0 = run_test tf_dih_y xx_float zz_float false 0.0 true false false false 0.0;;
let c_dih_y_full = run_test tf_dih_y xx_float zz_float false 0.0 true true true true 0.0;;

(* pass = 4 *)
result_stat c_dih_y_s;;

(* pass = 4292, mono = 8, pass_mono = 2 *)
result_stat c_dih_y;;
(* pass = 4294, mono = 10 *)
result_stat c_dih_y0;;
(* pass = 4292, mono = 8, pass_mono = 2 *)
result_stat c_dih_y_full;;

m_verify_raw0 n pp (eval_d0, eval_dd0, eval_0, eval_dih_y) c_dih_y_s xx1_s zz1_s;;
(* 10: 38.418; 300: 22.289 (pp = 8)*)
test 1 (m_verify_raw0 n pp (eval_d0, eval_dd0, eval_0, eval_dih_y) c_dih_y_s xx1_s) zz1_s;;


(*
m_verify_raw0 n pp (eval_d0, eval_dd0, eval_0, eval_dih_y) c_dih_y0 xx1 zz1;;
let c1_dih_y = transform_result xx_float zz_float c_dih_y;;
*)
