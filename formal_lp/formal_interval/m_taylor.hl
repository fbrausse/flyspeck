needs "../formal_lp/formal_interval/theory/multivariate_taylor.hl";;
needs "../formal_lp/formal_interval/second_approx.hl";;
needs "../formal_lp/formal_interval/eval_interval.hl";;

let max_dim = 8;;

let inst_first_type_var ty th =
  let ty_vars = type_vars_in_term (concl th) in
    if ty_vars = [] then
      failwith "inst_first_type: no type variables in the theorem"
    else
      INST_TYPE [ty, hd ty_vars] th;;

let float0 = mk_float 0 min_exp and
    interval0 = mk_float_interval_small_num 0;;


let real_ty = `:real` and
    real_list_ty = `:(real)list` and
    real_pair_ty = `:real#real` and
    real_pair_list_ty = `:(real#real)list` and
    nty = `:N`;;

let d_bounds_list_var = `d_bounds_list : (real#real)list` and
    dd_bounds_list_var = `dd_bounds_list : ((real#real)list)list`;;

let has_size_array = Array.init (max_dim + 1) 
  (fun i -> match i with
     | 0 -> TRUTH
     | 1 -> HAS_SIZE_1
     | _ -> define_finite_type i);;

let dimindex_array = Array.init (max_dim + 1) 
  (fun i -> if i < 1 then TRUTH else MATCH_MP DIMINDEX_UNIQUE has_size_array.(i));;

let n_type_array = Array.init (max_dim + 1)
  (fun i -> if i < 1 then bool_ty else 
     let dimindex_th = dimindex_array.(i) in
       (hd o snd o dest_type o snd o dest_const o rand o lhand o concl) dimindex_th);;

let n_vector_type_array = Array.init (max_dim + 1)
  (fun i -> if i < 1 then bool_ty else mk_type ("cart", [real_ty; n_type_array.(i)]));;



(********************)
(* List conversions *)
(********************)

(**********************)
(* raw_compute_length *)
let suc_const = `SUC`;;

let LENGTH_0' = (RULE o prove)(`LENGTH ([]:(A)list) = 0`, REWRITE_TAC[LENGTH]);;
let LENGTH_CONS' = (RULE o prove)(`LENGTH (CONS (h:A) t) = SUC (LENGTH t)`, REWRITE_TAC[LENGTH]);;


let raw_compute_length list_tm =
  let list_ty = type_of list_tm in
  let ty = (hd o snd o dest_type) list_ty in
  let inst_t = INST_TYPE[ty, aty] in
  let length_empty, length_cons = inst_t LENGTH_0', inst_t LENGTH_CONS' in
  let h_var, t_var = mk_var("h", ty), mk_var("t", list_ty) in

  let rec length_conv_raw = fun list_tm ->
    if (is_comb list_tm) then
      let ltm, t_tm = dest_comb list_tm in
      let h_tm = rand ltm in
      let th0 = INST[h_tm, h_var; t_tm, t_var] length_cons in
      let th1' = length_conv_raw t_tm in
      let th1 = AP_TERM suc_const th1' in
      let th2 = raw_suc_conv_hash (rand(concl th1)) in
	TRANS (TRANS th0 th1) th2
    else
      length_empty in
    length_conv_raw list_tm;;


(***************)
(* compute_zip *)

let ZIP_0' = prove(`ZIP ([]:(A)list) ([]:(B)list) = []`, REWRITE_TAC[ZIP]);;
let ZIP_CONS' = prove(`ZIP (CONS (h1:A) t1) (CONS (h2:B) t2) = CONS (h1, h2) (ZIP t1 t2)`,
		      REWRITE_TAC[ZIP]);;

let compute_zip list1_tm list2_tm =
  let list1_ty = type_of list1_tm and
      list2_ty = type_of list2_tm in
  let ty1 = (hd o snd o dest_type) list1_ty and
      ty2 = (hd o snd o dest_type) list2_ty in
  let inst_t = INST_TYPE[ty1, aty; ty2, bty] in
  let zip0, zip_cons = inst_t ZIP_0', inst_t ZIP_CONS' in
  let h1_var, t1_var = mk_var("h1", ty1), mk_var("t1", list1_ty) and
      h2_var, t2_var = mk_var("h2", ty2), mk_var("t2", list2_ty) in

  let rec zip_conv_rec = fun list1_tm list2_tm ->
    if (is_comb list1_tm) then
      let ltm1, t1_tm = dest_comb list1_tm and
	  ltm2, t2_tm = dest_comb list2_tm in
      let h1_tm, h2_tm = rand ltm1, rand ltm2 in
      let th0 = INST[h1_tm, h1_var; t1_tm, t1_var; h2_tm, h2_var; t2_tm, t2_var] zip_cons in
      let cons_tm = (rator o rand o concl) th0 in
      let th1' = zip_conv_rec t1_tm t2_tm in
      let th1 = AP_TERM cons_tm th1' in
	TRANS th0 th1
    else
      zip0 in
    zip_conv_rec list1_tm list2_tm;;


(****************)
(* compute_all2 *)

let ALL2_0' = prove(`ALL2 P ([]:(A)list) ([]:(B)list)`, REWRITE_TAC[ALL2]);;
let ALL2_CONS' = (RULE o prove)(`P h1 h2 /\ ALL2 P t1 t2 ==> ALL2 P (CONS (h1:A) t1) (CONS (h2:B) t2)`,
				REWRITE_TAC[ALL2]);;

(* Does not work for empty lists *)
let compute_all2 p_conv list1_tm list2_tm =
  let list1_ty = type_of list1_tm and
      list2_ty = type_of list2_tm in
  let ty1 = (hd o snd o dest_type) list1_ty and
      ty2 = (hd o snd o dest_type) list2_ty in
  let inst_t = INST_TYPE[ty1, aty; ty2, bty] in
  let all2_0, all2_cons = inst_t ALL2_0', inst_t ALL2_CONS' in
  let h1_var, t1_var = mk_var("h1", ty1), mk_var("t1", list1_ty) and
      h2_var, t2_var = mk_var("h2", ty2), mk_var("t2", list2_ty) and
      p_var = mk_var("P", mk_fun_ty ty1 (mk_fun_ty ty2 bool_ty)) in

  let rec all2_conv_rec = fun list1_tm list2_tm ->
    let ltm1, t1_tm = dest_comb list1_tm and
	ltm2, t2_tm = dest_comb list2_tm in
    let h1_tm, h2_tm = rand ltm1, rand ltm2 in
    let p_th = p_conv h1_tm h2_tm in
    let p_tm = (rator o rator o concl) p_th in
    let all2_th = if is_comb t1_tm then all2_conv_rec t1_tm t2_tm else INST[p_tm, p_var] all2_0 in
	(MY_PROVE_HYP all2_th o MY_PROVE_HYP p_th o 
	   INST[h1_tm, h1_var; t1_tm, t1_var; h2_tm, h2_var; t2_tm, t2_var; p_tm, p_var]) all2_cons in
    
    all2_conv_rec list1_tm list2_tm;;


let p_conv = (fun t1 t2 -> (EQT_ELIM o NUM_LT_CONV) (mk_binop lt_op_num t1 t2));;
let list1_tm = `[1;3;4;2;4]` and list2_tm = `[2;343;454;454;454]`;;

compute_all2 p_conv list1_tm list2_tm;;





(************************************)
(* m_cell_domain *)

let ALL2_ALL_ZIP = prove(`!(P:A->B->bool) l1 l2. LENGTH l1 = LENGTH l2 ==> 
    (ALL2 P l1 l2 <=> ALL (\p. P (FST p) (SND p)) (ZIP l1 l2))`,
  GEN_TAC THEN LIST_INDUCT_TAC THENL
    [
      GEN_TAC THEN REWRITE_TAC[LENGTH; EQ_SYM_EQ; LENGTH_EQ_NIL] THEN 
	DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
	REWRITE_TAC[ZIP; ALL2; ALL];
      ALL_TAC
    ] THEN

    LIST_INDUCT_TAC THEN REWRITE_TAC[LENGTH] THENL [ARITH_TAC; ALL_TAC] THEN
    REWRITE_TAC[eqSS] THEN DISCH_TAC THEN
    REWRITE_TAC[ALL2; ZIP; ALL] THEN
    FIRST_X_ASSUM (new_rewrite [] []) THEN ASM_REWRITE_TAC[]);;

let EL_ZIP = prove(`!(l1:(A)list) (l2:(B)list) i. LENGTH l1 = LENGTH l2 /\ i < LENGTH l1 ==> 
    EL i (ZIP l1 l2) = (EL i l1, EL i l2)`,
  LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[ZIP; LENGTH] THEN TRY ARITH_TAC THEN
    case THEN REWRITE_TAC[EL; HD; TL] THEN GEN_TAC THEN
    REWRITE_TAC[eqSS; ARITH_RULE `SUC n < SUC x <=> n < x`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;

let LENGTH_ZIP = prove(`!l1 l2. LENGTH l1 = LENGTH l2 ==> LENGTH (ZIP l1 l2) = LENGTH l1`,
  LIST_INDUCT_TAC THEN LIST_INDUCT_TAC THEN REWRITE_TAC[ZIP; LENGTH] THEN TRY ARITH_TAC THEN
    REWRITE_TAC[eqSS] THEN DISCH_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]);;

    

let VECTOR_COMPONENT = prove(`!l i. i IN 1..dimindex (:N) ==>
			       (vector l:A^N)$i = EL (i - 1) l`,
REWRITE_TAC[IN_NUMSEG] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN REWRITE_TAC[vector] THEN
  MATCH_MP_TAC LAMBDA_BETA THEN ASM_REWRITE_TAC[]);;


let test_domain_xi = new_definition
  `test_domain_xi xz yw <=> FST xz <= FST yw /\ FST yw <= SND xz /\ 
  FST yw - FST xz <= SND yw /\ SND xz - FST yw <= SND yw`;;

let MK_CELL_DOMAIN = prove(`!xz (yw:(real#real)list) x z y w.
    LENGTH x = dimindex (:N) /\ LENGTH z = dimindex (:N) /\
    LENGTH y = dimindex (:N) /\ LENGTH w = dimindex (:N) /\
    ZIP y w = yw /\ ZIP x z = xz /\
    ALL2 test_domain_xi xz yw ==>
    m_cell_domain (vector x, vector z:real^N) (vector y) (vector w)`,
  REPEAT GEN_TAC THEN STRIP_TAC THEN POP_ASSUM MP_TAC THEN
    SUBGOAL_THEN `LENGTH (xz:(real#real)list) = dimindex (:N) /\ LENGTH (yw:(real#real)list) = dimindex (:N)` ASSUME_TAC THENL
    [
      EXPAND_TAC "yw" THEN EXPAND_TAC "xz" THEN
	REPEAT (new_rewrite [] [] LENGTH_ZIP) THEN ASM_REWRITE_TAC[];
      ALL_TAC
    ] THEN
    rewrite [] [] ALL2_ALL_ZIP THEN ASM_REWRITE_TAC[m_cell_domain; GSYM ALL_EL] THEN DISCH_TAC THEN
    REWRITE_TAC[m_cell_domain] THEN GEN_TAC THEN DISCH_TAC THEN
    REPEAT (new_rewrite [] [] VECTOR_COMPONENT) THEN ASM_REWRITE_TAC[] THEN
    ABBREV_TAC `j = i - 1` THEN
    SUBGOAL_THEN `j < dimindex (:N)` ASSUME_TAC THENL
    [
      POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN REWRITE_TAC[IN_NUMSEG] THEN ARITH_TAC;
      ALL_TAC
    ] THEN
    FIRST_X_ASSUM (MP_TAC o SPEC `j:num`) THEN REWRITE_TAC[test_domain_xi] THEN
    rewrite [] [] LENGTH_ZIP THEN ASM_REWRITE_TAC[] THEN
    rewrite [] [] EL_ZIP THEN ASM_REWRITE_TAC[] THEN
    EXPAND_TAC "xz" THEN EXPAND_TAC "yw" THEN
    REPEAT (new_rewrite [] [] EL_ZIP) THEN ASM_REWRITE_TAC[] THEN
    ARITH_TAC);;




let float0_eq = FLOAT_TO_NUM_CONV (mk_float 0 min_exp);;
     

(* array of theorems *)
let mk_m_domain_array =
  let mk_m_domain n =
    let dimindex_th = dimindex_array.(n) in
    let n_ty = (hd o snd o dest_type o snd o dest_const o rand o lhand o concl) dimindex_th in
    let nty = `:N` in
      (UNDISCH_ALL o REWRITE_RULE[float0_eq] o DISCH_ALL o RULE o 
	 REWRITE_RULE[dimindex_th] o INST_TYPE[n_ty, nty]) MK_CELL_DOMAIN in
    Array.init (max_dim + 1) (fun i -> if i < 1 then TRUTH else mk_m_domain i);;



let x_var_real_list = `x:(real)list` and
    y_var_real_list = `y:(real)list` and
    z_var_real_list = `z:(real)list` and
    w_var_real_list = `w:(real)list` and
    yw_var = `yw:(real#real)list` and
    xz_var = `xz:(real#real)list` and
    xz_pair_var = `xz:real#real` and
    yw_pair_var = `yw:real#real`;;




let TEST_DOMAIN_XI' = (RULE o prove)(`xz = (x,z) /\ yw = (y,w) /\
    x <= y /\ y <= z /\ y - x <= w1 /\ z - y <= w2 /\ w1 <= w /\ w2 <= w ==> test_domain_xi xz yw`,
  SIMP_TAC[test_domain_xi] THEN REAL_ARITH_TAC);;


let eval_test_domain_xi xz yw =
  let x, z = dest_pair xz and
      y, w = dest_pair yw in
  let (<=) = (fun t1 t2 -> EQT_ELIM (float_le t1 t2)) and
      (-) = float_sub_hi pp in
  let x_le_y = x <= y and
      y_le_z = y <= z and
      yx_le_w1 = y - x and
      zy_le_w2 = z - y in
  let w1 = (rand o concl) yx_le_w1 and
      w2 = (rand o concl) zy_le_w2 in
  let w1_le_w = w1 <= w and
      w2_le_w = w2 <= w in
    (MY_PROVE_HYP (REFL xz) o MY_PROVE_HYP (REFL yw) o
      MY_PROVE_HYP x_le_y o MY_PROVE_HYP y_le_z o 
       MY_PROVE_HYP yx_le_w1 o MY_PROVE_HYP zy_le_w2 o
       MY_PROVE_HYP w1_le_w o MY_PROVE_HYP w2_le_w o
       INST[x, x_var_real; y, y_var_real; z, z_var_real; w, w_var_real;
	    w1, w1_var_real; w2, w2_var_real; 
	    xz, xz_pair_var; yw, yw_pair_var]) TEST_DOMAIN_XI';;
    

(* mk_m_center_domain *)
let mk_m_center_domain n pp x_list_tm z_list_tm =
  let x_list = dest_list x_list_tm and
      z_list = dest_list z_list_tm in
  let y_list =
    let ( * ) = (fun t1 t2 -> (rand o concl) (float_mul_eq t1 t2)) and
	(+) = (fun t1 t2 -> (rand o concl) (float_add_hi pp t1 t2)) in
      map2 (fun x y -> float_inv2 * (x + y)) x_list z_list in

  let w_list =
    let (-) = (fun t1 t2 -> (rand o concl) (float_sub_hi pp t1 t2)) and
	max = (fun t1 t2 -> (rand o concl) (float_max t1 t2)) in
    let w1 = map2 (-) y_list x_list and
	w2 = map2 (-) z_list y_list in
      map2 max w1 w2 in

  let y_list_tm = mk_list (y_list, real_ty) and
      w_list_tm = mk_list (w_list, real_ty) in

  let yw_zip_th = compute_zip y_list_tm w_list_tm and
      xz_zip_th = compute_zip x_list_tm z_list_tm in

  let yw_list_tm = (rand o concl) yw_zip_th and
      xz_list_tm = (rand o concl) xz_zip_th in

  let len_x_th = raw_compute_length x_list_tm and
      len_z_th = raw_compute_length z_list_tm and
      len_y_th = raw_compute_length y_list_tm and
      len_w_th = raw_compute_length w_list_tm in

  let all_th = compute_all2 eval_test_domain_xi xz_list_tm yw_list_tm in
    (MY_PROVE_HYP all_th o
       MY_PROVE_HYP len_x_th o MY_PROVE_HYP len_z_th o
       MY_PROVE_HYP len_y_th o MY_PROVE_HYP len_w_th o
       MY_PROVE_HYP yw_zip_th o MY_PROVE_HYP xz_zip_th o
       INST[x_list_tm, x_var_real_list; z_list_tm, z_var_real_list;
	    y_list_tm, y_var_real_list; w_list_tm, w_var_real_list;
	    yw_list_tm, yw_var; xz_list_tm, xz_var]) mk_m_domain_array.(n);;
  



let n = 8;;
let pp = 5;;

let x_list_tm = mk_list (replicate one_float n, real_ty) and
    z_list_tm = mk_list (replicate two_float n, real_ty);;

mk_m_center_domain n pp x_list_tm z_list_tm;;

test 100 (mk_m_center_domain n pp x_list_tm) z_list_tm;;


(***********************)
(* eval_m_taylor_const *)


let MK_M_TAYLOR_INTERVAL' = (RULE o MATCH_MP iffRL o SPEC_ALL) m_taylor_interval;;


let get_types_and_vars n =
  let ty = n_type_array.(n) and
      xty = n_vector_type_array.(n) in
  let x_var = mk_var ("x", xty) and
      f_var = mk_var ("f", mk_fun_ty xty real_ty) and
      y_var = mk_var ("y", xty) and
      w_var = mk_var ("w", xty) and
      domain_var = mk_var ("domain", mk_type ("prod", [xty; xty])) in
    ty, xty, x_var, f_var, y_var, w_var, domain_var;;



let gen_m_taylor_const_thm n const_int =
  let lhs, f_bounds = dest_comb (concl const_int) in
  let c_tm = rand lhs in
  let ty, _, x_var, f_var, _, _, _ = get_types_and_vars n in
  let f_tm = mk_abs (x_var, c_tm) in

  let pair0 = mk_pair (float0, float0) in
  let list0 = mk_list (replicate pair0 n, real_pair_ty) in
  let d_bounds_list = list0 and
      dd_bounds_list = mk_list (replicate list0 n, real_pair_list_ty) in

  let th0 = (DISCH_ALL o 
	       INST[f_tm, f_var; f_bounds, f_bounds_var;
		    d_bounds_list, d_bounds_list_var;
		    dd_bounds_list, dd_bounds_list_var] o 
	       inst_first_type_var ty) MK_M_TAYLOR_INTERVAL' in
  let th1 = REWRITE_RULE[diff2_domain_const; second_bounded; 
			 partial2_const; m_lin_approx; partial_const; const_int] th0 in
    UNDISCH_ALL (SIMP_RULE[all_n; interval0; m_lin_approx; diff2_const; diff2_imp_diff] th1);;




let dest_m_cell_domain domain_tm =
  let lhs, w_tm = dest_comb domain_tm in
  let lhs2, y_tm = dest_comb lhs in
    rand lhs2, y_tm, w_tm;;


let eval_m_taylor_const_int taylor_int_th domain_th =
  let domain_hyp = hd (hyp taylor_int_th) in
  let domain_var, y_var, w_var = dest_m_cell_domain domain_hyp and
      domain_tm, y_tm, w_tm = dest_m_cell_domain (concl domain_th) in
    (MY_PROVE_HYP domain_th o
       INST[domain_tm, domain_var; y_tm, y_var; w_tm, w_var]) taylor_int_th;;
  

let pp = 5;;
let const_int = pi_approx_array.(pp);;
let n = 3;;
let const_th = gen_m_taylor_const_thm n const_int;;
let domain_th = 
  let x_list_tm = mk_list (replicate one_float n, real_ty) and
      z_list_tm = mk_list (replicate two_float n, real_ty) in
    mk_m_center_domain n pp x_list_tm z_list_tm;;

eval_m_taylor_const_int const_th domain_th;;
test 1000 (eval_m_taylor_const_int const_th) domain_th;;


(**************************************************)

(* Given a variable of the type `:real^N` returns the number N *)
let get_dim = int_of_string o fst o dest_type o hd o tl o snd o dest_type o type_of;;


(**********************)
(* eval_m_taylor_poly *)

let partial_pow = prove(`!i f n (y:real^N). lift o f differentiable at y ==>
			  partial i (\x. f x pow n) y = &n * f y pow (n - 1) * partial i f y`,
  REPEAT STRIP_TAC THEN
    SUBGOAL_THEN `(\x:real^N. f x pow n) = (\t. t pow n) o f` (fun th -> REWRITE_TAC[th]) THENL
    [
      ONCE_REWRITE_TAC[GSYM eq_ext] THEN REWRITE_TAC[o_THM];
      ALL_TAC
    ] THEN
    new_rewrite [] [] partial_uni_compose THENL
    [
      ASM_REWRITE_TAC[] THEN
	new_rewrite [] [] REAL_DIFFERENTIABLE_POW_ATREAL THEN REWRITE_TAC[REAL_DIFFERENTIABLE_ID];
      ALL_TAC
    ] THEN
    new_rewrite [] [] derivative_pow THEN REWRITE_TAC[REAL_DIFFERENTIABLE_ID; derivative_x] THEN
    REAL_ARITH_TAC);;


let nth_diff2_pow = prove(`!n y. nth_diff_strong 2 (\x. x pow n) y`,
  REWRITE_TAC[nth_diff_strong2_eq] THEN REPEAT GEN_TAC THEN
    EXISTS_TAC `(:real)` THEN REWRITE_TAC[REAL_OPEN_UNIV; IN_UNIV] THEN GEN_TAC THEN
    new_rewrite [] [] REAL_DIFFERENTIABLE_POW_ATREAL THEN REWRITE_TAC[REAL_DIFFERENTIABLE_ID] THEN
    MATCH_MP_TAC differentiable_local THEN
    EXISTS_TAC `\x. &n * x pow (n - 1)` THEN EXISTS_TAC `(:real)` THEN
    REWRITE_TAC[REAL_OPEN_UNIV; IN_UNIV] THEN
    new_rewrite [] [] REAL_DIFFERENTIABLE_MUL_ATREAL THEN REWRITE_TAC[REAL_DIFFERENTIABLE_CONST] THENL
    [
      new_rewrite [] [] REAL_DIFFERENTIABLE_POW_ATREAL THEN REWRITE_TAC[REAL_DIFFERENTIABLE_ID];
      ALL_TAC
    ] THEN
    GEN_TAC THEN new_rewrite [] [] derivative_pow THEN REWRITE_TAC[REAL_DIFFERENTIABLE_ID] THEN
    REWRITE_TAC[derivative_x; REAL_MUL_RID]);;
    


let diff2_pow = prove(`!f n (x:real^N). diff2 f x ==> diff2 (\x. f x pow n) x`,
  REPEAT STRIP_TAC THEN
    SUBGOAL_THEN `(\x:real^N. f x pow n) = (\t. t pow n) o f` (fun th -> REWRITE_TAC[th]) THENL
    [
      ONCE_REWRITE_TAC[GSYM eq_ext] THEN REWRITE_TAC[o_THM];
      ALL_TAC
    ] THEN
    apply_tac diff2_uni_compose THEN ASM_REWRITE_TAC[nth_diff2_pow]);;


let diff2_domain_pow = prove(`!f n domain. diff2_domain domain f ==> 
			       diff2_domain domain (\x. f x pow n)`,
  REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN ASM_SIMP_TAC[diff2_pow]);;


let diff2_domain_tm = `diff2_domain domain`;;

let rec gen_diff2_domain_poly poly_tm =
  let x_var, expr = dest_abs poly_tm in
  let n = (int_of_string o fst o dest_type o hd o tl o snd o dest_type o type_of) x_var in
  let diff2_tm = mk_icomb (diff2_domain_tm, poly_tm) in
    if frees expr = [] then
      (* const *)
      (SPEC_ALL o ISPEC expr o inst_first_type_var (n_type_array.(n))) diff2_domain_const
    else
      let lhs, r_tm = dest_comb expr in
	if lhs = neg_op_real then
	  (* -- *)
	  let r_th = gen_diff2_domain_poly (mk_abs (x_var, r_tm)) in
	    prove(diff2_tm, MATCH_MP_TAC diff2_domain_neg THEN REWRITE_TAC[r_th])
	else
	  let op, l_tm = dest_comb lhs in
	  let name = (fst o dest_const) op in
	    if name = "$" then
	      (* x$k *)
	      let dim_th = dimindex_array.(n) in
		prove(diff2_tm, MATCH_MP_TAC diff2_domain_x THEN
			REWRITE_TAC[IN_NUMSEG; dim_th] THEN ARITH_TAC)
	    else
	      let l_th = gen_diff2_domain_poly (mk_abs (x_var, l_tm)) in
		if name = "real_pow" then
		  (* f pow n *)
		  prove(diff2_tm, MATCH_MP_TAC diff2_domain_pow THEN REWRITE_TAC[l_th])
		else
		  let r_th = gen_diff2_domain_poly (mk_abs (x_var, r_tm)) in
		    prove(diff2_tm,
			  MAP_FIRST apply_tac [diff2_domain_add; diff2_domain_sub; diff2_domain_mul] THEN
			    REWRITE_TAC[l_th; r_th])


let gen_diff2_poly =
  let th_imp = prove(`!f. (!domain. diff2_domain domain f) ==> !x:real^N. diff2 f x`,
		     REWRITE_TAC[diff2_domain] THEN REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
		       EXISTS_TAC `(x:real^N, x:real^N)` THEN
		       REWRITE_TAC[INTERVAL_SING; IN_SING]) in
    fun poly_tm ->
      (MATCH_MP th_imp o GEN_ALL o gen_diff2_domain_poly) poly_tm;;

let gen_diff_poly =
  let th_imp = prove(`!f. (!domain. diff2_domain domain f) ==> !x:real^N. lift o f differentiable at x`,
		     REWRITE_TAC[diff2_domain; diff2] THEN REPEAT STRIP_TAC THEN
		       FIRST_X_ASSUM (MP_TAC o SPECL [`x:real^N, x:real^N`; `x:real^N`]) THEN
		       REWRITE_TAC[INTERVAL_SING; IN_SING] THEN case THEN REPEAT STRIP_TAC THEN
		       FIRST_X_ASSUM (MP_TAC o SPEC `x:real^N`) THEN ASM_SIMP_TAC[]) in
    fun poly_tm ->
      (MATCH_MP th_imp o GEN_ALL o gen_diff2_domain_poly) poly_tm;;



let in_tm = `IN`;;

let gen_partial_poly i poly_tm =
  let i_tm = mk_small_numeral i in
  let rec gen_rec poly_tm =
    let x_var, expr = dest_abs poly_tm in
    let n = (int_of_string o fst o dest_type o hd o tl o snd o dest_type o type_of) x_var in
      if frees expr = [] then
	(* const *)
	(SPECL [i_tm; expr] o inst_first_type_var (n_type_array.(n))) partial_const
      else
	let lhs, r_tm = dest_comb expr in
	  if lhs = neg_op_real then
	    (* -- *)
	    let r_poly = mk_abs (x_var, r_tm) in
	    let r_diff = (SPEC_ALL o gen_diff_poly) r_poly and
		r_partial = gen_rec r_poly in
	    let th0 = SPEC i_tm (MATCH_MP partial_neg r_diff) in 
	      REWRITE_RULE[r_partial] th0
	    else
	      let op, l_tm = dest_comb lhs in
	      let name = (fst o dest_const) op in
		if name = "$" then
		  (* comp *)
		  let dim_th = dimindex_array.(n) in
		  let dim_tm = (lhand o concl) dim_th in
		  let i_eq_k = NUM_EQ_CONV (mk_eq (i_tm, r_tm)) in
		  let int_tm = mk_binop `..` `1` dim_tm in
		  let k_in_dim = prove(mk_comb (mk_icomb(in_tm, r_tm), int_tm),
				       REWRITE_TAC[IN_NUMSEG; dim_th] THEN ARITH_TAC) in
		    (REWRITE_RULE[i_eq_k] o MATCH_MP (SPECL [r_tm; i_tm] partial_x)) k_in_dim
		else
		  let l_poly = mk_abs (x_var, l_tm) in
		  let l_partial = gen_rec l_poly in
		  let l_diff = (SPEC_ALL o gen_diff_poly) l_poly in
		    if name = "real_pow" then
		      (* f pow n *)
		      let th0 = SPECL [i_tm; r_tm] (MATCH_MP partial_pow l_diff) in
			REWRITE_RULE[l_partial] th0
		    else
		      let r_poly = mk_abs (x_var, r_tm) in
		      let r_partial = gen_rec r_poly in
		      let r_diff = (SPEC_ALL o gen_diff_poly) r_poly in
		      let imp_th = assoc op [add_op_real, partial_add; 
					     sub_op_real, partial_sub;
					     mul_op_real, partial_mul] in
		      let th0 = SPEC i_tm (MATCH_MP (MATCH_MP imp_th l_diff) r_diff) in
			REWRITE_RULE[l_partial; r_partial] th0 in
    
  let th1 = gen_rec poly_tm in
  let th2 = ((NUM_REDUCE_CONV THENC REWRITE_CONV[DECIMAL] THENC REAL_POLY_CONV) o rand o concl) th1 in
    (REWRITE_RULE[ETA_AX] o ONCE_REWRITE_RULE[eq_ext] o GEN_ALL) (TRANS th1 th2);;


let gen_partial2_poly i j poly_tm =
  let partial_j = gen_partial_poly j poly_tm in
  let partial_ij = gen_partial_poly i (rand (concl partial_j)) in
  let pi = (rator o lhand o concl) partial_ij in
    REWRITE_RULE[GSYM partial2] (TRANS (AP_TERM pi partial_j) partial_ij);;


let poly_tm = `\x:real^2. (x$1 - x$2) pow 3 * (x$1 - x$2) * x$1 pow 2`;;
gen_partial2_poly 2 2 poly_tm;;



let expr_to_vector_fun =
  let comp_op = `$` in
    fun expr_tm ->
      let vars = sort (<) (frees expr_tm) in
      let n = length vars in
      let x_var = mk_var ("x", n_vector_type_array.(n)) in
      let x_tm = mk_icomb (comp_op, x_var) in
      let vars2 = map (fun i -> mk_comb (x_tm, mk_small_numeral i)) (1--n) in
	mk_abs (x_var, subst (zip vars2 vars) expr_tm);;


let delta_x4_poly = expr_to_vector_fun ((rand o concl o SPEC_ALL) Sphere.delta_x4);;
gen_partial2_poly 2 3 delta_x4_poly;;
(*
map (fun i -> map (fun j -> gen_partial2_poly i j poly_delta_x4) (1--6)) (1--6);;
*)



(**************************)
(* Examples *)
let schwefel_poly = expr_to_vector_fun `(x1 - x2 pow 2) pow 2 + (x2 - &1) pow 2 + 
  (x1 - x3 pow 2) pow 2 + (x3 - &1) pow 2`;;
let rd_poly = expr_to_vector_fun `-- x1 + &2 * x2 - x3 - #0.835634534 * x2 * (&1 + x2)`;;
let caprasse_poly = expr_to_vector_fun `-- x1 * x3 pow 3 + &4 * x2 * x3 pow 2 * x4 + 
  &4 * x1 * x3 * x4 pow 2 + &2 * x2 * x4 pow 3 + &4 * x1 * x3 + &4 * x3 pow 2 - 
  &10 * x2 * x4 - &10 * x4 pow 2 + &2`;;
let lv_poly = expr_to_vector_fun `x1 * x2 pow 2 + x1 * x3 pow 2 + x1 * x4 pow 2 - #1.1 * x1 + &1`;;
let butcher_poly = expr_to_vector_fun `x6 * x2 pow 2 + x5 * x3 pow 2 - x1 * x4 pow 2 + x4 pow 2 -
  &1 / &3 * x1 + &4 / &3 * x4`;;
let magnetism_poly = expr_to_vector_fun `x1 pow 2 + &2 * x2 pow 2 + &2 * x3 pow 2 + &2 * x4 pow 2 +
  &2 * x5 pow 2 + &2 * x6 pow 2 + &2 * x7 pow 2 - x1`;;
let heart_poly = expr_to_vector_fun `-- x1 * x6 pow 3 + &3 * x1 * x6 * x7 pow 2 - x3 * x7 pow 3 +
  &3 * x3 * x7 * x6 pow 2 - x2 * x5 pow 3 + &3 * x2 * x5 * x8 pow 2 - x4 * x8 pow 3 + 
  &3 * x3 * x8 * x5 pow 2 - #0.9563453`;;


let schwefel_min = `-- #0.00000000058806` and
    ld_min = `-- #36.7126907` and
    caprasse_min = `-- #3.1801` and
    lv_min = `-- #20.801` and
    butcher_min = `-- #1.44` and
    magnetism_min = `-- #0.25001` and
    heart_min = `-- #1.7435`;;


gen_partial2_poly 3 3 schwefel_poly;;
gen_partial2_poly 1 7 heart_poly;;


(********************************************)

let x_var_names = Array.init (max_dim + 1) (fun i -> "x"^(string_of_int i)) and
    y_var_names = Array.init (max_dim + 1) (fun i -> "y"^(string_of_int i)) and
    z_var_names = Array.init (max_dim + 1) (fun i -> "z"^(string_of_int i));;

let x_vars_array = Array.init (max_dim + 1) (fun i -> mk_var(x_var_names.(i), real_ty)) and
    y_vars_array = Array.init (max_dim + 1) (fun i -> mk_var(y_var_names.(i), real_ty)) and
    z_vars_array = Array.init (max_dim + 1) (fun i -> mk_var(z_var_names.(i), real_ty));;    

let df_vars_array = Array.init (max_dim + 1) (fun i -> mk_var ("df"^(string_of_int i), real_pair_ty));;
let dd_vars_array = Array.init (max_dim + 1) (fun i ->
   Array.init (max_dim + 1) (fun j -> mk_var ("dd"^(string_of_int i)^(string_of_int j), real_pair_ty)));;

let dest_vector = dest_list o rand;;

let mk_vector list_tm =
  let n = (length o dest_list) list_tm in
  let ty = (hd o snd o dest_type o type_of) list_tm in
  let vec = mk_const ("vector", [ty, aty; n_type_array.(n), nty]) in
    mk_comb (vec, list_tm);;

let mk_vector_list list =
    mk_vector (mk_list (list, type_of (hd list)));;


let el_thms_array =
  let el_tm = `EL : num->(A)list->A` in
  let gen0 n =
    let e_list = mk_list (map (fun i -> mk_var ("e"^(string_of_int i), aty)) (1--n), aty) in
    let el0_th = REWRITE_CONV[EL; HD] (mk_binop el_tm `0` e_list) in
      Array.create n el0_th in
  let array = Array.init (max_dim + 1) gen0 in
  let gen_i n i =
    let e_list = (rand o lhand o concl) array.(n).(i) in
    let prev_thm = array.(n - 1).(i - 1) in
    let i_tm = mk_small_numeral i in
    let prev_i = num_CONV i_tm in
    let el_th = REWRITE_CONV[prev_i; EL; HD; TL; prev_thm] (mk_binop el_tm i_tm e_list) in
      array.(n).(i) <- el_th in
  let _ = map (fun n -> map (fun i -> gen_i n i) (1--(n - 1))) (2--max_dim) in
    array;;


let gen_comp_thm n i =
  let i_tm = mk_small_numeral i and
      x_list = mk_list (map (fun i -> mk_var("x"^(string_of_int i), aty)) (1--n), aty) in
  let th0 = (ISPECL [x_list; i_tm] o inst_first_type_var (n_type_array.(n))) VECTOR_COMPONENT in
  let th1 = (CONV_RULE NUM_REDUCE_CONV o REWRITE_RULE[IN_NUMSEG; dimindex_array.(n)]) th0 in
    REWRITE_RULE[el_thms_array.(n).(i - 1)] th1;;

let comp_thms_array = Array.init (max_dim + 1)
  (fun n -> Array.init (n + 1)
       (fun i -> if i < 1 or n < 1 then TRUTH else gen_comp_thm n i));;




let gen_lin_approx_eq_thm n =
  let ty = n_type_array.(n) in
  let df_vars = map (fun i -> df_vars_array.(i)) (1--n) in
  let df_bounds_list = mk_list (df_vars, real_pair_ty) in
  let th0 = (SPECL[f_bounds_var; df_bounds_list] o inst_first_type_var ty) m_lin_approx in
  let th1 = (CONV_RULE NUM_REDUCE_CONV o REWRITE_RULE[all_n]) th0 in
    th1;;


let gen_lin_approx_poly_thm poly_tm =
  let x_var, _ = dest_abs poly_tm in
  let n = get_dim x_var in
  let diff_th = gen_diff_poly poly_tm in
  let partials = map (fun i -> gen_partial_poly i poly_tm) (1--n) in
  let lin_eq = (REWRITE_RULE partials o SPECL [poly_tm]) (gen_lin_approx_eq_thm n) in
  let x_vec = mk_vector_list (map (fun i -> x_vars_array.(i)) (1--n)) in
  let th1 = (REWRITE_RULE (Array.to_list comp_thms_array.(n)) o SPEC x_vec o REWRITE_RULE[diff_th]) lin_eq in
    th1;;



  

let eval_lin_approx_poly pp poly_tm =
  let x_var, _ = dest_abs poly_tm in
  let n = get_dim x_var in
  let th0 = gen_lin_approx_poly_thm poly_tm in
  let th1 = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o MATCH_MP iffRL) th0 in
  let build_eval int_hyp =
    let expr, b_var = dest_binary "interval_arith" int_hyp in
      (eval_constants pp o build_interval_fun) expr, b_var in
  let int_fs = map build_eval (hyp th1) in
    
  let rec gen_rules i_list =
    match i_list with
      | [] -> (I, fun vars -> I)
      | ((i_fun, var_tm) :: es) -> 
	  let (r1, r2) = gen_rules es in
	  let r int_th =
	    let b_tm = rand (concl int_th) in
	      MY_PROVE_HYP int_th o INST[b_tm, var_tm] in
	    match i_fun with
	      | Int_const th -> (r th o r1, r2)
	      | Int_var var_tm -> (r (INST[var_tm, x_var_real] CONST_INTERVAL') o r1, r2)
	      | _ -> (r1, fun vars -> r (eval_interval_fun pp i_fun vars) o r2 vars) in

  let r1, r2 = gen_rules int_fs in
  let th2 = r1 th1 in
    fun vector_tm ->
      let x_vals = dest_vector vector_tm in
      if length x_vals <> n then failwith (sprintf "Wrong vector size; expected size: %d" n)
      else
	let x_ints = map mk_const_interval x_vals in
	let vars = map (fun i -> x_vars_array.(i)) (1--n) in
	let eval_vars = zip vars x_ints in
	let th3 = INST (zip x_vals vars) th2 in
	  r2 eval_vars th3;;


let pp = 5;;
let test_poly = `\x:real^2. x$1 * x$2`;;
gen_lin_approx_poly_thm test_poly;;
let eval_test = eval_lin_approx_poly pp test_poly;;
let y_list = mk_list (replicate pi5 2, real_ty);;
eval_test (mk_vector y_list);;



(*******************************)

let pp = 5;;
let eval_rd = eval_lin_approx_poly pp rd_poly;;
let pi5 = (fst o dest_pair o rand o concl) pi_approx_array.(5);;
let y_list = mk_list (replicate pi5 3, real_ty);;
eval_rd (mk_vector y_list);;

let eval_schwefel = eval_lin_approx_poly pp schwefel_poly;;
let y_list = mk_list (replicate pi5 3, real_ty);;
eval_schwefel (mk_vector y_list);;


let eval_heart = eval_lin_approx_poly pp heart_poly;;
let y_list = mk_list (replicate pi5 8, real_ty);;
eval_heart (mk_vector y_list);;

let eval_magnetism = eval_lin_approx_poly pp magnetism_poly;;
let y_list = mk_list (replicate pi5 7, real_ty);;
eval_magnetism (mk_vector y_list);;



gen_lin_approx_poly_thm magnetism_poly;;
gen_lin_approx_poly_thm rd_poly;;


(*************************************)


(* 1 <= i /\ i <= n <=> i = 1 \/ i = 2 \/ ... \/ i = n *)
let i_int_array =
  let i_tm = `i:num` in
  let i_th0 = prove(`1 <= i /\ i <= SUC n <=> (1 <= i /\ i <= n) \/ i = SUC n`, ARITH_TAC) in
  let th1 = prove(`1 <= i /\ i <= 1 <=> i = 1`, ARITH_TAC) in
  let array = Array.create (max_dim + 1) th1 in
  let prove_next n =
    let n_tm = mk_small_numeral n in
    let prev_n = num_CONV n_tm in
    let tm = mk_conj (`1 <= i`, mk_binop le_op_num i_tm n_tm) in
    let th = REWRITE_CONV[prev_n; i_th0; array.(n - 1)] tm in
      array.(n) <- REWRITE_RULE[SYM prev_n; DISJ_ACI] th in
  let _ = map prove_next (2--max_dim) in
    array;;



(* (!i. 1 <= i /\ i <= n ==> P i) <=> P 1 /\ P 2 /\ ... /\ P n *)
let gen_in_interval =
  let th0 = prove(`(!i:num. (i = k \/ Q i) ==> P i) <=> (P k /\ (!i. Q i ==> P i))`, MESON_TAC[]) in
  let th1 = prove(`(!i:num. (i = k ==> P i)) <=> P k`, MESON_TAC[]) in
    fun n ->
      let n_tm = mk_small_numeral n and
	  i_tm = `i:num` in
      let lhs1 = mk_conj (`1 <= i`, mk_binop le_op_num i_tm n_tm) in
      let lhs = mk_forall (i_tm, mk_imp (lhs1, `(P:num->bool) i`)) in
	REWRITE_CONV[i_int_array.(n); th0; th1] lhs;;


let gen_second_bounded_eq_thm n =
  let ty, _, x_var, _, _, _, domain_var = get_types_and_vars n in
  let dd_vars = map (fun i -> map (fun j -> dd_vars_array.(j).(i)) (1--n)) (1--n) in
  let dd_bounds_list = mk_list (map (fun l -> mk_list (l, real_pair_ty)) dd_vars, real_pair_list_ty) in
  let th0 = (SPECL[domain_var; dd_bounds_list] o inst_first_type_var ty) second_bounded in
  let th1 = (CONV_RULE NUM_REDUCE_CONV o REWRITE_RULE[all_n]) th0 in
    th1;;

let gen_second_bounded_poly_thm poly_tm =
  let x_var, _ = dest_abs poly_tm in
  let n = get_dim x_var in
  let partials = map (fun i -> gen_partial_poly i poly_tm) (1--n) in
  let get_partial i eq_th = 
    let partial_i = gen_partial_poly i (rand (concl eq_th)) in
    let pi = (rator o lhand o concl) partial_i in
      REWRITE_RULE[GSYM partial2] (TRANS (AP_TERM pi eq_th) partial_i) in
  let partials2 = List.flatten (map (fun th -> map (fun i -> get_partial i th) (1--n)) partials) in
  let second_th = (REWRITE_RULE partials2 o SPECL [poly_tm]) (gen_second_bounded_eq_thm n) in
    second_th;;

(*  let eq_th = TAUT `(P ==> Q /\ R) <=> ((P ==> Q) /\ (P ==> R))` in
    REWRITE_RULE[eq_th; FORALL_AND_THM; GSYM m_bounded_on_int] second_th;;*)


gen_second_bounded_poly_thm lv_poly;;
let poly_tm = schwefel_poly;;
let poly_tm = delta_x4_poly;;
let poly_tm = lv_poly;;
let poly_tm = rd_poly;;
let poly_tm = `\x:real^3. x$1 * x$2 * x$3`;;
let th0 = gen_second_bounded_poly_thm poly_tm;;

let n = (get_dim o fst o dest_abs) poly_tm;;
let x_vector = mk_vector_list (map (fun i -> x_vars_array.(i)) (1--n)) and
    z_vector = mk_vector_list (map (fun i -> z_vars_array.(i)) (1--n));;
let _, _, _, _, _, _, domain_var = get_types_and_vars n;;
let th1 = INST[mk_pair (x_vector, z_vector), domain_var] th0;;
let th2 = REWRITE_RULE[IN_INTERVAL; dimindex_array.(n)] th1;;
let th3 = REWRITE_RULE[gen_in_interval n; GSYM interval_arith] th2;;
let th4 = REWRITE_RULE (Array.to_list comp_thms_array.(n)) th3;;

let final_th0 = (UNDISCH_ALL o MATCH_MP iffRL) th4;;

let x_var, h_tm = (dest_forall o hd o hyp) final_th0;;
let h1, h2 = dest_imp h_tm;;
let assum_ints = striplist dest_conj h1;;
let concl_ints = striplist dest_conj h2;;

let i_funs = map (fun int -> 
		    let expr, var = dest_interval_arith int in
		      (eval_constants pp o build_interval_fun) expr, var) concl_ints;;

let rec gen_rules i_list =
  match i_list with
    | [] -> (I, fun vars -> [])
    | ((i_fun, var_tm) :: es) -> 
	let r1, r2 = gen_rules es in
	let r int_th =
	  let b_tm = rand (concl int_th) in
	    REWRITE_RULE[int_th] o INST[b_tm, var_tm] in
	  match i_fun with
	    | Int_const th -> (r th o r1, r2)
(*	    | Int_var var_tm -> (r (INST[var_tm, x_var_real] CONST_INTERVAL') o r1) *)
	    | _ -> (r1, fun vars -> (var_tm, eval_interval_fun pp i_fun vars) :: r2 vars);;


let r1, r2 = gen_rules i_funs;;
let final_th = r1 (SYM th4);;



let vars = [`(x:real^3)$1`, two_interval; `(x:real^3)$2`, two_interval; `(x:real^3)$3`, one_interval];;
r2 vars;;
