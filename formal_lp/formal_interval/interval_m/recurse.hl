


(* port of recurse.cc *)

(*
This is the code that verifies a disjunct of nonlinear inequalities.
The are given as a list   (tf:tfunction list).  If tf = [f1;....;fk], then
the list represents the inequality (f1 < 0 \/ f2 < 0 .... fk < 0).

The end user should only need to define a cell option,
and then call recursive_verifier, which recursively bisects the domain
until a partition of the domain is found on which verifier_cell gives
a pass on each piece of the partition.

*)

flyspeck_needs "../formal_lp/formal_interval/interval_m/types.hl";;
flyspeck_needs "../formal_lp/formal_interval/interval_m/report.hl";;
flyspeck_needs "../formal_lp/formal_interval/interval_m/interval.hl";;
flyspeck_needs "../formal_lp/formal_interval/interval_m/univariate.hl";;
flyspeck_needs "../formal_lp/formal_interval/interval_m/line_interval.hl";;
flyspeck_needs "../formal_lp/formal_interval/interval_m/taylor.hl";;

module Recurse = struct

open Interval;;
open Univariate;;
open Line_interval;;
open Taylor;;

type cellOption = {
  only_check_deriv1_negative : bool;
  is_using_dihmax : bool;
  is_using_bigface126 : bool;
  width_cutoff : float;
  allow_sharp : bool;
  allow_derivatives : bool;
  mutable iteration_count : int;
  iteration_limit : int;
  recursion_depth : int;
};;

(* cell verification is complex, and we use exceptions to
    exit as soon as the status has been determined.   *)

type  cell_status = 
  | Cell_pass of int list
  | Cell_counterexample 
  | Cell_inconclusive of (int list * float list * float list);;

exception Return of  cell_status;;

type result_tree =
	| Result_false of (float list * float list)
	| Result_pass of (int list * float list * float list)
	| Result_glue of (int list * int * result_tree * result_tree);;

let rec result_size r =
  match r with
    | Result_false _ -> failwith "False result detected"
    | Result_glue (_, _, r1, r2) -> result_size r1 + result_size r2
    | Result_pass _ -> 1;;

	
let return c = raise (Return c);;


(* error checking and reporting functions *)

let string_of_domain x =
  let n = mth in
  Printf.sprintf "{%f, %f, %f, %f, %f, %f, %f, %f}" (n x 0) (n x 1) (n x 2) (n x 3) (n x 4) (n x 5) (n x 6) (n x 7);;

let string3 (x,z,s) =  (string_of_domain x ^"\n"^ string_of_domain z ^ "\n" ^ s);;

let boolify _ = true;;

let report_current = boolify o Report.report_timed o string3;;

let report_error = boolify o Report.report_error o string3;;

let report_fatal = boolify o Report.report_fatal o string3;;

(* let t = [0.1;0.2;0.3;0.4;0.5;0.6] in report_error (t,t,"ok");; *)

let periodic_count = 
  let end_count = ref 0 in
    fun () ->
      let _ = end_count := !end_count + 1 in
	(0 = ( !end_count mod 1000));;

let check_limit opt depth = 
  let _ = opt.iteration_count <- opt.iteration_count + 1 in
   ( opt.iteration_count < opt.iteration_limit or opt.iteration_limit = 0 ) &&
     (depth < opt.recursion_depth);;

let sgn x = if (x.lo > 0.0) then 1 else if (x.hi < 0.0) then -1 else 0;;

let rec same_sgn x y = (x = []) or (sgn (hd x) = sgn (hd y) && same_sgn (tl x) (tl y));;


(* has_monotone *)

 let rec has_monotone ti x z is found = match is with
  | [] -> (x,z,List.rev found)
  | j::js when (mth x j >= mth z j) ->
      has_monotone ti x z js found
  | j::js -> 
    let allpos = lower_partial ti j >= 0.0 in
    let allneg = upper_partial ti j < 0.0 in
    if (allpos) then
     let setj u = table (fun i -> (if i=j then mth z j else mth u i))  in
	has_monotone ti  (setj x) (setj z) js ((j + 1) :: found)
    else if (allneg) then
      let setj u = table (fun i -> (if i=j then mth x j else mth u i))  in
	has_monotone ti  (setj x) (setj z) js (-(j + 1) :: found)
    else has_monotone ti x z js found;;

(* loop as long as monotonicity keeps making progress.  *)

let rec going_strong(x,z,tf,opt,mono) =
  let (y,w) = center_form (x,z) in
  let maxwidth = maxl w in
  let target = 
	try evalf tf x z with Unstable -> return (Cell_inconclusive (mono,x,z)) in
  let _ = upper_bound target >= 0.0 or return (Cell_pass mono) in
  let _ = lower_bound target < 0.0 or return Cell_counterexample in
  let epsilon_width = 1.0e-8 in
  let _ = (maxwidth >= epsilon_width) or return Cell_counterexample in
  let (x,z,strong) = 
    if (opt.allow_derivatives) then has_monotone target x z iter8 []
    else (x,z,[]) in
    if (strong <> []) then 
		going_strong(x,z,tf,opt,mono @ strong) 
	else 
		(x,z,maxwidth,mono);;


(*
This procedure is mostly guided by heuristics that don't require formal
verification. In particular, no justification is required for tossing out inequalities
(since they appear as disjuncts, we can choose which one to prove).

Formal verification is required whenever a Cell_passes is issued,
and whenever the domain (x,z) is restricted.

The record (x0,z0) of the current outer boundary must be restricted to (x,z)
whenever an inequality is tossed out.
*)

let rec verify_cell (x,z,tf,opt) =
  try (
  let _ = not(periodic_count ()) or report_current (x,z,"periodic report") in
  let (x,z,maxwidth,mono) = going_strong(x,z,tf,opt,[]) in
    Cell_inconclusive (mono,x,z);
  )
  with Return c -> c;;

let rec recursive_verifier (depth,x,z,tf,opt) = 
  let _ = check_limit opt depth or report_fatal(x,z,Printf.sprintf "depth %d" depth) in
    match verify_cell(x,z,tf,opt)  with
      | Cell_counterexample -> Result_false (x,z)
      | Cell_pass mono -> Result_pass (mono,x,z)
      | Cell_inconclusive(mono,x,z) ->
	  let ( ++ ), ( / ) = up(); upadd, updiv in
	  let w2 = List.map2 upsub z x in 
	  let maxwidth2 = maxl w2 in
	  let j_wide =  try( find (fun i -> mth w2 i = maxwidth2) iter8) with
	    | _ -> failwith "recursive_verifier find" in
	  let yj = (mth x j_wide ++  mth z j_wide) / 2.0 in
	  let delta b v =table (fun i-> if (i=j_wide && b) then yj else mth v i) in
	  let r1 = recursive_verifier(depth+1, delta false x ,delta true z,tf,opt) in
		match r1 with
			| Result_false t -> Result_false t
			| _ ->
              (let r2 = recursive_verifier(depth+1, delta true x ,delta false z,tf,opt) in
				match r2 with
					| Result_false t -> Result_false t
					| _ -> Result_glue (mono, j_wide, r1, r2));;




 end;;
