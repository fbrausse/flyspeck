(* file combining all the function data *)

(*

This gives the verification of a sample inequality drawn from ineq.hl.

*)


flyspeck_needs "../formal_lp/formal_interval/interval_m/recurse.hl";;


open Interval;;
open Univariate;;
open Line_interval;;
open Taylor;;
open Recurse;;

(* This was found  in recurse.cc, but doesn't belong there. *)

let deltainf = 
  let ( * ) =  downmul in
  let ( + ) = downadd  in
  let  ( - ) = downsub in
  let ( ~- ) = ( ~-. ) in
    fun x1 x2 x3 x4 x5 x6 ->
      (down();
         ((~- x2)*x3)*x4 +((~-  x1)*x3)*x5 +((~-  x1)*x2)*x6 +((~-  x4)*x5)*x6 +
   x3*(x1 + x2 + x4 + x5)*x6 +  (x3*(~- x3- x6))*x6 +
   x2*x5*(x1 + x3 + x4 + x6) + x2*(x5*(~- x2-x5)) +
        x1*x4*(x2 + x3 + x5 + x6)+ x1*(x4*(~- x1-x4)));;


let tupl x = let n = List.nth x in (n 0,n 1,n 2,n 3,n 4,n 5,n 6,n 7);;
let tupl_int x = let n = (fun i -> mk_interval (List.nth x i, List.nth x i)) in (n 0,n 1,n 2,n 3,n 4,n 5,n 6,n 7);;

let delta_x4L =   
  fun x ->
    let (x1,x2,x3,x4,x5,x6,_,_) = tupl x in
    let ( + ),( * ) = up(); (upadd,upmul) in
    let fhi,tdhi=
    ( (~-.  x2)*x3 +(~-.  x1)*x4 + x2*x5 + x3*x6 +(~-.  x5)*x6 +
                x1*(~-. x1) + x1*(~-. x4) + x1*(x2 + x3 + x5 + x6),
        [ (~-. 2.0)* x1 + x2 + x3 + (~-.  2.0)* x4 + x5 + x6;
	 x1 + (~-.  1.0) * x3 + x5;
	 x1 + (~-.  1.0) * x2 + x6;
	 (~-. 2.0) * x1;
	 x1 + x2 + (~-. 1.0) * x6;
	 x1 + x3 + (~-. 1.0)* x5; 0.; 0.]) in
    let ( + ),( * ) = down(); (downadd,downmul) in
    let flo,tdlo = 
	 (~-. x2)*x3 +(~-.  x1)*x4 + x2*x5 + x3*x6 +(~-.  x5)*x6 +
                x1*(~-. x1) + x1*(~-. x4) + x1*(x2 + x3 + x5 + x6),
        [ (~-. 2.0)* x1 + x2 + x3 + (~-.  2.0)* x4 + x5 + x6;
	 x1 + (~-.  1.0) * x3 + x5;
	 x1 + (~-.  1.0) * x2 + x6;
	 (~-. 2.0) * x1;
	 x1 + x2 + (~-. 1.0) * x6;
	 x1 + x3 + (~-.  1.0)* x5; 0.; 0.] in
      mk_line (mk_interval(flo,fhi),map (fun (x,y)->mk_interval(x,y)) (zip tdlo tdhi));;

let delta_x4DD = 
  let m i = let r = float_of_int i in mk_interval(r,r) in
  let intdata = [[-2; 1; 1; -2; 1; 1;0;0]; [1; 0; -1; 0; 1; 0;0;0]; [1; -1; 0; 0; 0; 1;0;0]; 
		 [-2; 0; 0; 0; 0; 0;0;0]; [1; 1; 0; 0; 0; -1;0;0]; [1; 0; 1; 0; -1; 0;0;0];
		[0;0;0;0;0;0;0;0]; [0;0;0;0;0;0;0;0]] in
    table2 (fun i j -> m (mth2 intdata i j));;

let delta_x4 = Prim_a (make_primitiveA ( delta_x4L, (fun x z -> delta_x4DD)));;


(*********************)
let delta_x4L' =   
  fun x ->
    let (x1,x2,x3,x4,x5,x6,_,_) = tupl_int x in
    let ( + ),( * ),( - ), (!) = iadd, imul, isub, (fun x -> mk_interval (x,x)) in
    let f = ineg x2 * x3 - x1 * x4 + x2 * x5 + x3 * x6 - x5 * x6 - x1 * x1 - x1 * x4 +
	x1 * (x2 + x3 + x5 + x6) in
    let df = [!(-2.0) * x1 + x2 + x3 - !2.0 * x4 + x5 + x6;
	      x1 - x3 + x5;
	      x1 - x2 + x6;
	      !(-2.0) * x1;
	      x1 + x2 - x6;
	      x1 + x3 - x5;
	     zero; zero] in
      mk_line (f, df);;
	

let delta_x4' = Prim_a (make_primitiveA ( delta_x4L', (fun x z -> delta_x4DD)));;


let rd_poly = expr_to_vector_fun `-- x1 + &2 * x2 - x3 - #0.835634534 * x2 * (&1 + x2)`;;


let rd_polyL =   
  fun x ->
    let (x1,x2,x3,_,_,_,_,_) = tupl_int x in
    let ( + ), ( * ), ( - ), (!) = iadd, imul, isub, (fun x -> mk_interval (x,x)) in
    let f = ineg x1 + !2.0 * x2 - x3 - !0.835634534 * x2 * (!1.0 + x2) in
    let df = [!(-1.0);
	      !(2.0) - !0.835634534 * (!1.0 + x2 + x2);
	      !(-1.0); zero; zero; zero; zero; zero] in
      mk_line (f, df);;


let rd_polyDD = 
  let m r = mk_interval(r,r) in
    table2 (fun i j -> if i = 1 && j = 1 then m (-0.835634534 *. 2.0) else zero);;


let rd_poly' = Prim_a (make_primitiveA ( rd_polyL, (fun x z -> rd_polyDD)));;



(* sample based on ineq.hl "JNTEFVP 1"; *)

let sample = 
  let xx = [4.0;4.0;4.0;4.0;4.0;8.0;0.;0.] in
  let zz = let h02 = 6.3504 in [h02;h02;h02;h02;h02;25.4016;0.;0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_x4,mone) in
  let testmaxat = 6.02525 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let truemaxat = 6.02525951999999165 in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =true;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


result_size sample;;


(***********)

let sample2 = 
  let xx = [-5.0;-5.0;-5.0;0.0;0.0;0.0;0.0;0.0] in
  let zz = [5.0;5.0;5.0;0.0;0.0;0.0;0.0;0.0] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(rd_poly',mone) in
  let testmaxat = -36.7126907 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


(***************************)


(****************************)
(* Automatic conversion of formal interval functions into functions *)




type int_fun =
  | F_int_var of int
  | F_int_const of interval
  | F_int_pow of int * int_fun
  | F_int_neg of int_fun
  | F_int_add of int_fun * int_fun
  | F_int_sub of int_fun * int_fun
  | F_int_mul of int_fun * int_fun;;

let rec build_fun i_fun =
  match i_fun with
    | Int_var tm -> 
	(try F_int_var (dest_small_numeral (rand tm))
	 with Failure _ ->
	   let name = (fst o dest_var) tm in
	     F_int_var (int_of_string (String.sub name 1 (String.length name - 1))))
    | Int_const th ->
	let f1, f2 = (dest_pair o rand o concl) th in
	let int = mk_interval (float_of_float_tm f1, float_of_float_tm f2) in
	  F_int_const int
    | Int_pow (n, f) -> F_int_pow (n, build_fun f)
    | Int_unary (op, f) ->
	let f' = build_fun f in
	  if op = neg_op_real then F_int_neg f' else failwith ("Unsupported operator: "^string_of_term op)
    | Int_binary (op, f1, f2) ->
	let f1', f2' = build_fun f1, build_fun f2 in
	  if op = add_op_real then F_int_add (f1',f2')
	  else if op = sub_op_real then F_int_sub (f1',f2')
	  else if op = mul_op_real then F_int_mul (f1',f2') 
	  else failwith ("Unsupported operator: "^string_of_term op)
    | _ -> failwith "Unsupported function";;


let gen_pow op id n x =
  let ( * ) = op in
  let rec pow n =
    if n <= 0 then id
    else if n = 1 then x
    else if n land 1 = 1 then
      x * pow (n - 1)
    else
      let t = pow (n lsr 1) in
	t * t in
    pow n;;


let ipow = gen_pow imul Interval.one;;    



let eval_int_fun i_fun =
  fun x ->
    let rec eval_rec f =
      match f with
	| F_int_var i -> List.nth x (i - 1)
	| F_int_const int -> int
	| F_int_neg f1 -> ineg (eval_rec f1)
	| F_int_pow (n,f1) -> ipow n (eval_rec f1)
	| F_int_add (f1,f2) -> iadd (eval_rec f1) (eval_rec f2)
	| F_int_sub (f1,f2) -> isub (eval_rec f1) (eval_rec f2)
	| F_int_mul (f1,f2) -> imul (eval_rec f1) (eval_rec f2) in
      eval_rec i_fun;;




let buildL pp poly_tm =
  let lin_th = gen_lin_approx_poly_thm poly_tm in
  let funs = map (fst o dest_interval_arith) ((striplist dest_conj o rand o concl) lin_th) in
  let i_funs = map (eval_constants pp o build_interval_fun) funs in
  let fs = map build_fun i_funs @ (replicate (F_int_const zero) (8 - length funs + 1)) in
  let eval_fs = map eval_int_fun fs in
  let f, df = hd eval_fs, tl eval_fs in
    fun x ->
      let vars = map (fun x -> mk_interval (x,x)) x in
	mk_line (f vars, map (fun df -> df vars) df);;


let rec shape_list n list =
  if length list <= n then [list]
  else 
    let l1, l2 = chop_list n list in
      l1 :: shape_list n l2;;


let buildDD pp poly_tm =
  let n = (get_dim o fst o dest_abs) poly_tm in
  let second_th = gen_second_bounded_poly_thm poly_tm in
  let funs = (striplist dest_conj o rand o snd o dest_forall o rand o concl) second_th in
  let i_funs = map (eval_constants pp o build_interval_fun o fst o dest_interval_arith) funs in
  let fs0 = map build_fun i_funs in
  let pad1 = replicate (F_int_const zero) (8 - n) and
      pad2 = replicate (F_int_const zero) 8 in
  let pad3 = replicate pad2 (8 - n) in
  let fs = (map (fun l -> l @ pad1) (shape_list n fs0)) @ pad3 in
  let eval_fs = map (map eval_int_fun) fs in
    fun x z ->
      let ints = map2 (curry mk_interval) x z in
	map (map (fun f -> f ints)) eval_fs;;


let build_taylor pp poly_tm =
  let lin = buildL pp poly_tm and
      dd = buildDD pp poly_tm in
    Prim_a (make_primitiveA ( lin, dd));;



let pp = 10;;
let i_fun = (eval_constants pp o build_interval_fun) (body rd_poly);;
let i_fun2 = build_fun i_fun;;

let rd_polyL' = buildL pp rd_poly;;
let rd_polyDD' = buildDD pp rd_poly;;
let rd_taylor = build_taylor pp rd_poly;;

(********************************)


let delta_x_poly = 
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x in
    expr_to_vector_fun tm;;

let delta_y_poly =
  let tm = (rand o concl o SPEC_ALL o REWRITE_RULE[Sphere.delta_x]) Sphere.delta_y in
    expr_to_vector_fun tm;;

let delta_x4_poly =
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x4 in
    expr_to_vector_fun tm;;

let delta_y4_poly =
  let tm = (rand o concl o SPECL[`y1*y1`; `y2*y2`; `y3*y3`; `y4*y4`; `y5*y5`; `y6*y6`]) Sphere.delta_x4 in
    expr_to_vector_fun tm;;


let delta_x = build_taylor pp delta_x_poly;;
let delta_y = build_taylor pp delta_y_poly;;
let delta_x4' = build_taylor pp delta_x4_poly;;
let delta_y4 = build_taylor pp delta_y4_poly;;

let lin = buildL pp delta_x_poly;;
lin x;;


let x = replicate 1.0 8 and
    y = replicate 2.0 8 and
    z = replicate 3.0 8 and
    w = replicate 1.0 8;;

evalf4 delta_x w x y z;;
evalf4 delta_y w x y z;;
evalf4 delta_x4 w x y z;;
evalf4 delta_x4' w x y z;;


(* delta_x >= 128.0 *)
let sample3 = 
  let xx = replicate 4.0 6 @ [0.; 0.] and
      zz = replicate 6.3504 6 @ [0.; 0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_x,mone) in
  let testmaxat = 127.9999 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


result_size sample3;;

(* delta_y >= 128 *)

let sample4 = 
  let xx = replicate 2.0 6 @ [0.; 0.] and
      zz = replicate 2.52 6 @ [0.; 0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_y,mone) in
  let testmaxat = 127.9999 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;

result_size sample4;;


(***********************************)

let run_test f x z min_flag min_max allow_d =
  let pad = replicate 0.0 (8 - length x) in
  let xx = x @ pad and zz = z @ pad in
  let mone = mk_interval(-1.0,-1.0) in
  let neg_f = Scale(f, mone) in
  let ff = if min_flag then
    Plus(neg_f, Scale(unit,mk_interval(min_max, min_max)))
  else 
    Plus(f, Scale(unit, ineg (mk_interval(min_max, min_max)))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =allow_d;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


let four_y1_delta_y_poly = 
  let x_var, tm = dest_abs delta_y_poly in
    mk_abs (x_var, mk_binop mul_op_real `&4` (mk_binop mul_op_real `(x:real^6)$1 * x$1` tm));;

let neg_delta_y4_poly =
  let x_var, tm = dest_abs delta_y4_poly in
    mk_abs (x_var, mk_comb (neg_op_real, tm));;

let four_y1_delta_y = build_taylor pp four_y1_delta_y_poly;;
let neg_delta_y4 = build_taylor pp neg_delta_y4_poly;;
dih_y_taylor;;

let pi_taylor = build_taylor 10 `\x:real^1. pi`;;
let neg_pi_taylor = build_taylor 10 `\x:real^1. --pi`;;
let pi2_taylor = build_taylor 10 `\x:real^1. pi / &2`;;


(* dih_y *)
let dih_y_taylor =
  let denom = Uni_compose (uinv, Uni_compose (usqrt, four_y1_delta_y)) in
    Plus (pi2_taylor, Uni_compose (uatan, tf_product neg_delta_y4 denom));;

(* sol_y *)

Sphere.sol_y;;
let sol_y_taylor =
  let dih1 = dih_y_taylor and
      dih2 = Composite (dih_y_taylor, x2, x3, x1, x5, x6, x4, unit, unit) and
      dih3 = Composite (dih_y_taylor, x3, x1, x2, x6, x4, x5, unit, unit) in
    Plus (dih1, Plus (dih2, Plus (dih3, neg_pi_taylor)));;


let pi_val= 3.1415926535897932;;
let sol0_val = 0.5512855984325308;;
let const1_val = sol0_val /. pi_val;;
let const1_plus1 = const1_val +. 1.0;;


let ly_taylor = build_taylor pp `\x:real^1. #2.52 / #0.52 - x$1 * inv(#0.52)`;;
let lnazim_y_taylor =
  tf_product ly_taylor dih_y_taylor;;

Sphere.taum;;
let taum_taylor =
  let azim1 = lnazim_y_taylor and
      azim2 = Composite (lnazim_y_taylor, x2, x3, x1, x5, x6, x4, unit, unit) and
      azim3 = Composite (lnazim_y_taylor, x3, x1, x2, x6, x4, x5, unit, unit) in
  let f1 = Scale (sol_y_taylor, mk_interval (const1_plus1, const1_plus1)) and
      f2 = Plus (azim1, Plus (azim2, azim3)) in
    Plus (f1, Scale (f2, mk_interval (~-.const1_val, ~-.const1_val)));;

(*********************)
let x = [2.0001; 2.0001; 2.0001; 2.0; 2.0; 2.0; 0.0; 0.0] and
    z = [2.52; 2.52; 2.52; 2.0; 2.0; 2.0; 0.0; 0.0];;

let taum_test1 = run_test taum_taylor x z true 0.0 false;;
result_size taum_test1;;

(***)
let x = [2.0; 2.0; 2.0; 2.0; 2.0; 2.52; 0.0; 0.0] and
    z = [2.52; 2.52; 2.52; 2.0; 2.0; 2.52; 0.0; 0.0];;

(CONV_RULE (NUM_REDUCE_CONV THENC REAL_RAT_REDUCE_CONV) o SPECL[`2`; `1`]) Sphere.tame_table_d;;

let taum_test2 = run_test taum_taylor x z true 0.103 false;;
result_size taum_test2;;

(***)
let x = [2.0; 2.0; 2.0; 2.1771; 2.0; 2.0; 0.0; 0.0] and
    z = [2.52; 2.52; 2.52; 2.52; 2.52; 2.52; 0.0; 0.0];;

let taum_test3 = run_test taum_taylor x z true 0.04 false;;
result_size taum_test3;;


(***)
let x, z =
  replicate 2.0 6 @ [0.;0.], 
  replicate 2.52 6 @ [0.;0.];;
let ineq = Plus (taum_taylor, Scale (dih_y_taylor, mk_interval (0.626, 0.626)));;
let taum_test4 = run_test ineq x z true 0.77 false;;
(* 52540 *)
result_size taum_test4;;


let ineq = Plus (taum_taylor, Scale (dih_y_taylor, mk_interval (-0.259, -0.259)));;
let taum_test5 = run_test ineq x z true (-0.32) false;;
(* 37737 *)
result_size taum_test5;;


(*********************)


let x, z =
  replicate 2.0 6 @ [0.;0.], 
  replicate 2.52 6 @ [0.;0.];;

let ineq1_test = run_test dih_y_taylor x z true 0.852 false;;
(* 10298 *)
result_size ineq1_test;;    

let ineq2_test = run_test dih_y_taylor x z false 1.893 true;;
(* 4905 (4886 with derivatives) *)
result_size ineq2_test;;


let rec pass_intervals r =
  match r with
    | Result_false _ -> failwith "False result"
    | Result_glue (_,r1,r2) -> pass_intervals r1 @ pass_intervals r2
    | Result_pass (x,z) -> [x,z];;


let intersect_results r1 r2 =
  let i1 = pass_intervals r1 and
      i2 = pass_intervals r2 in
  let i = intersect i1 i2 in
    length i, i;;

(* 1683 *)
let n1, i1 = intersect_results ineq1_test ineq2_test;;
(* 583 *)
let n2, i2 = intersect_results ineq1_test taum_test4;;
(* 5 *)
let n3, i3 = intersect_results ineq2_test taum_test4;;

(* 14486 *)
let n4, i4 = intersect_results taum_test4 taum_test5;;
maxl (map (maxl o filter (fun x -> x <> 0.) o snd o center_form) (pass_intervals taum_test4));;

let x = 2;;


(*****************************)


(*
Sphere.dih_x;;
Ineq.I_5735387903;;
Ineq.dart_std3;;

Ineq.getexact "5735387903";;
Ineq.getexact "5490182221";;
Ineq.getexact "2570626711";;
Ineq.getexact "3296257235";;

Ineq.getexact "8519146937";;
Ineq.getexact "4667071578";;
Ineq.getexact "1395142356";;
Ineq.getexact "7394240696";;
Ineq.getexact "7726998381";;
Ineq.getexact "4047599236";;

Ineq.getexact "8248508703";;
Ineq.getexact "7931207804";;

Ineq.getexact "4491491732";;
*)



(**********************************)




let eval_poly = build_taylor pp schwefel_poly;;
let sample = run_test eval_poly [-10.;-10.;-10.] [10.;10.;10.] true (-0.01) false;;
(* 6813 *)
result_size sample;;
let sample = run_test eval_poly [-10.;-10.;-10.] [10.;10.;10.] true (-0.0000000001) true;;
(* 2987 *)
result_size sample;;

let pp = 10;;
let schwefel_eval = eval_m_taylor_poly pp schwefel_poly;;
let x_list = mk_list (replicate one_float 3, real_ty) and
    z_list = mk_list (replicate pi5 3, real_ty);;

let domain3_th = mk_m_center_domain 3 pp x_list z_list;;

(* 10: 187.73 (pp = 10) *)
test 3000 schwefel_eval domain3_th;;



let eval_poly = build_taylor pp rd_poly;;
let sample = run_test eval_poly [-5.;-5.;-5.] [5.;5.;5.] true (-36.7126907) false;;
(* 1 *)
result_size sample;;


let eval_poly = build_taylor pp caprasse_poly;;
let sample = run_test eval_poly [-0.5;-0.5;-0.5;-0.5] [0.5;0.5;0.5;0.5] true (-3.1801) false;;
(* 428 *)
result_size sample;;
let sample = run_test eval_poly [-0.5;-0.5;-0.5;-0.5] [0.5;0.5;0.5;0.5] true (-3.1801) true;;
(* 100 *)
result_size sample;;


let eval_poly = build_taylor pp lv_poly;;
let sample = run_test eval_poly [-2.0;-2.0;-2.0;-2.0] [2.0;2.0;2.0;2.0] true (-20.801) false;;
(* 160 *)
result_size sample;;
let sample = run_test eval_poly [-2.0;-2.0;-2.0;-2.0] [2.0;2.0;2.0;2.0] true (-20.801) true;;
(* 48 *)
result_size sample;;


let eval_poly = build_taylor pp butcher_poly;;
let sample = run_test eval_poly [-1.0;-0.1;-0.1;-1.0;-0.1;-0.1] [0.0;0.9;0.5;-0.1;-0.05;-0.03] true (-1.44) false;;
(* 2 *)
result_size sample;;
let sample = run_test eval_poly [-1.0;-0.1;-0.1;-1.0;-0.1;-0.1] [0.0;0.9;0.5;-0.1;-0.05;-0.03] true (-1.44) true;;
(* 2 *)
result_size sample;;


let eval_poly = build_taylor pp magnetism_poly;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) false;;
(* 759936 *)
result_size sample;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) true (-0.25001) true;;
(* 77 *)
result_size sample;;


let eval_poly = build_taylor pp heart_poly;;
(* Error (w = 10^(-9), depth = 400), Fatal (depth = 200) *)
let sample = run_test eval_poly [-0.1; 0.4; -0.7; -0.7; 0.1; -0.1; -0.3; -1.1]
  [0.4; 1.0; -0.4; 0.4; 0.2; 0.2; 1.1; -0.3] true (-1.7435) false;;
(* 5973 *)
result_size sample;;

let sample = run_test eval_poly [-0.1; 0.4; -0.7; -0.7; 0.1; -0.1; -0.3; -1.1]
  [0.4; 1.0; -0.4; 0.4; 0.2; 0.2; 1.1; -0.3] true (-1.7435) true;;
(* 190 *)
result_size sample;;

let pp = 10;;
let heart_eval = eval_m_taylor_poly pp heart_poly;;
let x_list = mk_list (replicate one_float 8, real_ty) and
    z_list = mk_list (replicate pi5 8, real_ty);;

let domain8_th = mk_m_center_domain 8 5 x_list z_list;;

(* 51.291 *)
test 200 heart_eval domain8_th;;
