(* file combining all the function data *)

(*

This gives the verification of a sample inequality drawn from ineq.hl.

*)


flyspeck_needs "../formal_lp/formal_interval/interval_m/recurse.hl";;


open Interval;;
open Univariate;;
open Line_interval;;
open Taylor;;
open Recurse;;

(* This was found  in recurse.cc, but doesn't belong there. *)

let deltainf = 
  let ( * ) =  downmul in
  let ( + ) = downadd  in
  let  ( - ) = downsub in
  let ( ~- ) = ( ~-. ) in
    fun x1 x2 x3 x4 x5 x6 ->
      (down();
         ((~- x2)*x3)*x4 +((~-  x1)*x3)*x5 +((~-  x1)*x2)*x6 +((~-  x4)*x5)*x6 +
   x3*(x1 + x2 + x4 + x5)*x6 +  (x3*(~- x3- x6))*x6 +
   x2*x5*(x1 + x3 + x4 + x6) + x2*(x5*(~- x2-x5)) +
        x1*x4*(x2 + x3 + x5 + x6)+ x1*(x4*(~- x1-x4)));;


let tupl x = let n = List.nth x in (n 0,n 1,n 2,n 3,n 4,n 5,n 6,n 7);;
let tupl_int x = let n = (fun i -> mk_interval (List.nth x i, List.nth x i)) in (n 0,n 1,n 2,n 3,n 4,n 5,n 6,n 7);;

let delta_x4L =   
  fun x ->
    let (x1,x2,x3,x4,x5,x6,_,_) = tupl x in
    let ( + ),( * ) = up(); (upadd,upmul) in
    let fhi,tdhi=
    ( (~-.  x2)*x3 +(~-.  x1)*x4 + x2*x5 + x3*x6 +(~-.  x5)*x6 +
                x1*(~-. x1) + x1*(~-. x4) + x1*(x2 + x3 + x5 + x6),
        [ (~-. 2.0)* x1 + x2 + x3 + (~-.  2.0)* x4 + x5 + x6;
	 x1 + (~-.  1.0) * x3 + x5;
	 x1 + (~-.  1.0) * x2 + x6;
	 (~-. 2.0) * x1;
	 x1 + x2 + (~-. 1.0) * x6;
	 x1 + x3 + (~-. 1.0)* x5; 0.; 0.]) in
    let ( + ),( * ) = down(); (downadd,downmul) in
    let flo,tdlo = 
	 (~-. x2)*x3 +(~-.  x1)*x4 + x2*x5 + x3*x6 +(~-.  x5)*x6 +
                x1*(~-. x1) + x1*(~-. x4) + x1*(x2 + x3 + x5 + x6),
        [ (~-. 2.0)* x1 + x2 + x3 + (~-.  2.0)* x4 + x5 + x6;
	 x1 + (~-.  1.0) * x3 + x5;
	 x1 + (~-.  1.0) * x2 + x6;
	 (~-. 2.0) * x1;
	 x1 + x2 + (~-. 1.0) * x6;
	 x1 + x3 + (~-.  1.0)* x5; 0.; 0.] in
      mk_line (mk_interval(flo,fhi),map (fun (x,y)->mk_interval(x,y)) (zip tdlo tdhi));;

let delta_x4DD = 
  let m i = let r = float_of_int i in mk_interval(r,r) in
  let intdata = [[-2; 1; 1; -2; 1; 1;0;0]; [1; 0; -1; 0; 1; 0;0;0]; [1; -1; 0; 0; 0; 1;0;0]; 
		 [-2; 0; 0; 0; 0; 0;0;0]; [1; 1; 0; 0; 0; -1;0;0]; [1; 0; 1; 0; -1; 0;0;0];
		[0;0;0;0;0;0;0;0]; [0;0;0;0;0;0;0;0]] in
    table2 (fun i j -> m (mth2 intdata i j));;

let delta_x4 = Prim_a (make_primitiveA ( delta_x4L, (fun x z -> delta_x4DD)));;


(*********************)
let delta_x4L' =   
  fun x ->
    let (x1,x2,x3,x4,x5,x6,_,_) = tupl_int x in
    let ( + ),( * ),( - ), (!) = iadd, imul, isub, (fun x -> mk_interval (x,x)) in
    let f = ineg x2 * x3 - x1 * x4 + x2 * x5 + x3 * x6 - x5 * x6 - x1 * x1 - x1 * x4 +
	x1 * (x2 + x3 + x5 + x6) in
    let df = [!(-2.0) * x1 + x2 + x3 - !2.0 * x4 + x5 + x6;
	      x1 - x3 + x5;
	      x1 - x2 + x6;
	      !(-2.0) * x1;
	      x1 + x2 - x6;
	      x1 + x3 - x5;
	     zero; zero] in
      mk_line (f, df);;
	

let delta_x4' = Prim_a (make_primitiveA ( delta_x4L', (fun x z -> delta_x4DD)));;


let rd_poly = expr_to_vector_fun `-- x1 + &2 * x2 - x3 - #0.835634534 * x2 * (&1 + x2)`;;


let rd_polyL =   
  fun x ->
    let (x1,x2,x3,_,_,_,_,_) = tupl_int x in
    let ( + ), ( * ), ( - ), (!) = iadd, imul, isub, (fun x -> mk_interval (x,x)) in
    let f = ineg x1 + !2.0 * x2 - x3 - !0.835634534 * x2 * (!1.0 + x2) in
    let df = [!(-1.0);
	      !(2.0) - !0.835634534 * (!1.0 + x2 + x2);
	      !(-1.0); zero; zero; zero; zero; zero] in
      mk_line (f, df);;


let rd_polyDD = 
  let m r = mk_interval(r,r) in
    table2 (fun i j -> if i = 1 && j = 1 then m (-0.835634534 *. 2.0) else zero);;


let rd_poly' = Prim_a (make_primitiveA ( rd_polyL, (fun x z -> rd_polyDD)));;



(* sample based on ineq.hl "JNTEFVP 1"; *)

let sample = 
  let xx = [4.0;4.0;4.0;4.0;4.0;8.0;0.;0.] in
  let zz = let h02 = 6.3504 in [h02;h02;h02;h02;h02;25.4016;0.;0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_x4,mone) in
  let testmaxat = 6.02525 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let truemaxat = 6.02525951999999165 in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =true;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


result_size sample;;


(***********)

let sample2 = 
  let xx = [-5.0;-5.0;-5.0;0.0;0.0;0.0;0.0;0.0] in
  let zz = [5.0;5.0;5.0;0.0;0.0;0.0;0.0;0.0] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(rd_poly',mone) in
  let testmaxat = -36.7126907 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


(***************************)


(****************************)
(* Automatic conversion of formal interval functions into functions *)




type int_fun =
  | F_int_var of int
  | F_int_const of interval
  | F_int_pow of int * int_fun
  | F_int_neg of int_fun
  | F_int_add of int_fun * int_fun
  | F_int_sub of int_fun * int_fun
  | F_int_mul of int_fun * int_fun;;

let rec build_fun i_fun =
  match i_fun with
    | Int_var tm -> 
	(try F_int_var (dest_small_numeral (rand tm))
	 with Failure _ ->
	   let name = (fst o dest_var) tm in
	     F_int_var (int_of_string (String.sub name 1 (String.length name - 1))))
    | Int_const th ->
	let f1, f2 = (dest_pair o rand o concl) th in
	let int = mk_interval (float_of_float_tm f1, float_of_float_tm f2) in
	  F_int_const int
    | Int_pow (n, f) -> F_int_pow (n, build_fun f)
    | Int_unary (op, f) ->
	let f' = build_fun f in
	  if op = neg_op_real then F_int_neg f' else failwith ("Unsupported operator: "^string_of_term op)
    | Int_binary (op, f1, f2) ->
	let f1', f2' = build_fun f1, build_fun f2 in
	  if op = add_op_real then F_int_add (f1',f2')
	  else if op = sub_op_real then F_int_sub (f1',f2')
	  else if op = mul_op_real then F_int_mul (f1',f2') 
	  else failwith ("Unsupported operator: "^string_of_term op)
    | _ -> failwith "Unsupported function";;


let gen_pow op id n x =
  let ( * ) = op in
  let rec pow n =
    if n <= 0 then id
    else if n = 1 then x
    else if n land 1 = 1 then
      x * pow (n - 1)
    else
      let t = pow (n lsr 1) in
	t * t in
    pow n;;


let ipow = gen_pow imul Interval.one;;    



let eval_int_fun i_fun =
  fun x ->
    let rec eval_rec f =
      match f with
	| F_int_var i -> List.nth x (i - 1)
	| F_int_const int -> int
	| F_int_neg f1 -> ineg (eval_rec f1)
	| F_int_pow (n,f1) -> ipow n (eval_rec f1)
	| F_int_add (f1,f2) -> iadd (eval_rec f1) (eval_rec f2)
	| F_int_sub (f1,f2) -> isub (eval_rec f1) (eval_rec f2)
	| F_int_mul (f1,f2) -> imul (eval_rec f1) (eval_rec f2) in
      eval_rec i_fun;;




let buildL pp poly_tm =
  let lin_th = gen_lin_approx_poly_thm poly_tm in
  let funs = map (fst o dest_interval_arith) ((striplist dest_conj o rand o concl) lin_th) in
  let i_funs = map (eval_constants pp o build_interval_fun) funs in
  let fs = map build_fun i_funs @ (replicate (F_int_const zero) (8 - length funs + 1)) in
  let eval_fs = map eval_int_fun fs in
  let f, df = hd eval_fs, tl eval_fs in
    fun x ->
      let vars = map (fun x -> mk_interval (x,x)) x in
	mk_line (f vars, map (fun df -> df vars) df);;


let rec shape_list n list =
  if length list <= n then [list]
  else 
    let l1, l2 = chop_list n list in
      l1 :: shape_list n l2;;


let buildDD pp poly_tm =
  let n = (get_dim o fst o dest_abs) poly_tm in
  let second_th = gen_second_bounded_poly_thm poly_tm in
  let funs = (striplist dest_conj o rand o snd o dest_forall o rand o concl) second_th in
  let i_funs = map (eval_constants pp o build_interval_fun o fst o dest_interval_arith) funs in
  let fs0 = map build_fun i_funs in
  let pad1 = replicate (F_int_const zero) (8 - n) and
      pad2 = replicate (F_int_const zero) 8 in
  let pad3 = replicate pad2 (8 - n) in
  let fs = (map (fun l -> l @ pad1) (shape_list n fs0)) @ pad3 in
  let eval_fs = map (map eval_int_fun) fs in
    fun x z ->
      let ints = map2 (curry mk_interval) x z in
	map (map (fun f -> f ints)) eval_fs;;


let build_taylor pp poly_tm =
  let lin = buildL pp poly_tm and
      dd = buildDD pp poly_tm in
    Prim_a (make_primitiveA ( lin, dd));;



let pp = 10;;
let i_fun = (eval_constants pp o build_interval_fun) (body rd_poly);;
let i_fun2 = build_fun i_fun;;

let rd_polyL' = buildL pp rd_poly;;
let rd_polyDD' = buildDD pp rd_poly;;
let rd_taylor = build_taylor pp rd_poly;;

(********************************)


let delta_x_poly = 
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x in
    expr_to_vector_fun tm;;

let delta_y_poly =
  let tm = (rand o concl o SPEC_ALL o REWRITE_RULE[Sphere.delta_x]) Sphere.delta_y in
    expr_to_vector_fun tm;;

let delta_x4_poly =
  let tm = (rand o concl o SPEC_ALL) Sphere.delta_x4 in
    expr_to_vector_fun tm;;

let delta_y4_poly =
  let tm = (rand o concl o SPECL[`y1*y1`; `y2*y2`; `y3*y3`; `y4*y4`; `y5*y5`; `y6*y6`]) Sphere.delta_x4 in
    expr_to_vector_fun tm;;


let delta_x = build_taylor pp delta_x_poly;;
let delta_y = build_taylor pp delta_y_poly;;
let delta_x4' = build_taylor pp delta_x4_poly;;
let delta_y4 = build_taylor pp delta_y4_poly;;

let lin = buildL pp delta_x_poly;;
lin x;;


let x = replicate 1.0 8 and
    y = replicate 2.0 8 and
    z = replicate 3.0 8 and
    w = replicate 1.0 8;;

evalf4 delta_x w x y z;;
evalf4 delta_y w x y z;;
evalf4 delta_x4 w x y z;;
evalf4 delta_x4' w x y z;;


(* delta_x >= 128.0 *)
let sample3 = 
  let xx = replicate 4.0 6 @ [0.; 0.] and
      zz = replicate 6.3504 6 @ [0.; 0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_x,mone) in
  let testmaxat = 127.9999 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;


result_size sample3;;

(* delta_y >= 128 *)

let sample4 = 
  let xx = replicate 2.0 6 @ [0.; 0.] and
      zz = replicate 2.52 6 @ [0.; 0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(delta_y,mone) in
  let testmaxat = 127.9999 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;

result_size sample4;;


(***********************************)

let four_y1_delta_y_poly = 
  let x_var, tm = dest_abs delta_y_poly in
    mk_abs (x_var, mk_binop mul_op_real `&4` (mk_binop mul_op_real `(x:real^6)$1 * x$1` tm));;

let neg_delta_y4_poly =
  let x_var, tm = dest_abs delta_y4_poly in
    mk_abs (x_var, mk_comb (neg_op_real, tm));;

let four_y1_delta_y = build_taylor pp four_y1_delta_y_poly;;
let neg_delta_y4 = build_taylor pp neg_delta_y4_poly;;


let dih_y_taylor =
  let denom = Uni_compose (uinv, Uni_compose (usqrt, four_y1_delta_y)) in
    Uni_compose (uatan, tf_product neg_delta_y4 denom);;


let x, z =
  let t = 2.0 and h = 2.52 in
  let x = [t; h; h; h; h; h;0.;0.] and
      z = [2.26; h; h; h; h; h;0.;0.] in
    x, z;;
let y, w = center_form (x,z);;


let sample5 = 
  let xx = [2.0; 2.0; 2.0; 2.0; 2.0; 2.0; 0.; 0.] and
      zz = [2.52; 2.52; 2.52; 2.52; 2.52; 2.52; 0.; 0.] in
  let mone = mk_interval(-1.0,-1.0) in
  let mdelta_x4 = Scale(dih_y_taylor,mone) in
  let pi = 3.14159265 in
  let testmaxat = 0.852 -. pi *. 0.5 in
  let ff = Plus(mdelta_x4,Scale(unit,mk_interval(testmaxat,testmaxat))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =false;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;

result_size sample5;;


(*
Sphere.dih_x;;
Ineq.I_5735387903;;
Ineq.dart_std3;;

Ineq.getexact "5735387903";;
Ineq.getexact "5490182221";;
Ineq.getexact "2570626711";;
Ineq.getexact "3296257235";;

Ineq.getexact "8519146937";;
Ineq.getexact "4667071578";;
Ineq.getexact "1395142356";;
Ineq.getexact "7394240696";;
Ineq.getexact "7726998381";;
Ineq.getexact "4047599236";;

Ineq.getexact "8248508703";;
Ineq.getexact "7931207804";;

Ineq.getexact "4491491732";;
*)



(**********************************)

let run_test f x z min allow_d =
  let pad = replicate 0.0 (8 - length x) in
  let xx = x @ pad and zz = z @ pad in
  let mone = mk_interval(-1.0,-1.0) in
  let neg_f = Scale(f, mone) in
  let ff = Plus(neg_f, Scale(unit,mk_interval(min, min))) in
  let opt =  {
    only_check_deriv1_negative = false;
    is_using_dihmax =false;
    is_using_bigface126 =false;
    width_cutoff =0.05;
    allow_sharp =false;
    allow_derivatives =allow_d;
    iteration_count =0;
    iteration_limit =0;
    recursion_depth =200;
  } in
    recursive_verifier(0,xx,zz,xx,zz,[ff],opt);;



let eval_poly = build_taylor pp schwefel_poly;;
let sample = run_test eval_poly [-10.;-10.;-10.] [10.;10.;10.] (-0.01) false;;
(* 6813 *)
result_size sample;;

let eval_poly = build_taylor pp rd_poly;;
let sample = run_test eval_poly [-5.;-5.;-5.] [5.;5.;5.] (-36.7126907) false;;
(* 1 *)
result_size sample;;


let eval_poly = build_taylor pp caprasse_poly;;
let sample = run_test eval_poly [-0.5;-0.5;-0.5;-0.5] [0.5;0.5;0.5;0.5] (-3.1801) false;;
(* 428 *)
result_size sample;;
let sample = run_test eval_poly [-0.5;-0.5;-0.5;-0.5] [0.5;0.5;0.5;0.5] (-3.1801) true;;
(* Error *)
result_size sample;;


let eval_poly = build_taylor pp lv_poly;;
let sample = run_test eval_poly [-2.0;-2.0;-2.0;-2.0] [2.0;2.0;2.0;2.0] (-20.801) false;;
(* 160 *)
result_size sample;;
let sample = run_test eval_poly [-2.0;-2.0;-2.0;-2.0] [2.0;2.0;2.0;2.0] (-20.801) true;;
(* 48 *)
result_size sample;;


let eval_poly = build_taylor pp butcher_poly;;
let sample = run_test eval_poly [-1.0;-0.1;-0.1;-1.0;-0.1;-0.1] [0.0;0.9;0.5;-0.1;-0.05;-0.03] (-1.44) false;;
(* 2 *)
result_size sample;;
let sample = run_test eval_poly [-1.0;-0.1;-0.1;-1.0;-0.1;-0.1] [0.0;0.9;0.5;-0.1;-0.05;-0.03] (-1.44) true;;
(* 2 *)
result_size sample;;


let eval_poly = build_taylor pp magnetism_poly;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) (-0.25001) false;;
(* 759936 *)
result_size sample;;
let sample = run_test eval_poly (replicate (-1.0) 7) (replicate 1.0 7) (-0.25001) true;;
(* Error *)
result_size sample;;


let eval_poly = build_taylor pp heart_poly;;
(* Error (w = 10^(-9), depth = 400), Fatal (depth = 200) *)
let sample = run_test eval_poly [-0.1; 0.4; -0.7; -0.7; 0.1; -0.1; -0.3; -1.1]
  [0.4; 1.0; -0.4; 0.4; 0.2; 0.2; 1.1; -0.3] (-1.7435) false;;

let x, z = match sample with
  | Result_false (x,z) -> x, z;;
upper_bound (evalf eval_poly x z);;


let sample = run_test eval_poly [-0.1; 0.4; -0.7; -0.7; 0.1; -0.1; -0.3; -1.1]
  [0.4; 1.0; -0.4; 0.4; 0.2; 0.2; 1.1; -0.3] (-1.748) false;;
(* 6087 *)
result_size sample;;


(* Error *)
let sample = run_test eval_poly [-0.1; 0.4; -0.7; -0.7; 0.1; -0.1; -0.3; -1.1]
  [0.4; 1.0; -0.4; 0.4; 0.2; 0.2; 1.1; -0.3] (-1.7435) true;;
