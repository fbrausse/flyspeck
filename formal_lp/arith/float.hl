needs "arith_hash.hl";;


open Arith_hash;;



let zero_const = `_0` and
    t_const = `T` and
    f_const = `F`;;

let n_var_num = `n:num` and
    m_var_num = `m:num` and
    k_var_num = `k:num` and
    e_var_num = `e:num` and
    e1_var_num = `e1:num` and
    e2_var_num = `e2:num` and
    r_var_num = `r:num` and
    r1_var_num = `r1:num` and
    r2_var_num = `r2:num` and
    n1_var_num = `n1:num` and
    n2_var_num = `n2:num` and
    m1_var_num = `m1:num` and
    m2_var_num = `m2:num` and
    x_var_num = `x:num` and
    y_var_num = `y:num`;;

let le_op_num = `(<=):num->num->bool` and
    lt_op_num = `(<):num->num->bool` and
    mul_op_num = `( * ):num->num->num` and
    plus_op_num = `(+):num->num->num` and
    minus_op_num = `(-):num->num->num` and
    div_op_real = `(/):real->real->real` and
    mul_op_real = `( * ):real->real->real` and
    plus_op_real = `(+):real->real->real` and
    minus_op_real = `(-):real->real->real` and
    neg_op_real = `(--):real->real`;;



let b0_const = (fst o dest_comb o lhand o concl) (def_array.(0));;
let b0_name = (fst o dest_const) b0_const;;
let maximum = 1 lsl bits;;
let base_const = mk_small_numeral maximum;;


let NUM_REMOVE = prove(mk_eq(mk_comb(num_const, n_var_num), n_var_num), REWRITE_TAC[num_def; NUMERAL]);;


(* B0 n = base * n *)
let b0_thm = prove(mk_eq(mk_comb(b0_const, n_var_num),
			 mk_binop mul_op_num base_const n_var_num),
		   REWRITE_TAC[def_array.(0)] THEN
		     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV) [BIT0] THEN
		     ARITH_TAC);;



(* num_exp definition *)
let num_exp_tm = mk_eq (`(num_exp:num->num->num) n e`,
			mk_binop mul_op_num n_var_num (mk_binop `EXP` base_const e_var_num));;
(* let num_exp = new_definition `num_exp n e = n * 2 EXP e`;; *)
let num_exp = new_definition num_exp_tm;;


let dest_num_exp tm =
  let ltm, e_tm = dest_comb tm in
    rand ltm, e_tm;;



let NUM_EXP_EXP = prove(`!n e1 e2. num_exp (num_exp n e1) e2 = num_exp n (e1 + e2)`,
   REPEAT GEN_TAC THEN
     REWRITE_TAC[num_exp; EXP_ADD] THEN
     ARITH_TAC);;

let NUM_EXP_EXP' = SPEC_ALL NUM_EXP_EXP;;


let NUM_EXP_SUM = prove(`!n e1 e2. num_exp n (e1 + e2) = num_exp n e1 * num_exp 1 e2`,
   REPEAT GEN_TAC THEN
     REWRITE_TAC[num_exp; EXP_ADD] THEN
     ARITH_TAC);;


let NUM_EXP_SUM1 = prove(`!n e1 e2. num_exp n (e1 + e2) = num_exp 1 e1 * num_exp n e2`,
			 REPEAT GEN_TAC THEN REWRITE_TAC[num_exp; EXP_ADD] THEN ARITH_TAC);;



let NUM_EXP_0 = prove(`!n. n = num_exp n 0`,
		      GEN_TAC THEN REWRITE_TAC[num_exp; EXP; MULT_CLAUSES]);;
			
let NUM_EXP_0' = (SPEC_ALL o REWRITE_RULE[NUMERAL]) NUM_EXP_0;;


let NUM_EXP_LE = prove(`!m n e. m <= n ==> num_exp m e <= num_exp n e`,
     SIMP_TAC[num_exp; LE_MULT_RCANCEL]);;

let NUM_EXP_LE' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_LE;;


let NUM_EXP_LT = prove(`!m n e. m < n ==> num_exp m e < num_exp n e`,
		       SIMP_TAC[num_exp; LT_MULT_RCANCEL; EXP_EQ_0] THEN
			 ARITH_TAC);;

let NUM_EXP_LT' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_LT;;



let NUM_EXP_EQ_0 = prove(`!n e. num_exp n e = 0 <=> n = 0`,
   REPEAT STRIP_TAC THEN
     ASM_REWRITE_TAC[num_exp; MULT_EQ_0; EXP_EQ_0] THEN
     ARITH_TAC);;


let NUM_EXP_MUL = prove(`!n1 e1 n2 e2. num_exp n1 e1 * num_exp n2 e2 = num_exp (n1 * n2) (e1 + e2)`,
			REWRITE_TAC[num_exp; EXP_ADD] THEN ARITH_TAC);;

let NUM_EXP_ADD = prove(`!n1 e1 n2 e2. e1 <= e2 ==> 
			  num_exp n1 e1 + num_exp n2 e2 = num_exp (n1 + num_exp n2 (e2 - e1)) e1`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[num_exp] THEN
     REWRITE_TAC[ARITH_RULE `(a + b * c) * d = a * d + b * (c * d):num`] THEN
     REWRITE_TAC[GSYM EXP_ADD] THEN
     ASM_SIMP_TAC[ARITH_RULE `e1 <= e2 ==> e2 - e1 + e1 = e2:num`]);;




let NUM_EXP_DIV1 = prove(`~(n2 = 0) /\ e2 <= e1 ==>
			   num_exp n1 e1 DIV num_exp n2 e2 = num_exp n1 (e1 - e2) DIV n2`,
   STRIP_TAC THEN
     (*`num_exp n1 e1 = 16 EXP e2 * num_exp n1 (e1 - e2)` MP_TAC THENL*)
     SUBGOAL_THEN (mk_eq(`num_exp n1 e1`, mk_binop mul_op_num (mk_binop `EXP` base_const `e2:num`) `num_exp n1 (e1 - e2)`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp] THEN
	 ONCE_REWRITE_TAC[ARITH_RULE `a * b * c = b * (a * c:num)`] THEN
         REWRITE_TAC[GSYM EXP_ADD] THEN
	 ASM_SIMP_TAC[ARITH_RULE `e2 <= e1 ==> e2 + e1 - e2 = e1:num`];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     SUBGOAL_THEN (mk_eq(`num_exp n2 e2`, mk_binop mul_op_num (mk_binop `EXP` base_const `e2:num`) `n2:num`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp; MULT_AC];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     MATCH_MP_TAC DIV_MULT2 THEN
     ASM_REWRITE_TAC[MULT_EQ_0; DE_MORGAN_THM; EXP_EQ_0] THEN
     ARITH_TAC);;



let NUM_EXP_DIV2 = prove(`~(n2 = 0) /\ e1 <= e2 ==>
			   num_exp n1 e1 DIV num_exp n2 e2 = n1 DIV num_exp n2 (e2 - e1)`,
   STRIP_TAC THEN
     (*`num_exp n2 e2 = 16 EXP e1 * num_exp n2 (e2 - e1)` MP_TAC THENL*)
     SUBGOAL_THEN (mk_eq(`num_exp n2 e2`, mk_binop mul_op_num (mk_binop `EXP` base_const `e1:num`) `num_exp n2 (e2 - e1)`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp] THEN
	 ONCE_REWRITE_TAC[ARITH_RULE `a * b * c = b * (a * c:num)`] THEN
         REWRITE_TAC[GSYM EXP_ADD] THEN
	 ASM_SIMP_TAC[ARITH_RULE `e1 <= e2 ==> e1 + e2 - e1 = e2:num`];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     SUBGOAL_THEN (mk_eq(`num_exp n1 e1`, mk_binop mul_op_num (mk_binop `EXP` base_const `e1:num`) `n1:num`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp; MULT_AC];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     MATCH_MP_TAC DIV_MULT2 THEN
     ASM_REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM; EXP_EQ_0] THEN
     ARITH_TAC);;
     




(* B0 n = num_exp n bits *)
let normal_lemma1 = prove(mk_eq(mk_comb(b0_const, n_var_num), `num_exp n 1`),
   REWRITE_TAC[def_array.(0); num_exp] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV) [BIT0] THEN
     ARITH_TAC);;


let NUMERALS_TO_NUM = REWRITE_RULE[NUM_THM] o CONV_RULE (DEPTH_CONV NUMERAL_TO_NUM_CONV);;

let NORMAL_LEMMA1 = NUMERALS_TO_NUM normal_lemma1;;

let normal_lemma2 = prove(mk_eq (mk_comb (b0_const, `num_exp n e`), `num_exp n (SUC e)`),
   REWRITE_TAC[normal_lemma1; NUM_EXP_EXP] THEN ARITH_TAC);;



let rec normalize tm =
  if (is_comb tm) then
    let ltm, rtm = dest_comb tm in
    let lname = (fst o dest_const) ltm in
      if (lname = b0_name) then
	let lth = INST[rtm, n_var_num] NORMAL_LEMMA1 in
	let rth, flag = normalize rtm in
	  if flag then
	    let ltm, lexp = (dest_comb o snd o dest_eq o concl) lth in
	    let ltm, rtm = dest_comb ltm in
	    let rn, rexp = (dest_comb o snd o dest_eq o concl) rth in
	    let rn = rand rn in
	    let th1 = AP_THM (AP_TERM ltm rth) lexp in
	    let th2 = INST[rexp, e1_var_num; lexp, e2_var_num; rn, n_var_num] NUM_EXP_EXP' in
	    let th3 = TRANS lth (TRANS th1 th2) in
	    let ltm, rtm = (dest_comb o snd o dest_eq o concl) th3 in
	    let add_th = raw_add_conv_hash rtm in
	    let th4 = AP_TERM ltm add_th in
	      (TRANS th3 th4, true)
	  else
	    (lth, true)
      else
	(REFL tm, false)
  else
    (REFL tm, false);;



(*
let tm = `B0 (B0 (B0 (B1 (B2 (B3 _0)))))`;;
(* 8: 0.568 *)
test 10000 normalize tm;; (* 0.568 *)
(* 8: 0.012 *)
test 10000 normalize `B2 (B3 (B4 _0))`;; 
*)


(************************************)

let SYM_NUM_EXP_0' = SYM NUM_EXP_0';;

let NUM_EXP_n0 = prove(`!e. num_exp 0 e = 0`, REWRITE_TAC[num_exp; MULT_CLAUSES]);;

let NUM_EXP_n0' = (REWRITE_RULE[NUMERAL] o SPEC_ALL) NUM_EXP_n0;;


let NUM_EXP_DENORM = (UNDISCH_ALL o prove)
  (`(e = _0 <=> F) ==> num_exp n e = B0 (num_exp n (PRE e))`,
   REWRITE_TAC[] THEN ONCE_REWRITE_TAC[SYM (REWRITE_CONV[NUMERAL] `0`)] THEN
     REWRITE_TAC[num_exp; b0_thm] THEN
     REWRITE_TAC[ARITH_RULE `16 * n * a = n * 16 * a`] THEN
     REWRITE_TAC[GSYM EXP] THEN
     SIMP_TAC[ARITH_RULE `~(e = 0) ==> SUC (PRE e) = e`]);;





(* Converts num_exp n e to a numeral by adding e B0's *)
let rec denormalize tm =
  let ltm, etm = dest_comb tm in
  let ntm = rand ltm in
    if (etm = zero_const) then
      INST[ntm, n_var_num] SYM_NUM_EXP_0'
    else
      if ntm = zero_const then
	INST[etm, e_var_num] NUM_EXP_n0'
      else
	let e_th = raw_eq0_hash_conv etm in
	let th0' = INST[etm, e_var_num; ntm, n_var_num] NUM_EXP_DENORM in
	let th0 = MY_PROVE_HYP e_th th0' in
	let b0_tm, rtm = dest_comb(rand(concl th0)) in
	let ltm, pre_tm = dest_comb rtm in
	let pre_th = raw_pre_hash_conv pre_tm in
	let th1 = AP_TERM ltm pre_th in
	let th2 = denormalize (rand(concl th1)) in
	  TRANS th0 (AP_TERM b0_tm (TRANS th1 th2));;



(*
let tm = `num_exp (B1 (B3 (B5 _0))) (B15 _0)`;;
denormalize tm;;
(* 4: 0.264 *)
test 1000 denormalize tm;;
*)



(***************************************)



let rec comb_number tm n =
  if (is_comb tm) then comb_number ((snd o dest_comb) tm) (n + 1) else n;;


let make_lo_thm i =
  let th_concl = mk_binop `(<=):num->num->bool` 
    (mk_comb (const_array.(0), n_var_num))
    (mk_comb (const_array.(i), n_var_num)) in
    prove(th_concl,
	  REWRITE_TAC[def_array.(i); def_array.(0); ARITH_LE; LE_REFL]);;


let lo_thm_array = Array.init maximum make_lo_thm;;
let lo_thm_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add lo_thm_table const_array.(i) lo_thm_array.(i);
done;;



let make_lo_thm2 i =
  let th_concl = mk_imp (`n <= m:num`,
			 mk_binop `(<=):num->num->bool`
			  (mk_comb (const_array.(0), n_var_num))
			  (mk_comb (const_array.(i), m_var_num))) in
    (UNDISCH_ALL o prove) (th_concl,
	  REWRITE_TAC[def_array.(i); def_array.(0); ARITH_LE]);;


let lo_thm2_array = Array.init maximum make_lo_thm2;;
let lo_thm2_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add lo_thm2_table const_array.(i) lo_thm2_array.(i);
done;;




let make_hi_thm i =
  let th_concl = mk_imp (`n < m:num`,
			 mk_binop `(<):num->num->bool`
			  (mk_comb (const_array.(i), n_var_num))
			  (mk_comb (const_array.(0), m_var_num))) in
    (UNDISCH_ALL o prove) (th_concl,
			   REWRITE_TAC[def_array.(i); def_array.(0); ARITH_LT]);;



let hi_thm_array = Array.init maximum make_hi_thm;;
let hi_thm_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add hi_thm_table const_array.(i) hi_thm_array.(i);
done;;



(***************************************)


let LE_REFL' = SPEC_ALL LE_REFL;;
let LE_TRANS' = (UNDISCH_ALL o SPEC_ALL o REWRITE_RULE[GSYM IMP_IMP]) LE_TRANS;;


let lo_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      INST[tm, n_var_num] LE_REFL'
    else
      let rec lo_bound n tm =
	let btm, rtm = dest_comb tm in
	let th0 = INST[rtm, n_var_num] (Hashtbl.find lo_thm_table btm) in
	  if n > 1 then
	    let rth = lo_bound (n - 1) rtm in
	    let xtm = rand (rator (concl rth)) in
	    let th1' = INST[xtm, n_var_num; rtm, m_var_num] (Hashtbl.find lo_thm2_table btm) in
	    let th1 = MY_PROVE_HYP rth th1' in
	      th1
	  else
	    th0 in

	lo_bound (n - p) tm;;
	      


let N_LT_SUC = ARITH_RULE `n < SUC n`;;
let LT_IMP_LE' = (UNDISCH_ALL o SPEC_ALL) LT_IMP_LE;;
let N_LT_SUC = ARITH_RULE `n < SUC n`;;	    
let LT_LE_TRANS = (UNDISCH_ALL o ARITH_RULE) `n < e ==> e <= m ==> n < m:num`;;


(* Generates a theorem |- n <= m such that m contains at most p non-zero digits *)
let hi_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      INST[tm, n_var_num] LE_REFL'
    else
      let k = n - p in

      let rec check_b0s n tm =
	let btm, rtm = dest_comb tm in
	  if ((fst o dest_const) btm = b0_name) then
	    if n > 1 then check_b0s (n - 1) rtm else true
	  else
	    false in

	if (check_b0s k tm) then
	  INST[tm, n_var_num] LE_REFL'
	else
	  let rec hi_bound n tm =
	    if n > 0 then
	      let btm, rtm = dest_comb tm in
	      let r_th = hi_bound (n - 1) rtm in
	      let xtm = rand (concl r_th) in
	      let th0 = INST[rtm, n_var_num; xtm, m_var_num] (Hashtbl.find hi_thm_table btm) in
		MY_PROVE_HYP r_th th0
	    else
	      let th0 = INST[tm, n_var_num] N_LT_SUC in
	      let ltm, suc_tm = dest_comb (concl th0) in
	      let suc_th = raw_suc_conv_hash suc_tm in
		EQ_MP (AP_TERM ltm suc_th) th0 in

	  let th = hi_bound k tm in
	  let m_tm, l_tm = dest_comb (concl th) in
	    MY_PROVE_HYP th (INST[rand m_tm, m_var_num; l_tm, n_var_num] LT_IMP_LE');;



		  

let tm = `B10 (B12 (B11 (B1 (B14 (B15 _0)))))`;;
hi_num_conv 4 tm;;

let tm = `B0 (B0 (B1 (B2 _0)))`;;
hi_num_conv 2 tm;;







(* Generates a theorem |- n < m such that m contains at most p non-zero digits *)
let hi_lt_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      let th0 = INST[tm, n_var_num] N_LT_SUC in
      let ltm, rtm = dest_comb(concl th0) in
      let suc_th = raw_suc_conv_hash rtm in
	EQ_MP (AP_TERM ltm suc_th) th0
    else
      let k = n - p in

      let rec check_b0s n tm =
	let btm, rtm = dest_comb tm in
	  if ((fst o dest_const) btm = b0_name) then
	    if n > 1 then check_b0s (n - 1) rtm else true
	  else
	    false in

	if (check_b0s k tm) then
	  let th0 = INST[tm, n_var_num] N_LT_SUC in
	  let ltm, rtm = dest_comb (concl th0) in
	  let suc_th = raw_suc_conv_hash rtm in
	  let suc_tm = rand(concl suc_th) in
	  let th1 = hi_num_conv p suc_tm in
	  let th2 = EQ_MP (AP_TERM ltm suc_th) th0 in
	  let th = INST[tm, n_var_num; suc_tm, e_var_num; rand(concl th1), m_var_num] LT_LE_TRANS in
	    MY_PROVE_HYP th1 (MY_PROVE_HYP th2 th)

	else
	  let rec hi_bound n tm =
	    if n > 0 then
	      let btm, rtm = dest_comb tm in
	      let r_th = hi_bound (n - 1) rtm in
	      let xtm = rand (concl r_th) in
	      let th0 = INST[rtm, n_var_num; xtm, m_var_num] (Hashtbl.find hi_thm_table btm) in
		MY_PROVE_HYP r_th th0
	    else
	      let th0 = INST[tm, n_var_num] N_LT_SUC in
	      let ltm, suc_tm = dest_comb (concl th0) in
	      let suc_th = raw_suc_conv_hash suc_tm in
		EQ_MP (AP_TERM ltm suc_th) th0 in
	    hi_bound k tm;;
			


let tm = `B10 (B12 (B11 (B1 (B14 (B15 _0)))))`;;
hi_num_conv 4 tm;;
hi_lt_num_conv 4 tm;;

let tm = `B0 (B0 (B1 (B2 _0)))`;;
hi_num_conv 3 tm;;
hi_lt_num_conv 3 tm;;
      

(*****************************************)




let num_exp_lo p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = lo_num_conv p n_tm in
  let m_tm = rand (rator (concl n_th)) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, m_var_num; n_tm, n_var_num; e_tm, e_var_num] NUM_EXP_LE' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
	EQ_MP (AP_THM (AP_TERM le_op_num th4) tm) th0

	
    else
      th0;;



let num_exp_hi p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = hi_num_conv p n_tm in
  let m_tm = rand (concl n_th) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, n_var_num; n_tm, m_var_num; e_tm, e_var_num] NUM_EXP_LE' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
	EQ_MP (AP_TERM (rator (concl th0)) th4) th0
    else
      th0;;




let num_exp_hi_lt p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = hi_lt_num_conv p n_tm in
  let m_tm = rand (concl n_th) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, n_var_num; n_tm, m_var_num; e_tm, e_var_num] NUM_EXP_LT' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
	EQ_MP (AP_TERM (rator (concl th0)) th4) th0
    else
      th0;;





(*
let tm = `num_exp (B5 (B1 (B2 (B3 _0)))) (B3 _0)`;;
num_exp_lo 2 tm;;
num_exp_hi 2 tm;;
num_exp_hi_lt 2 tm;;
num_exp_hi_lt 2 `num_exp (B0 (B0 (B1 _0))) (B4 _0)`;;
(* 4: 0.848 *)
test 10000 (num_exp_lo 2) tm;;	
(* 4: 0.448 *)
test 10000 (num_exp_lo 3) tm;;
(* 4: 0.116 *)
test 10000 (num_exp_lo 5) tm;;
*)


(***************************************)

(* num_exp_mul *)

let NUM_EXP_MUL' = SPEC_ALL NUM_EXP_MUL;;

let num_exp_mul tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let th0 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
		 n2_tm, n2_var_num; e2_tm, e2_var_num] NUM_EXP_MUL' in
  let ltm, tm_add = dest_comb (rand (concl th0)) in
  let tm_mul = rand ltm in
  let th_mul = raw_mul_conv_hash tm_mul in
  let th_add = raw_add_conv_hash tm_add in
    TRANS th0 (MK_COMB (AP_TERM (rator ltm) th_mul, th_add));;



(* num_exp_add *)

let NUM_EXP_ADD' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_ADD;;
let ADD_COMM = ARITH_RULE `m + n = n + m:num`;;

let num_exp_add tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let e_sub, e_le = raw_sub_and_le_hash_conv e1_tm e2_tm in

  let flag = (rand(concl e_le) = e2_tm) in

  let th0' = 
    if flag then
      INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
	   n2_tm, n2_var_num; e2_tm, e2_var_num] NUM_EXP_ADD'
    else
      INST[n2_tm, n1_var_num; e2_tm, e1_var_num;
	   n1_tm, n2_var_num; e1_tm, e2_var_num] NUM_EXP_ADD' in

  let th0 = MY_PROVE_HYP e_le th0' in
  let ltm, e0_tm = dest_comb(rand(concl th0)) in
  let exp_tm, add_tm = dest_comb ltm in
  let ltm, d_tm = dest_comb add_tm in
  let th1 = AP_TERM (rator d_tm) e_sub in
  let th2 = denormalize (rand(concl th1)) in
  let th3 = AP_TERM ltm (TRANS th1 th2) in
  let th4 = raw_add_conv_hash (rand(concl th3)) in
  let th5 = AP_THM (AP_TERM exp_tm (TRANS th3 th4)) e0_tm in
  let th = TRANS th0 th5 in
    if flag then th else 
      TRANS (INST[tm1, m_var_num; tm2, n_var_num] ADD_COMM) th;;


let tm1 = `num_exp (B0 (B4 (B1 _0))) (B1 (B3 _0))`;;
let tm2 = `num_exp (B4 (B6 _0)) (B1 (B2 _0))`;;
num_exp_add tm1 tm2;;
num_exp_add tm2 tm1;;
num_exp_mul tm1 tm2;;
(* 4: 0.836 *)
test 10000 (num_exp_mul tm1) tm2;;
(* 4: 4.112 *)
test 10000 (num_exp_add tm1) tm2;;



(*************************************)

(* division *)

let NUM_EXP_DIV1' = (UNDISCH_ALL o PURE_REWRITE_RULE[NUMERAL] o
		       PURE_ONCE_REWRITE_RULE[ARITH_RULE `~(x = 0) <=> (x = 0 <=> F)`] o
		       REWRITE_RULE[GSYM IMP_IMP]) NUM_EXP_DIV1;;
let NUM_EXP_DIV2' = (UNDISCH_ALL o PURE_REWRITE_RULE[NUMERAL] o
		       PURE_ONCE_REWRITE_RULE[ARITH_RULE `~(x = 0) <=> (x = 0 <=> F)`] o
		       REWRITE_RULE[GSYM IMP_IMP]) NUM_EXP_DIV2;;


let num_exp_div tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let e_sub, e_le = raw_sub_and_le_hash_conv e1_tm e2_tm in

  let inst = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
		  n2_tm, n2_var_num; e2_tm, e2_var_num] in

  let n2_not_0 = raw_eq0_hash_conv n2_tm in
    if ((fst o dest_const o rand o concl) n2_not_0 = "T") then
      failwith "num_exp_div: n2 = 0"
    else
      if (rand(concl e_le) = e1_tm) then
 	let th0' = inst NUM_EXP_DIV1' in
	let th0 = MY_PROVE_HYP n2_not_0 (MY_PROVE_HYP e_le th0') in

	let ltm, rtm = dest_comb(rand(concl th0)) in
	let div_tm, rtm2 = dest_comb ltm in
	let num_exp_tm = rator rtm2 in

	let th1 = AP_THM (AP_TERM div_tm (AP_TERM num_exp_tm e_sub)) rtm in
	let ltm, rtm = dest_comb(rand(concl th1)) in
	let tm1 = rand ltm in
  
	let th2 = AP_THM (AP_TERM div_tm (denormalize tm1)) rtm in
	let th3 = raw_div_hash_conv (rand(concl th2)) in
	let th = TRANS th0 (TRANS th1 (TRANS th2 th3)) in
	  TRANS th (INST[rand(concl th), n_var_num] NUM_EXP_0')

      else
	let th0' = inst NUM_EXP_DIV2' in
	let th0 = MY_PROVE_HYP n2_not_0 (MY_PROVE_HYP e_le th0') in

	let ltm, rtm = dest_comb(rand(concl th0)) in
	let num_exp_tm = rator rtm in
	let th1 = AP_TERM ltm (AP_TERM num_exp_tm e_sub) in

	let ltm, rtm = dest_comb(rand(concl th1)) in
	let th2 = AP_TERM ltm (denormalize rtm) in
	let th3 = raw_div_hash_conv (rand(concl th2)) in
	let th = TRANS th0 (TRANS th1 (TRANS th2 th3)) in
	  TRANS th (INST[rand(concl th), n_var_num] NUM_EXP_0');;




(*
let tm1 = `num_exp (B0 (B4 (B1 _0))) (B1 (B3 _0))`;;
let tm2 = `num_exp (B4 (B6 _0)) (B1 (B2 _0))`;;
num_exp_div tm1 tm2;;
num_exp_div tm2 tm1;;
(* 4: 1.768 *)
test 1000 (num_exp_div tm1) tm2;;
(* 4: 0.656 *)
test 1000 (num_exp_div tm2) tm1;;
*)

(*****************************)

(* Computes the lower bound for (op tm1 tm2) *)
let num_exp_op_lo p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let lo_th = num_exp_lo p rtm in
  let ltm = rator (concl lo_th) in
  let th0 = AP_TERM ltm op_th in
    EQ_MP (SYM th0) lo_th;;



let num_exp_op_hi p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let hi_th = num_exp_hi p rtm in
  let tm = rand (concl hi_th) in
  let th0 = AP_THM (AP_TERM le_op_num op_th) tm in
    EQ_MP (SYM th0) hi_th;;



let num_exp_op_hi_lt p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let hi_lt_th = num_exp_hi_lt p rtm in
  let tm = rand (concl hi_lt_th) in
  let th0 = AP_THM (AP_TERM lt_op_num op_th) tm in
    EQ_MP (SYM th0) hi_lt_th;;



num_exp_op_lo 1 num_exp_div tm1 tm2;;
num_exp_op_hi 1 num_exp_div tm1 tm2;;
num_exp_op_hi_lt 1 num_exp_div tm1 tm2;;



let x = 2;;



(******************************************)


(* interval *)


let interval_arith = new_definition `interval_arith (x:real) (lo, hi) <=> lo <= x /\ x <= hi`;;


let CONST_INTERVAL = prove(`!x. interval_arith x (x,x)`, 
			   REWRITE_TAC[interval_arith; REAL_LE_REFL]);;


let APPROX_INTERVAL = prove(`(a <= lo /\ hi <= b) /\ interval_arith x (lo, hi)
                              ==> interval_arith x (a,b)`,
   REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;

let APPROX_INTERVAL' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP]) APPROX_INTERVAL;;

let INTERVAL_NEG = prove(`interval_arith x (a, b) ==>
                           interval_arith (--x) (--b, --a)`,
			 REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;



(* float *)



let min_exp = 10;;
let min_exp_num_const = rand (mk_small_numeral_array min_exp);;
let min_exp_const = mk_small_numeral min_exp;;
let float_tm = mk_eq(`float (s:bool) (n:num) (e:num):real`, 
		     mk_binop div_op_real 
		       `(if s then (-- &1) else &1) * &(num_exp n e)`
		       (mk_comb (`&`, mk_comb(`num_exp 1`, min_exp_const))));;
let float = new_definition float_tm;;




let mk_num_exp n_tm e_tm = mk_binop num_exp_const n_tm e_tm;;


(* float s n e -> "s", n, e *)
let dest_float tm =
  let ltm, e_tm = dest_comb tm in
  let ltm, n_tm = dest_comb ltm in
    (fst o dest_const o rand) ltm, n_tm, e_tm;;




let float_of_num_concl = mk_eq(`&n`, mk_comb(`float F n`, min_exp_const));;
let FLOAT_OF_NUM = (GEN_ALL o prove)(float_of_num_concl,
			 REWRITE_TAC[float; num_exp; REAL_MUL_LID] THEN
			   REWRITE_TAC[GSYM REAL_OF_NUM_MUL; REAL_MUL_LID; real_div] THEN
			   SUBGOAL_THEN `~(&(16 EXP 10) = &0)` ASSUME_TAC THENL
			   [
			     REWRITE_TAC[REAL_OF_NUM_EQ; EXP_EQ_0] THEN ARITH_TAC;
			     ALL_TAC
			   ] THEN
			   ASM_SIMP_TAC[GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]);;



let FLOAT_NEG = prove(`!s n e. --float s n e = float (~s) n e`,
   REWRITE_TAC[float] THEN REAL_ARITH_TAC);;


let FLOAT_NEG_F = (GSYM o REWRITE_RULE[] o SPEC `T`) FLOAT_NEG;;
let FLOAT_NEG_T = (GSYM o REWRITE_RULE[] o SPEC `F`) FLOAT_NEG;;




let FLOAT_F_POS = prove(`!n e. &0 <= float F n e`,
   REPEAT GEN_TAC THEN REWRITE_TAC[float; REAL_MUL_LID; real_div] THEN
     MATCH_MP_TAC REAL_LE_MUL THEN
     REWRITE_TAC[REAL_POS; REAL_LE_INV_EQ]);;


let FLOAT_T_NEG = prove(`!n e. float T n e <= &0`,
			REPEAT GEN_TAC THEN REWRITE_TAC[float; real_div] THEN
			  REWRITE_TAC[REAL_ARITH `(-- &1 * a) * b <= &0 <=> &0 <= a * b`] THEN
			  MATCH_MP_TAC REAL_LE_MUL THEN
			  REWRITE_TAC[REAL_POS; REAL_LE_INV_EQ]);;



let FLOAT_EQ_0 = prove(`!s n e. float s n e = &0 <=> n = 0`,
		       REPEAT GEN_TAC THEN REWRITE_TAC[float; real_div] THEN
			 REWRITE_TAC[REAL_ENTIRE] THEN
			 EQ_TAC THENL
			 [
			   STRIP_TAC THEN POP_ASSUM MP_TAC THENL
			     [
			       COND_CASES_TAC THEN REAL_ARITH_TAC;
			       REWRITE_TAC[REAL_OF_NUM_EQ; NUM_EXP_EQ_0];
			       REWRITE_TAC[REAL_INV_EQ_0; REAL_OF_NUM_EQ; NUM_EXP_EQ_0] THEN
				 ARITH_TAC
			     ];

			   DISCH_TAC THEN
			     DISJ1_TAC THEN DISJ2_TAC THEN
			     ASM_REWRITE_TAC[REAL_OF_NUM_EQ; NUM_EXP_EQ_0]
			 ]);;


let FLOAT_F_bound = (GEN_ALL o prove)(`num_exp n1 e1 <= num_exp n2 e2
				      ==> float F n1 e1 <= float F n2 e2`,
   DISCH_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID; real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE; REAL_LE_INV_EQ; REAL_POS]);;


let FLOAT_T_bound = (GEN_ALL o prove)(`num_exp n1 e1 <= num_exp n2 e2
					==> float T n2 e2 <= float T n1 e1`,
		      REWRITE_TAC[FLOAT_NEG_T; REAL_LE_NEG; FLOAT_F_bound]);;



let mod_plus = new_definition `mod_plus s1 s2 = (~(s1 /\ s2) /\ (s1 \/ s2))`;;




let EXP_INV_lemma = prove(`!n e1 e2. ~(n = 0) /\ e2 <= e1 ==> &(n EXP (e1 - e2)) = 
			      &(n EXP e1) * inv(&(n EXP e2))`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_POW] THEN
     MP_TAC (SPECL [`&n`; `e2:num`; `e1:num`] REAL_POW_SUB) THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_EQ; real_div]);;


let NUM_EXP_SUB_lemma = prove(`!n e1 e2. e2 <= e1 ==> &(num_exp n (e1 - e2)) = 
				  &(num_exp n e1) * inv(&(num_exp 1 e2))`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[num_exp] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     MP_TAC (SPECL [base_const; `e1:num`; `e2:num`] EXP_INV_lemma) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN ARITH_TAC;
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REAL_ARITH_TAC);;



(* FLOAT_MUL *)
let FLOAT_MUL = prove(`!s1 s2. 10 <= e /\ num_exp n1 e1 * num_exp n2 e2 = num_exp n e ==>
			  float s1 n1 e1 * float s2 n2 e2 = 
			     float (mod_plus s1 s2) n (e - 10)`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[float] THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) / c * (d * e) / f = (a * d) * (b * e) / c / f`] THEN
     
     SUBGOAL_THEN `(if s1 then -- &1 else &1) * (if s2 then -- &1 else &1) = if mod_plus s1 s2 then -- &1 else &1` MP_TAC THENL
     [
       REWRITE_TAC[mod_plus] THEN
	 COND_CASES_TAC THEN COND_CASES_TAC THEN
	 REWRITE_TAC[REAL_ARITH `-- &1 * -- &1 = &1`; REAL_MUL_LID; REAL_MUL_RID];
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REWRITE_TAC[real_div] THEN
     REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN
     REWRITE_TAC[REAL_EQ_MUL_LCANCEL] THEN
     DISJ2_TAC THEN
     
     SUBGOAL_THEN `&(num_exp n (e - 10)) = &(num_exp n e) * inv(&(num_exp 1 10))` MP_TAC THENL
     [
       MP_TAC (SPECL [`n:num`; `e:num`; min_exp_const] NUM_EXP_SUB_lemma) THEN
	 ASM_REWRITE_TAC[];
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_MUL]);;
     


let FLOAT_MUL_FF = (REWRITE_RULE[mod_plus] o SPECL[`F`; `F`]) FLOAT_MUL;;
let FLOAT_MUL_FT = (REWRITE_RULE[mod_plus] o SPECL[`F`; `T`]) FLOAT_MUL;;
let FLOAT_MUL_TF = (REWRITE_RULE[mod_plus] o SPECL[`T`; `F`]) FLOAT_MUL;;
let FLOAT_MUL_TT = (REWRITE_RULE[mod_plus] o SPECL[`T`; `T`]) FLOAT_MUL;;



let FLOAT_MUL_FF_hi, FLOAT_MUL_FF_lo = 
  let ff_hi = `10 <= e /\ e - 10 = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e 
                   ==> float F n1 e1 * float F n2 e2 <= float F n r` in
  let ff_lo = `10 <= e /\ e - 10 = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2 
	           ==> float F n r <= float F n1 e1 * float F n2 e2` in
  let proof = 
    REPEAT STRIP_TAC THEN
      POP_ASSUM MP_TAC THEN
      POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
      REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_MUL] THEN
      DISCH_TAC THEN
      MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
      ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
      REWRITE_TAC[REAL_ARITH `a / b * c / d = (a * c) / b / d`] THEN
      REWRITE_TAC[real_div] THEN
      REWRITE_TAC[REAL_MUL_ASSOC] THEN
      MATCH_MP_TAC REAL_LE_RMUL THEN
      REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     
      SUBGOAL_THEN `&(num_exp n (e - 10)) = z * inv(&(num_exp 1 10))` MP_TAC THENL
      [
	MP_TAC (SPECL [`n:num`; `e:num`; min_exp_const] NUM_EXP_SUB_lemma) THEN
	  ASM_REWRITE_TAC[];
	ALL_TAC
      ] THEN

      DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
      MATCH_MP_TAC REAL_LE_RMUL THEN
      ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] in
    prove(ff_hi, proof), prove(ff_lo, proof);;



let FLOAT_MUL_TT_hi, FLOAT_MUL_TT_lo =
  let tt_hi = `10 <= e /\ e - 10 = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e 
			    ==> float T n1 e1 * float T n2 e2 <= float F n r` in
  let tt_lo = `10 <= e /\ e - 10 = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2 
                   ==> float F n r <= float T n1 e1 * float T n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `--a * --b = a * b`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(tt_hi, proof), prove(tt_lo, proof);;



let FLOAT_MUL_FT_hi, FLOAT_MUL_FT_lo = 
  let ft_hi = `10 <= e /\ e - 10 = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2 
                    ==> float F n1 e1 * float T n2 e2 <= float T n r` in
  let ft_lo = `10 <= e /\ e - 10 = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e 
                   ==> float T n r <= float F n1 e1 * float T n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `a * --b <= --c <=> c <= a * b`] THEN
      REWRITE_TAC[REAL_ARITH `--c <= a * --b <=> a * b <= c`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(ft_hi, proof), prove(ft_lo, proof);;



let FLOAT_MUL_TF_hi, FLOAT_MUL_TF_lo = 
  let ft_hi = `10 <= e /\ e - 10 = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2 
                    ==> float T n1 e1 * float F n2 e2 <= float T n r` in
  let ft_lo = `10 <= e /\ e - 10 = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e 
                   ==> float T n r <= float T n1 e1 * float F n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `--a * b <= --c <=> c <= a * b`] THEN
      REWRITE_TAC[REAL_ARITH `--c <= --a * b <=> a * b <= c`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(ft_hi, proof), prove(ft_lo, proof);;


(*********************************************)

(* float_mul_lo, float_mul_hi *)

let FLOAT_MUL_FF_hi' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_MUL_FF_hi;;
let FLOAT_MUL_FF_lo' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_MUL_FF_lo;;



let float_mul_lo p f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_mul_lo: not implemented"
    else
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in
      let mul_th = num_exp_op_lo p num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand (concl mul_th)) in
      let sub_th, le_th = raw_sub_and_le_hash_conv e_tm min_exp_num_const in
	if (rand(concl le_th) <> e_tm) then 
	  failwith "float_mul_lo: underflow" 
	else
	  let r_tm = rand(concl sub_th) in
	  let th0 = INST[e_tm, e_var_num; r_tm, r_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_MUL_FF_lo' in
	    MY_PROVE_HYP sub_th (MY_PROVE_HYP mul_th (MY_PROVE_HYP le_th th0));;


      
let float_mul_hi p f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_mul_hi: not implemented"
    else
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in
      let mul_th = num_exp_op_hi p num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand (concl mul_th)) in
      let sub_th, le_th = raw_sub_and_le_hash_conv e_tm min_exp_num_const in
	if (rand(concl le_th) <> e_tm) then 
	  failwith "float_mul_hi: underflow" 
	else
	  let r_tm = rand(concl sub_th) in
	  let th0 = INST[e_tm, e_var_num; r_tm, r_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_MUL_FF_hi' in
	    MY_PROVE_HYP sub_th (MY_PROVE_HYP mul_th (MY_PROVE_HYP le_th th0));;





(*********************************************)

(* FLOAT_DIV *)


let DIV_lemma = prove(`!x y. ~(y = 0) ==> &(x DIV y) <= &x / &y /\ &x / &y <= &(x DIV y + 1)`,
   REPEAT GEN_TAC THEN DISCH_TAC THEN
     MP_TAC (SPECL [`y:num`; `x:num`] FLOOR_DIV_DIV) THEN
     ASM_REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[SYM th]) THEN
     SIMP_TAC[FLOOR; REAL_LT_IMP_LE]);;


let FLOAT_DIV_FF = prove(`e2 + k <= 10 + e + e1 /\ ~(n2 = 0) /\
			   num_exp n1 k DIV num_exp n2 0 = num_exp n e 
			     ==> float F n ((10 + e + e1) - (e2 + k)) <= float F n1 e1 / float F n2 e2`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 10) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
	 REWRITE_TAC[real_div] THEN
	 REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
	 REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
	 REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
	 REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN
	 SUBGOAL_THEN `~(&16 pow k = &0)` ASSUME_TAC THENL
	 [
	   REWRITE_TAC[REAL_POW_EQ_0] THEN
	     REAL_ARITH_TAC;
	   ALL_TAC
	 ] THEN

	 ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
	 REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
	 ASM_REWRITE_TAC[EXP] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[]);;




let FLOAT_DIV_FF_lo = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ r2 - r1 = r /\
                             r1 <= r2 /\ ~(n2 = 0) /\
			   num_exp n e <= num_exp n1 k DIV num_exp n2 0 
			     ==> float F n r <= float F n1 e1 / float F n2 e2`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN
     REPLICATE_TAC 3 (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 10) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
	 REWRITE_TAC[real_div] THEN
	 REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
	 REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
	 REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
	 REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN
	 SUBGOAL_THEN `~(&16 pow k = &0)` ASSUME_TAC THENL
	 [
	   REWRITE_TAC[REAL_POW_EQ_0] THEN
	     REAL_ARITH_TAC;
	   ALL_TAC
	 ] THEN

	 ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
	 REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
	 ASM_REWRITE_TAC[EXP] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     STRIP_TAC THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `&(x DIV y)` THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE]);;




let FLOAT_DIV_FF_hi = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ r2 - r1 = r /\
                              r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n1 k DIV num_exp n2 0 < num_exp n e
			      ==> float F n1 e1 / float F n2 e2 <= float F n r`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN
     REPLICATE_TAC 3 (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 10) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
	 REWRITE_TAC[real_div] THEN
	 REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
	 REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
	 REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
	 REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN
	 SUBGOAL_THEN `~(&16 pow k = &0)` ASSUME_TAC THENL
	 [
	   REWRITE_TAC[REAL_POW_EQ_0] THEN
	     REAL_ARITH_TAC;
	   ALL_TAC
	 ] THEN

	 ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
	 REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
	 ASM_REWRITE_TAC[EXP] THEN
	 ARITH_TAC;
       ALL_TAC
     ] THEN

     STRIP_TAC THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `&(x DIV y + 1)` THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE] THEN
     UNDISCH_TAC `x DIV y < z` THEN
     ARITH_TAC);;



let FLOAT_DIV_TT_lo = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ r2 - r1 = r /\
                              r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n e <= num_exp n1 k DIV num_exp n2 0
	     ==> float F n r <= float T n1 e1 / float T n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;

let FLOAT_DIV_TT_hi = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ 
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n1 k DIV num_exp n2 0 < num_exp n e
	     ==> float T n1 e1 / float T n2 e2 <= float F n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;


let FLOAT_DIV_FT_lo = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ 
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n1 k DIV num_exp n2 0 < num_exp n e
	     ==> float T n r <= float F n1 e1 / float T n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a <= b * --c <=> b * c <= a`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;

let FLOAT_DIV_FT_hi = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ 
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n e <= num_exp n1 k DIV num_exp n2 0
	     ==> float F n1 e1 / float T n2 e2 <= float T n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `a * --b <= --c <=> c <= a * b`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;


let FLOAT_DIV_TF_lo = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ 
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n1 k DIV num_exp n2 0 < num_exp n e
	     ==> float T n r <= float T n1 e1 / float F n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a <= --b * c <=> b * c <= a`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;

let FLOAT_DIV_TF_hi = prove(`e2 + k = r1 /\ 10 + e + e1 = r2 /\ 
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
			      num_exp n e <= num_exp n1 k DIV num_exp n2 0
	     ==> float T n1 e1 / float F n2 e2 <= float T n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a * b <= --c <=> c <= a * b`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;


(******************************************)

(* float_div_lo, float_div_hi *)

let FLOAT_DIV_FF_hi' = (UNDISCH_ALL o 
			  PURE_REWRITE_RULE[TAUT `~P <=> (P <=> F)`] o 
			  REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_DIV_FF_hi;;
let FLOAT_DIV_FF_lo' = (UNDISCH_ALL o 
			  PURE_REWRITE_RULE[TAUT `~P <=> (P <=> F)`] o
			  REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_DIV_FF_lo;;



let float_div_lo pp f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_div_lo: not implemented"
    else
      let k_tm = rand (mk_small_numeral_array (2 * pp)) in
      let num_exp1 = mk_num_exp n1 k_tm in
      let num_exp2 = mk_num_exp n2 zero_const in
      let div_th = num_exp_op_lo pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand (concl div_th)) in

      let r1_th = raw_add_conv_hash (mk_binop plus_op_num e2 k_tm) in
      let r1_tm = rand(concl r1_th) in
      let e_plus_e1 = raw_add_conv_hash (mk_binop plus_op_num e_tm e1) in
      let ltm, rtm = dest_comb(concl e_plus_e1) in
      let r2_th' = raw_add_conv_hash (mk_binop plus_op_num min_exp_num_const rtm) in
      let r2_th = TRANS (AP_TERM (mk_comb (plus_op_num, min_exp_num_const)) e_plus_e1) r2_th' in
      let r2_tm = rand(concl r2_th) in

      let sub_th, le_th = raw_sub_and_le_hash_conv r2_tm r1_tm in
	if (rand(concl le_th) <> r2_tm) then
	  failwith "float_div_lo: underflow"
	else
	  let r_tm = rand(concl sub_th) in
	  let n2_not_zero = raw_eq0_hash_conv n2 in

	  let th0 = INST[r1_tm, r1_var_num; r2_tm, r2_var_num; n1, n1_var_num; e1, e1_var_num;
			 e_tm, e_var_num; k_tm, k_var_num; n2, n2_var_num; e2, e2_var_num; 
			 n_tm, n_var_num; r_tm, r_var_num] FLOAT_DIV_FF_lo' in
	  let th1 = MY_PROVE_HYP n2_not_zero (MY_PROVE_HYP div_th (MY_PROVE_HYP le_th th0)) in
	    MY_PROVE_HYP sub_th (MY_PROVE_HYP r2_th (MY_PROVE_HYP r1_th th1));;



let float_div_hi pp f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_div_hi: not implemented"
    else
      let k_tm = rand (mk_small_numeral_array (2 * pp)) in
      let num_exp1 = mk_num_exp n1 k_tm in
      let num_exp2 = mk_num_exp n2 zero_const in
      let div_th = num_exp_op_hi_lt pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand (concl div_th)) in

      let r1_th = raw_add_conv_hash (mk_binop plus_op_num e2 k_tm) in
      let r1_tm = rand(concl r1_th) in
      let e_plus_e1 = raw_add_conv_hash (mk_binop plus_op_num e_tm e1) in
      let ltm, rtm = dest_comb(concl e_plus_e1) in
      let r2_th' = raw_add_conv_hash (mk_binop plus_op_num min_exp_num_const rtm) in
      let r2_th = TRANS (AP_TERM (mk_comb (plus_op_num, min_exp_num_const)) e_plus_e1) r2_th' in
      let r2_tm = rand(concl r2_th) in

      let sub_th, le_th = raw_sub_and_le_hash_conv r2_tm r1_tm in
	if (rand(concl le_th) <> r2_tm) then
	  failwith "float_div_hi: underflow"
	else
	  let r_tm = rand(concl sub_th) in
	  let n2_not_zero = raw_eq0_hash_conv n2 in

	  let th0 = INST[r1_tm, r1_var_num; r2_tm, r2_var_num; n1, n1_var_num; e1, e1_var_num;
			 e_tm, e_var_num; k_tm, k_var_num; n2, n2_var_num; e2, e2_var_num; 
			 n_tm, n_var_num; r_tm, r_var_num] FLOAT_DIV_FF_hi' in
	  let th1 = MY_PROVE_HYP n2_not_zero (MY_PROVE_HYP div_th (MY_PROVE_HYP le_th th0)) in
	    MY_PROVE_HYP sub_th (MY_PROVE_HYP r2_th (MY_PROVE_HYP r1_th th1));;



float_div_lo 1 `float F (B1 _0) (B10 _0)` `float F (B3 _0) (B10 _0)`;;
float_div_hi 1 `float F (B1 _0) (B10 _0)` `float F (B3 _0) (B10 _0)`;;
float_div_hi 5 f1 f2;;



 

(***********************************)


(* FLOAT_ADD *)

let FLOAT_ADD_FF = prove(`num_exp n1 e1 + num_exp n2 e2 = num_exp n e
    ==> float F n1 e1 + float F n2 e2 = float F n e`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_ADD]);;



let FLOAT_ADD_FF_lo = prove(`num_exp n e <= num_exp n1 e1 + num_exp n2 e2 
			      ==> float F n e <= float F n1 e1 + float F n2 e2`,
   REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_ADD] THEN
     REPEAT STRIP_TAC THEN
     MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
     ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     REWRITE_TAC[real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS]);;



let FLOAT_ADD_FF_hi = prove(`num_exp n1 e1 + num_exp n2 e2 <= num_exp n e
			      ==> float F n1 e1 + float F n2 e2 <= float F n e`,
   REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_ADD] THEN
     REPEAT STRIP_TAC THEN
     MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
     ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     REWRITE_TAC[real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS]);;

(******************************************)

(* float_add_lo, float_add_hi *)



let FLOAT_ADD_FF_hi' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_ADD_FF_hi;;
let FLOAT_ADD_FF_lo' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM) FLOAT_ADD_FF_lo;;



let float_add_lo p f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_add_lo: not implemented"
    else
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in
      let add_th = num_exp_op_lo p num_exp_add num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand (concl add_th)) in
      let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
		     e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_FF_lo' in
	MY_PROVE_HYP add_th th0;;


      
let float_add_hi p f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 <> "F" or s2 <> "F" then
      failwith "float_add_hi: not implemented"
    else
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in
      let add_th = num_exp_op_hi p num_exp_add num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand (concl add_th)) in
      let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
		     e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_FF_hi' in
	MY_PROVE_HYP add_th th0;;

float_add_lo 1 f1 f2;;
float_add_hi 1 f1 f2;;





(******************************************)

(* float intervals *)

let FLOAT_OF_NUM' = SPEC_ALL FLOAT_OF_NUM;;

let FLOAT_INTERVAL_OF_NUM = (NUMERALS_TO_NUM o prove)(`interval_arith (&n) (float F n 10, float F n 10)`,
   REWRITE_TAC[FLOAT_OF_NUM; CONST_INTERVAL]);;

let FLOAT_F_bound' = (UNDISCH_ALL o SPEC_ALL) FLOAT_F_bound;;

let FLOAT_T_bound' = (UNDISCH_ALL o SPEC_ALL) FLOAT_T_bound;;



let amp_op_real = `(&):num->real` and
    interval_const = `interval_arith` and
    num_exp_const = `num_exp`;;

let x_var_real = `x:real` and
    y_var_real = `y:real` and
    z_var_real = `z:real` and
    a_var_real = `a:real` and
    b_var_real = `b:real` and
    lo_var_real = `lo:real` and
    hi_var_real = `hi:real`;;




(* interval_arith x (float s1 n1 e1, float s2 n2 e2) -> x, float s1 n1 e1, float s2 n2 e2 *)
let dest_float_interval tm =
  let ltm, rtm = dest_comb tm in
  let f1, f2 = dest_pair rtm in
    rand ltm, f1, f2;;




let mk_float_interval_num n =
  let n_tm0 = mk_small_numeral n in
  let n_th = NUMERAL_TO_NUM_CONV n_tm0 in
  let n_tm = rand(rand(concl n_th)) in
  let n_th1 = TRANS n_th (INST[n_tm, n_var_num] NUM_REMOVE) in
  let th1 = AP_TERM amp_op_real n_th1 in
  let int_th = INST[n_tm, n_var_num] FLOAT_INTERVAL_OF_NUM in
  let rtm = rand(concl int_th) in
    EQ_MP (SYM (AP_THM (AP_TERM interval_const th1) rtm)) int_th;;






(* Returns the lower bound for the given float *)
let float_lo p tm =
  let s, n_tm, e_tm = dest_float tm in
    if s = "F" then
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_lo p num_exp_tm in
      let ltm, e1_tm = dest_comb(lhand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num; n_tm, n2_var_num; e_tm, e2_var_num] FLOAT_F_bound' in
	MY_PROVE_HYP th0 th1
    else
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_hi p num_exp_tm in
      let ltm, e1_tm = dest_comb(rand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n_tm, n1_var_num; e_tm, e1_var_num; n1_tm, n2_var_num; e1_tm, e2_var_num] FLOAT_T_bound' in
	MY_PROVE_HYP th0 th1;;



(* Returns the upper bound for the given float *)
let float_hi p tm =
  let s, n_tm, e_tm = dest_float tm in
    if s = "F" then
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_hi p num_exp_tm in
      let ltm, e2_tm = dest_comb(rand(concl th0)) in
      let n2_tm = rand ltm in
      let th1 = INST[n_tm, n1_var_num; e_tm, e1_var_num; n2_tm, n2_var_num; e2_tm, e2_var_num] FLOAT_F_bound' in
	MY_PROVE_HYP th0 th1
    else
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_lo p num_exp_tm in
      let ltm, e1_tm = dest_comb(lhand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num; n_tm, n2_var_num; e_tm, e2_var_num] FLOAT_T_bound' in
	MY_PROVE_HYP th0 th1;;






(* Approximates the given interval with p-digit float numbers *)
let float_interval_round p th =
  let x_tm, f1, f2 = dest_float_interval (concl th) in
  let lo_th = float_lo p f1 in
  let hi_th = float_hi p f2 in
  let lo_tm = lhand(concl lo_th) in
  let hi_tm = rand(concl hi_th) in
  let th0 = INST[x_tm, x_var_real; f1, lo_var_real; f2, hi_var_real; lo_tm, a_var_real; hi_tm, b_var_real] APPROX_INTERVAL' in
    MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th th0));;





let th = mk_float_interval_num 124235353;;
float_interval_round 5 th;;
(* 4: 0.240 *)
test 1000 (float_interval_round 5) th;;




(****************************************)

(* float_interval_neg *)


let FLOAT_INTERVAL_NEG = prove(`!s1 s2. interval_arith x (float s1 n1 e1, float s2 n2 e2)
				 ==> interval_arith (--x) (float (~s2) n2 e2, float (~s1) n1 e1)`,
   REPEAT GEN_TAC THEN
     DISCH_THEN (fun th -> MP_TAC (MATCH_MP INTERVAL_NEG th)) THEN
     SIMP_TAC[FLOAT_NEG]);;


let FLOAT_INTERVAL_NEG_FF = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`F`; `F`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_FT = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`F`; `T`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_TF = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`T`; `F`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_TT = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`T`; `T`]) FLOAT_INTERVAL_NEG;;





(* |- interval x (float s1 n1 e1, float s2 n2 e2) -> 
   |- interval (--x) (float ~s2 n2 e2, float ~s1 n1 e1 *)
let float_interval_neg th =
  let x_tm, f1, f2 = dest_float_interval (concl th) in
  let s1, n1_tm, e1_tm = dest_float f1 in
  let s2, n2_tm, e2_tm = dest_float f2 in
  let inst = INST[x_tm, x_var_real; n1_tm, n1_var_num; e1_tm, e1_var_num;
		  n2_tm, n2_var_num; e2_tm, e2_var_num] in
  let th0 =
    if s1 = "F" then
      if s2 = "F" then
	inst FLOAT_INTERVAL_NEG_FF
      else
	inst FLOAT_INTERVAL_NEG_FT
    else
      if s2 = "F" then
	inst FLOAT_INTERVAL_NEG_TF
      else
	inst FLOAT_INTERVAL_NEG_TT in
    MY_PROVE_HYP th th0;;



(***********************************************)

(* float_interval_mul *)


let FLOAT_INTERVAL_MUL_FF = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    float F n e <= float F n1 e1 * float F m1 r1 /\
    float F n2 e2 * float F m2 r2 <= float F m r
    ==> interval_arith (x * y) (float F n e, float F m r)`,
   MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
     MAP_EVERY ABBREV_TAC [`lo = float F n e`; `hi = float F m r`] THEN
     SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
     [
       MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
	 REWRITE_TAC[FLOAT_F_POS];
       ALL_TAC
     ] THEN
     REPEAT (POP_ASSUM (fun th -> ALL_TAC)) THEN
     REWRITE_TAC[interval_arith] THEN
     REPEAT STRIP_TAC THENL
     [
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `a * c:real` THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_MUL2 THEN
	 ASM_REWRITE_TAC[];
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `b * d:real` THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_MUL2 THEN
	 ASM_REWRITE_TAC[] THEN
	 CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL
	 [
	   EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[];
	   EXISTS_TAC `c:real` THEN ASM_REWRITE_TAC[]
	 ]
     ]);;

 
let float_interval_mul pp th1 th2 = 
  let x, l_lo, l_hi = dest_float_interval (concl th1) in
  let y, r_lo, r_hi = dest_float_interval (concl th2) in
  let s1, n1, e1 = dest_float l_lo and
      s2, n2, e2 = dest_float l_hi and
      s3, m1, r1 = dest_float r_lo and
      s4, m2, r2 = dest_float r_hi in
    if s1 <> "F" or s3 <> "F" then 
      failwith "float_interval_mul: not implemented" 
    else
      let lo_th = float_mul_lo pp l_lo r_lo in
      let hi_th = float_mul_hi pp l_hi r_hi in
      let ltm, e_tm = dest_comb(lhand(concl lo_th)) in
      let n_tm = rand ltm in
      let ltm, r_tm = dest_comb(rand(concl hi_th)) in
      let m_tm = rand ltm in
      let th0 = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
		     y, y_var_real; n2, n2_var_num; e2, e2_var_num;
		     m1, m1_var_num; r1, r1_var_num; m2, m2_var_num;
		     r2, r2_var_num; n_tm, n_var_num; e_tm, e_var_num; 
		     m_tm, m_var_num; r_tm, r_var_num] FLOAT_INTERVAL_MUL_FF in
	MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th1 (MY_PROVE_HYP th2 th0)));;



let th1 = mk_float_interval_num 123456781;;
let th2 = mk_float_interval_num 514553443;;
(* 4: 0.340 *)
test 100 (float_interval_mul 5 th1) th2;;
(* 4: 0.368 *)
test 100 (float_interval_mul 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514553443;;
let tm = mk_binop mul_op_num tm1 tm2;;

(* 4: 0.148 *)
test 100 NUM_MULT_HASH_CONV tm;;


let th1' = float_interval_round 5 th1;;
let th2' = float_interval_round 5 th2;;

(* 4: 0.176 *)
test 100 (float_interval_mul 5 th1') th2';;



(*************************************)

(* float_interval_div *)

let FLOAT_INTERVAL_DIV_FF = (UNDISCH_ALL o
			       PURE_REWRITE_RULE[TAUT `~P <=> (P <=> F)`] o
			       REWRITE_RULE[GSYM IMP_IMP] o 
			       NUMERALS_TO_NUM o prove)(
  `~(m1 = 0) /\ ~(m2 = 0) /\
    interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    float F n e <= float F n1 e1 / float F m2 r2 /\
    float F n2 e2 / float F m1 r1 <= float F m r
    ==> interval_arith (x / y) (float F n e, float F m r)`,
   MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
     MAP_EVERY ABBREV_TAC [`lo = float F n e`; `hi = float F m r`] THEN
     REWRITE_TAC[real_div] THEN
     STRIP_TAC THEN
     SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
     [
       MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
	 REWRITE_TAC[FLOAT_F_POS];
       ALL_TAC
     ] THEN
     SUBGOAL_THEN `~(c = &0) /\ ~(d = &0)` MP_TAC THENL
     [
       EXPAND_TAC "c" THEN EXPAND_TAC "d" THEN
	 ASM_REWRITE_TAC[FLOAT_EQ_0];
       ALL_TAC
     ] THEN

     REPLICATE_TAC 6 (POP_ASSUM MP_TAC) THEN
     REPEAT (POP_ASSUM (fun th -> ALL_TAC)) THEN
     REWRITE_TAC[interval_arith] THEN
     REPEAT STRIP_TAC THENL
     [
       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `a * inv d` THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_MUL2 THEN
	 ASM_REWRITE_TAC[REAL_LE_INV_EQ] THEN
	 MATCH_MP_TAC REAL_LE_INV2 THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LTE_TRANS THEN
	 EXISTS_TAC `c:real` THEN
	 ASM_REWRITE_TAC[REAL_ARITH `&0 < c <=> ~(c = &0) /\ &0 <= c`];

       MATCH_MP_TAC REAL_LE_TRANS THEN
	 EXISTS_TAC `b * inv c` THEN
	 ASM_REWRITE_TAC[] THEN
	 MATCH_MP_TAC REAL_LE_MUL2 THEN
	 ASM_REWRITE_TAC[REAL_LE_INV_EQ] THEN
	 REPEAT CONJ_TAC THENL
	 [
	   MATCH_MP_TAC REAL_LE_TRANS THEN
	     EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[];
	   MATCH_MP_TAC REAL_LE_TRANS THEN
	     EXISTS_TAC `c:real` THEN ASM_REWRITE_TAC[];
	   ALL_TAC
	 ] THEN
	 MATCH_MP_TAC REAL_LE_INV2 THEN
	 ASM_REWRITE_TAC[REAL_ARITH `&0 < c <=> ~(c = &0) /\ &0 <= c`]
     ]);;



 
let float_interval_div pp th1 th2 = 
  let x, l_lo, l_hi = dest_float_interval (concl th1) in
  let y, r_lo, r_hi = dest_float_interval (concl th2) in
  let s1, n1, e1 = dest_float l_lo and
      s2, n2, e2 = dest_float l_hi and
      s3, m1, r1 = dest_float r_lo and
      s4, m2, r2 = dest_float r_hi in
    if s1 <> "F" or s3 <> "F" then 
      failwith "float_interval_div: not implemented" 
    else
      let lo_th = float_div_lo pp l_lo r_hi in
      let hi_th = float_div_hi pp l_hi r_lo in
      let m1_th = raw_eq0_hash_conv m1 in
      let m2_th = raw_eq0_hash_conv m2 in
      
      let ltm, e_tm = dest_comb(lhand(concl lo_th)) in
      let n_tm = rand ltm in
      let ltm, r_tm = dest_comb(rand(concl hi_th)) in
      let m_tm = rand ltm in
      let th0 = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
		     y, y_var_real; n2, n2_var_num; e2, e2_var_num;
		     m1, m1_var_num; r1, r1_var_num; m2, m2_var_num;
		     r2, r2_var_num; n_tm, n_var_num; e_tm, e_var_num; 
		     m_tm, m_var_num; r_tm, r_var_num] FLOAT_INTERVAL_DIV_FF in
      let th = MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th1 (MY_PROVE_HYP th2 th0))) in
	MY_PROVE_HYP m1_th (MY_PROVE_HYP m2_th th);;






let th1 = mk_float_interval_num 123456781;;
let th2 = mk_float_interval_num 514;;
float_interval_div 5 th1 th2;;
float_interval_div 1 th1 th2;;
(* 4: 0.392 *)
test 100 (float_interval_div 5 th1) th2;;
(* 4: 0.224 *)
test 100 (float_interval_div 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514;;
let tm = mk_binop `DIV` tm1 tm2;;

(* 4: 0.056 *)
test 100 NUM_DIV_HASH_CONV tm;;
NUM_DIV_HASH_CONV tm;;


let th1' = float_interval_round 3 th1;;
let th2' = float_interval_round 3 th2;;

(* 4: 0.256 *)
test 100 (float_interval_div 3 th1') th2';;



let th1 = mk_float_interval_num 1;;
let th2 = mk_float_interval_num 17;;

float_interval_div 5 th1 th2;;




(*****************************************)

(* float_interval_add *)

let n1_var_real = `n1:real` and
    n2_var_real = `n2:real` and
    m1_var_real = `m1:real` and
    m2_var_real = `m2:real` and
    n_var_real = `n:real` and
    m_var_real = `m:real`;;


let INTERVAL_ADD = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (n1, m1) /\
    interval_arith y (n2, m2) /\
    n <= n1 + n2 /\ m1 + m2 <= m
    ==> interval_arith (x + y) (n, m)`,
   REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;

	   EXISTS_TAC `c:real` THEN ASM_REWRITE_TAC[]
	 ]
     ]);;



 
let float_interval_add pp th1 th2 = 
  let x, n1, m1 = dest_float_interval (concl th1) in
  let y, n2, m2 = dest_float_interval (concl th2) in
  let lo_th = float_add_lo pp n1 n2 in
  let hi_th = float_add_hi pp m1 m2 in
  let n_tm = lhand (concl lo_th) in
  let m_tm = rand (concl hi_th) in
  let th0 = INST[x, x_var_real; n1, n1_var_real; m1, m1_var_real;
		 y, y_var_real; n2, n2_var_real; m2, m2_var_real;
		 n_tm, n_var_real; m_tm, m_var_real] INTERVAL_ADD in
    MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th2 (MY_PROVE_HYP th1 th0)));;







let th1 = mk_float_interval_num 123456781;;
let th2 = mk_float_interval_num 514;;
float_interval_add 5 th1 th2;;
float_interval_add 1 th1 th2;;
(* 4: 0.424 *)
test 1000 (float_interval_add 5 th1) th2;;
(* 4: 0.648 *)
test 1000 (float_interval_add 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514;;
let tm = mk_binop plus_op_num tm1 tm2;;

(* 4: 0.036 *)
test 1000 NUM_ADD_HASH_CONV tm;;
NUM_ADD_HASH_CONV tm;;


let th1' = float_interval_round 3 th1;;
let th2' = float_interval_round 3 th2;;
float_interval_add 3 th1' th2';;

(* 4: 0.724 *)
test 1000 (float_interval_add 3 th1') th2';;







(*

(**********************************)

let num_interval = new_definition `num_interval (x:num) (n1, n2) <=> n1 <= x /\ x <= n2`;;

let NUM_INTERVAL_CONST = prove(`num_interval n (n,n)`,
			       REWRITE_TAC[num_interval; LE_REFL]);;

let NUM_INTERVAL_ROUND = prove(`!x n1 n2 m1 m2. m1 <= n1 /\ n2 <= m2 /\ num_interval x (n1, n2)
				 ==> num_interval x (m1, m2)`,
			       REWRITE_TAC[num_interval] THEN ARITH_TAC);;

let NUM_INTERVAL_ROUND' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL) NUM_INTERVAL_ROUND;;



let num_exp_interval_round p th =
  let ltm, rtm = dest_comb(concl th) in
  let n1_tm, n2_tm = dest_pair rtm in
  let m1_le_n1 = num_exp_lo p n1_tm in
  let n2_le_m2 = num_exp_hi p n2_tm in
  let m1_tm = lhand (concl m1_le_n1) in
  let m2_tm = rand (concl n2_le_m2) in
  let th0 = INST[m1_tm, m1_var_num; n1_tm, n1_var_num;
		 m2_tm, m2_var_num; n2_tm, n2_var_num; rand ltm, x_var_num] NUM_INTERVAL_ROUND' in
    MY_PROVE_HYP th (MY_PROVE_HYP n2_le_m2 (MY_PROVE_HYP m1_le_n1 th0));;


let th = INST[`num_exp (B4 (B4 (B6 _0))) (B15 (B1 _0))`, n_var_num] NUM_INTERVAL_CONST;;
num_exp_interval_round 1 th;;


let x = 2;;



(**********************************)



let mul_lemma = (UNDISCH_ALL o prove) (`m <= n ==> m * x = y ==> e <= y ==> e <= n * x:num`,
				       DISCH_TAC THEN 
					 DISCH_THEN (fun th -> REWRITE_TAC[SYM th]) THEN
					 DISCH_TAC THEN
					 MATCH_MP_TAC LE_TRANS THEN
					 EXISTS_TAC `m * x:num` THEN
					 ASM_REWRITE_TAC[LE_MULT_RCANCEL]);;



let mul_step p th0 tm =
  let m_tm, n_tm = dest_comb (concl th0) in
  let m_tm = rand m_tm in
  let mul_th = num_exp_mul m_tm tm in
  let lo_th = num_exp_lo p (rand (concl mul_th)) in
  let e_tm, y_tm = dest_comb (concl lo_th) in
  let th = INST[rand e_tm, e_var_num; y_tm, y_var_num; 
		m_tm, m_var_num; n_tm, n_var_num; tm, x_var_num] mul_lemma in
    MY_PROVE_HYP th0 (MY_PROVE_HYP mul_th (MY_PROVE_HYP lo_th th));;



let mul_step_test th0 tm =
  let m_tm, n_tm = dest_comb (concl th0) in
  let m_tm = rand m_tm in
  let mul_th = raw_mul_conv_hash (mk_binop mul_op_num tm n_tm) in
  let th = AP_TERM (mk_comb (mul_op_num, tm)) th0 in
    TRANS th mul_th;;




(**********************)

let nums = 1--200;;

let my_conv = rand o concl o ONCE_REWRITE_CONV[NUM_EXP_0'] o rand o concl o REWRITE_CONV[NUM_THM] o mk_small_numeral_array;;
let my_conv' = rand o concl o REWRITE_CONV[NUM_THM] o mk_small_numeral_array;;

let tms = map my_conv nums;;
let tms' = map my_conv' nums;;
let th0 = INST[`num_exp (B1 _0) _0`, n_var_num] LE_REFL';;

let p = 10;;
let r = List.fold_left (fun th tm -> mul_step p th tm) th0 tms;;

(* 4, p = 10: 0.388 *)
test 10 (List.fold_left (fun th tm -> mul_step p th tm) th0) tms;;

let th0' = REFL `B1 _0`;;
List.fold_left (fun th tm -> mul_step_test th tm) th0' tms';;
(* 1.808 *)
test 10 (List.fold_left (fun th tm -> mul_step_test th tm) th0') tms';;




let m_tm = (rand o rator o rand o rator o concl) r and
    e_tm = (rand o rand o rator o concl) r;;

let m = (dest_numeral o rand o concl o NUM_TO_NUMERAL_CONV) (mk_comb(num_const, m_tm));;
let e = (dest_numeral o rand o concl o NUM_TO_NUMERAL_CONV) (mk_comb(num_const, e_tm));;

m */ Num.num_of_int maximum **/ e;;


let ntms = map Num.num_of_int nums;;
List.fold_left (fun n1 n2 -> n1 */ n2) (Num.num_of_int 1) ntms;;




(***********************)


let x = 2;;


(***************************************)


let float = new_definition `float s m e = (-- &1) pow (if s then 1 else 0) * &m * (&2) pow e`;;


let mul_lemma = prove(`float s1 m1 e1 * float s2 m2 e2 = float (~(s1 /\ s2) /\ (s1 \/ s2)) (m1 * m2) (e1 + e2)`,
   REPEAT GEN_TAC THEN
     REWRITE_TAC[float] THEN
     REWRITE_TAC[REAL_ARITH `(a * b * c) * x * y * z = (a * x) * (b * y) * (c * z)`] THEN
     SUBGOAL_THEN `-- &1 pow (if s1 then 1 else 0) * -- &1 pow (if s2 then 1 else 0) = -- &1 pow (if ~(s1 /\ s2) /\ (s1 \/ s2) then 1 else 0)` (fun th -> REWRITE_TAC[th]) THENL
     [
       REAL_ARITH_TAC;
       ALL_TAC
     ] THEN
     
     REWRITE_TAC[REAL_EQ_MUL_LCANCEL] THEN
     DISJ2_TAC THEN
     REWRITE_TAC[GSYM REAL_POW_ADD; REAL_OF_NUM_MUL]);;

*)
