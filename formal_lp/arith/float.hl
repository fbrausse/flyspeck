needs "arith_hash2.hl";;


open Arith_hash2;;


(* The main parameter (should be even for the square root operation) *)
let min_exp = 50;;


(* interval *)


let interval_arith = new_definition `interval_arith (x:real) (lo, hi) <=> lo <= x /\ x <= hi`;;


let CONST_INTERVAL = prove(`!x. interval_arith x (x,x)`,
                           REWRITE_TAC[interval_arith; REAL_LE_REFL]);;


let APPROX_INTERVAL = prove(`(a <= lo /\ hi <= b) /\ interval_arith x (lo, hi)
                              ==> interval_arith x (a,b)`,
   REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;

let APPROX_INTERVAL' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP]) APPROX_INTERVAL;;

let INTERVAL_NEG = prove(`interval_arith x (a, b) ==>
                           interval_arith (--x) (--b, --a)`,
                         REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;


let zero_const = `_0` and
    t_const = `T` and
    f_const = `F`;;

let n_var_num = `n:num` and
    m_var_num = `m:num` and
    k_var_num = `k:num` and
    e_var_num = `e:num` and
    e1_var_num = `e1:num` and
    e2_var_num = `e2:num` and
    r_var_num = `r:num` and
    r1_var_num = `r1:num` and
    r2_var_num = `r2:num` and
    n1_var_num = `n1:num` and
    n2_var_num = `n2:num` and
    m1_var_num = `m1:num` and
    m2_var_num = `m2:num` and
    x_var_num = `x:num` and
    y_var_num = `y:num`;;

let le_op_num = `(<=):num->num->bool` and
    lt_op_num = `(<):num->num->bool` and
    mul_op_num = `( * ):num->num->num` and
    plus_op_num = `(+):num->num->num` and
    minus_op_num = `(-):num->num->num` and
    div_op_real = `(/):real->real->real` and
    div_op_num = `DIV` and
    mul_op_real = `( * ):real->real->real` and
    plus_op_real = `(+):real->real->real` and
    minus_op_real = `(-):real->real->real` and
    neg_op_real = `(--):real->real`;;



let amp_op_real = `(&):num->real` and
    interval_const = `interval_arith` and
    num_exp_const = `num_exp`;;

let x_var_real = `x:real` and
    y_var_real = `y:real` and
    z_var_real = `z:real` and
    a_var_real = `a:real` and
    b_var_real = `b:real` and
    lo_var_real = `lo:real` and
    hi_var_real = `hi:real`;;



let b0_const = (fst o dest_comb o lhand o concl) (def_array.(0));;
let b0_name = (fst o dest_const) b0_const;;
let base_const = mk_small_numeral maximum;;


let NUM_REMOVE = prove(mk_eq(mk_comb(num_const, n_var_num), n_var_num), REWRITE_TAC[num_def; NUMERAL]);;


(* B0 n = base * n *)
let b0_thm = prove(mk_eq(mk_comb(b0_const, n_var_num),
                         mk_binop mul_op_num base_const n_var_num),
                   REWRITE_TAC[def_array.(0)] THEN
                     TRY ARITH_TAC THEN
                     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV) [BIT0] THEN
                     ARITH_TAC);;




(* num_exp definition *)
let num_exp_tm = mk_eq (`(num_exp:num->num->num) n e`,
                        mk_binop mul_op_num n_var_num (mk_binop `EXP` base_const e_var_num));;
(* let num_exp = new_definition `num_exp n e = n * 2 EXP e`;; *)
let num_exp = new_definition num_exp_tm;;


let dest_num_exp tm =
  let ltm, e_tm = dest_comb tm in
    rand ltm, e_tm;;



let num_exp_const = `num_exp`;;
let mk_num_exp n_tm e_tm = mk_binop num_exp_const n_tm e_tm;;




(* float *)




let min_exp_num_const = rand (mk_small_numeral_array min_exp);;
let min_exp_const = mk_small_numeral min_exp;;

let min_exp_def = new_definition (mk_eq(`min_exp:num`, min_exp_const));;

let float_tm = `float s n e = (if s then (-- &1) else &1) * &(num_exp n e) / &(num_exp 1 min_exp)`;;
let float = new_definition float_tm;;




(* float s n e -> "s", n, e *)
let dest_float tm =
  let ltm, e_tm = dest_comb tm in
  let ltm, n_tm = dest_comb ltm in
  let float_tm, s_tm = dest_comb ltm in
    if (fst o dest_const) float_tm <> "float" then
      failwith "dest_float: not float"
    else
      (fst o dest_const) s_tm, n_tm, e_tm;;



(************************************)




let NUM_EXP_EXP = prove(`!n e1 e2. num_exp (num_exp n e1) e2 = num_exp n (e1 + e2)`,
   REPEAT GEN_TAC THEN
     REWRITE_TAC[num_exp; EXP_ADD] THEN
     ARITH_TAC);;

let NUM_EXP_EXP' = SPEC_ALL NUM_EXP_EXP;;


let NUM_EXP_SUM = prove(`!n e1 e2. num_exp n (e1 + e2) = num_exp n e1 * num_exp 1 e2`,
   REPEAT GEN_TAC THEN
     REWRITE_TAC[num_exp; EXP_ADD] THEN
     ARITH_TAC);;


let NUM_EXP_SUM1 = prove(`!n e1 e2. num_exp n (e1 + e2) = num_exp 1 e1 * num_exp n e2`,
                         REPEAT GEN_TAC THEN REWRITE_TAC[num_exp; EXP_ADD] THEN ARITH_TAC);;



let NUM_EXP_0 = prove(`!n. n = num_exp n 0`,
                      GEN_TAC THEN REWRITE_TAC[num_exp; EXP; MULT_CLAUSES]);;

let NUM_EXP_0' = (SPEC_ALL o REWRITE_RULE[NUMERAL]) NUM_EXP_0;;


let NUM_EXP_LE = prove(`!m n e. m <= n ==> num_exp m e <= num_exp n e`,
     SIMP_TAC[num_exp; LE_MULT_RCANCEL]);;

let NUM_EXP_LE' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_LE;;


let NUM_EXP_LT = prove(`!m n e. m < n ==> num_exp m e < num_exp n e`,
                       SIMP_TAC[num_exp; LT_MULT_RCANCEL; EXP_EQ_0] THEN
                         ARITH_TAC);;

let NUM_EXP_LT' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_LT;;



let NUM_EXP_EQ_0 = prove(`!n e. num_exp n e = 0 <=> n = 0`,
   REPEAT STRIP_TAC THEN
     ASM_REWRITE_TAC[num_exp; MULT_EQ_0; EXP_EQ_0] THEN
     ARITH_TAC);;


let NUM_EXP_MUL = prove(`!n1 e1 n2 e2. num_exp n1 e1 * num_exp n2 e2 = num_exp (n1 * n2) (e1 + e2)`,
                        REWRITE_TAC[num_exp; EXP_ADD] THEN ARITH_TAC);;

let NUM_EXP_ADD = prove(`!n1 e1 n2 e2. e1 <= e2 ==>
                          num_exp n1 e1 + num_exp n2 e2 = num_exp (n1 + num_exp n2 (e2 - e1)) e1`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[num_exp] THEN
     REWRITE_TAC[ARITH_RULE `(a + b * c) * d = a * d + b * (c * d):num`] THEN
     REWRITE_TAC[GSYM EXP_ADD] THEN
     ASM_SIMP_TAC[ARITH_RULE `e1 <= e2 ==> e2 - e1 + e1 = e2:num`]);;



let NUM_EXP_SUB2 = prove(`!n1 e1 n2 e2 r. e1 <= e2 /\ e2 - e1 = r ==>
			   num_exp n1 e1 - num_exp n2 e2 = num_exp (n1 - num_exp n2 r) e1`,
   REPEAT STRIP_TAC THEN
     POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
     REWRITE_TAC[num_exp] THEN
     MP_TAC (ARITH_RULE `e1 <= e2 ==> e2 = (e2 - e1) + e1:num`) THEN
     ASM_REWRITE_TAC[] THEN
     DISCH_THEN (fun th -> GEN_REWRITE_TAC (LAND_CONV o ONCE_DEPTH_CONV) [th]) THEN
     REWRITE_TAC[EXP_ADD; MULT_ASSOC] THEN
     REWRITE_TAC[GSYM RIGHT_SUB_DISTRIB]);;



let NUM_EXP_SUB1 = prove(`!n1 e1 n2 e2 r. e2 <= e1 /\ e1 - e2 = r ==>
			   num_exp n1 e1 - num_exp n2 e2 = num_exp (num_exp n1 r - n2) e2`,
   REPEAT STRIP_TAC THEN
     POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
     REWRITE_TAC[num_exp] THEN
     MP_TAC (ARITH_RULE `e2 <= e1 ==> e1 = (e1 - e2) + e2:num`) THEN
     ASM_REWRITE_TAC[] THEN
     DISCH_THEN (fun th -> GEN_REWRITE_TAC (LAND_CONV o ONCE_DEPTH_CONV) [th]) THEN
     REWRITE_TAC[EXP_ADD; MULT_ASSOC] THEN
     REWRITE_TAC[GSYM RIGHT_SUB_DISTRIB]);;



let NUM_EXP_LE1 = prove(`!n1 e1 n2 e2 r. e2 <= e1 /\ e1 - e2 = r /\ n2 <= num_exp n1 r
			      ==> num_exp n2 e2 <= num_exp n1 e1`,
   REPEAT GEN_TAC THEN REWRITE_TAC[num_exp] THEN
     STRIP_TAC THEN
     POP_ASSUM MP_TAC THEN POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN DISCH_TAC THEN
     MP_TAC (ARITH_RULE `e2 <= e1 ==> e1 = (e1 - e2) + e2:num`) THEN
     ASM_REWRITE_TAC[] THEN
     DISCH_THEN(fun th -> ONCE_REWRITE_TAC[th]) THEN
     REWRITE_TAC[EXP_ADD; MULT_ASSOC] THEN
     ASM_REWRITE_TAC[LE_MULT_RCANCEL]);;



let NUM_EXP_LE2 = prove(`!n1 e1 n2 e2 r. e1 <= e2 /\ e2 - e1 = r /\ num_exp n2 r <= n1
			      ==> num_exp n2 e2 <= num_exp n1 e1`,
   REPEAT GEN_TAC THEN REWRITE_TAC[num_exp] THEN
     STRIP_TAC THEN
     POP_ASSUM MP_TAC THEN POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN DISCH_TAC THEN
     MP_TAC (ARITH_RULE `e1 <= e2 ==> e2 = (e2 - e1) + e1:num`) THEN
     ASM_REWRITE_TAC[] THEN
     DISCH_THEN(fun th -> ONCE_REWRITE_TAC[th]) THEN
     REWRITE_TAC[EXP_ADD; MULT_ASSOC] THEN
     ASM_REWRITE_TAC[LE_MULT_RCANCEL]);;

			      
     




let NUM_EXP_DIV1 = prove(`~(n2 = 0) /\ e2 <= e1 ==>
                           num_exp n1 e1 DIV num_exp n2 e2 = num_exp n1 (e1 - e2) DIV n2`,
   STRIP_TAC THEN
     (*`num_exp n1 e1 = 16 EXP e2 * num_exp n1 (e1 - e2)` MP_TAC THENL*)
     SUBGOAL_THEN (mk_eq(`num_exp n1 e1`, mk_binop mul_op_num (mk_binop `EXP` base_const `e2:num`) `num_exp n1 (e1 - e2)`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp] THEN
         ONCE_REWRITE_TAC[ARITH_RULE `a * b * c = b * (a * c:num)`] THEN
         REWRITE_TAC[GSYM EXP_ADD] THEN
         ASM_SIMP_TAC[ARITH_RULE `e2 <= e1 ==> e2 + e1 - e2 = e1:num`];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     SUBGOAL_THEN (mk_eq(`num_exp n2 e2`, mk_binop mul_op_num (mk_binop `EXP` base_const `e2:num`) `n2:num`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp; MULT_AC];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     MATCH_MP_TAC DIV_MULT2 THEN
     ASM_REWRITE_TAC[MULT_EQ_0; DE_MORGAN_THM; EXP_EQ_0] THEN
     ARITH_TAC);;



let NUM_EXP_DIV2 = prove(`~(n2 = 0) /\ e1 <= e2 ==>
                           num_exp n1 e1 DIV num_exp n2 e2 = n1 DIV num_exp n2 (e2 - e1)`,
   STRIP_TAC THEN
     (*`num_exp n2 e2 = 16 EXP e1 * num_exp n2 (e2 - e1)` MP_TAC THENL*)
     SUBGOAL_THEN (mk_eq(`num_exp n2 e2`, mk_binop mul_op_num (mk_binop `EXP` base_const `e1:num`) `num_exp n2 (e2 - e1)`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp] THEN
         ONCE_REWRITE_TAC[ARITH_RULE `a * b * c = b * (a * c:num)`] THEN
         REWRITE_TAC[GSYM EXP_ADD] THEN
         ASM_SIMP_TAC[ARITH_RULE `e1 <= e2 ==> e1 + e2 - e1 = e2:num`];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     SUBGOAL_THEN (mk_eq(`num_exp n1 e1`, mk_binop mul_op_num (mk_binop `EXP` base_const `e1:num`) `n1:num`)) MP_TAC THENL
     [
       REWRITE_TAC[num_exp; MULT_AC];
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     MATCH_MP_TAC DIV_MULT2 THEN
     ASM_REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM; EXP_EQ_0] THEN
     ARITH_TAC);;





(* B0 n = num_exp n bits *)
let normal_lemma1 = prove(mk_eq(mk_comb(b0_const, n_var_num), `num_exp n 1`),
   REWRITE_TAC[def_array.(0); num_exp] THEN
     TRY ARITH_TAC THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV) [BIT0] THEN
     ARITH_TAC);;


let NUMERALS_TO_NUM = REWRITE_RULE[NUM_THM] o CONV_RULE (DEPTH_CONV NUMERAL_TO_NUM_CONV);;

let NORMAL_LEMMA1 = NUMERALS_TO_NUM normal_lemma1;;

let normal_lemma2 = prove(mk_eq (mk_comb (b0_const, `num_exp n e`), `num_exp n (SUC e)`),
   REWRITE_TAC[normal_lemma1; NUM_EXP_EXP] THEN ARITH_TAC);;



let rec normalize tm =
  if (is_comb tm) then
    let ltm, rtm = dest_comb tm in
    let lname = (fst o dest_const) ltm in
      if (lname = b0_name) then
        let lth = INST[rtm, n_var_num] NORMAL_LEMMA1 in
        let rth, flag = normalize rtm in
          if flag then
            let ltm, lexp = (dest_comb o snd o dest_eq o concl) lth in
            let ltm, rtm = dest_comb ltm in
            let rn, rexp = (dest_comb o snd o dest_eq o concl) rth in
            let rn = rand rn in
            let th1 = AP_THM (AP_TERM ltm rth) lexp in
            let th2 = INST[rexp, e1_var_num; lexp, e2_var_num; rn, n_var_num] NUM_EXP_EXP' in
            let th3 = TRANS lth (TRANS th1 th2) in
            let ltm, rtm = (dest_comb o snd o dest_eq o concl) th3 in
            let add_th = raw_add_conv_hash rtm in
            let th4 = AP_TERM ltm add_th in
              (TRANS th3 th4, true)
          else
            (lth, true)
      else
        (REFL tm, false)
  else
    (REFL tm, false);;


(* Converts a raw numeral to a num_exp expression *)
let to_num_exp tm =
  let x, flag = normalize tm in
    if flag then x
    else
      INST[tm, n_var_num] NUM_EXP_0';;
	



(*
let tm = `B0 (B0 (B0 (B1 (B2 (B3 _0)))))`;;
(* 8: 0.568 *)
test 10000 normalize tm;; (* 0.568 *)
(* 8: 0.012 *)
test 10000 normalize `B2 (B3 (B4 _0))`;;
*)



(************************************)

let SYM_NUM_EXP_0' = SYM NUM_EXP_0';;

let NUM_EXP_n0 = prove(`!e. num_exp 0 e = 0`, REWRITE_TAC[num_exp; MULT_CLAUSES]);;

let NUM_EXP_n0' = (REWRITE_RULE[NUMERAL] o SPEC_ALL) NUM_EXP_n0;;


let NUM_EXP_DENORM = (UNDISCH_ALL o prove)
  (mk_imp(`e = _0 <=> F`, mk_eq(`num_exp n e`, mk_comb (b0_const, `num_exp n (PRE e)`))),
   REWRITE_TAC[] THEN ONCE_REWRITE_TAC[SYM (REWRITE_CONV[NUMERAL] `0`)] THEN
     REWRITE_TAC[num_exp; b0_thm] THEN
     REWRITE_TAC[ARITH_RULE (mk_eq(mk_binop mul_op_num base_const `n * a:num`,
                                   mk_binop mul_op_num `n:num` (mk_binop mul_op_num base_const `a:num`)))] THEN
     REWRITE_TAC[GSYM EXP] THEN
     SIMP_TAC[ARITH_RULE `~(e = 0) ==> SUC (PRE e) = e`]);;




(* Converts num_exp n e to a numeral by adding e B0's *)
let rec denormalize tm =
  let ltm, etm = dest_comb tm in
  let ntm = rand ltm in
    if (etm = zero_const) then
      INST[ntm, n_var_num] SYM_NUM_EXP_0'
    else
      if ntm = zero_const then
        INST[etm, e_var_num] NUM_EXP_n0'
      else
        let e_th = raw_eq0_hash_conv etm in
        let th0' = INST[etm, e_var_num; ntm, n_var_num] NUM_EXP_DENORM in
        let th0 = MY_PROVE_HYP e_th th0' in
        let b0_tm, rtm = dest_comb(rand(concl th0)) in
        let ltm, pre_tm = dest_comb rtm in
        let pre_th = raw_pre_hash_conv pre_tm in
        let th1 = AP_TERM ltm pre_th in
        let th2 = denormalize (rand(concl th1)) in
          TRANS th0 (AP_TERM b0_tm (TRANS th1 th2));;



(*
let tm = `num_exp (B1 (B3 (B5 _0))) (B15 _0)`;;
denormalize tm;;
(* 4: 0.264 *)
test 1000 denormalize tm;;
*)


(***************************************)



let rec comb_number tm n =
  if (is_comb tm) then comb_number ((snd o dest_comb) tm) (n + 1) else n;;


let make_lo_thm i =
  let th_concl = mk_binop `(<=):num->num->bool`
    (mk_comb (const_array.(0), n_var_num))
    (mk_comb (const_array.(i), n_var_num)) in
    prove(th_concl,
          REWRITE_TAC[def_array.(i); def_array.(0)] THEN
            REWRITE_TAC[ARITH_LE; LE_REFL] THEN
            ARITH_TAC);;



let lo_thm_array = Array.init maximum make_lo_thm;;
let lo_thm_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add lo_thm_table const_array.(i) lo_thm_array.(i);
done;;



let make_lo_thm2 i =
  let th_concl = mk_imp (`n <= m:num`,
                         mk_binop `(<=):num->num->bool`
                          (mk_comb (const_array.(0), n_var_num))
                          (mk_comb (const_array.(i), m_var_num))) in
    (UNDISCH_ALL o prove) (th_concl,
          REWRITE_TAC[def_array.(i); def_array.(0); ARITH_LE] THEN
                          ARITH_TAC);;


let lo_thm2_array = Array.init maximum make_lo_thm2;;
let lo_thm2_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add lo_thm2_table const_array.(i) lo_thm2_array.(i);
done;;




let make_hi_thm i =
  let th_concl = mk_imp (`n < m:num`,
                         mk_binop `(<):num->num->bool`
                          (mk_comb (const_array.(i), n_var_num))
                          (mk_comb (const_array.(0), m_var_num))) in
    (UNDISCH_ALL o prove) (th_concl,
                           REWRITE_TAC[def_array.(i); def_array.(0); ARITH_LT] THEN
                             ARITH_TAC);;



let hi_thm_array = Array.init maximum make_hi_thm;;
let hi_thm_table = Hashtbl.create maximum;;

for i = 0 to maximum - 1 do
  Hashtbl.add hi_thm_table const_array.(i) hi_thm_array.(i);
done;;



(***************************************)


let LE_REFL' = SPEC_ALL LE_REFL;;
let LE_TRANS' = (UNDISCH_ALL o SPEC_ALL o REWRITE_RULE[GSYM IMP_IMP]) LE_TRANS;;


let lo_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      INST[tm, n_var_num] LE_REFL'
    else
      let rec lo_bound n tm =
        let btm, rtm = dest_comb tm in
        let th0 = INST[rtm, n_var_num] (Hashtbl.find lo_thm_table btm) in
          if n > 1 then
            let rth = lo_bound (n - 1) rtm in
            let xtm = rand (rator (concl rth)) in
            let th1' = INST[xtm, n_var_num; rtm, m_var_num] (Hashtbl.find lo_thm2_table btm) in
            let th1 = MY_PROVE_HYP rth th1' in
              th1
          else
            th0 in

        lo_bound (n - p) tm;;



let N_LT_SUC = ARITH_RULE `n < SUC n`;;
let LT_IMP_LE' = (UNDISCH_ALL o SPEC_ALL) LT_IMP_LE;;
let N_LT_SUC = ARITH_RULE `n < SUC n`;;
let LT_LE_TRANS = (UNDISCH_ALL o ARITH_RULE) `n < e ==> e <= m ==> n < m:num`;;


(* Generates a theorem |- n <= m such that m contains at most p non-zero digits *)
let hi_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      INST[tm, n_var_num] LE_REFL'
    else
      let k = n - p in

      let rec check_b0s n tm =
        let btm, rtm = dest_comb tm in
          if ((fst o dest_const) btm = b0_name) then
            if n > 1 then check_b0s (n - 1) rtm else true
          else
            false in

        if (check_b0s k tm) then
          INST[tm, n_var_num] LE_REFL'
        else
          let rec hi_bound n tm =
            if n > 0 then
              let btm, rtm = dest_comb tm in
              let r_th = hi_bound (n - 1) rtm in
              let xtm = rand (concl r_th) in
              let th0 = INST[rtm, n_var_num; xtm, m_var_num] (Hashtbl.find hi_thm_table btm) in
                MY_PROVE_HYP r_th th0
            else
              let th0 = INST[tm, n_var_num] N_LT_SUC in
              let ltm, suc_tm = dest_comb (concl th0) in
              let suc_th = raw_suc_conv_hash suc_tm in
                EQ_MP (AP_TERM ltm suc_th) th0 in

          let th = hi_bound k tm in
          let m_tm, l_tm = dest_comb (concl th) in
            MY_PROVE_HYP th (INST[rand m_tm, m_var_num; l_tm, n_var_num] LT_IMP_LE');;




(*
let tm = `B10 (B12 (B11 (B1 (B14 (B15 _0)))))`;;
hi_num_conv 4 tm;;

let tm = `B0 (B0 (B1 (B2 _0)))`;;
hi_num_conv 2 tm;;
*)



(* Generates a theorem |- n < m such that m contains at most p non-zero digits *)
let hi_lt_num_conv p tm =
  let n = comb_number tm 0 in
    if (n <= p) then
      let th0 = INST[tm, n_var_num] N_LT_SUC in
      let ltm, rtm = dest_comb(concl th0) in
      let suc_th = raw_suc_conv_hash rtm in
        EQ_MP (AP_TERM ltm suc_th) th0
    else
      let k = n - p in

      let rec check_b0s n tm =
        let btm, rtm = dest_comb tm in
          if ((fst o dest_const) btm = b0_name) then
            if n > 1 then check_b0s (n - 1) rtm else true
          else
            false in

        if (check_b0s k tm) then
          let th0 = INST[tm, n_var_num] N_LT_SUC in
          let ltm, rtm = dest_comb (concl th0) in
          let suc_th = raw_suc_conv_hash rtm in
          let suc_tm = rand(concl suc_th) in
          let th1 = hi_num_conv p suc_tm in
          let th2 = EQ_MP (AP_TERM ltm suc_th) th0 in
          let th = INST[tm, n_var_num; suc_tm, e_var_num; rand(concl th1), m_var_num] LT_LE_TRANS in
            MY_PROVE_HYP th1 (MY_PROVE_HYP th2 th)

        else
          let rec hi_bound n tm =
            if n > 0 then
              let btm, rtm = dest_comb tm in
              let r_th = hi_bound (n - 1) rtm in
              let xtm = rand (concl r_th) in
              let th0 = INST[rtm, n_var_num; xtm, m_var_num] (Hashtbl.find hi_thm_table btm) in
                MY_PROVE_HYP r_th th0
            else
              let th0 = INST[tm, n_var_num] N_LT_SUC in
              let ltm, suc_tm = dest_comb (concl th0) in
              let suc_th = raw_suc_conv_hash suc_tm in
                EQ_MP (AP_TERM ltm suc_th) th0 in
            hi_bound k tm;;



(*
let tm = `B10 (B12 (B11 (B1 (B14 (B15 _0)))))`;;
hi_num_conv 4 tm;;
hi_lt_num_conv 4 tm;;

let tm = `B0 (B0 (B1 (B2 _0)))`;;
hi_num_conv 3 tm;;
hi_lt_num_conv 3 tm;;
*)


(*****************************************)




let num_exp_lo p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = lo_num_conv p n_tm in
  let m_tm = rand (rator (concl n_th)) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, m_var_num; n_tm, n_var_num; e_tm, e_var_num] NUM_EXP_LE' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
        EQ_MP (AP_THM (AP_TERM le_op_num th4) tm) th0


    else
      th0;;



let num_exp_hi p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = hi_num_conv p n_tm in
  let m_tm = rand (concl n_th) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, n_var_num; n_tm, m_var_num; e_tm, e_var_num] NUM_EXP_LE' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
        EQ_MP (AP_TERM (rator (concl th0)) th4) th0
    else
      th0;;




let num_exp_hi_lt p tm =
  let ltm, e_tm = dest_comb tm in
  let n_tm = rand ltm in
  let n_th = hi_lt_num_conv p n_tm in
  let m_tm = rand (concl n_th) in
  let m_norm, flag = normalize m_tm in

  let th0' = INST[m_tm, n_var_num; n_tm, m_var_num; e_tm, e_var_num] NUM_EXP_LT' in
  let th0 = MY_PROVE_HYP n_th th0' in
    if flag then
      let th1 = AP_THM (AP_TERM (rator ltm) m_norm) e_tm in
      let m_tm, me_tm = (dest_comb o rand o concl) m_norm in
      let th2 = INST[me_tm, e1_var_num; e_tm, e2_var_num; rand m_tm, n_var_num] NUM_EXP_EXP' in
      let th3 = TRANS th1 th2 in
      let ltm, rtm = (dest_comb o rand o concl) th3 in
      let th_add = raw_add_conv_hash rtm in
      let th4 = TRANS th3 (AP_TERM ltm th_add) in
        EQ_MP (AP_TERM (rator (concl th0)) th4) th0
    else
      th0;;





(*
let tm = `num_exp (B5 (B1 (B2 (B3 _0)))) (B3 _0)`;;
num_exp_lo 2 tm;;
num_exp_hi 2 tm;;
num_exp_hi_lt 2 tm;;
num_exp_hi_lt 2 `num_exp (B0 (B0 (B1 _0))) (B4 _0)`;;
(* 4: 0.848 *)
test 10000 (num_exp_lo 2) tm;;
(* 4: 0.448 *)
test 10000 (num_exp_lo 3) tm;;
(* 4: 0.116 *)
test 10000 (num_exp_lo 5) tm;;
*)


(***************************************)

(* num_exp_mul *)

let NUM_EXP_MUL' = SPEC_ALL NUM_EXP_MUL;;

let num_exp_mul tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let th0 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
                 n2_tm, n2_var_num; e2_tm, e2_var_num] NUM_EXP_MUL' in
  let ltm, tm_add = dest_comb (rand (concl th0)) in
  let tm_mul = rand ltm in
  let th_mul = raw_mul_conv_hash tm_mul in
  let th_add = raw_add_conv_hash tm_add in
    TRANS th0 (MK_COMB (AP_TERM (rator ltm) th_mul, th_add));;


(**********************************)

(* num_exp_add *)

let NUM_EXP_ADD' = (UNDISCH_ALL o SPEC_ALL) NUM_EXP_ADD;;
let ADD_COMM = ARITH_RULE `m + n = n + m:num`;;

let num_exp_add tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let e_sub, e_le = raw_sub_and_le_hash_conv e1_tm e2_tm in

  let flag = (rand(concl e_le) = e2_tm) in

  let th0' =
    if flag then
      INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
           n2_tm, n2_var_num; e2_tm, e2_var_num] NUM_EXP_ADD'
    else
      INST[n2_tm, n1_var_num; e2_tm, e1_var_num;
           n1_tm, n2_var_num; e1_tm, e2_var_num] NUM_EXP_ADD' in

  let th0 = MY_PROVE_HYP e_le th0' in
  let ltm, e0_tm = dest_comb(rand(concl th0)) in
  let exp_tm, add_tm = dest_comb ltm in
  let ltm, d_tm = dest_comb add_tm in
  let th1 = AP_TERM (rator d_tm) e_sub in
  let th2 = denormalize (rand(concl th1)) in
  let th3 = AP_TERM ltm (TRANS th1 th2) in
  let th4 = raw_add_conv_hash (rand(concl th3)) in
  let th5 = AP_THM (AP_TERM exp_tm (TRANS th3 th4)) e0_tm in
  let th = TRANS th0 th5 in
    if flag then th else
      TRANS (INST[tm1, m_var_num; tm2, n_var_num] ADD_COMM) th;;


(*
let tm1 = `num_exp (B0 (B4 (B1 _0))) (B1 (B3 _0))`;;
let tm2 = `num_exp (B4 (B6 _0)) (B1 (B2 _0))`;;
num_exp_add tm1 tm2;;
num_exp_add tm2 tm1;;
num_exp_mul tm1 tm2;;
(* 4: 0.836 *)
test 10000 (num_exp_mul tm1) tm2;;
(* 4: 4.112 *)
test 10000 (num_exp_add tm1) tm2;;
*)


(****************************************)

(* num_exp_sub *)

let NUM_EXP_SUB1' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL) NUM_EXP_SUB1 and
    NUM_EXP_SUB2' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL) NUM_EXP_SUB2 and
    NUM_EXP_LE1' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL) NUM_EXP_LE1 and
    NUM_EXP_LE2' = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o SPEC_ALL) NUM_EXP_LE2;;


(* Returns two theorems: |- tm1 - tm2 = tm, |- tm2 <= tm1 or
   |- tm2 - tm1 = tm, |- tm1 <= tm2 *)
let num_exp_sub tm1 tm2 =
  let n1_tm, e1_tm = dest_num_exp tm1 in
  let n2_tm, e2_tm = dest_num_exp tm2 in
  let e_sub, e_le = raw_sub_and_le_hash_conv e1_tm e2_tm in

    if rand(concl e_le) = e1_tm then
      (* e2 <= e1 *)
      let e1_sub_e2 = rand(concl e_sub) in
      let a0 = mk_num_exp n1_tm e1_sub_e2 in
      let b = n2_tm in
      let a_th = denormalize a0 in
      let a = rand(concl a_th) in

      let th_sub, th_le = raw_sub_and_le_hash_conv a b in
	if rand(concl th_le) = a then
	  (* b <= a *)
	  let a_sub_b = TRANS (AP_THM (AP_TERM minus_op_num a_th) b) th_sub in
	  let b_le_a = EQ_MP (SYM (AP_TERM (rator(concl th_le)) a_th)) th_le in
	  let th0 = AP_THM (AP_TERM num_exp_const a_sub_b) e2_tm in

	  let inst = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
			  n2_tm, n2_var_num; e2_tm, e2_var_num; e1_sub_e2, r_var_num] in
	  let th1_sub = inst NUM_EXP_SUB1' in
	  let th1_le = inst NUM_EXP_LE1' in
	  let th2_sub = MY_PROVE_HYP e_sub (MY_PROVE_HYP e_le th1_sub) in
	  let th2_le = MY_PROVE_HYP e_sub (MY_PROVE_HYP b_le_a (MY_PROVE_HYP e_le th1_le)) in
	    TRANS th2_sub th0, th2_le

	else
	  (* a <= b *)
	  let b_sub_a = TRANS (AP_TERM (rator(lhand(concl th_sub))) a_th) th_sub in
	  let a_le_b = EQ_MP (SYM (AP_THM (AP_TERM le_op_num a_th) b)) th_le in
	  let th0 = AP_THM (AP_TERM num_exp_const b_sub_a) e2_tm in
	  let inst = INST[n2_tm, n1_var_num; e2_tm, e1_var_num;
			  n1_tm, n2_var_num; e1_tm, e2_var_num; e1_sub_e2, r_var_num] in
	  let th1_sub = inst NUM_EXP_SUB2' in
	  let th1_le = inst NUM_EXP_LE2' in
	  let th2_sub = MY_PROVE_HYP e_sub (MY_PROVE_HYP e_le th1_sub) in
	  let th2_le = MY_PROVE_HYP e_sub (MY_PROVE_HYP a_le_b (MY_PROVE_HYP e_le th1_le)) in
	    TRANS th2_sub th0, th2_le

    else
      (* e1 <= e2 *)
      let e2_sub_e1 = rand(concl e_sub) in
      let b0 = mk_num_exp n2_tm e2_sub_e1 in
      let a = n1_tm in
      let b_th = denormalize b0 in
      let b = rand(concl b_th) in

      let th_sub, th_le = raw_sub_and_le_hash_conv a b in
	if rand(concl th_le) = a then
	  (* b <= a *)
	  let a_sub_b = TRANS (AP_TERM (rator(lhand(concl th_sub))) b_th) th_sub in
	  let b_le_a = EQ_MP (SYM (AP_THM (AP_TERM le_op_num b_th) a)) th_le in
	  let th0 = AP_THM (AP_TERM num_exp_const a_sub_b) e1_tm in
	  let inst = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
			  n2_tm, n2_var_num; e2_tm, e2_var_num; e2_sub_e1, r_var_num] in
	  let th1_sub = inst NUM_EXP_SUB2' in
	  let th1_le = inst NUM_EXP_LE2' in
	  let th2_sub = MY_PROVE_HYP e_sub (MY_PROVE_HYP e_le th1_sub) in
	  let th2_le = MY_PROVE_HYP e_sub (MY_PROVE_HYP b_le_a (MY_PROVE_HYP e_le th1_le)) in
	    TRANS th2_sub th0, th2_le

	else
	  (* a <= b *)
	  let b_sub_a = TRANS (AP_THM (AP_TERM minus_op_num b_th) a) th_sub in
	  let a_le_b = EQ_MP (SYM (AP_TERM (rator(concl th_le)) b_th)) th_le in
	  let th0 = AP_THM (AP_TERM num_exp_const b_sub_a) e1_tm in
	  let inst = INST[n2_tm, n1_var_num; e2_tm, e1_var_num;
			  n1_tm, n2_var_num; e1_tm, e2_var_num; e2_sub_e1, r_var_num] in
	  let th1_sub = inst NUM_EXP_SUB1' in
	  let th1_le = inst NUM_EXP_LE1' in
	  let th2_sub = MY_PROVE_HYP e_sub (MY_PROVE_HYP e_le th1_sub) in
	  let th2_le = MY_PROVE_HYP e_sub (MY_PROVE_HYP a_le_b (MY_PROVE_HYP e_le th1_le)) in
	    TRANS th2_sub th0, th2_le;;



  
(*
let tm1 = `num_exp (D3 (D4 (D1 _0))) (D2 _0)`;;
let tm2 = `num_exp (D1 (D2 (D1 _0))) (D3 _0)`;;
num_exp_sub tm1 tm2;;
(* 10: 0.252 *)
test 1000 (num_exp_sub tm1) tm2;;
*)




(*************************************)

(* division *)

let NUM_EXP_DIV1' = (UNDISCH_ALL o PURE_REWRITE_RULE[NUMERAL] o
                       PURE_ONCE_REWRITE_RULE[ARITH_RULE `~(x = 0) <=> (x = 0 <=> F)`] o
                       REWRITE_RULE[GSYM IMP_IMP]) NUM_EXP_DIV1;;
let NUM_EXP_DIV2' = (UNDISCH_ALL o PURE_REWRITE_RULE[NUMERAL] o
                       PURE_ONCE_REWRITE_RULE[ARITH_RULE `~(x = 0) <=> (x = 0 <=> F)`] o
                       REWRITE_RULE[GSYM IMP_IMP]) NUM_EXP_DIV2;;


let num_exp_div tm1 tm2 =
  let n1_tm, e1_tm = dest_comb tm1 in
  let n1_tm = rand n1_tm in
  let n2_tm, e2_tm = dest_comb tm2 in
  let n2_tm = rand n2_tm in
  let e_sub, e_le = raw_sub_and_le_hash_conv e1_tm e2_tm in

  let inst = INST[n1_tm, n1_var_num; e1_tm, e1_var_num;
                  n2_tm, n2_var_num; e2_tm, e2_var_num] in

  let n2_not_0 = raw_eq0_hash_conv n2_tm in
    if ((fst o dest_const o rand o concl) n2_not_0 = "T") then
      failwith "num_exp_div: n2 = 0"
    else
      if (rand(concl e_le) = e1_tm) then
         let th0' = inst NUM_EXP_DIV1' in
        let th0 = MY_PROVE_HYP n2_not_0 (MY_PROVE_HYP e_le th0') in

        let ltm, rtm = dest_comb(rand(concl th0)) in
        let div_tm, rtm2 = dest_comb ltm in
        let num_exp_tm = rator rtm2 in

        let th1 = AP_THM (AP_TERM div_tm (AP_TERM num_exp_tm e_sub)) rtm in
        let ltm, rtm = dest_comb(rand(concl th1)) in
        let tm1 = rand ltm in

        let th2 = AP_THM (AP_TERM div_tm (denormalize tm1)) rtm in
        let th3 = raw_div_hash_conv (rand(concl th2)) in
        let th = TRANS th0 (TRANS th1 (TRANS th2 th3)) in
          TRANS th (INST[rand(concl th), n_var_num] NUM_EXP_0')

      else
        let th0' = inst NUM_EXP_DIV2' in
        let th0 = MY_PROVE_HYP n2_not_0 (MY_PROVE_HYP e_le th0') in

        let ltm, rtm = dest_comb(rand(concl th0)) in
        let num_exp_tm = rator rtm in
        let th1 = AP_TERM ltm (AP_TERM num_exp_tm e_sub) in

        let ltm, rtm = dest_comb(rand(concl th1)) in
        let th2 = AP_TERM ltm (denormalize rtm) in
        let th3 = raw_div_hash_conv (rand(concl th2)) in
        let th = TRANS th0 (TRANS th1 (TRANS th2 th3)) in
          TRANS th (INST[rand(concl th), n_var_num] NUM_EXP_0');;




(*
let tm1 = `num_exp (B0 (B4 (B1 _0))) (B1 (B3 _0))`;;
let tm2 = `num_exp (B4 (B6 _0)) (B1 (B2 _0))`;;
num_exp_div tm1 tm2;;
num_exp_div tm2 tm1;;
(* 4: 1.768 *)
test 1000 (num_exp_div tm1) tm2;;
(* 4: 0.656 *)
test 1000 (num_exp_div tm2) tm1;;
*)

(*****************************)

(* Computes the lower bound for (op tm1 tm2) *)
let num_exp_op_lo p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let lo_th = num_exp_lo p rtm in
  let ltm = rator (concl lo_th) in
  let th0 = AP_TERM ltm op_th in
    EQ_MP (SYM th0) lo_th;;



let num_exp_op_hi p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let hi_th = num_exp_hi p rtm in
  let tm = rand (concl hi_th) in
  let th0 = AP_THM (AP_TERM le_op_num op_th) tm in
    EQ_MP (SYM th0) hi_th;;



let num_exp_op_hi_lt p op tm1 tm2 =
  let op_th = op tm1 tm2 in
  let rtm = rand (concl op_th) in
  let hi_lt_th = num_exp_hi_lt p rtm in
  let tm = rand (concl hi_lt_th) in
  let th0 = AP_THM (AP_TERM lt_op_num op_th) tm in
    EQ_MP (SYM th0) hi_lt_th;;


(*
num_exp_op_lo 1 num_exp_add tm1 tm2;;
num_exp_op_hi 1 num_exp_div tm1 tm2;;
num_exp_op_hi_lt 1 num_exp_div tm1 tm2;;
*)


(******************************************)

(* float *)


let FLOAT_OF_NUM = (GEN_ALL o prove)(`&n = float F n min_exp`,
                         REWRITE_TAC[float; num_exp; REAL_MUL_LID] THEN
                           REWRITE_TAC[GSYM REAL_OF_NUM_MUL; REAL_MUL_LID; real_div] THEN
                           SUBGOAL_THEN (mk_comb(`(~)`, mk_eq(mk_comb(`&`, mk_binop `EXP` base_const `min_exp`), `&0`))) ASSUME_TAC THENL
                           [
                             REWRITE_TAC[REAL_OF_NUM_EQ; EXP_EQ_0] THEN ARITH_TAC;
                             ALL_TAC
                           ] THEN
                           ASM_SIMP_TAC[GSYM REAL_MUL_ASSOC; REAL_MUL_RINV; REAL_MUL_RID]);;



let FLOAT_NEG = prove(`!s n e. --float s n e = float (~s) n e`,
   REWRITE_TAC[float] THEN REAL_ARITH_TAC);;


let FLOAT_NEG_F = (GSYM o REWRITE_RULE[] o SPEC `T`) FLOAT_NEG;;
let FLOAT_NEG_T = (GSYM o REWRITE_RULE[] o SPEC `F`) FLOAT_NEG;;




let FLOAT_F_POS = prove(`!n e. &0 <= float F n e`,
   REPEAT GEN_TAC THEN REWRITE_TAC[float; REAL_MUL_LID; real_div] THEN
     MATCH_MP_TAC REAL_LE_MUL THEN
     REWRITE_TAC[REAL_POS; REAL_LE_INV_EQ]);;


let FLOAT_T_NEG = prove(`!n e. float T n e <= &0`,
                        REPEAT GEN_TAC THEN REWRITE_TAC[float; real_div] THEN
                          REWRITE_TAC[REAL_ARITH `-- &1 * a * b <= &0 <=> &0 <= a * b`] THEN
                          MATCH_MP_TAC REAL_LE_MUL THEN
                          REWRITE_TAC[REAL_POS; REAL_LE_INV_EQ]);;



let FLOAT_EQ_0 = prove(`!s n e. float s n e = &0 <=> n = 0`,
                       REPEAT GEN_TAC THEN REWRITE_TAC[float; real_div] THEN
                         REWRITE_TAC[REAL_ENTIRE] THEN
                         EQ_TAC THENL
                         [
                           STRIP_TAC THEN POP_ASSUM MP_TAC THENL
                             [
                               COND_CASES_TAC THEN REAL_ARITH_TAC;
                               REWRITE_TAC[REAL_OF_NUM_EQ; NUM_EXP_EQ_0];
                               REWRITE_TAC[REAL_INV_EQ_0; REAL_OF_NUM_EQ; NUM_EXP_EQ_0] THEN
                                 ARITH_TAC
                             ];

                           DISCH_TAC THEN
			     DISJ2_TAC THEN DISJ1_TAC THEN
                             ASM_REWRITE_TAC[REAL_OF_NUM_EQ; NUM_EXP_EQ_0]
                         ]);;


let FLOAT_F_bound = (GEN_ALL o prove)(`num_exp n1 e1 <= num_exp n2 e2
                                      ==> float F n1 e1 <= float F n2 e2`,
   DISCH_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID; real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE; REAL_LE_INV_EQ; REAL_POS]);;


let FLOAT_T_bound = (GEN_ALL o prove)(`num_exp n1 e1 <= num_exp n2 e2
                                        ==> float T n2 e2 <= float T n1 e1`,
                      REWRITE_TAC[FLOAT_NEG_T; REAL_LE_NEG; FLOAT_F_bound]);;



let mod_plus = new_definition `mod_plus s1 s2 = (~(s1 /\ s2) /\ (s1 \/ s2))`;;




let EXP_INV_lemma = prove(`!n e1 e2. ~(n = 0) /\ e2 <= e1 ==> &(n EXP (e1 - e2)) =
                              &(n EXP e1) * inv(&(n EXP e2))`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_POW] THEN
     MP_TAC (SPECL [`&n`; `e2:num`; `e1:num`] REAL_POW_SUB) THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_EQ; real_div]);;


let NUM_EXP_SUB_lemma = prove(`!n e1 e2. e2 <= e1 ==> &(num_exp n (e1 - e2)) =
                                  &(num_exp n e1) * inv(&(num_exp 1 e2))`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[num_exp] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     MP_TAC (SPECL [base_const; `e1:num`; `e2:num`] EXP_INV_lemma) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[] THEN ARITH_TAC;
       ALL_TAC
     ] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REAL_ARITH_TAC);;



(* FLOAT_MUL *)

let FLOAT_MUL = prove(`!s1 s2. min_exp <= e /\ num_exp n1 e1 * num_exp n2 e2 = num_exp n e
			  ==> float s1 n1 e1 * float s2 n2 e2 =
			      float (mod_plus s1 s2) n (e - min_exp)`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[float] THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b / c) * (d * e / f) = (a * d) * (b * e) / c / f`] THEN

     SUBGOAL_THEN `(if s1 then -- &1 else &1) * (if s2 then -- &1 else &1) = if mod_plus s1 s2 then -- &1 else &1` MP_TAC THENL
     [
       REWRITE_TAC[mod_plus] THEN
         COND_CASES_TAC THEN COND_CASES_TAC THEN
         REWRITE_TAC[REAL_ARITH `-- &1 * -- &1 = &1`; REAL_MUL_LID; REAL_MUL_RID];
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REWRITE_TAC[real_div] THEN
     REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN
     REWRITE_TAC[REAL_EQ_MUL_LCANCEL] THEN
     DISJ2_TAC THEN

     MP_TAC (SPECL[`n:num`; `e:num`; `min_exp`] NUM_EXP_SUB_lemma) THEN
     ASM_REWRITE_TAC[] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_MUL]);;



let FLOAT_MUL_FF = (REWRITE_RULE[mod_plus] o SPECL[`F`; `F`]) FLOAT_MUL;;
let FLOAT_MUL_FT = (REWRITE_RULE[mod_plus] o SPECL[`F`; `T`]) FLOAT_MUL;;
let FLOAT_MUL_TF = (REWRITE_RULE[mod_plus] o SPECL[`T`; `F`]) FLOAT_MUL;;
let FLOAT_MUL_TT = (REWRITE_RULE[mod_plus] o SPECL[`T`; `T`]) FLOAT_MUL;;


let FLOAT_MUL_FF_hi, FLOAT_MUL_FF_lo =
  let ff_hi = `min_exp <= e /\ e - min_exp = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e
                      ==> float F n1 e1 * float F n2 e2 <= float F n r` in
  let ff_lo = `min_exp <= e /\ e - min_exp = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2
                      ==> float F n r <= float F n1 e1 * float F n2 e2` in
  let proof =
    REPEAT STRIP_TAC THEN
      POP_ASSUM MP_TAC THEN
      POP_ASSUM (fun th -> REWRITE_TAC[SYM th]) THEN
      REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_MUL] THEN
      DISCH_TAC THEN
      MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
      ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
      REWRITE_TAC[REAL_ARITH `a / b * c / d = (a * c) / b / d`] THEN
      REWRITE_TAC[real_div] THEN
      REWRITE_TAC[REAL_MUL_ASSOC] THEN
      MATCH_MP_TAC REAL_LE_RMUL THEN
      REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN

      MP_TAC (SPECL [`n:num`; `e:num`; `min_exp`] NUM_EXP_SUB_lemma) THEN
      ASM_REWRITE_TAC[] THEN
      DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
      MATCH_MP_TAC REAL_LE_RMUL THEN
      ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] in
    prove(ff_hi, proof), prove(ff_lo, proof);;



let FLOAT_MUL_TT_hi, FLOAT_MUL_TT_lo =
  let tt_hi = `min_exp <= e /\ e - min_exp = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e
                     ==> float T n1 e1 * float T n2 e2 <= float F n r` in
  let tt_lo = `min_exp <= e /\ e - min_exp = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2
                     ==> float F n r <= float T n1 e1 * float T n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `--a * --b = a * b`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(tt_hi, proof), prove(tt_lo, proof);;



let FLOAT_MUL_FT_hi, FLOAT_MUL_FT_lo =
  let ft_hi = `min_exp <= e /\ e - min_exp = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2
                     ==> float F n1 e1 * float T n2 e2 <= float T n r` in
  let ft_lo = `min_exp <= e /\ e - min_exp = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e
                     ==> float T n r <= float F n1 e1 * float T n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `a * --b <= --c <=> c <= a * b`] THEN
      REWRITE_TAC[REAL_ARITH `--c <= a * --b <=> a * b <= c`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(ft_hi, proof), prove(ft_lo, proof);;



let FLOAT_MUL_TF_hi, FLOAT_MUL_TF_lo =
  let ft_hi = `min_exp <= e /\ e - min_exp = r /\ num_exp n e <= num_exp n1 e1 * num_exp n2 e2
                     ==> float T n1 e1 * float F n2 e2 <= float T n r` in
  let ft_lo = `min_exp <= e /\ e - min_exp = r /\ num_exp n1 e1 * num_exp n2 e2 <= num_exp n e
                     ==> float T n r <= float T n1 e1 * float F n2 e2` in
  let proof =
    REWRITE_TAC[FLOAT_NEG_T] THEN
      REWRITE_TAC[REAL_ARITH `--a * b <= --c <=> c <= a * b`] THEN
      REWRITE_TAC[REAL_ARITH `--c <= --a * b <=> a * b <= c`] THEN
      REWRITE_TAC[FLOAT_MUL_FF_hi; FLOAT_MUL_FF_lo] in
    prove(ft_hi, proof), prove(ft_lo, proof);;


(*********************************************)

(* float_mul_lo, float_mul_hi *)

let transform = UNDISCH_ALL o NUMERALS_TO_NUM o REWRITE_RULE[min_exp_def; GSYM IMP_IMP];;
let FLOAT_MUL_FF_hi' = transform FLOAT_MUL_FF_hi and
    FLOAT_MUL_FF_lo' = transform FLOAT_MUL_FF_lo and
    FLOAT_MUL_TT_hi' = transform FLOAT_MUL_TT_hi and
    FLOAT_MUL_TT_lo' = transform FLOAT_MUL_TT_lo and
    FLOAT_MUL_FT_hi' = transform FLOAT_MUL_FT_hi and
    FLOAT_MUL_FT_lo' = transform FLOAT_MUL_FT_lo and
    FLOAT_MUL_TF_hi' = transform FLOAT_MUL_TF_hi and
    FLOAT_MUL_TF_lo' = transform FLOAT_MUL_TF_lo;;



let float_mul_lo pp f1 f2 =
  let s1, n1, e1 = dest_float f1 and
      s2, n2, e2 = dest_float f2 in
  let flag = s1 = s2 in
  let num_exp1 = mk_num_exp n1 e1 and
      num_exp2 = mk_num_exp n2 e2 in

  let mul_th, n_tm, e_tm = 
    if flag then
      let th = num_exp_op_lo pp num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand (concl th)) in
	th, n_tm, e_tm
    else
      let th = num_exp_op_hi pp num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand (concl th)) in
	th, n_tm, e_tm in

  let sub_th, le_th = raw_sub_and_le_hash_conv e_tm min_exp_num_const in
    if (rand(concl le_th) <> e_tm) then
      failwith "float_mul_lo: underflow"
    else
      let r_tm = rand(concl sub_th) in
      let inst = INST[e_tm, e_var_num; r_tm, r_var_num; n_tm, n_var_num;
		      n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] in
      let th0 = inst
	(if flag then
	   if s1 = "F" then FLOAT_MUL_FF_lo' else FLOAT_MUL_TT_lo'
	 else
	   if s1 = "F" then FLOAT_MUL_FT_lo' else FLOAT_MUL_TF_lo') in
	MY_PROVE_HYP sub_th (MY_PROVE_HYP mul_th (MY_PROVE_HYP le_th th0));;





let float_mul_hi pp f1 f2 =
  let s1, n1, e1 = dest_float f1 and
      s2, n2, e2 = dest_float f2 in
  let flag = s1 = s2 in
  let num_exp1 = mk_num_exp n1 e1 and
      num_exp2 = mk_num_exp n2 e2 in

  let mul_th, n_tm, e_tm = 
    if flag then
      let th = num_exp_op_hi pp num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand (concl th)) in
	th, n_tm, e_tm
    else
      let th = num_exp_op_lo pp num_exp_mul num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand (concl th)) in
	th, n_tm, e_tm in

  let sub_th, le_th = raw_sub_and_le_hash_conv e_tm min_exp_num_const in
    if (rand(concl le_th) <> e_tm) then
      failwith "float_mul_hi: underflow"
    else
      let r_tm = rand(concl sub_th) in
      let inst = INST[e_tm, e_var_num; r_tm, r_var_num; n_tm, n_var_num;
		      n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] in
      let th0 = inst
	(if flag then
	   if s1 = "F" then FLOAT_MUL_FF_hi' else FLOAT_MUL_TT_hi'
	 else
	   if s1 = "F" then FLOAT_MUL_FT_hi' else FLOAT_MUL_TF_hi') in
	MY_PROVE_HYP sub_th (MY_PROVE_HYP mul_th (MY_PROVE_HYP le_th th0));;




(*********************************************)

(* FLOAT_DIV *)


let DIV_lemma = prove(`!x y. ~(y = 0) ==> &(x DIV y) <= &x / &y /\ &x / &y <= &(x DIV y + 1)`,
   REPEAT GEN_TAC THEN DISCH_TAC THEN
     MP_TAC (SPECL [`y:num`; `x:num`] FLOOR_DIV_DIV) THEN
     ASM_REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
     DISCH_THEN (fun th -> REWRITE_TAC[SYM th]) THEN
     SIMP_TAC[FLOOR; REAL_LT_IMP_LE]);;


let FLOAT_DIV_FF = prove(`e2 + k <= min_exp + e + e1 /\ ~(n2 = 0) /\
                           num_exp n1 k DIV num_exp n2 0 = num_exp n e
                             ==> float F n ((min_exp + e + e1) - (e2 + k)) <= float F n1 e1 / float F n2 e2`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 min_exp) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
         REWRITE_TAC[real_div] THEN
         REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
         REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
         REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
         REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN

         SUBGOAL_THEN (mk_comb(`(~)`, mk_eq(mk_binop `pow` (mk_comb (`&`, base_const)) `k:num`, `&0`))) ASSUME_TAC THENL
         [
           REWRITE_TAC[REAL_POW_EQ_0] THEN
             REAL_ARITH_TAC;
           ALL_TAC
         ] THEN

         ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
         REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
         REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
         ASM_REWRITE_TAC[EXP] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[]);;




let FLOAT_DIV_FF_lo = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\ r2 - r1 = r /\
                             r1 <= r2 /\ ~(n2 = 0) /\
                           num_exp n e <= num_exp n1 k DIV num_exp n2 0
                             ==> float F n r <= float F n1 e1 / float F n2 e2`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN
     REPLICATE_TAC 3 (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 min_exp) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
         REWRITE_TAC[real_div] THEN
         REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
         REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
         REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
         REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN
         SUBGOAL_THEN
         (mk_comb(`(~)`, mk_eq(mk_binop `pow` (mk_comb (`&`, base_const)) `k:num`, `&0`))) ASSUME_TAC THENL
         [
           REWRITE_TAC[REAL_POW_EQ_0] THEN
             REAL_ARITH_TAC;
           ALL_TAC
         ] THEN

         ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
         REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
         REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
         ASM_REWRITE_TAC[EXP] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     STRIP_TAC THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `&(x DIV y)` THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE]);;




let FLOAT_DIV_FF_hi = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\ r2 - r1 = r /\
                              r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n1 k DIV num_exp n2 0 < num_exp n e
                              ==> float F n1 e1 / float F n2 e2 <= float F n r`,
   MAP_EVERY ABBREV_TAC [`z = num_exp n e`; `x = num_exp n1 k`; `y = num_exp n2 0`] THEN
     REPEAT STRIP_TAC THEN
     REPLICATE_TAC 3 (POP_ASSUM MP_TAC) THEN
     REPLICATE_TAC 3 (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN
     REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[real_div; REAL_INV_MUL; REAL_INV_INV] THEN
     REWRITE_TAC[REAL_ARITH `(a * b) * c * d = (b * d) * (a * c)`] THEN
     SUBGOAL_THEN `~(&(num_exp 1 min_exp) = &0)` ASSUME_TAC THENL
     [
       REWRITE_TAC[num_exp; REAL_OF_NUM_EQ; MULT_CLAUSES; EXP_EQ_0] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN

     ASM_SIMP_TAC[NUM_EXP_SUB_lemma] THEN
     SUBGOAL_THEN `&(num_exp n1 e1) * inv(&(num_exp n2 e2)) = (&x / &y) * &(num_exp 1 e1) * inv(&(num_exp 1 (e2 + k)))` MP_TAC THENL
     [
       EXPAND_TAC "x" THEN EXPAND_TAC "y" THEN
         REWRITE_TAC[real_div] THEN
         REWRITE_TAC[num_exp; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW] THEN
         REWRITE_TAC[REAL_MUL_LID; REAL_INV_MUL; REAL_INV_1; real_pow; REAL_MUL_RID] THEN
         REWRITE_TAC[REAL_POW_ADD; REAL_INV_MUL] THEN
         REWRITE_TAC[REAL_ARITH `((a * b) * c) * d * e * f = (b * f) * (a * c * d * e)`] THEN
         SUBGOAL_THEN
         (mk_comb(`(~)`, mk_eq(mk_binop `pow` (mk_comb (`&`, base_const)) `k:num`, `&0`))) ASSUME_TAC THENL
         [
           REWRITE_TAC[REAL_POW_EQ_0] THEN
             REAL_ARITH_TAC;
           ALL_TAC
         ] THEN

         ASM_SIMP_TAC[REAL_MUL_RINV; REAL_MUL_LID] THEN
         REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     DISCH_THEN (fun th -> REWRITE_TAC[th]) THEN
     ONCE_REWRITE_TAC[REAL_ARITH `(a * b) * c = (a * c) * b`] THEN
     REWRITE_TAC[REAL_MUL_ASSOC] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     ONCE_REWRITE_TAC[NUM_EXP_SUM1] THEN
     REWRITE_TAC[NUM_EXP_SUM] THEN
     REWRITE_TAC[GSYM REAL_OF_NUM_MUL] THEN
     ASM_REWRITE_TAC[REAL_ARITH `(a * b * c) * d = (d * a) * b * c`] THEN
     ASM_SIMP_TAC[REAL_MUL_LINV; REAL_MUL_LID] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS] THEN
     MP_TAC (SPEC_ALL DIV_lemma) THEN
     ANTS_TAC THENL
     [
       EXPAND_TAC "y" THEN
         REWRITE_TAC[num_exp; MULT_EQ_0; DE_MORGAN_THM] THEN
         ASM_REWRITE_TAC[EXP] THEN
         ARITH_TAC;
       ALL_TAC
     ] THEN

     STRIP_TAC THEN
     MATCH_MP_TAC REAL_LE_TRANS THEN
     EXISTS_TAC `&(x DIV y + 1)` THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_LE] THEN
     UNDISCH_TAC `x DIV y < z` THEN
     ARITH_TAC);;



let FLOAT_DIV_TT_lo = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\ r2 - r1 = r /\
                              r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n e <= num_exp n1 k DIV num_exp n2 0
             ==> float F n r <= float T n1 e1 / float T n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;

let FLOAT_DIV_TT_hi = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n1 k DIV num_exp n2 0 < num_exp n e
             ==> float T n1 e1 / float T n2 e2 <= float F n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;


let FLOAT_DIV_FT_lo = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n1 k DIV num_exp n2 0 < num_exp n e
             ==> float T n r <= float F n1 e1 / float T n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a <= b * --c <=> b * c <= a`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;

let FLOAT_DIV_FT_hi = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n e <= num_exp n1 k DIV num_exp n2 0
             ==> float F n1 e1 / float T n2 e2 <= float T n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `a * --b <= --c <=> c <= a * b`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;


let FLOAT_DIV_TF_lo = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n1 k DIV num_exp n2 0 < num_exp n e
             ==> float T n r <= float T n1 e1 / float F n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a <= --b * c <=> b * c <= a`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_hi]);;

let FLOAT_DIV_TF_hi = prove(`e2 + k = r1 /\ min_exp + e + e1 = r2 /\
                              r2 - r1 = r /\ r1 <= r2 /\ ~(n2 = 0) /\
                              num_exp n e <= num_exp n1 k DIV num_exp n2 0
             ==> float T n1 e1 / float F n2 e2 <= float T n r`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a * b <= --c <=> c <= a * b`] THEN
     REWRITE_TAC[GSYM real_div] THEN
     REWRITE_TAC[FLOAT_DIV_FF_lo]);;


(******************************************)

(* float_div_lo, float_div_hi *)

let transform = UNDISCH_ALL o PURE_REWRITE_RULE[TAUT `~P <=> (P <=> F)`] o
  NUMERALS_TO_NUM o REWRITE_RULE[GSYM IMP_IMP; min_exp_def];;

let FLOAT_DIV_FF_hi' = transform FLOAT_DIV_FF_hi and
    FLOAT_DIV_FF_lo' = transform FLOAT_DIV_FF_lo and
    FLOAT_DIV_TT_hi' = transform FLOAT_DIV_TT_hi and
    FLOAT_DIV_TT_lo' = transform FLOAT_DIV_TT_lo and
    FLOAT_DIV_FT_hi' = transform FLOAT_DIV_FT_hi and
    FLOAT_DIV_FT_lo' = transform FLOAT_DIV_FT_lo and
    FLOAT_DIV_TF_hi' = transform FLOAT_DIV_TF_hi and
    FLOAT_DIV_TF_lo' = transform FLOAT_DIV_TF_lo;;



let float_div_lo pp f1 f2 =
  let s1, n1, e1 = dest_float f1 and
      s2, n2, e2 = dest_float f2 in
  let flag = s1 = s2 in

  let k_tm = rand (mk_small_numeral_array (2 * pp)) in
  let num_exp1 = mk_num_exp n1 k_tm and
      num_exp2 = mk_num_exp n2 zero_const in
  let div_th, n_tm, e_tm =
    if flag then
      let th = num_exp_op_lo pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand(concl th)) in
	th, n_tm, e_tm
    else
      let th = num_exp_op_hi_lt pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand(concl th)) in
	th, n_tm, e_tm in

  let r1_th = raw_add_conv_hash (mk_binop plus_op_num e2 k_tm) in
  let r1_tm = rand(concl r1_th) in
  let e_plus_e1 = raw_add_conv_hash (mk_binop plus_op_num e_tm e1) in
  let ltm, rtm = dest_comb(concl e_plus_e1) in
  let r2_th' = raw_add_conv_hash (mk_binop plus_op_num min_exp_num_const rtm) in
  let r2_th = TRANS (AP_TERM (mk_comb (plus_op_num, min_exp_num_const)) e_plus_e1) r2_th' in
  let r2_tm = rand(concl r2_th) in
  let sub_th, le_th = raw_sub_and_le_hash_conv r2_tm r1_tm in
    if rand(concl le_th) <> r2_tm then
      failwith "float_div_lo: underflow"
    else
      let r_tm = rand(concl sub_th) in
      let n2_not_zero = raw_eq0_hash_conv n2 in
      let inst = INST[r1_tm, r1_var_num; r2_tm, r2_var_num;
		      n1, n1_var_num; e1, e1_var_num;
		      e_tm, e_var_num; k_tm, k_var_num;
		      n2, n2_var_num; e2, e2_var_num;
		      n_tm, n_var_num; r_tm, r_var_num] in
      let th0 = inst
	(if flag then
	   if s1 = "F" then FLOAT_DIV_FF_lo' else FLOAT_DIV_TT_lo'
	 else
	   if s1 = "F" then FLOAT_DIV_FT_lo' else FLOAT_DIV_TF_lo') in
      let th1 = MY_PROVE_HYP n2_not_zero (MY_PROVE_HYP div_th (MY_PROVE_HYP le_th th0)) in
	MY_PROVE_HYP sub_th (MY_PROVE_HYP r2_th (MY_PROVE_HYP r1_th th1));;





let float_div_hi pp f1 f2 =
  let s1, n1, e1 = dest_float f1 and
      s2, n2, e2 = dest_float f2 in
  let flag = s1 = s2 in

  let k_tm = rand (mk_small_numeral_array (2 * pp)) in
  let num_exp1 = mk_num_exp n1 k_tm and
      num_exp2 = mk_num_exp n2 zero_const in
  let div_th, n_tm, e_tm =
    if flag then
      let th = num_exp_op_hi_lt pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (rand(concl th)) in
	th, n_tm, e_tm
    else
      let th = num_exp_op_lo pp num_exp_div num_exp1 num_exp2 in
      let n_tm, e_tm = dest_num_exp (lhand(concl th)) in
	th, n_tm, e_tm in

  let r1_th = raw_add_conv_hash (mk_binop plus_op_num e2 k_tm) in
  let r1_tm = rand(concl r1_th) in
  let e_plus_e1 = raw_add_conv_hash (mk_binop plus_op_num e_tm e1) in
  let ltm, rtm = dest_comb(concl e_plus_e1) in
  let r2_th' = raw_add_conv_hash (mk_binop plus_op_num min_exp_num_const rtm) in
  let r2_th = TRANS (AP_TERM (mk_comb (plus_op_num, min_exp_num_const)) e_plus_e1) r2_th' in
  let r2_tm = rand(concl r2_th) in
  let sub_th, le_th = raw_sub_and_le_hash_conv r2_tm r1_tm in
    if rand(concl le_th) <> r2_tm then
      failwith "float_div_hi: underflow"
    else
      let r_tm = rand(concl sub_th) in
      let n2_not_zero = raw_eq0_hash_conv n2 in
      let inst = INST[r1_tm, r1_var_num; r2_tm, r2_var_num;
		      n1, n1_var_num; e1, e1_var_num;
		      e_tm, e_var_num; k_tm, k_var_num;
		      n2, n2_var_num; e2, e2_var_num;
		      n_tm, n_var_num; r_tm, r_var_num] in
      let th0 = inst
	(if flag then
	   if s1 = "F" then FLOAT_DIV_FF_hi' else FLOAT_DIV_TT_hi'
	 else
	   if s1 = "F" then FLOAT_DIV_FT_hi' else FLOAT_DIV_TF_hi') in
      let th1 = MY_PROVE_HYP n2_not_zero (MY_PROVE_HYP div_th (MY_PROVE_HYP le_th th0)) in
	MY_PROVE_HYP sub_th (MY_PROVE_HYP r2_th (MY_PROVE_HYP r1_th th1));;





(*
float_div_lo 1 `float F (B1 _0) (B10 _0)` `float F (B3 _0) (B10 _0)`;;
float_div_hi 1 `float F (B1 _0) (B10 _0)` `float F (B3 _0) (B10 _0)`;;
float_div_hi 5 f1 f2;;
*)




(***********************************)


(* FLOAT_ADD *)

let FLOAT_ADD_FF = prove(`num_exp n1 e1 + num_exp n2 e2 = num_exp n e
    ==> float F n1 e1 + float F n2 e2 = float F n e`,
   REPEAT STRIP_TAC THEN
     REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     ASM_REWRITE_TAC[REAL_OF_NUM_ADD]);;


let FLOAT_ADD_TT = prove(`num_exp n1 e1 + num_exp n2 e2 = num_exp n e
    ==> float T n1 e1 + float T n2 e2 = float T n e`,
   REWRITE_TAC[FLOAT_NEG_T; REAL_ARITH `--a + --b = --c <=> a + b = c`] THEN
     REWRITE_TAC[FLOAT_ADD_FF]);;



let FLOAT_ADD_FF_lo = prove(`num_exp n e <= num_exp n1 e1 + num_exp n2 e2
                              ==> float F n e <= float F n1 e1 + float F n2 e2`,
   REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_ADD] THEN
     REPEAT STRIP_TAC THEN
     MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
     ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     REWRITE_TAC[real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS]);;





let FLOAT_ADD_FF_hi = prove(`num_exp n1 e1 + num_exp n2 e2 <= num_exp n e
                              ==> float F n1 e1 + float F n2 e2 <= float F n e`,
   REWRITE_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_ADD] THEN
     REPEAT STRIP_TAC THEN
     MAP_EVERY ABBREV_TAC [`z = &(num_exp n e)`; `x = &(num_exp n1 e1)`; `y = &(num_exp n2 e2)`] THEN
     ASM_REWRITE_TAC[float; REAL_MUL_LID] THEN
     REWRITE_TAC[REAL_ARITH `a / b + c / b = (a + c) / b`] THEN
     REWRITE_TAC[real_div] THEN
     MATCH_MP_TAC REAL_LE_RMUL THEN
     ASM_REWRITE_TAC[REAL_LE_INV_EQ; REAL_POS]);;



let FLOAT_ADD_TT_lo = prove(`num_exp n1 e1 + num_exp n2 e2 <= num_exp n e
			      ==> float T n e <= float T n1 e1 + float T n2 e2`,
   REWRITE_TAC[FLOAT_NEG_T; REAL_ARITH `--a <= --b + --c <=> b + c <= a`] THEN
     REWRITE_TAC[FLOAT_ADD_FF_hi]);;



let FLOAT_ADD_TT_hi = prove(`num_exp n e <= num_exp n1 e1 + num_exp n2 e2
			      ==> float T n1 e1 + float T n2 e2 <= float T n e`,
   REWRITE_TAC[FLOAT_NEG_T; REAL_ARITH `--b + --c <= --a <=> a <= b + c`] THEN
     REWRITE_TAC[FLOAT_ADD_FF_lo]);;



let FLOAT_ADD_FT_F_lo = prove(`num_exp n2 e2 <= num_exp n1 e1 ==>
				num_exp n e <= num_exp n1 e1 - num_exp n2 e2 
				==> float F n e <= float F n1 e1 + float T n2 e2`,
   MAP_EVERY ABBREV_TAC[`z = num_exp n e`; `x = num_exp n1 e1`; `y = num_exp n2 e2`] THEN
     ASM_REWRITE_TAC[FLOAT_NEG_T; float; REAL_MUL_LID] THEN
     DISCH_TAC THEN
     ASM_SIMP_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_SUB] THEN
     REWRITE_TAC[num_exp; min_exp_def; MULT_CLAUSES; GSYM REAL_OF_NUM_POW] THEN
     REAL_ARITH_TAC);;


let FLOAT_ADD_FT_T_lo = prove(`num_exp n1 e1 <= num_exp n2 e2 ==>
				num_exp n2 e2 - num_exp n1 e1 <= num_exp n e
				==> float T n e <= float F n1 e1 + float T n2 e2`,
   MAP_EVERY ABBREV_TAC[`z = num_exp n e`; `x = num_exp n1 e1`; `y = num_exp n2 e2`] THEN
     ASM_REWRITE_TAC[FLOAT_NEG_T; float; REAL_MUL_LID] THEN
     DISCH_TAC THEN
     ASM_SIMP_TAC[GSYM REAL_OF_NUM_LE; GSYM REAL_OF_NUM_SUB] THEN
     REWRITE_TAC[num_exp; min_exp_def; MULT_CLAUSES; GSYM REAL_OF_NUM_POW] THEN
     REAL_ARITH_TAC);;


let FLOAT_ADD_FT_F_hi = prove(`num_exp n2 e2 <= num_exp n1 e1 ==>
				num_exp n1 e1 - num_exp n2 e2 <= num_exp n e
				==> float F n1 e1 + float T n2 e2 <= float F n e`,
   REWRITE_TAC[FLOAT_NEG_T; REAL_ARITH `a + --b <= c <=> --c <= b + --a`] THEN
     REWRITE_TAC[GSYM FLOAT_NEG_T; FLOAT_ADD_FT_T_lo]);;


let FLOAT_ADD_FT_T_hi = prove(`num_exp n1 e1 <= num_exp n2 e2 ==>
				num_exp n e <= num_exp n2 e2 - num_exp n1 e1
				==> float F n1 e1 + float T n2 e2 <= float T n e`,
   REWRITE_TAC[FLOAT_NEG_T; REAL_ARITH `a + --b <= --c <=> c <= b + --a`] THEN
     REWRITE_TAC[GSYM FLOAT_NEG_T; FLOAT_ADD_FT_F_lo]);;
     



(******************************************)

(* float_add_lo, float_add_hi *)

let m_var_real = `m:real` and
    n_var_real = `n:real`;;

let REAL_ADD_COMM = CONJUNCT1 REAL_ADD_AC;;

let transform = UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o NUMERALS_TO_NUM;;
let FLOAT_ADD_FF_hi' = transform FLOAT_ADD_FF_hi and
    FLOAT_ADD_FF_lo' = transform FLOAT_ADD_FF_lo and
    FLOAT_ADD_TT_hi' = transform FLOAT_ADD_TT_hi and
    FLOAT_ADD_TT_lo' = transform FLOAT_ADD_TT_lo and
    FLOAT_ADD_FT_F_lo' = transform FLOAT_ADD_FT_F_lo and
    FLOAT_ADD_FT_T_lo' = transform FLOAT_ADD_FT_T_lo and
    FLOAT_ADD_FT_F_hi' = transform FLOAT_ADD_FT_F_hi and
    FLOAT_ADD_FT_T_hi' = transform FLOAT_ADD_FT_T_hi;;




let float_add_lo pp f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 = s2 then
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in

	if s1 = "F" then
	  (* F + F *)
	  let add_th = num_exp_op_lo pp num_exp_add num_exp1 num_exp2 in
	  let n_tm, e_tm = dest_num_exp (lhand(concl add_th)) in
	  let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_FF_lo' in
	    MY_PROVE_HYP add_th th0
	else
	  (* T + T *)
	  let add_th = num_exp_op_hi pp num_exp_add num_exp1 num_exp2 in
	  let n_tm, e_tm = dest_num_exp (rand(concl add_th)) in
	  let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_TT_lo' in
	    MY_PROVE_HYP add_th th0
    else
      (* F + T or T + F *)
      let th0, n1, e1, n2, e2 =
	if s1 = "T" then
	  INST[f2, m_var_real; f1, n_var_real] REAL_ADD_COMM, n2, e2, n1, e1
	else
	  REFL(mk_binop plus_op_real f1 f2), n1, e1, n2, e2 in

      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in

      let sub_th, le_th = num_exp_sub num_exp1 num_exp2 in
      let sub_tm = rand(concl sub_th) in

	if rand(concl le_th) = num_exp1 then
	  let lo_th = num_exp_lo pp sub_tm in
	  let n_tm, e_tm = dest_num_exp (lhand(concl lo_th)) in
	  let lo_sub_th = EQ_MP (AP_TERM (rator(concl lo_th)) (SYM sub_th)) lo_th in

	  let th1 = INST[n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num;
			 n_tm, n_var_num; e_tm, e_var_num] FLOAT_ADD_FT_F_lo' in
	  let th2 = MY_PROVE_HYP lo_sub_th (MY_PROVE_HYP le_th th1) in
	    EQ_MP (AP_TERM (rator(concl th2)) th0) th2

	else 
	  let hi_th = num_exp_hi pp sub_tm in
	  let n_tm, e_tm = dest_num_exp(rand(concl hi_th)) in
	  let hi_sub_th = EQ_MP (SYM (AP_THM (AP_TERM le_op_num sub_th) (rand(concl hi_th)))) hi_th in

	  let th1 = INST[n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num;
			 n_tm, n_var_num; e_tm, e_var_num] FLOAT_ADD_FT_T_lo' in
	  let th2 = MY_PROVE_HYP hi_sub_th (MY_PROVE_HYP le_th th1) in
	    EQ_MP (AP_TERM (rator(concl th2)) th0) th2;;






let float_add_hi pp f1 f2 =
  let s1, n1, e1 = dest_float f1 in
  let s2, n2, e2 = dest_float f2 in
    if s1 = s2 then
      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in

	if s1 = "F" then
	  (* F + F *)
	  let add_th = num_exp_op_hi pp num_exp_add num_exp1 num_exp2 in
	  let n_tm, e_tm = dest_num_exp (rand(concl add_th)) in
	  let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_FF_hi' in
	    MY_PROVE_HYP add_th th0
	else
	  (* T + T *)
	  let add_th = num_exp_op_lo pp num_exp_add num_exp1 num_exp2 in
	  let n_tm, e_tm = dest_num_exp (lhand(concl add_th)) in
	  let th0 = INST[e_tm, e_var_num; n_tm, n_var_num; n1, n1_var_num;
			 e1, e1_var_num; n2, n2_var_num; e2, e2_var_num] FLOAT_ADD_TT_hi' in
	    MY_PROVE_HYP add_th th0
    else
      (* F + T or T + F *)
      let th0, n1, e1, n2, e2 =
	if s1 = "T" then
	  INST[f2, m_var_real; f1, n_var_real] REAL_ADD_COMM, n2, e2, n1, e1
	else
	  REFL(mk_binop plus_op_real f1 f2), n1, e1, n2, e2 in

      let num_exp1 = mk_num_exp n1 e1 in
      let num_exp2 = mk_num_exp n2 e2 in

      let sub_th, le_th = num_exp_sub num_exp1 num_exp2 in
      let sub_tm = rand(concl sub_th) in

	if rand(concl le_th) = num_exp1 then
	  let hi_th = num_exp_hi pp sub_tm in
	  let n_tm, e_tm = dest_num_exp (rand(concl hi_th)) in
	  let hi_sub_th = EQ_MP (SYM (AP_THM (AP_TERM le_op_num sub_th) (rand(concl hi_th)))) hi_th in

	  let th1 = INST[n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num;
			 n_tm, n_var_num; e_tm, e_var_num] FLOAT_ADD_FT_F_hi' in
	  let th2 = MY_PROVE_HYP hi_sub_th (MY_PROVE_HYP le_th th1) in
	    EQ_MP (AP_THM (AP_TERM le_op_real th0) (rand(concl th2))) th2

	else 
	  let lo_th = num_exp_lo pp sub_tm in
	  let n_tm, e_tm = dest_num_exp(lhand(concl lo_th)) in
	  let lo_sub_th = EQ_MP (AP_TERM (rator(concl lo_th)) (SYM sub_th)) lo_th in

	  let th1 = INST[n1, n1_var_num; e1, e1_var_num; n2, n2_var_num; e2, e2_var_num;
			 n_tm, n_var_num; e_tm, e_var_num] FLOAT_ADD_FT_T_hi' in
	  let th2 = MY_PROVE_HYP lo_sub_th (MY_PROVE_HYP le_th th1) in
	    EQ_MP (AP_THM (AP_TERM le_op_real th0) (rand(concl th2))) th2;;



(*
float_add_lo 1 f1 f2;;
float_add_hi 1 f1 f2;;
*)



(******************************************)

(* float_sub_lo, float_sub_hi *)


let s1_var_bool = `s1:bool` and
    f1_var_real = `f1:real` and
    f2_var_real = `f2:real`;;


let FLOAT_SUB_F_EQ_ADD = (SYM o prove)(`f1 - float F n2 e2 = f1 + float T n2 e2`,
				       REWRITE_TAC[FLOAT_NEG_T] THEN REAL_ARITH_TAC);;

let FLOAT_SUB_T_EQ_ADD = (SYM o prove)(`f1- float T n2 e2 = f1+ float F n2 e2`,
				       REWRITE_TAC[FLOAT_NEG_T] THEN REAL_ARITH_TAC);;



let float_sub_lo pp f1 f2 =
  let s2, n2, e2 = dest_float f2 in
  let th0 =
    INST[f1, f1_var_real; n2, n2_var_num; e2, e2_var_num] 
      (if s2 = "F" then FLOAT_SUB_F_EQ_ADD else FLOAT_SUB_T_EQ_ADD) in
  let ltm,f2_tm = dest_comb(lhand(concl th0)) in
  let f1_tm = rand ltm in
  let lo_th = float_add_lo pp f1_tm f2_tm in
    EQ_MP (AP_TERM (rator(concl lo_th)) th0) lo_th;;



let float_sub_hi pp f1 f2 =
  let s2, n2, e2 = dest_float f2 in
  let th0 =
    INST[f1, f1_var_real; n2, n2_var_num; e2, e2_var_num]
      (if s2 = "F" then FLOAT_SUB_F_EQ_ADD else FLOAT_SUB_T_EQ_ADD) in
  let ltm, f2_tm = dest_comb(lhand(concl th0)) in
  let f1_tm = rand ltm in
  let hi_th = float_add_hi pp f1_tm f2_tm in
    EQ_MP (AP_THM (AP_TERM le_op_real th0) (rand(concl hi_th))) hi_th;;




(*
let f1 = `float F (D5 (D2 _0)) (D0 (D1 _0))`;;
let f2 = `float F (D3 (D2 _0)) (D9 _0)`;;
float_sub_hi 1 f2 f1;;
*)



(******************************************)

(* float intervals *)

let FLOAT_OF_NUM' = (SPEC_ALL o REWRITE_RULE[min_exp_def]) FLOAT_OF_NUM;;

let FLOAT_INTERVAL_OF_NUM = (NUMERALS_TO_NUM o REWRITE_RULE[min_exp_def] o prove)(`interval_arith (&n) (float F n min_exp, float F n min_exp)`,
   REWRITE_TAC[FLOAT_OF_NUM; CONST_INTERVAL]);;

let FLOAT_F_bound' = (UNDISCH_ALL o SPEC_ALL) FLOAT_F_bound;;

let FLOAT_T_bound' = (UNDISCH_ALL o SPEC_ALL) FLOAT_T_bound;;






(* interval_arith x (float s1 n1 e1, float s2 n2 e2) -> x, float s1 n1 e1, float s2 n2 e2 *)
let dest_float_interval tm =
  let ltm, rtm = dest_comb tm in
  let f1, f2 = dest_pair rtm in
    rand ltm, f1, f2;;




let mk_float_interval_small_num n =
  let n_tm0 = mk_small_numeral n in
  let n_th = NUMERAL_TO_NUM_CONV n_tm0 in
  let n_tm = rand(rand(concl n_th)) in
  let n_th1 = TRANS n_th (INST[n_tm, n_var_num] NUM_REMOVE) in
  let th1 = AP_TERM amp_op_real n_th1 in
  let int_th = INST[n_tm, n_var_num] FLOAT_INTERVAL_OF_NUM in
  let rtm = rand(concl int_th) in
    EQ_MP (SYM (AP_THM (AP_TERM interval_const th1) rtm)) int_th;;


let mk_float_interval_num n =
  let n_tm0 = mk_numeral n in
  let n_th = NUMERAL_TO_NUM_CONV n_tm0 in
  let n_tm = rand(rand(concl n_th)) in
  let n_th1 = TRANS n_th (INST[n_tm, n_var_num] NUM_REMOVE) in
  let th1 = AP_TERM amp_op_real n_th1 in
  let int_th = INST[n_tm, n_var_num] FLOAT_INTERVAL_OF_NUM in
  let rtm = rand(concl int_th) in
    EQ_MP (SYM (AP_THM (AP_TERM interval_const th1) rtm)) int_th;;






(* Returns the lower bound for the given float *)
let float_lo p tm =
  let s, n_tm, e_tm = dest_float tm in
    if s = "F" then
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_lo p num_exp_tm in
      let ltm, e1_tm = dest_comb(lhand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num; n_tm, n2_var_num; e_tm, e2_var_num] FLOAT_F_bound' in
        MY_PROVE_HYP th0 th1
    else
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_hi p num_exp_tm in
      let ltm, e1_tm = dest_comb(rand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n_tm, n1_var_num; e_tm, e1_var_num; n1_tm, n2_var_num; e1_tm, e2_var_num] FLOAT_T_bound' in
        MY_PROVE_HYP th0 th1;;



(* Returns the upper bound for the given float *)
let float_hi p tm =
  let s, n_tm, e_tm = dest_float tm in
    if s = "F" then
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_hi p num_exp_tm in
      let ltm, e2_tm = dest_comb(rand(concl th0)) in
      let n2_tm = rand ltm in
      let th1 = INST[n_tm, n1_var_num; e_tm, e1_var_num; n2_tm, n2_var_num; e2_tm, e2_var_num] FLOAT_F_bound' in
        MY_PROVE_HYP th0 th1
    else
      let num_exp_tm = mk_num_exp n_tm e_tm in
      let th0 = num_exp_lo p num_exp_tm in
      let ltm, e1_tm = dest_comb(lhand(concl th0)) in
      let n1_tm = rand ltm in
      let th1 = INST[n1_tm, n1_var_num; e1_tm, e1_var_num; n_tm, n2_var_num; e_tm, e2_var_num] FLOAT_T_bound' in
        MY_PROVE_HYP th0 th1;;






(* Approximates the given interval with p-digit float numbers *)
let float_interval_round p th =
  let x_tm, f1, f2 = dest_float_interval (concl th) in
  let lo_th = float_lo p f1 in
  let hi_th = float_hi p f2 in
  let lo_tm = lhand(concl lo_th) in
  let hi_tm = rand(concl hi_th) in
  let th0 = INST[x_tm, x_var_real; f1, lo_var_real; f2, hi_var_real; lo_tm, a_var_real; hi_tm, b_var_real] APPROX_INTERVAL' in
    MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th th0));;




(*
let th = mk_float_interval_num 124235353;;
float_interval_round 5 th;;
(* 4: 0.240 *)
test 1000 (float_interval_round 5) th;;
*)



(****************************************)

(* float_interval_neg *)


let FLOAT_INTERVAL_NEG = prove(`!s1 s2. interval_arith x (float s1 n1 e1, float s2 n2 e2)
                                 ==> interval_arith (--x) (float (~s2) n2 e2, float (~s1) n1 e1)`,
   REPEAT GEN_TAC THEN
     DISCH_THEN (fun th -> MP_TAC (MATCH_MP INTERVAL_NEG th)) THEN
     SIMP_TAC[FLOAT_NEG]);;


let FLOAT_INTERVAL_NEG_FF = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`F`; `F`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_FT = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`F`; `T`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_TF = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`T`; `F`]) FLOAT_INTERVAL_NEG;;
let FLOAT_INTERVAL_NEG_TT = (UNDISCH_ALL o REWRITE_RULE[] o SPECL[`T`; `T`]) FLOAT_INTERVAL_NEG;;





(* |- interval x (float s1 n1 e1, float s2 n2 e2) ->
   |- interval (--x) (float ~s2 n2 e2, float ~s1 n1 e1 *)
let float_interval_neg th =
  let x_tm, f1, f2 = dest_float_interval (concl th) in
  let s1, n1_tm, e1_tm = dest_float f1 in
  let s2, n2_tm, e2_tm = dest_float f2 in
  let inst = INST[x_tm, x_var_real; n1_tm, n1_var_num; e1_tm, e1_var_num;
                  n2_tm, n2_var_num; e2_tm, e2_var_num] in
  let th0 =
    if s1 = "F" then
      if s2 = "F" then
        inst FLOAT_INTERVAL_NEG_FF
      else
        inst FLOAT_INTERVAL_NEG_FT
    else
      if s2 = "F" then
        inst FLOAT_INTERVAL_NEG_TF
      else
        inst FLOAT_INTERVAL_NEG_TT in
    MY_PROVE_HYP th th0;;



(***********************************************)

(* float_interval_mul *)


let f1_var_real = `f1:real` and
    f2_var_real = `f2:real`;;


let FLOAT_INTERVAL_MUL_FF_FF = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    f1 <= float F n1 e1 * float F m1 r1 /\
    float F n2 e2 * float F m2 r2 <= f2
    ==> interval_arith (x * y) (f1, f2)`,
   MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
     SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
     [
       MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
         REWRITE_TAC[FLOAT_F_POS];
       ALL_TAC
     ] THEN
     REPEAT (POP_ASSUM (fun th -> ALL_TAC)) THEN
     REWRITE_TAC[interval_arith] THEN
     REPEAT STRIP_TAC THENL
     [
       MATCH_MP_TAC REAL_LE_TRANS THEN
         EXISTS_TAC `a * c:real` THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC REAL_LE_MUL2 THEN
         ASM_REWRITE_TAC[];
       MATCH_MP_TAC REAL_LE_TRANS THEN
         EXISTS_TAC `b * d:real` THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC REAL_LE_MUL2 THEN
         ASM_REWRITE_TAC[] THEN
         CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL
         [
           EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[];
           EXISTS_TAC `c:real` THEN ASM_REWRITE_TAC[]
         ]
     ]);;




let FLOAT_INTERVAL_MUL_TT_TT = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (float T n1 e1, float T n2 e2) /\
    interval_arith y (float T m1 r1, float T m2 r2) /\
    f1 <= float T n2 e2 * float T m2 r2 /\
    float T n1 e1 * float T m1 r1 <= f2
    ==> interval_arith (x * y) (f1, f2)`,
  REWRITE_TAC[FLOAT_NEG_T] THEN
    REWRITE_TAC[interval_arith] THEN
    MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
    SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
    [
      MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
	REWRITE_TAC[FLOAT_F_POS];
      ALL_TAC
    ] THEN
    REWRITE_TAC[REAL_NEG_MUL2] THEN
    REPEAT STRIP_TAC THENL
    [
      MATCH_MP_TAC REAL_LE_TRANS THEN
	EXISTS_TAC `b * d:real` THEN
	ASM_REWRITE_TAC[] THEN
	ONCE_REWRITE_TAC[REAL_ARITH `a <= x * y <=> a <= --x * --y`] THEN
	MATCH_MP_TAC REAL_LE_MUL2 THEN
	ONCE_REWRITE_TAC[REAL_ARITH `b <= --x <=> x <= --b`] THEN
	ASM_REWRITE_TAC[];
      MATCH_MP_TAC REAL_LE_TRANS THEN
	EXISTS_TAC `a * c:real` THEN
	ASM_REWRITE_TAC[] THEN
	ONCE_REWRITE_TAC[REAL_ARITH `x * y <= a <=> --x * --y <= a`] THEN
	MATCH_MP_TAC REAL_LE_MUL2 THEN
	ONCE_REWRITE_TAC[REAL_ARITH `--x <= c <=> --c <= x`] THEN
	ASM_REWRITE_TAC[] THEN
	ASSUME_TAC (REAL_ARITH `!b x. &0 <= b /\ x <= --b ==> &0 <= --x`) THEN
	CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THENL
	[
	  EXISTS_TAC `b:real` THEN ASM_REWRITE_TAC[];
	  EXISTS_TAC `d:real` THEN ASM_REWRITE_TAC[]
	]
    ]);;




let FLOAT_INTERVAL_MUL_FF_TT = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float T m1 r1, float T m2 r2) /\
    f1 <= float F n2 e2 * float T m1 r1 /\
    float F n1 e1 * float T m2 r2 <= f2
    ==> interval_arith (x * y) (f1, f2)`,
  REWRITE_TAC[FLOAT_NEG_T] THEN
    REWRITE_TAC[interval_arith] THEN
    MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
    SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
    [
      MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
	REWRITE_TAC[FLOAT_F_POS];
      ALL_TAC
    ] THEN

    REPEAT STRIP_TAC THENL
    [
      MATCH_MP_TAC REAL_LE_TRANS THEN
	EXISTS_TAC `b * --c` THEN
	ASM_REWRITE_TAC[] THEN
	ONCE_REWRITE_TAC[REAL_ARITH `b * --c <= x * y <=> x * --y <= b * c`] THEN
	MATCH_MP_TAC REAL_LE_MUL2 THEN
	ONCE_REWRITE_TAC[REAL_ARITH `--y <= c <=> --c <= y`] THEN
	ASM_REWRITE_TAC[] THEN
	CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL
	[
	  EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[];
	  EXISTS_TAC `d:real` THEN
	    ONCE_REWRITE_TAC[REAL_ARITH `d <= --y <=> y <= --d`] THEN
	    ASM_REWRITE_TAC[]
	];

      MATCH_MP_TAC REAL_LE_TRANS THEN
	EXISTS_TAC `a * --d` THEN
	ASM_REWRITE_TAC[] THEN
	ONCE_REWRITE_TAC[REAL_ARITH `x * y <= a * --d <=> a * d <= x * --y`] THEN
	MATCH_MP_TAC REAL_LE_MUL2 THEN
	ONCE_REWRITE_TAC[REAL_ARITH `d <= --y <=> y <= --d`] THEN
	ASM_REWRITE_TAC[]
    ]);;



let FLOAT_INTERVAL_MUL_TT_FF = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (float T n1 e1, float T n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    f1 <= float T n1 e1 * float F m2 r2 /\
    float T n2 e2 * float F m1 r1 <= f2
    ==> interval_arith (x * y) (f1, f2)`,
   STRIP_TAC THEN
     MP_TAC ((GEN_ALL o DISCH_ALL) FLOAT_INTERVAL_MUL_FF_TT) THEN
     DISCH_THEN (MP_TAC o SPECL[`n1:num`; `e1:num`; `n2:num`; `e2:num`; `m1:num`; `r1:num`; `m2:num`; `r2:num`]) THEN
     DISCH_THEN (MP_TAC o SPECL[`y:real`; `x:real`; `f1:real`; `f2:real`]) THEN
     REPEAT (POP_ASSUM MP_TAC) THEN
     SIMP_TAC[REAL_MUL_AC]);;




let float_interval_mul pp th1 th2 =
  let x, l_lo, l_hi = dest_float_interval (concl th1) and
      y, r_lo, r_hi = dest_float_interval (concl th2) in
  let s1, n1, e1 = dest_float l_lo and
      s2, n2, e2 = dest_float l_hi and
      s3, m1, r1 = dest_float r_lo and
      s4, m2, r2 = dest_float r_hi in

    if s1 <> s2 or s3 <> s4 then
      failwith "float_interval_mul: not implemented"
    else
      let lo_th, hi_th, th0 =
	if s1 = "F" then
	  if s3 = "F" then
	    float_mul_lo pp l_lo r_lo, float_mul_hi pp l_hi r_hi, FLOAT_INTERVAL_MUL_FF_FF
	  else
	    float_mul_lo pp l_hi r_lo, float_mul_hi pp l_lo r_hi, FLOAT_INTERVAL_MUL_FF_TT
	else
	  if s3 = "F" then
	    float_mul_lo pp l_lo r_hi, float_mul_hi pp l_hi r_lo, FLOAT_INTERVAL_MUL_TT_FF
	  else
	    float_mul_lo pp l_hi r_hi, float_mul_hi pp l_lo r_lo, FLOAT_INTERVAL_MUL_TT_TT in

      let f1_tm = lhand(concl lo_th) and
	  f2_tm = rand(concl hi_th) in

      let th = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
		    y, y_var_real; n2, n2_var_num; e2, e2_var_num;
		    m1, m1_var_num; r1, r1_var_num;
		    m2, m2_var_num; r2, r2_var_num;
		    f1_tm, f1_var_real; f2_tm, f2_var_real] th0 in
	MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th1 (MY_PROVE_HYP th2 th)));;



(*
let th1 = mk_float_interval_small_num 135;;
let th2 = mk_float_interval_small_num 34;;
let th1' = float_interval_neg th1;;
let th2' = float_interval_neg th2;;

float_interval_mul 2 th1 th2;;
float_interval_mul 2 th1 th2';;
float_interval_mul 2 th1' th2;;
float_interval_mul 2 th1' th2';;
*)


(*
let th1 = mk_float_interval_small_num 123456781;;
let th2 = mk_float_interval_small_num 514553443;;
(* 4: 0.340 *)
test 100 (float_interval_mul 5 th1) th2;;
(* 4: 0.368 *)
test 100 (float_interval_mul 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514553443;;
let tm = mk_binop mul_op_num tm1 tm2;;

(* 4: 0.148 *)
test 100 NUM_MULT_HASH_CONV tm;;


let th1' = float_interval_round 5 th1;;
let th2' = float_interval_round 5 th2;;

(* 4: 0.176 *)
test 100 (float_interval_mul 5 th1') th2';;
*)


(*************************************)

(* float_interval_div *)

let FLOAT_INTERVAL_DIV_FF_FF = prove(
  `~(m1 = 0) /\
    interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    f1 <= float F n1 e1 / float F m2 r2 /\
    float F n2 e2 / float F m1 r1 <= f2
    ==> interval_arith (x / y) (f1, f2)`,
   MAP_EVERY ABBREV_TAC [`a = float F n1 e1`; `b = float F n2 e2`; `c = float F m1 r1`; `d = float F m2 r2`] THEN
     REWRITE_TAC[real_div] THEN
     STRIP_TAC THEN
     SUBGOAL_THEN `&0 <= a /\ &0 <= b /\ &0 <= c /\ &0 <= d` MP_TAC THENL
     [
       MAP_EVERY EXPAND_TAC ["a"; "b"; "c"; "d"] THEN
         REWRITE_TAC[FLOAT_F_POS];
       ALL_TAC
     ] THEN
     SUBGOAL_THEN `~(c = &0)` ASSUME_TAC THENL
     [
       EXPAND_TAC "c" THEN ASM_REWRITE_TAC[FLOAT_EQ_0];
       ALL_TAC
     ] THEN
     STRIP_TAC THEN
     SUBGOAL_THEN `~(d = &0)` MP_TAC THENL
     [
       MATCH_MP_TAC (REAL_ARITH `~(c = &0) /\ &0 <= c /\ c <= d ==> ~(d = &0)`) THEN
	 ASM_REWRITE_TAC[] THEN
	 UNDISCH_TAC `interval_arith y (c,d)` THEN
	 REWRITE_TAC[interval_arith] THEN
	 REAL_ARITH_TAC;
       ALL_TAC
     ] THEN

     REPLICATE_TAC 10 (POP_ASSUM MP_TAC) THEN
     REPEAT (POP_ASSUM (fun th -> ALL_TAC)) THEN
     REWRITE_TAC[interval_arith] THEN
     REPEAT STRIP_TAC THENL
     [
       MATCH_MP_TAC REAL_LE_TRANS THEN
         EXISTS_TAC `a * inv d` THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC REAL_LE_MUL2 THEN
         ASM_REWRITE_TAC[REAL_LE_INV_EQ] THEN
         MATCH_MP_TAC REAL_LE_INV2 THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC REAL_LTE_TRANS THEN
         EXISTS_TAC `c:real` THEN
         ASM_REWRITE_TAC[REAL_ARITH `&0 < c <=> ~(c = &0) /\ &0 <= c`];

       MATCH_MP_TAC REAL_LE_TRANS THEN
         EXISTS_TAC `b * inv c` THEN
         ASM_REWRITE_TAC[] THEN
         MATCH_MP_TAC REAL_LE_MUL2 THEN
         ASM_REWRITE_TAC[REAL_LE_INV_EQ] THEN
         REPEAT CONJ_TAC THENL
         [
           MATCH_MP_TAC REAL_LE_TRANS THEN
             EXISTS_TAC `a:real` THEN ASM_REWRITE_TAC[];
           MATCH_MP_TAC REAL_LE_TRANS THEN
             EXISTS_TAC `c:real` THEN ASM_REWRITE_TAC[];
           ALL_TAC
         ] THEN
         MATCH_MP_TAC REAL_LE_INV2 THEN
         ASM_REWRITE_TAC[REAL_ARITH `&0 < c <=> ~(c = &0) /\ &0 <= c`]
     ]);;



let FLOAT_INTERVAL_DIV_TT_TT = prove(
  `~(m2 = 0) /\
    interval_arith x (float T n1 e1, float T n2 e2) /\
    interval_arith y (float T m1 r1, float T m2 r2) /\
    f1 <= float T n2 e2 / float T m1 r1 /\
    float T n1 e1 / float T m2 r2 <= f2
    ==> interval_arith (x / y) (f1,f2)`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[interval_arith] THEN
     REWRITE_TAC[REAL_ARITH `--a <= x /\ x <= --b <=> b <= --x /\ --x <= a`] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[GSYM interval_arith] THEN
     STRIP_TAC THEN
     MP_TAC ((SPECL[`n2:num`; `e2:num`; `m1:num`; `r1:num`; `n1:num`; `e1:num`; `m2:num`; `r2:num`; `--x`; `--y`] o GEN_ALL) FLOAT_INTERVAL_DIV_FF_FF) THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; REAL_NEG_MUL2] THEN
     DISCH_THEN MATCH_MP_TAC THEN
     ASM_REWRITE_TAC[]);;     



let FLOAT_INTERVAL_DIV_FF_TT = prove(
  `~(m2 = 0) /\
    interval_arith x (float F n1 e1, float F n2 e2) /\
    interval_arith y (float T m1 r1, float T m2 r2) /\
    f1 <= float F n2 e2 / float T m2 r2 /\
    float F n1 e1 / float T m1 r1 <= f2
    ==> interval_arith (x / y) (f1,f2)`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `a * --b <= c <=> --c <= a * b`] THEN
     REWRITE_TAC[REAL_ARITH `c <= a * --b <=> a * b <= --c`] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[interval_arith] THEN
     REWRITE_TAC[REAL_ARITH `--a <= x /\ x <= --b <=> b <= --x /\ --x <= a`] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[GSYM interval_arith] THEN
     STRIP_TAC THEN
     MP_TAC ((SPECL[`n1:num`; `e1:num`; `m1:num`; `r1:num`; `n2:num`; `e2:num`; `m2:num`; `r2:num`; `x:real`; `--y`; `--f2`; `--f1`] o GEN_ALL) FLOAT_INTERVAL_DIV_FF_FF) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[real_div];
       ALL_TAC
     ] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; interval_arith] THEN
     REAL_ARITH_TAC);;



let FLOAT_INTERVAL_DIV_TT_FF = prove(
  `~(m1 = 0) /\
    interval_arith x (float T n1 e1, float T n2 e2) /\
    interval_arith y (float F m1 r1, float F m2 r2) /\
    f1 <= float T n1 e1 / float F m1 r1 /\
    float T n2 e2 / float F m2 r2 <= f2
    ==> interval_arith (x / y) (f1,f2)`,
   REWRITE_TAC[FLOAT_NEG_T] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG] THEN
     REWRITE_TAC[REAL_ARITH `--a * b <= c <=> --c <= a * b`] THEN
     REWRITE_TAC[REAL_ARITH `c <= --a * b <=> a * b <= --c`] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[interval_arith] THEN
     REWRITE_TAC[REAL_ARITH `--a <= x /\ x <= --b <=> b <= --x /\ --x <= a`] THEN
     GEN_REWRITE_TAC (LAND_CONV o DEPTH_CONV)[GSYM interval_arith] THEN
     STRIP_TAC THEN
     MP_TAC ((SPECL[`n2:num`; `e2:num`; `m2:num`; `r2:num`; `n1:num`; `e1:num`; `m1:num`; `r1:num`; `--x:real`; `y:real`; `--f2`; `--f1`] o GEN_ALL) FLOAT_INTERVAL_DIV_FF_FF) THEN
     ANTS_TAC THENL
     [
       ASM_REWRITE_TAC[real_div];
       ALL_TAC
     ] THEN
     REWRITE_TAC[real_div; REAL_INV_NEG; interval_arith] THEN
     REAL_ARITH_TAC);;





let transform = UNDISCH_ALL o
  PURE_REWRITE_RULE[TAUT `~P <=> (P <=> F)`] o
  REWRITE_RULE[GSYM IMP_IMP] o
  NUMERALS_TO_NUM;;


let FLOAT_INTERVAL_DIV_FF_FF' = transform FLOAT_INTERVAL_DIV_FF_FF and
    FLOAT_INTERVAL_DIV_TT_TT' = transform FLOAT_INTERVAL_DIV_TT_TT and
    FLOAT_INTERVAL_DIV_FF_TT' = transform FLOAT_INTERVAL_DIV_FF_TT and
    FLOAT_INTERVAL_DIV_TT_FF' = transform FLOAT_INTERVAL_DIV_TT_FF;;



let float_interval_div pp th1 th2 =
  let x, l_lo, l_hi = dest_float_interval (concl th1) and
      y, r_lo, r_hi = dest_float_interval (concl th2) in
  let s1, n1, e1 = dest_float l_lo and
      s2, n2, e2 = dest_float l_hi and
      s3, m1, r1 = dest_float r_lo and
      s4, m2, r2 = dest_float r_hi in

    if s1 <> s2 or s3 <> s4 then
      failwith "float_interval_mul: not implemented"
    else
      let lo_th, hi_th, th0, zero_th =
	if s1 = "F" then
	  if s3 = "F" then
	    float_div_lo pp l_lo r_hi, float_div_hi pp l_hi r_lo, 
	FLOAT_INTERVAL_DIV_FF_FF', raw_eq0_hash_conv m1
	  else
	    float_div_lo pp l_hi r_hi, float_div_hi pp l_lo r_lo, 
	FLOAT_INTERVAL_DIV_FF_TT', raw_eq0_hash_conv m2
	else
	  if s3 = "F" then
	    float_div_lo pp l_lo r_lo, float_div_hi pp l_hi r_hi, 
	FLOAT_INTERVAL_DIV_TT_FF', raw_eq0_hash_conv m1
	  else
	    float_div_lo pp l_hi r_lo, float_div_hi pp l_lo r_hi, 
	FLOAT_INTERVAL_DIV_TT_TT', raw_eq0_hash_conv m2 in

      let f1_tm = lhand(concl lo_th) and
	  f2_tm = rand(concl hi_th) in

      let th = INST[x, x_var_real; n1, n1_var_num; e1, e1_var_num;
		    y, y_var_real; n2, n2_var_num; e2, e2_var_num;
		    m1, m1_var_num; r1, r1_var_num;
		    m2, m2_var_num; r2, r2_var_num;
		    f1_tm, f1_var_real; f2_tm, f2_var_real] th0 in
	MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th1 (MY_PROVE_HYP th2 (MY_PROVE_HYP zero_th th))));;





(*
let th1 = mk_float_interval_small_num 123456781;;
let th2 = mk_float_interval_small_num 514;;
let th1' = float_interval_neg th1;;
let th2' = float_interval_neg th2;;
float_interval_div 5 th1 th2;;
float_interval_div 5 th1' th2;;
float_interval_div 5 th1 th2';;
float_interval_div 5 th1' th2';;
float_interval_div 1 th1 th2;;
(* 4: 0.392 *)
test 100 (float_interval_div 5 th1) th2;;
(* 4: 0.224 *)
test 100 (float_interval_div 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514;;
let tm = mk_binop `DIV` tm1 tm2;;

(* 4: 0.056 *)
test 100 NUM_DIV_HASH_CONV tm;;
NUM_DIV_HASH_CONV tm;;


let th1' = float_interval_round 3 th1;;
let th2' = float_interval_round 3 th2;;

(* 4: 0.256 *)
test 100 (float_interval_div 3 th1') th2';;




let th1 = mk_float_interval_num 1;;
let th2 = mk_float_interval_num 17;;

float_interval_div 5 th1 th2;;
*)



(*****************************************)

(* float_interval_add, float_interval_sub *)

let n1_var_real = `n1:real` and
    n2_var_real = `n2:real` and
    m1_var_real = `m1:real` and
    m2_var_real = `m2:real` and
    n_var_real = `n:real` and
    m_var_real = `m:real`;;


let INTERVAL_ADD = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (n1, m1) /\
    interval_arith y (n2, m2) /\
    n <= n1 + n2 /\ m1 + m2 <= m
    ==> interval_arith (x + y) (n, m)`,
   REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;



let INTERVAL_SUB = (UNDISCH_ALL o REWRITE_RULE[GSYM IMP_IMP] o prove)(
  `interval_arith x (n1, m1) /\
    interval_arith y (n2, m2) /\
    n <= n1 - m2 /\ m1 - n2 <= m
    ==> interval_arith (x - y) (n, m)`,
  REWRITE_TAC[interval_arith] THEN REAL_ARITH_TAC);;




let float_interval_add pp th1 th2 =
  let x, n1, m1 = dest_float_interval (concl th1) in
  let y, n2, m2 = dest_float_interval (concl th2) in
  let lo_th = float_add_lo pp n1 n2 in
  let hi_th = float_add_hi pp m1 m2 in
  let n_tm = lhand (concl lo_th) in
  let m_tm = rand (concl hi_th) in
  let th0 = INST[x, x_var_real; n1, n1_var_real; m1, m1_var_real;
                 y, y_var_real; n2, n2_var_real; m2, m2_var_real;
                 n_tm, n_var_real; m_tm, m_var_real] INTERVAL_ADD in
    MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th2 (MY_PROVE_HYP th1 th0)));;



let float_interval_sub pp th1 th2 =
  let x, n1, m1 = dest_float_interval (concl th1) in
  let y, n2, m2 = dest_float_interval (concl th2) in
  let lo_th = float_sub_lo pp n1 m2 in
  let hi_th = float_sub_hi pp m1 n2 in
  let n_tm = lhand(concl lo_th) in
  let m_tm = rand(concl hi_th) in
  let th0 = INST[x, x_var_real; n1, n1_var_real; m1, m1_var_real;
		 y, y_var_real; n2, n2_var_real; m2, m2_var_real;
		 n_tm, n_var_real; m_tm, m_var_real] INTERVAL_SUB in
    MY_PROVE_HYP lo_th (MY_PROVE_HYP hi_th (MY_PROVE_HYP th2 (MY_PROVE_HYP th1 th0)));;



(*
let th1 = mk_float_interval_num (Num.num_of_int 123456781);;
let th2 = mk_float_interval_num (Num.num_of_int 514);;
let th3 = float_interval_neg th1;;
float_interval_add 5 th1 th2;;
float_interval_sub 5 th2 th1;;
float_interval_add 1 th1 th2;;

float_interval_add 5 th3 th2;;
float_interval_add 1 th3 th2;;

(* 4: 0.424 *)
test 1000 (float_interval_add 5 th1) th2;;
(* 4: 0.648 *)
test 1000 (float_interval_add 1 th1) th2;;


let tm1 = mk_small_numeral_array 123456781;;
let tm2 = mk_small_numeral_array 514;;
let tm = mk_binop plus_op_num tm1 tm2;;

(* 4: 0.036 *)
test 1000 NUM_ADD_HASH_CONV tm;;
NUM_ADD_HASH_CONV tm;;


let th1' = float_interval_round 3 th1;;
let th2' = float_interval_round 3 th2;;
float_interval_add 3 th1' th2';;

(* 4: 0.724 *)
test 1000 (float_interval_add 3 th1') th2';;
*)





(******************************************)

(* FLOAT_TO_NUM_CONV *)


let FLOAT_TO_NUM_CONV tm =
  let ltm, e_tm = dest_comb tm in
  let f_tm, n_tm = dest_comb ltm in
    if (fst o dest_const o rator) f_tm <> "float" then
      failwith "FLOAT_TO_NUM_CONV"
    else
      let n_th' = SYM (INST[n_tm, n_var_num] NUM_THM) in
      let e_th' = SYM (INST[e_tm, n_var_num] NUM_THM) in
      let n_th = TRANS n_th' (NUM_TO_NUMERAL_CONV (mk_comb(num_const, n_tm))) in
      let e_th = TRANS e_th' (NUM_TO_NUMERAL_CONV (mk_comb(num_const, e_tm))) in
      let th0 = MK_COMB (AP_TERM f_tm n_th, e_th) in
      let tm0 = rand(concl th0) in
      let th1 = REWRITE_CONV[float; num_exp; REAL_MUL_LID; GSYM REAL_OF_NUM_MUL; GSYM REAL_OF_NUM_POW; min_exp_def] tm0 in
      let th2 = REAL_RAT_REDUCE_CONV (rand(concl th1)) in
	TRANS th0 (TRANS th1 th2);;


