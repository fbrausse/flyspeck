(* Dependencies *)
needs "../formal_lp/arith/informal/informal_m_taylor.hl";;
needs "../formal_lp/formal_interval/interval_m/verifier.hl";;

(*module Informal_verifier = struct*)

open Informal_float;;
open Informal_interval;;
open Informal_taylor;;
open Recurse;;


type verification_funs =
{
  taylor : m_cell_domain -> m_taylor_interval;
  f : ifloat list -> ifloat list -> interval;
  df : int -> ifloat list -> ifloat list -> interval;
  ddf : int -> int -> ifloat list -> ifloat list -> interval;
};;

itlist2;;
(* m_subset_interval *)
let m_subset_interval a b c d =
  let n = length a in
  let prove_le l1 l2 = itlist2 (fun x y r -> le_float x y && r) l1 l2 true in
    prove_le a c && prove_le d b;;

(* m_taylor_cell_pass *)
let m_taylor_cell_pass pp ti =
  let upper = eval_m_taylor_upper_bound pp ti in
    lt0_float upper;;

(* m_taylor_cell_pass0 *)
let m_taylor_cell_pass0 int =
  (lt0_float o snd o dest_interval) int;;

(* m_cell_pass_subdomain *)
let m_cell_pass_subdomain domain2 pass_domain =
  let a, b = pass_domain.lo, pass_domain. hi in
  let c, d = domain2.lo, domain2.hi in
    m_subset_interval a b c d;;

(* m_incr_pass *)
let m_incr_pass pp j ti =
  let partial_bound = eval_m_taylor_lower_partial pp j ti in
    ge0_float partial_bound;;

(* m_decr_pass *)
let m_decr_pass pp j ti =
  let partial_bound = eval_m_taylor_upper_partial pp j ti in
    le0_float partial_bound;;

(* m_convex_pass *)
let m_convex_pass int =
  (ge0_float o fst o dest_interval) int;;


(* mk_verification_functions *)
let mk_verification_functions pp f partials partials2 =
  let n = length partials in
  let taylor = eval_m_taylor pp f partials partials2 in
  let eval0 = mk_eval_function pp f in
  let eval1 = map (fun i -> mk_eval_function pp ((rand o concl o List.nth partials) (i - 1))) (1--n) in
  let eval2 = map (fun i ->
		     map (fun j -> 
			    let d2 = List.nth (List.nth partials2 (i - 1)) (j - 1) in
			      mk_eval_function pp ((rand o concl) d2)) (1--n)) (1--n) in
    {
      taylor = taylor;
      f = eval0;
      df = (fun i -> List.nth eval1 (i - 1));
      ddf = (fun i j -> List.nth (List.nth eval2 (j - 1)) (i - 1));
    };;


(* split_domain *)
let split_domain pp j domain = 
  let n = length domain.w in
  let t = List.nth domain.y (j - 1) in
  let vv = map (fun i -> if i = j then t else List.nth domain.hi (i - 1)) (1--n) in
  let uu = map (fun i -> if i = j then t else List.nth domain.lo (i - 1)) (1--n) in
    mk_m_center_domain pp domain.lo vv, mk_m_center_domain pp uu domain.hi;;
  

(* restrict_domain *)
let restrict_domain j left_flag domain =
  let replace list j v = map (fun i -> if i = j then v else List.nth list (i - 1)) (1--length list) in
  let t = List.nth (if left_flag then domain.lo else domain.hi) (j - 1) in
  let lo = if left_flag then domain.lo else replace domain.lo j t in
  let hi = if left_flag then replace domain.hi j t else domain.hi in
  let w = replace domain.w j float_0 in
  let y = replace domain.y j t in
    {lo = lo; hi = hi; w = w; y = y};;


(*****************************)
(* m_verify_raw *)
let m_verify_raw pp fs certificate domain0 ref_list =
  let r_size = result_size certificate in
  let k = ref 0 in

  let rec rec_verify =
    let verify_mono mono domain c1 = true in
      fun domain certificate ->
	match certificate with
	  | Result_mono (mono, r1) ->
	      let mono_strs = 
		map (fun m -> sprintf "%s%d (%b)" (if m.decr_flag then "-" else "") 
		       m.variable m.df0_flag) mono in
	      let _ = report (sprintf "Mono: [%s]" (String.concat ";" mono_strs)) in
		verify_mono mono domain r1

	  | Result_pass (f0_flag, _, _) -> 
	      let _ = k := !k + 1 in
	      let _ = report (sprintf "Verifying: %d/%d (f0_flag = %b)" !k r_size f0_flag) in
	      let pass_flag = 
		if f0_flag then
		  m_taylor_cell_pass0 (fs.f domain.lo domain.hi)
		else
		  m_taylor_cell_pass pp (fs.taylor domain) in
		if not pass_flag then
		  failwith "pass: failed"
		else
		  pass_flag

	  | Result_glue (i, convex_flag, r1, r2) ->
	      let domain1, domain2 =
		if convex_flag then
		  let d1 = restrict_domain (i + 1) true domain in
		  let d2 = restrict_domain (i + 1) false domain in
		    d1, d2
		else
		  split_domain pp (i + 1) domain in
	      let pass1 = rec_verify domain1 r1 in
	      let pass2 = rec_verify domain2 r2 in
	      let pass_flag =
		if convex_flag then
		  let _ = report (sprintf "GlueConvex: %d" (i + 1)) in
		    m_convex_pass (fs.ddf (i + 1) (i + 1) domain.lo domain.hi) && pass1 && pass2
		else
		  pass1 && pass2 in
		if not pass_flag then
		  failwith "glue: failed"
		else
		  pass_flag

	  | Result_pass_ref i ->
	      let _ = report (sprintf "Ref: %d" i) in
	      let pass_flag =
		if i > 0 then
		  let _ = List.nth ref_list (i - 1) in
		    true
		else
		  let pass_domain = List.nth ref_list (-i - 1) in
		    m_cell_pass_subdomain domain pass_domain in
		if not pass_flag then
		  failwith "ref: failed"
		else
		  pass_flag 

	  | _ -> failwith "False result" in
    
    rec_verify domain0 certificate;;



(*
    let rec apply_trans sub_ths th0 acc =
      match sub_ths with
	| [] -> rev acc
	| th :: ths -> 
	    let th' = eval_subset_trans th th0 in
	      apply_trans ths th' (th' :: acc) in

    let rec mk_domains mono th0 acc =
      match mono with
	| [] -> rev acc
	| m :: ms ->
	    let j, flag = m.variable, m.decr_flag in
	    let ths = restrict_domain n j flag th0 in
	      mk_domains ms (fst ths) (ths :: acc) in

    let verify_mono mono domain_th certificate =
      let domain, _, _ = (dest_m_cell_domain o concl) domain_th in
      let xx, zz = dest_pair domain in
      let df0_flags = itlist (fun m b -> m.df0_flag & b) mono true in
      let _ = report (sprintf "df0_flags = %b" df0_flags) in
      let taylor_th, diff2_th = 
	if df0_flags then
	  TRUTH, diff2_f xx zz
	else
	  let t_th = eval_taylor domain_th in
	  let _, d_th, _, _ = dest_m_taylor_thms n t_th in
	    t_th, d_th in

      let domain_ths = mk_domains mono domain_th [] in
(*      let domains = domain_th :: map fst (butlast domain_ths) in *)

(*      let gen_mono (m, domain_th) = *)
      let gen_mono m =
	if m.df0_flag then
	  if m.decr_flag then
	    eval_interval_arith_hi n (eval_f m.variable xx zz)
	  else
	    eval_interval_arith_lo n (eval_f m.variable xx zz)
	else
	  if m.decr_flag then
	    eval_m_taylor_upper_partial n pp m.variable taylor_th
	  else
	    eval_m_taylor_lower_partial n pp m.variable taylor_th in

(*      let mono_ths = map gen_mono (zip mono domains) in *)
      let mono_ths = map gen_mono mono in
      let pass_th0 = rec_verify ((fst o last) domain_ths) certificate in
      let sub_th0 = (eval_subset_refl o rand o concl o snd o hd) domain_ths in
      let sub_ths = apply_trans (sub_th0 :: map snd (butlast domain_ths)) sub_th0 [] in
      let th = rev_itlist (fun ((m, mono_th), sub_th) pass_th ->
			     let j, flag = m.variable, m.decr_flag in
			       m_mono_pass_gen n j flag diff2_th mono_th sub_th pass_th)
	(rev (zip (zip mono mono_ths) sub_ths)) pass_th0 in
	if hyp th <> [] then failwith ("hyp <> []: "^string_of_thm th) else th in
*)
	



(*****************)

(* m_verify_raw0 *)
let m_verify_raw0 pp fs certificate xx zz =
  m_verify_raw pp fs certificate (mk_m_center_domain pp xx zz) [];;

	    
(* m_verify_list *)
let m_verify_list pp fs certificate_list xx zz =
  let domain_hash = Hashtbl.create (length certificate_list * 10) in
  let mem, find, add = Hashtbl.mem domain_hash, 
    Hashtbl.find domain_hash, Hashtbl.add domain_hash in

  let get_m_cell_domain pp domain0 path =
    let rec get_rec domain path hash =
      match path with
	| [] -> domain
	| (s, j) :: ps ->
	    let hash' = hash^s^(string_of_int j) in
	      if mem hash' then 
		get_rec (find hash') ps hash'
	      else
		if s = "l" or s = "r" then
		  let domain1, domain2 = split_domain pp j domain in
		  let hash1 = hash^"l"^(string_of_int j) and
		      hash2 = hash^"r"^(string_of_int j) in
		  let _ = add hash1 domain1; add hash2 domain2 in
		    if s = "l" then
		      get_rec domain1 ps hash'
		    else
		      get_rec domain2 ps hash'
		else
		  let l_flag = (s = "ml") in
		  let domain' = restrict_domain j l_flag domain in
		  let _ = add hash' domain' in
		    get_rec domain' ps hash' in
      get_rec domain0 path "" in

  let domain0 = mk_m_center_domain pp xx zz in
  let size = length certificate_list in
  let k = ref 0 in
  let rec rec_verify certificate_list ref_list =
    match certificate_list with
      | [] -> last ref_list
      | (path, certificate) :: cs ->
	  let _ = k := !k + 1; report (sprintf "List: %d/%d" !k size) in
	  let domain = get_m_cell_domain pp domain0 path in
	  let _ = m_verify_raw pp fs certificate domain ref_list in
	    rec_verify cs (ref_list @ [domain]) in
    rec_verify certificate_list [];;

