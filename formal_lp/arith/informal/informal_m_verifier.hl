(* Dependencies *)
needs "../formal_lp/arith/informal/informal_m_taylor.hl";;
needs "../formal_lp/formal_interval/interval_m/verifier.hl";;

module Informal_verifier = struct

open Informal_float;;
open Informal_interval;;
open Informal_taylor;;
open Recurse;;


type verification_funs =
{
  taylor : m_cell_domain -> m_taylor_interval;
  f : ifloat list -> ifloat list -> interval;
  df : int -> ifloat list -> ifloat list -> interval;
  ddf : int -> int -> ifloat list -> ifloat list -> interval;
};;


(* m_subset_interval *)
let m_subset_interval a b c d =
  let n = length a in
  let prove_le l1 l2 = itlist2 (fun x y r -> le_float x y && r) l1 l2 true in
    prove_le a c && prove_le d b;;

(* m_taylor_cell_pass *)
let m_taylor_cell_pass pp ti =
  let upper = eval_m_taylor_upper_bound pp ti in
    lt0_float upper;;

(* m_taylor_cell_pass0 *)
let m_taylor_cell_pass0 int =
  (lt0_float o snd o dest_interval) int;;

(* m_cell_pass_subdomain *)
let m_cell_pass_subdomain domain2 pass_domain =
  let a, b = pass_domain.lo, pass_domain. hi in
  let c, d = domain2.lo, domain2.hi in
    m_subset_interval a b c d;;

(* m_incr_pass *)
let m_incr_pass pp j ti =
  let partial_bound = eval_m_taylor_lower_partial pp j ti in
    ge0_float partial_bound;;

(* m_decr_pass *)
let m_decr_pass pp j ti =
  let partial_bound = eval_m_taylor_upper_partial pp j ti in
    le0_float partial_bound;;

(* m_mono_pass_gen *)
let m_mono_pass_gen decr_flag bound =
  (if decr_flag then le0_float else ge0_float) bound;;

(* m_convex_pass *)
let m_convex_pass int =
  (ge0_float o fst o dest_interval) int;;


(* mk_verification_functions *)
let mk_verification_functions pp f partials partials2 =
  let n = length partials in
  let taylor = eval_m_taylor pp f partials partials2 in
  let eval0 = mk_eval_function pp f in
  let eval1 = map (fun i -> mk_eval_function pp ((rand o concl o List.nth partials) (i - 1))) (1--n) in
  let eval2 = map (fun i ->
		     map (fun j -> 
			    let d2 = List.nth (List.nth partials2 (i - 1)) (j - 1) in
			      mk_eval_function pp ((rand o concl) d2)) (1--n)) (1--n) in
    {
      taylor = taylor;
      f = eval0;
      df = (fun i -> List.nth eval1 (i - 1));
      ddf = (fun i j -> List.nth (List.nth eval2 (j - 1)) (i - 1));
    };;


(* split_domain *)
let split_domain pp j domain = 
  let n = length domain.w in
  let t = List.nth domain.y (j - 1) in
  let vv = map (fun i -> if i = j then t else List.nth domain.hi (i - 1)) (1--n) in
  let uu = map (fun i -> if i = j then t else List.nth domain.lo (i - 1)) (1--n) in
    mk_m_center_domain pp domain.lo vv, mk_m_center_domain pp uu domain.hi;;
  

(* restrict_domain *)
let restrict_domain j left_flag domain =
  let replace list j v = map (fun i -> if i = j then v else List.nth list (i - 1)) (1--length list) in
  let t = List.nth (if left_flag then domain.lo else domain.hi) (j - 1) in
  let lo = if left_flag then domain.lo else replace domain.lo j t in
  let hi = if left_flag then replace domain.hi j t else domain.hi in
  let w = replace domain.w j float_0 in
  let y = replace domain.y j t in
    {lo = lo; hi = hi; w = w; y = y};;


(*****************************)
(* m_verify_raw *)
let m_verify_raw pp fs certificate domain0 ref_list =
  let r_size = result_size certificate in
  let k = ref 0 in

  let rec rec_verify =
    let rec mk_domains mono dom0 acc =
      match mono with
	| [] -> rev acc
	| m :: ms ->
	    let j, flag = m.variable, m.decr_flag in
	    let dom = restrict_domain j flag dom0 in
	      mk_domains ms dom (dom :: acc) in

    let verify_mono mono domain certificate =
      let xx, zz = domain.lo, domain.hi in
      let taylor = fs.taylor domain in
      let domains = mk_domains mono domain [] in
      let gen_mono m =
	if m.df0_flag then
	  if m.decr_flag then
	    (snd o dest_interval) (fs.df m.variable xx zz)
	  else
	    (fst o dest_interval) (fs.df m.variable xx zz)
	else
	  if m.decr_flag then
	    eval_m_taylor_upper_partial pp m.variable taylor
	  else
	    eval_m_taylor_lower_partial pp m.variable taylor in

      let monos = map gen_mono mono in
      let pass0 = rec_verify (last domains) certificate in
      let pass_flag = rev_itlist (fun (m, bound) pass -> 
				    let flag = m.decr_flag in
				      m_mono_pass_gen flag bound && pass) (rev (zip mono monos)) pass0 in
	if not pass_flag then
	  failwith "mono: failed"
	else
	  pass_flag in

      fun domain certificate ->
	match certificate with
	  | Result_mono (mono, r1) ->
	      let mono_strs = 
		map (fun m -> sprintf "%s%d (%b)" (if m.decr_flag then "-" else "") 
		       m.variable m.df0_flag) mono in
	      let _ = report (sprintf "Mono: [%s]" (String.concat ";" mono_strs)) in
		verify_mono mono domain r1

	  | Result_pass (f0_flag, _, _) -> 
	      let _ = k := !k + 1 in
	      let _ = report (sprintf "Verifying: %d/%d (f0_flag = %b)" !k r_size f0_flag) in
	      let pass_flag = 
		if f0_flag then
		  m_taylor_cell_pass0 (fs.f domain.lo domain.hi)
		else
		  m_taylor_cell_pass pp (fs.taylor domain) in
		if not pass_flag then
		  failwith "pass: failed"
		else
		  pass_flag

	  | Result_glue (i, convex_flag, r1, r2) ->
	      let domain1, domain2 =
		if convex_flag then
		  let d1 = restrict_domain (i + 1) true domain in
		  let d2 = restrict_domain (i + 1) false domain in
		    d1, d2
		else
		  split_domain pp (i + 1) domain in
	      let pass1 = rec_verify domain1 r1 in
	      let pass2 = rec_verify domain2 r2 in
	      let pass_flag =
		if convex_flag then
		  let _ = report (sprintf "GlueConvex: %d" (i + 1)) in
		    m_convex_pass (fs.ddf (i + 1) (i + 1) domain.lo domain.hi) && pass1 && pass2
		else
		  pass1 && pass2 in
		if not pass_flag then
		  failwith "glue: failed"
		else
		  pass_flag

	  | Result_pass_ref i ->
	      let _ = report (sprintf "Ref: %d" i) in
	      let pass_flag =
		if i > 0 then
		  let _ = List.nth ref_list (i - 1) in
		    true
		else
		  let pass_domain = List.nth ref_list (-i - 1) in
		    m_cell_pass_subdomain domain pass_domain in
		if not pass_flag then
		  failwith "ref: failed"
		else
		  pass_flag 

	  | _ -> failwith "False result" in
    
    rec_verify domain0 certificate;;



(*****************)

(* m_verify_raw0 *)
let m_verify_raw0 pp fs certificate xx zz =
  m_verify_raw pp fs certificate (mk_m_center_domain pp xx zz) [];;

	    
(* m_verify_list *)
let m_verify_list pp fs certificate_list xx zz =
  let domain_hash = Hashtbl.create (length certificate_list * 10) in
  let mem, find, add = Hashtbl.mem domain_hash, 
    Hashtbl.find domain_hash, Hashtbl.add domain_hash in

  let get_m_cell_domain pp domain0 path =
    let rec get_rec domain path hash =
      match path with
	| [] -> domain
	| (s, j) :: ps ->
	    let hash' = hash^s^(string_of_int j) in
	      if mem hash' then 
		get_rec (find hash') ps hash'
	      else
		if s = "l" or s = "r" then
		  let domain1, domain2 = split_domain pp j domain in
		  let hash1 = hash^"l"^(string_of_int j) and
		      hash2 = hash^"r"^(string_of_int j) in
		  let _ = add hash1 domain1; add hash2 domain2 in
		    if s = "l" then
		      get_rec domain1 ps hash'
		    else
		      get_rec domain2 ps hash'
		else
		  let l_flag = (s = "ml") in
		  let domain' = restrict_domain j l_flag domain in
		  let _ = add hash' domain' in
		    get_rec domain' ps hash' in
      get_rec domain0 path "" in

  let domain0 = mk_m_center_domain pp xx zz in
  let size = length certificate_list in
  let k = ref 0 in
  let rec rec_verify certificate_list ref_list =
    match certificate_list with
      | [] -> last ref_list
      | (path, certificate) :: cs ->
	  let _ = k := !k + 1; report (sprintf "List: %d/%d" !k size) in
	  let domain = get_m_cell_domain pp domain0 path in
	  let _ = m_verify_raw pp fs certificate domain ref_list in
	    rec_verify cs (ref_list @ [domain]) in
    rec_verify certificate_list [];;

end;;


(* Tests *)
needs "../formal_lp/formal_interval/m_verifier.hl";;

let reset_all () =
  Arith_cache.reset_stat();
  Arith_cache.reset_cache();
  Arith_float.reset_stat();
  Arith_float.reset_cache();;

let dest_int int =
  let f1, f2 = Informal_interval.dest_interval int in
    Informal_float.dest_float f1, Informal_float.dest_float f2;;

let dest_f = Informal_float.dest_float;;

let dest_dom dom =
  map dest_f dom.Informal_taylor.lo,
  map dest_f dom.Informal_taylor.hi,
  map dest_f dom.Informal_taylor.y,
  map dest_f dom.Informal_taylor.w;;

let dest_ti ti =
  dest_int ti.Informal_taylor.f, 
  map dest_int ti.Informal_taylor.df, 
  map (map dest_int) ti.Informal_taylor.ddf;;





(* mk_verification_functions *)
let mk_verification_functions pp poly_tm min_flag value_tm =
  let x_tm, body_tm = dest_abs poly_tm in
  let new_expr =
    uncurry (mk_binop sub_op_real) (if min_flag then value_tm, body_tm else body_tm, value_tm) in
  let new_f = mk_abs (x_tm, new_expr) in
  let n = get_dim x_tm in

  let partials = map (fun i -> 
			let _ = report (sprintf "Partial %d/%d" i n) in
			  gen_partial_poly i new_f) (1--n) in
  let get_partial i eq_th = 
    let partial_i = gen_partial_poly i (rand (concl eq_th)) in
    let pi = (rator o lhand o concl) partial_i in
      REWRITE_RULE[GSYM partial2] (TRANS (AP_TERM pi eq_th) partial_i) in
  let partials2 = map (fun j -> 
			 let th = List.nth partials (j - 1) in
			 let _ = report (sprintf "Partial2 %d/%d" j n) in
			   map (fun i -> get_partial i th) (1--n)) (1--n) in

  let diff_th = gen_diff_poly new_f in
  let lin_th = gen_lin_approx_poly_thm new_f diff_th partials in
  let diff2_th = gen_diff2_domain_poly new_f in
  let second_th = gen_second_bounded_poly_thm new_f partials2 in

  let replace_numeral i th =
    let num_eq = (REWRITE_RULE[Arith_hash.NUM_THM] o NUMERAL_TO_NUM_CONV) (mk_small_numeral i) in
      GEN_REWRITE_RULE (LAND_CONV o RATOR_CONV o DEPTH_CONV) [num_eq] th in

  let eval0 = map (fun i -> 
		     if i = 0 then mk_eval_function pp new_f
		     else 
		       let d_th = List.nth partials (i - 1) in
		       let eq_th = replace_numeral i d_th in
			 mk_eval_function_eq pp eq_th) (0--n) in

  let eval2 = map (fun i ->
		     map (fun j ->
			    let d2_th = List.nth (List.nth partials2 (i - 1)) (j - 1) in
			    let eq_th' = replace_numeral i d2_th in
			    let eq_th = replace_numeral j eq_th' in
			      mk_eval_function_eq pp eq_th) (1--n)) (1--n) in

  let diff2_f = eval_diff2_poly diff2_th in
  let eval_f = eval_m_taylor pp diff2_th lin_th second_th in
  let taylor_f = build_taylor pp lin_th second_th in
    ((fun i -> List.nth eval0 i), 
     (fun i j -> List.nth (List.nth eval2 (j - 1)) (i - 1)),
     diff2_f,
     eval_f), taylor_f, Informal_verifier.mk_verification_functions pp new_f partials partials2;;



needs "../formal_lp/formal_interval/m_examples_poly.hl";;





(***)
(* schwefel *)
let pp = 12;;
let n = 3;;
let xx = `[-- &10; -- &10; -- &10]` and
    zz = `[&10; &10; &10]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx2 = Informal_taylor.convert_to_float_list pp true xx and
    zz2 = Informal_taylor.convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_schwefel, tf_schwefel, i_schwefel = mk_verification_functions pp schwefel_poly true schwefel_min;;
let c00 = run_test tf_schwefel xx_float zz_float false 0.0 true true false false 0.0;;
let c0 = run_test tf_schwefel xx_float zz_float false 0.0 true true false true 0.0;;
result_stat c0;;
let c1' = run_test tf_schwefel xx_float zz_float false 0.0 true true true true 0.0;;
let c1 = transform_result xx_float zz_float c1';;
(* 641 (661 after eps = 1e-10)*)
length c1;;

(* 138.377 *)
reset_all();;
test 1 (m_verify_raw0 n pp eval_schwefel c00 xx1) zz1;;

Informal_verifier.m_verify_raw0 pp i_schwefel c00 xx2 zz2;;


(* 27.486 *)
reset_all();;
test 1 (m_verify_raw0 n pp eval_schwefel c0 xx1) zz1;;

Informal_verifier.m_verify_raw0 pp i_schwefel c0 xx2 zz2;;

Arith_float.print_stat();;
Arith_cache.print_stat();;

(* 24.194 *)
reset_all();;
test 1 (m_verify_list n pp eval_schwefel c1 xx1) zz1;;

Informal_verifier.m_verify_list pp i_schwefel c1 xx2 zz2;;


(***)
(* rd *)

let pp = 12;;
let n = 3;;
let xx = `[-- &5; -- &5; -- &5]` and
    zz = `[&5; &5; &5]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;
let xx2 = Informal_taylor.convert_to_float_list pp true xx and
    zz2 = Informal_taylor.convert_to_float_list pp false zz;;
let xx_float = map float_of_float_tm (dest_list xx1) and
    zz_float = map float_of_float_tm (dest_list zz1);;

let eval_rd, tf_rd, i_rd = mk_verification_functions pp rd_poly true rd_min;;
let certificate = run_test tf_rd xx_float zz_float false 0.0 true true true false 0.0;;
(* 1 *)
result_size certificate;;
m_verify_raw0 n pp eval_rd certificate xx1 zz1;;

Informal_verifier.m_verify_raw0 12 i_rd certificate xx2 zz2;;


let dom_th = mk_m_center_domain n pp xx1 zz1;;
let dom = Informal_taylor.mk_m_center_domain pp xx2 zz2;;

let _, _, _, rd_taylor = eval_rd;;
let taylor_th = rd_taylor dom_th;;
let taylor = i_rd.Informal_verifier.taylor dom;;
dest_ti taylor;;

let upper_th = eval_m_taylor_upper_bound n pp taylor_th;;
dest_f (Informal_taylor.eval_m_taylor_upper_bound pp taylor);;
