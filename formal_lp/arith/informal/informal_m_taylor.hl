(* Dependencies *)
needs "../formal_lp/arith/informal/informal_arith.hl";;
needs "../formal_lp/arith/informal/informal_eval_interval.hl";;


module Informal_taylor = struct

open Informal_interval;;
open Informal_float;;
open Informal_eval_interval;;


type m_cell_domain = 
{
  lo : ifloat list;
  hi : ifloat list;
  y : ifloat list;
  w : ifloat list;
};;


type m_taylor_interval =
{
  n : int;
  domain : m_cell_domain;
  f : interval;
  df : interval list;
  ddf : interval list list; 
};;


let float_0 = mk_small_num_float 0 and
    float_1 = mk_small_num_float 1 and
    float_2 = mk_small_num_float 2;;

let float_inv2 = div_float_lo 1 float_1 float_2;;

(* convert_to_float_list *)
let convert_to_float_list pp lo_flag list_tm =
  let tms = dest_list list_tm in
  let i_funs = map build_interval_fun tms in
  let ints = map (fun f -> eval_interval_fun pp f [] []) i_funs in
  let extract = (if lo_flag then fst else snd) o dest_interval in
    map extract ints;;


(* mk_m_center_domain *)
let mk_m_center_domain pp x_list z_list =
  let y_list =
    let ( * ), (+) = mul_float_eq, add_float_hi pp in
      map2 (fun x z -> if eq_float x z then x else float_inv2 * (x + z)) x_list z_list in

  (* test: x <= y <= z *)
  let flag1 = itlist2 (fun x y a -> le_float x y && a) x_list y_list true and
      flag2 = itlist2 (fun y z a -> le_float y z && a) y_list z_list true in
    if not flag1 or not flag2 then
      failwith "mk_m_center_domain: ~(x <= y <= z)"
    else
      let w_list =
	let (-) = sub_float_hi pp in
	let w1 = map2 (-) y_list x_list in
	let w2 = map2 (-) z_list y_list in
	  map2 max_float w1 w2 in
	{lo = x_list; hi = z_list; y = y_list; w = w_list};;


(* eval_m_taylor (pp0 for initial evaluation of constants) *)
let eval_m_taylor pp0 f_tm partials partials2 =
  let build = eval_constants pp0 o build_interval_fun o snd o dest_abs in
  let f = build f_tm in
  let n = length partials in
  let dfs = map (build o rand o concl) partials in
  let d2fs = map (build o rand o concl) (List.flatten partials2) in
  let f_dfs_list = find_and_replace_all (f :: dfs) [] in
  let d2fs_list = find_and_replace_all d2fs [] in
    fun pp domain ->
      let y_ints = map (fun y -> mk_interval (y, y)) domain.y in
      let xz_ints = map mk_interval (zip domain.lo domain.hi) in
      let f_dfs_vals = eval_interval_fun_list pp f_dfs_list y_ints in
      let d2fs_vals = eval_interval_fun_list pp d2fs_list xz_ints in
	{n = n; domain = domain;
	 f = hd f_dfs_vals; df = tl f_dfs_vals;
	ddf = Arith_misc.shape_list n d2fs_vals};;


(* mk_eval_functionq *)
let mk_eval_function pp0 f_tm =
  let build = eval_constants pp0 o build_interval_fun o snd o dest_abs in
  let f = build f_tm in
  let f_list = find_and_replace_all [f] [] in
    fun pp x_list z_list ->
      let xz_ints = map mk_interval (zip x_list z_list) in
      let f_val = eval_interval_fun_list pp f_list xz_ints in
	hd f_val;;


(* list_sum2_hi *)
let list_sum2_hi pp f_hi list1 list2 =
  let rec rec_conv list1 list2 =
    match list1 with
      | h1 :: t1 -> 
	  (let h2, t2 = hd list2, tl list2 in
	   let f_val = f_hi pp h1 h2 in
	     match t1 with
	       | _ :: _ ->
		   let sum2_t = rec_conv t1 t2 in
		     add_float_hi pp f_val sum2_t
	       | _ -> f_val)
      | _ -> float_0 in
    rec_conv list1 list2;;


(* error_mul_f2_hi *)
let error_mul_f2_hi pp a int = mul_float_hi pp a (abs_interval int);;

(* error_mul_f1_hi *)
let error_mul_f1_hi w pp x list =
  let sum2 = list_sum2_hi pp error_mul_f2_hi w list in
    mul_float_hi pp x sum2;;


(* eval_m_taylor_error *)
let eval_m_taylor_error pp ti =
  let w = ti.domain.w in
    list_sum2_hi pp (error_mul_f1_hi w) w ti.ddf;;

(* eval_m_taylor_upper_bound *)
let eval_m_taylor_upper_bound pp ti =
  let f_hi = (snd o dest_interval) ti.f in
  let error = eval_m_taylor_error pp ti in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w ti.df in
  let a =
    let ( * ), (+) = mul_float_hi pp, add_float_hi pp in
      sum2 + float_inv2 * error in
    add_float_hi pp f_hi a;;

(* eval_m_taylor_lower_bound *)
let eval_m_taylor_lower_bound pp ti =
  let f_lo = (fst o dest_interval) ti.f in
  let error = eval_m_taylor_error pp ti in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w ti.df in
  let a =
    let ( * ), (+) = mul_float_hi pp, add_float_hi pp in
      sum2 + float_inv2 * error in
    sub_float_lo pp f_lo a;;


(* eval_m_taylor_bound *)
let eval_m_taylor_bound pp ti =
  let f_lo, f_hi = dest_interval ti.f in
  let error = eval_m_taylor_error pp ti in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w ti.df in
  let a =
    let ( * ), (+) = mul_float_hi pp, add_float_hi pp in
      sum2 + float_inv2 * error in
  let hi = add_float_hi pp f_hi a in
  let lo = sub_float_lo pp f_lo a in
    mk_interval (lo, hi);;


(* eval_m_taylor_upper_partial *)
let eval_m_taylor_upper_partial pp i ti =
  let df_hi = (snd o dest_interval o List.nth ti.df) (i - 1) in
  let dd_list = List.nth ti.ddf (i - 1) in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w dd_list in
    add_float_hi pp df_hi sum2;;


(* eval_m_taylor_lower_partial *)
let eval_m_taylor_lower_partial pp i ti =
  let df_lo = (fst o dest_interval o List.nth ti.df) (i - 1) in
  let dd_list = List.nth ti.ddf (i - 1) in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w dd_list in
    sub_float_lo pp df_lo sum2;;


(* eval_m_taylor_interval_partial *)
let eval_m_taylor_interval_partial pp i ti =
  let df_lo, df_hi = (dest_interval o List.nth ti.df) (i - 1) in
  let dd_list = List.nth ti.ddf (i - 1) in
  let sum2 = list_sum2_hi pp error_mul_f2_hi ti.domain.w dd_list in
  let lo = sub_float_lo pp df_lo sum2 in
  let hi = add_float_hi pp df_hi sum2 in
    mk_interval (lo, hi);;






end;;


(*
(* Tests *)

open Informal_taylor;;

let dest_int int =
  let f1, f2 = Informal_interval.dest_interval int in
    Informal_float.dest_float f1, Informal_float.dest_float f2;;

let dest_ti ti =
  dest_int ti.f, map dest_int ti.df, map (map dest_int) ti.ddf;;

let dest_f = Informal_float.dest_float;;


needs "../formal_lp/formal_interval/m_taylor.hl";;

let convert_to_float_list pp lo_flag list_tm =
  let tms = dest_list list_tm in
  let i_funs = map build_interval_fun tms in
  let ints = map (fun f -> eval_interval_fun pp f [] []) i_funs in
  let extract = (if lo_flag then fst else snd) o dest_pair o rand o concl in
    mk_list (map extract ints, real_ty);;

let pp = 7;;
let poly = expr_to_vector_fun `x1 + x2 * x3 + x3 * (x1 + x3 pow 2)`;;
let n = (get_dim o fst o dest_abs) poly;;

let xx = `[#1.1; &2; -- sqrt(&2)]` and
    zz = `[&3; &3; &1 + sqrt(&3)]`;;

let xx1 = convert_to_float_list pp true xx and
    zz1 = convert_to_float_list pp false zz;;

let xx0 = Informal_taylor.convert_to_float_list pp true xx and
    zz0 = Informal_taylor.convert_to_float_list pp false zz;;

let dom_th = mk_m_center_domain n pp xx1 zz1;;
let dom = Informal_taylor.mk_m_center_domain pp xx0 zz0;;

let partials = map (fun i -> gen_partial_poly i poly) (1--n);;
let get_partial i eq_th =
  let partial_i = gen_partial_poly i (rand (concl eq_th)) in
  let pi = (rator o lhand o concl) partial_i in
    REWRITE_RULE[GSYM partial2] (TRANS (AP_TERM pi eq_th) partial_i);;
let partials2 = map (fun j ->
		       let th = List.nth partials (j - 1) in
			 map (fun i -> get_partial i th) (1--n)) (1--n);;

let diff_th = gen_diff_poly poly;;
let diff2_th = gen_diff2_domain_poly poly;;
let lin_th = gen_lin_approx_poly_thm poly diff_th partials;;
let second_th = gen_second_bounded_poly_thm poly partials2;;

let eval_taylor = eval_m_taylor pp diff2_th lin_th second_th;;
let taylor = Informal_taylor.eval_m_taylor pp poly partials partials2;;

let ti_th = eval_taylor dom_th;;
let ti = taylor dom;;
dest_ti ti;;

(* 1.20 *)
test 100 eval_taylor dom_th;;
(* 0.04 *)
test 100 taylor dom;;

(* bounds *)
eval_m_taylor_bound n pp ti_th;;
dest_int (Informal_taylor.eval_m_taylor_bound pp ti);;

eval_m_taylor_upper_bound n pp ti_th;;
dest_f (Informal_taylor.eval_m_taylor_upper_bound pp ti);;

eval_m_taylor_lower_bound n pp ti_th;;
dest_f (Informal_taylor.eval_m_taylor_lower_bound pp ti);;


(* 1.288 *)
test 100 (eval_m_taylor_bound n pp) ti_th;;
(* 0.044 *)
test 100 (Informal_taylor.eval_m_taylor_bound pp) ti;;



(* partials *)

eval_m_taylor_upper_partial n pp 1 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_upper_partial pp 1 ti);;

eval_m_taylor_upper_partial n pp 2 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_upper_partial pp 2 ti);;

eval_m_taylor_upper_partial n pp 3 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_upper_partial pp 3 ti);;


eval_m_taylor_lower_partial n pp 1 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_lower_partial pp 1 ti);;

eval_m_taylor_lower_partial n pp 2 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_lower_partial pp 2 ti);;

eval_m_taylor_lower_partial n pp 3 ti_th;;
dest_f (Informal_taylor.eval_m_taylor_lower_partial pp 3 ti);;

eval_m_taylor_interval_partial n pp 1 ti_th;;
dest_int (Informal_taylor.eval_m_taylor_interval_partial pp 1 ti);;
*)
