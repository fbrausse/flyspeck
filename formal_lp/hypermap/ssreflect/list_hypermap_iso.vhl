"needs \"../formal_lp/hypermap/ssreflect/list_hypermap-compiled.hl\"".
"needs \"../formal_lp/hypermap/ssreflect/add_triangle-compiled.hl\"".

Module List_hypermap_iso.

"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Hypermap_and_fan".
"open Fan_defs".
"open List_hypermap".
"open Add_triangle".
"open Hypermap_iso".



Section MoreFan.

Variable V : `:real^3->bool`.
Variable E : `:(real^3->bool)->bool`.

(* TODO: move to HypermapAndFan.hl *)
Lemma fan_imp_finite_set V E: `FAN (vec 0,V,E) ==> FINITE V`.
Proof. by rewrite FAN fan1 => ->. Qed.


Lemma fst_node_hypermap_of_fan x y: `FAN (vec 0, V, E) /\ x IN node (hypermap_of_fan (V,E)) y
	==> FST x = FST y`.
Proof.
move => [fanV x_in].
apply: (FAN_NODE_EQ_lemma fanV).
by rewrite EQ_SYM_EQ; apply Hypermap.lemma_node_identity.
Qed.


Lemma e_fan_pair_ext_explicit v w: `(v,w) IN dart_of_fan (V,E)
	==> e_fan_pair_ext (V,E) (v,w) = (w,v)`.
Proof.
rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM e_fan_pair_ext /=.
case vw_in: `v,w IN _` => /=; first by rewrite e_fan_pair.
by move => [z] [_]; rewrite PAIR_EQ => [] [-> ->].
Qed.


Lemma fan_number_of_nodes V E: `FAN (vec 0,V,E) 
	==> number_of_nodes (hypermap_of_fan (V,E)) = CARD V`.
Proof.
rewrite number_of_nodes => fanV.
move: (NODE_SET_AS_IMAGE fanV) => [f] [inj] ->.
by rewrite CARD_IMAGE_INJ // (fan_imp_finite_set fanV) /= => x y [_] [_] /inj.
Qed.

End MoreFan.


(* res_inv *)
Section MoreResInv.

Lemma inj_res_inv_left f s t x: `INJ f s t /\ x IN s ==> res_inv f s (f x) = x`.
Proof. by rewrite INJ => [] h; rewrite res_inv_left //. Qed.

Lemma surj_res_inv_right f s t y: `SURJ f s t /\ y IN t ==>
	f (res_inv f s y) = y /\ res_inv f s y IN s`.
Proof. by rewrite SURJ => h; rewrite !(res_inv_right f s t) //. Qed.

End MoreResInv.




(* MoreSeq *)
Section MoreSeq.


"let zip = GEN_ALL Seq.zip".
"let take = GEN_ALL Seq.take".
"let MEM = GEN_ALL MEM".

Lemma take_zip s1 s2 n: `take n (zip s1 s2) = zip (take n s1) (take n s2)`.
Proof.
elim: s1 s2 n => [| h1 t1 Ih1] [|h2 t2]; rewrite ?take zip ?take ?zip //.
by case => [|n]; rewrite !take zip.
Qed.

Lemma drop_zip s1 s2 n: `dropl n (zip s1 s2) = zip (dropl n s1) (dropl n s2)`.
Proof.
elim: s1 s2 n => [| h1 t2 Ih1] [|h2 t2]; rewrite ?drop zip ?drop ?zip //.
by case => [|n]; rewrite !drop ?zip.
Qed.

Lemma rot_zip s1 s2 n: `sizel s1 = sizel s2
	==> rot n (zip s1 s2) = zip (rot n s1) (rot n s2)`.
Proof.
move => size_eq.
by rewrite rot drop_zip take_zip -zip_cat -?rot // !size_drop size_eq.
Qed.

Lemma rotr_zip s1 s2 n: `sizel s1 = sizel s2
	==> rotr n (zip s1 s2) = zip (rotr n s1) (rotr n s2)`.
Proof.
move => size_eq.
by rewrite !rotr size1_zip size_eq ?leqnn // rot_zip.
Qed.

Lemma size1 x: `sizel [x] = 1`.
Proof. by rewrite size_cons size_nil ONE. Qed.

Lemma nth_rot x0 s k i: `k <= sizel s /\ i < sizel s
	==> nth x0 (rot k s) i = nth x0 s ((k + i) MOD sizel s)`.
Proof.
move => ineqs.
rewrite rot nth_cat size_drop.
case i_lt: `i:num < _` => /=.
  by rewrite nth_drop MOD_LT //; move: i_lt ineqs; arith.
have ->: `i - (sizel s - k) = (k + i) - sizel s` by move: i_lt ineqs; arith.
rewrite nth_take; first by move: i_lt ineqs; arith.
have {2}->: `k + i = 1 * sizel s + ((k + i) - sizel s)` by move: i_lt ineqs; arith.
rewrite MOD_MULT_ADD MOD_LT //.
by move: ineqs; arith.
Qed.

Lemma head_belast x0 x s: `0 < sizel s ==> headl x0 (belast x s) = x`.
Proof.
case: s => [|h t _]; first by rewrite size_nil ltn0.
by rewrite belast head.
Qed.

Lemma nth_belast x0 s x i: `i < sizel s ==> 
	nth x0 (belast x s) i = if i = 0 then x else nth x0 s (i - 1)`.
Proof.
elim: s i x => [|h t Ih] [|i x]; rewrite ?size_nil ?ltn0 //.
  by move => x lt; rewrite nth0 head_belast.
rewrite size_cons ltSS eqS0 /= => i_lt.
rewrite belast nth Ih // succnK.
by case: i => [|j] /=; rewrite nth // succnK eqS0.
Qed.

Lemma take_belast s x n: `n < sizel s /\ 0 < n ==> take n (belast x s) = x :: take (n - 1) s`.
Proof.
elim: s n x => [|h t Ih] [|n x]; rewrite ?size_nil ?ltn0 //.
rewrite belast take size_cons ltSS => ineqs.
case: n ineqs => [_|n ineqs]; first by rewrite -ONE subnn !take.
by rewrite Ih ?succnK ?take // gtS0.
Qed.

Lemma size1_eq s: `sizel s = 1 <=> ?x. s = [x]`.
Proof.
split => [| [x] ->]; last by rewrite size1.
case: s => [|h t]; first by rewrite size_nil; arith.
by rewrite size_cons ONE eqSS size_eq0 => ->; exists h.
Qed.


(* list_sumn *)
"let list_sumn = new_definition `list_sumn s f = foldr (\a b. f a + b) 0 s`".

"let foldr = GEN_ALL foldr".
"let map = GEN_ALL map".
"let ALL2 = GEN_ALL ALL2".

Lemma list_sumn_nil f: `list_sumn [] f = 0`.
Proof. by rewrite list_sumn foldr. Qed.

Lemma list_sumn_cons h t f: `list_sumn (CONS h t) f = f h + list_sumn t f`.
Proof. by rewrite list_sumn foldr -list_sumn. Qed.

Lemma list_sum_eq_list_sumn s f: `list_sum s ((&) o f) = &(list_sumn s f)`.
Proof.
elim: s => [|h t Ih]; first by rewrite Seq2.list_sum_nil list_sumn_nil.
by rewrite list_sumn_cons Seq2.list_sum_cons -REAL_OF_NUM_ADD o_THM Ih.
Qed.

Lemma count_flatten s a: `count a (flatten s) = list_sumn (map (count a) s) I`.
Proof.
elim: s => [|h t Ih]; rewrite flatten foldr.
  by rewrite count map list_sumn_nil.
by rewrite -flatten map list_sumn_cons -Ih count_cat I_THM.
Qed.

Lemma perm_eq_flatten s1 s2: `perm_eq s1 s2 ==> perm_eq (flatten s1) (flatten s2)`.
Proof.
move => perm; rewrite perm_eqP => a.
rewrite !count_flatten -REAL_OF_NUM_EQ -!list_sum_eq_list_sumn.
by apply (Seq2.list_sum_perm_eq); rewrite Seq2.perm_eq_map.
Qed.



Lemma ALL2_cat f s1 t1 s2 t2: `sizel s1 = sizel s2 ==> 
	(ALL2 f (s1 ++ t1) (s2 ++ t2) <=> ALL2 f s1 s2 /\ ALL2 f t1 t2)`.
Proof.
elim: s1 s2 => [|h1 r1 Ih] [|h2 r2]; rewrite !(size_cons, size_nil) !cat !ALL2 //; try arith.
by rewrite eqSS => /Ih ->; rewrite andbA.
Qed.


Lemma rot_rot_eq_rot s m n: `?k. rot m (rot n s) = rot k s`.
Proof.
case m_le: `m <= sizel s` => /=; last first.
  by exists n; rewrite rot_oversize // size_rot; move: m_le; arith.
case n_le: `n <= sizel s` => /=; last first.
  by exists m; rewrite (rot_oversize n) //; move: n_le; arith.
rewrite rot_add_mod //.
set k := `if _ then _1 else _2`.
by exists k.
Qed.


Lemma index_take s n x: `indexl x (take n s) = if indexl x s < n then (indexl x s) else n`.
Proof.
elim: s n => [|h t Ih] [|n]; rewrite take ?index_nil; try arith.
rewrite !Seq2.index_cons.
case x_eq_h: `x = h` => /=; first by arith.
by rewrite ltSS Ih; case: `_1 < n:num`.
Qed.


Lemma index_drop_le s n x: `n <= indexl x s ==> indexl x (dropl n s) = indexl x s - n`.
Proof.
elim: s n => [|h t Ih] [|n]; rewrite drop ?index_nil; try arith.
rewrite !Seq2.index_cons.
case x_eq_h: `x = h` => /=; first by arith.
by rewrite leqSS subSS => /Ih ->.
Qed.


Lemma index_drop_uniq s n x: `uniq s ==>
	indexl x (dropl n s) = if n <= indexl x s then (indexl x s - n) else (sizel s - n)`.
Proof.
move => uniq_s.
case n_lt: `n < sizel s` => /=; last first.
  rewrite drop_oversize leqNgt // index_nil.
  by move: (index_size x s) n_lt; arith.
case n_le: `n:num <= _` => /=; first by rewrite index_drop_le.
rewrite -size_drop -index_eq_size.
apply: contraL uniq_s => mem_drop.
rewrite -(cat_take_drop n s) (mem_imp_not_uniq_cat x) // mem_drop.
rewrite -index_mem index_take size_take.
by rewrite NOT_LE in n_le; rewrite n_le /= n_lt.
Qed.


Lemma index_rot s n x: `uniq s /\ n < sizel s /\ MEM x s ==> 
  indexl x (rot n s) = if n <= indexl x s then (indexl x s - n) else (indexl x s + sizel s - n)`.
Proof.
move => [uniq_s] [n_lt] mem_x.
rewrite rot index_cat -index_mem size_drop index_drop_uniq // index_take.
set i := `indexl x s`.
have i_lt: `i < sizel s` by move: mem_x; rewrite -index_mem i_def.
by move: i_lt n_lt; arith.
Qed.



End MoreSeq.


Lemma next_el_outside s x: `~(MEM x s) ==> next_el s x = x`.
Proof.
rewrite !index_eq_size => i_eq.
rewrite next_el i_eq.
case: s => [|h t]; first by rewrite size_nil sub0n /= head.
rewrite size_cons "ARITH_RULE `!n. ~(SUC n = SUC n - 1)`" /=.
by rewrite !nth_default // ?size_rot size_cons; arith.
Qed.


Lemma next_el_rot_eq s n: `uniq s ==> next_el (rot n s) = next_el s`.
Proof.
move => uniq_s; rewrite FUN_EQ_THM => x.
case n_lt: `n < sizel s` => /=; last first.
  by rewrite rot_oversize // -NOT_LT.
case mem_x: `MEM x s` => /=; last first.
  by rewrite !next_el_outside // mem_rot.
have mem_rot: `MEM x (rot n s)` by rewrite mem_rot.
rewrite !next_el_rot // -!nth0 index_rot //.
set i := `indexl x s`.
have i_lt: `i < sizel s` by move: mem_x; rewrite -index_mem.
have size_gt0: `0 < sizel s`.
  by case: s mem_x => [|h t]; rewrite MEM // size_cons gtS0.
have ineqs: `i + 1 <= sizel s /\ n <= sizel s /\ i - n + 1 <= sizel s /\ ~(0 = sizel s)`.
  by move: i_lt n_lt; arith.
case n_le: `n:num <= _` => /=.
  rewrite !nth_rot // ?size_rot // !addn0 -?DIVISION //.
  rewrite -{1}(MOD_LT n_lt) MOD_ADD_MOD //.
  by have ->: `n + i - n + 1 = i + 1` by move: n_le; arith.
have ineq2: `(i + sizel s - n) + 1 <= sizel s` by move: n_le i_lt; arith.
rewrite !nth_rot // ?size_rot // -?DIVISION // !addn0.
rewrite -{1}(MOD_LT n_lt) MOD_ADD_MOD //.
have ->: `n + (i + sizel s - n) + 1 = 1 * sizel s + (i + 1)` by move: n_lt; arith.
by rewrite MOD_MULT_ADD.
Qed.


Lemma next_el_inj s x y: `uniq s ==> (next_el s x = next_el s y <=> x = y)`.
Proof.
move => uniq_s; split => [| -> //].
case mem_x: `MEM x s` => /=; last first.
  rewrite next_el_outside // => x_eq.
  suff mem_y: `~MEM y s` by move: x_eq; rewrite next_el_outside.
  by apply: contra mem_x => /mem_next_el; rewrite -x_eq.
case mem_y: `MEM y s` => /=; last first.
  rewrite (next_el_outside mem_y) => y_eq.
  by move: (mem_next_el mem_x); rewrite y_eq mem_y.
by move/(congr1 `prev_el s`); rewrite !prev_next_id.
Qed.


Lemma prev_el_rot_eq s n x: `uniq s /\ MEM x s ==> prev_el (rot n s) x = prev_el s x`.
Proof.
move => [uniq_s mem_x].
rewrite -next_el_inj // -{1}(next_el_rot_eq n) // !next_prev_id //.
by rewrite rot_uniq mem_rot.
Qed.



(* Main definitions *)
(* Given a list [1;2;3;4;...;n], yields two lists [[1;2;3]; [1;4;...;n]] *)
"let split_list_face = new_definition
	`split_list_face f = if sizel f <= 3 then [f] else [take 3 f; HD f :: dropl 2 f]`".

"let split_list_hyp = (GEN_ALL o define) 
	`split_list_hyp [] d = [] /\
	 split_list_hyp (f :: t) d = 
		if MEM d (list_pairs f) then
			split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f)) ++ t
		else
			f :: split_list_hyp t d`".


"let list_hyp_diag = new_definition `list_hyp_diag L d = (SND d, FST (prev_el (find_face L d) d))`".

(* SplitListHyp *)
Section SplitListHyp.

Implicit Type d: `:A#A`.

Lemma rot_list_pairs s n: `rot n (list_pairs s) = list_pairs (rot n s)`.
Proof. by rewrite list_pairs rot_zip ?size_rot // rot_rot -list_pairs. Qed.

Lemma list_pairs_rot s n: `perm_eq (list_pairs (rot n s)) (list_pairs s)`.
Proof. by rewrite -rot_list_pairs perm_eq_rot. Qed.

Lemma split_list_hyp_alt L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list L d and
	         n = indexl (find_pair_list L d) L in
	split_list_hyp L d = take n L ++ 
		(split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f))) ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  rewrite Seq.index_head take cat add0n drop1 behead.
  by rewrite split_list_hyp mem_d.
move => mem_dt.
rewrite split_list_hyp mem_d /= Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma d_not_in_dart_split_eq L d: `~(MEM d (list_of_darts L)) ==> split_list_hyp L d = L`.
Proof.
rewrite mem_list_of_darts NOT_EXISTS_THM negb_and.
elim: L => [|h t Ih]; rewrite split_list_hyp // => mem_d.
move: (mem_d h); rewrite "GEN_ALL MEM" /= Ih // => x.
move: (mem_d x); rewrite "GEN_ALL MEM" negb_or.
by case => ->.
Qed.


Lemma find_pair_list_empty L d: `find_pair_list L d = [] <=> ~(MEM d (list_of_darts L))`.
Proof.
elim: L => [| h t Ih]; rewrite find_pair_list ?list_of_darts_nil ?MEM //.
rewrite list_of_darts_cons mem_cat negb_or.
case mem_d: `MEM d _` => /=; last by rewrite Ih.
rewrite -implybF => h_eq.
by move: mem_d; rewrite h_eq list_pairs zip MEM.
Qed.


Lemma list_eq_cat_find_pair_list L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list L d and
	         n = indexl (find_pair_list L d) L in
	L = take n L ++ [f] ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  by rewrite Seq.index_head take cat add0n drop1 behead cat1s.
move => mem_dt; rewrite {1}Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop !cat.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma list_eq_cat_list_diag f d: `MEM d (list_pairs f) /\ 2 <= sizel f
	==> (let k = indexl d (list_pairs f) and
	     	y = FST (prev_el (list_pairs f) d) in
			rot k f = [FST d] ++ belast (SND d) (dropl 2 (rot k f)) ++ [y])`.
move => [mem_d f_size]; "CONV_TAC let_CONV".
set k := `indexl d _`.
set y := `FST (_1 _2 d)`.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
apply: (eq_from_nth y); rewrite size_rot !size_cat !size1 size_belast size_drop size_rot.
split => [|i]; first by move: f_size; arith.
have size_ineqs: `2 <= sizel f /\ 1 < sizel f /\ 0 < sizel f /\ k <= sizel f /\ 0 < sizel f - 1 /\ 1 <= sizel f`.
  by move: k_lt f_size; arith.
case: i => [_ | i].
  rewrite nth_rot // addn0 MOD_LT // cat1s nth.
  move: (nth_index `y,y` mem_d).
  by rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => ->.
case size_eq: `sizel f = 2` => /=.
  rewrite drop_oversize ?size_rot size_eq ?leqnn // belast !cat nth => i_lt.
  have ->: `i = 0` by move: i_lt; arith.
  rewrite nth nth_rot -?ONE //.
  rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
  rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
  rewrite list_pairs nth_zip ?size_rot // FST size_eq.
  by have ->: `2 - 1 + k = k + 1` by arith.
have size_ineqs2: `0 < sizel f - 2 /\ 2 < sizel f` by move: size_eq f_size; arith.
case: i => [_ | i].
  rewrite cat1s nth -ONE nth_rot // nth_cat size_belast size_drop size_rot size_ineqs2 /=.
  rewrite nth0 head_belast ?size_drop ?size_rot //.
  move: (nth_index `y,y` mem_d).
  rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => <-.
  by rewrite addnC nth_rot.
move => i_lt; rewrite cat1s nth.
case i_lt2: `SUC i < sizel f - 2` => /=.
  rewrite -{1}(cat_take_drop `2`) nth_cat size_take size_rot size_ineqs2 /=.
  have -> /=: `SUC (SUC i) < 2 <=> F` by arith.
  have ->: `SUC (SUC i) - 2 = i` by arith.
  rewrite nth_cat size_belast size_drop size_rot i_lt2 /=.
  by rewrite nth_belast ?succnK ?eqS0 // size_drop size_rot.
have ->: `SUC i = sizel f - 2` by move: i_lt2 i_lt; arith.
rewrite nth_cat size_belast size_drop size_rot ltnn /= subnn nth.
rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
rewrite list_pairs nth_zip ?size_rot // FST.
by have ->: `k + SUC (sizel f - 2) = sizel f - 1 + k` by move: f_size; arith.
Qed.


Lemma split_list_explicit L d: `let f = find_pair_list L d in
	(let y = FST (prev_el (list_pairs f) d) and
	     k = indexl d (list_pairs f) in
	3 < sizel f
	==> split_list_face (rotr 1 (rot k f)) 
		= [[y; FST d; SND d]; [y; SND d] ++ dropl 3 (rotr 1 (rot k f))]
	/\ perm_eq (list_of_darts (split_list_face (rotr 1 (rot k f)))) 
		([list_hyp_diag L d; e_list L (list_hyp_diag L d)] ++ list_pairs f))`.
do !"CONV_TAC let_CONV".
case mem_d: `MEM d (list_of_darts L)` => /=; last first.
  move: mem_d; rewrite -find_pair_list_empty => ->.
  by rewrite size_nil; arith.
move => f_size.
set f := `find_pair_list L d`.
set y := `FST _`.
set k := `indexl d _`.
set f' := `rotr 1 _`.
have := "let_RULE list_eq_cat_list_diag" d f; "ANTS_TAC".
  by rewrite -{1}f_def -dart_in_find_pair_list mem_d; move: f_size; arith.
rewrite list_hyp_diag e_list /= find_face_alt f_def y_def k_def => rot_eq.
move/(congr1 `rotr 1`): (rot_eq); rewrite catA cats1 rotr1_rcons -cat1s catA cat1s f'_def EQ_SYM_EQ => f'_eq.
have eqX: `belast (SND d) (dropl 2 (rot k f)) = SND d :: dropl 3 f'`.
  have: `1 <= sizel (dropl 2 (rot k f))` by rewrite size_drop size_rot; move: f_size; arith.
  rewrite -f'_eq; case: `dropl 2 (rot k f)` => [|h t]; first by rewrite size_nil; arith.
  rewrite belast -(cat1s `SND d`) catA cats1 !rcons drop_size_cat ?cat //.
  by rewrite !size_cons size_nil; arith.
have h1: `_1 = _2`.
  rewrite split_list_face -{1}f'_def size_rotr size_rot leqNgt f_size /=.
  congr `[_1; _2]`.
    by rewrite -f'_eq eqX -(cat1s `SND d`) catA cats1 !rcons take_size_cat // !size_cons size_nil; arith.
  rewrite -f'_eq eqX drop_size_cat ?(size_cons, size_nil); first by arith.
  rewrite -{1}(cat1s y) -catA cat1s "GEN_ALL HD".
  by rewrite -{2}(cat1s `SND d`) catA drop_size_cat !cat // !size_cons size_nil; arith.
rewrite h1 /= !list_of_darts_cons list_of_darts_nil cats0 cat.
rewrite 2!list_pairs !rot1_cons !rcons cat1s rcons !zip.
rewrite perm_catC -cat1s perm_catC -cat1s -(cat1s `FST d,SND d`).
rewrite !catA perm_catC -!catA (cat1s `SND d,y`) !catA perm_catC perm_cat2l.
apply: (perm_eq_trans `list_pairs (rot k f)`).
rewrite list_pairs_rot andbT rot_eq eqX cat1s.
rewrite list_pairs rot1_cons cat rcons zip rcons_cat !rcons.
rewrite perm_catC cat1s perm_cons.
rewrite -(cat1s y `[FST d]`) -[`SND d :: _1 ++ [y]`]cat1s !catA zip_cat.
  by rewrite !size_cat !size_cons addnC.
by rewrite cat1s !cats1 !zip cats1 // perm_eq_refl.
Qed.


Lemma darts_of_list_split L d: `3 < sizel (find_pair_list L d)
	==> perm_eq (list_of_darts (split_list_hyp L d))
		   ([list_hyp_diag L d; e_list L (list_hyp_diag L d)] ++ list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
have mem_d: `MEM d (list_of_darts L)`.
  by apply: contraLR f_size; rewrite -find_pair_list_empty => ->; rewrite size_nil; arith.
rewrite "let_RULE split_list_hyp_alt" // {4}("let_RULE list_eq_cat_find_pair_list" L d) //.
have [split_eq darts_perm] := "let_RULE split_list_explicit" f_size.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_catCA perm_cat2l catA perm_cat2r.
by rewrite perm_eq_sym list_of_darts_cons list_of_darts_nil cats0 darts_perm.
Qed.


Lemma darts_of_list_split_same L d: `sizel (find_pair_list L d) <= 3
	==> perm_eq (list_of_darts (split_list_hyp L d)) (list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
case mem_d: `MEM d (list_of_darts L)` => /=; last first.
  by rewrite d_not_in_dart_split_eq // perm_eq_refl.
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_cat2l perm_cat2r.
rewrite split_list_face -f'_def size_rotr size_rot f_size /=.
set k := `indexl d _`.
rewrite !list_of_darts !"GEN_ALL foldr" /= !cats0 rotr size_rot -!rot_list_pairs.
apply: (perm_eq_trans `rot k _`).
by rewrite !(perm_eq_rot, perm_eq_sym).
Qed.


Lemma list_of_elements_split L d: `perm_eq (list_of_elements L) (list_of_elements (split_list_hyp L d))`.
Proof.
apply uniq_perm_eq; rewrite !uniq_list_of_elements /= => i.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" mem_d).
set f := `find_pair_list L d`.
set n := `indexl f L`.
rewrite !list_of_elements !flatten_cat !mem_undup !mem_cat.
apply: orb_id2l => _; apply: orb_id2r => _.
rewrite flatten_cons flatten0 cats0.
rewrite split_list_face size_rotr size_rot.
case f_size: `_ <= 3` => /=; rewrite !flatten_cons flatten0 cats0.
  by rewrite mem_rotr mem_rot.
set s := `rotr 1 _`.
have [k ->]: `?k. s = rot k f`.
  rewrite -s_def rotr size_rot.
  have [k eq] := rot_rot_eq_rot f `sizel f - 1` `indexl d (list_pairs f)`.
  by exists k.
have ineqs: `3 < sizel f /\ 2 < 3` by move: f_size; arith.
rewrite -(mem_rot k f); split.
  rewrite -{1}(cat_take_drop `3`) !mem_cat MEM.
  case => /= mem_i; right; right.
  rewrite -(cat_take_drop `3` `rot k f`) drop_cat size_take size_rot ineqs /= ineqs /=.
  by rewrite mem_cat mem_i.
rewrite mem_cat MEM; case => [/mem_take | [-> | /mem_drop]] //.
have: `0 < sizel (rot k f)` by rewrite size_rot; move: ineqs; arith.
by case: `rot k f` => [|h t]; rewrite ?(size_nil, ltn0) // "GEN_ALL HD" MEM.
Qed.
  

Lemma mem_list_hyp_diag L d: `MEM d (list_of_darts L) /\ 
	(sizel (find_pair_list L d) = 1 \/ sizel (find_pair_list L d) = 3)
	==> MEM (list_hyp_diag L d) (find_face L d)`.
Proof.
move => [mem_d size_eq]; rewrite list_hyp_diag find_face_alt.
set f := `find_pair_list L d`.
set k := `indexl d (list_pairs f)`.
set y := `FST _`.
have mem_d2: `MEM d (list_pairs f)` by rewrite -f_def -dart_in_find_pair_list.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
case: size_eq => size_eq.
  move: size_eq; rewrite size1_eq => [] [x] f_eq.
  move: mem_d2; rewrite -y_def f_eq list_pairs rot1_cons rcons !zip mem_seq1 => ->.
  by rewrite SND prev_el Seq.index_head /= !last FST mem_seq1.
rewrite -(perm_eq_mem (list_pairs_rot f k)).
have size_ineq: `2 <= sizel f` by move: size_eq; arith.
have := "let_RULE list_eq_cat_list_diag" mem_d2 size_ineq.
rewrite k_def y_def => ->.
set l := `dropl 2 _`.
suff ->: `belast (SND d) l = [SND d]`.
  by rewrite !cat list_pairs rot1_cons !rcons !zip !MEM.
have: `sizel l = 1` by rewrite -l_def size_drop size_rot size_eq; arith.
by rewrite size1_eq => [] [x] ->; rewrite !belast.
Qed.


Lemma good_list_split L d: `good_list L /\
	(sizel (find_pair_list L d) <= 3 \/
		~(MEM (list_hyp_diag L d) (list_of_darts L)) 
		/\ ~(FST (list_hyp_diag L d) = SND (list_hyp_diag L d)))
	==> good_list (split_list_hyp L d)`.
Proof.
move => [goodL hyp].
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have := "let_RULE split_list_hyp_alt" mem_d.
have := "let_RULE list_eq_cat_find_pair_list" mem_d.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
move: (goodL); rewrite !good_list => [] [uniqL] [allL] symL L_eq split_eq.
case f_size: `sizel (find_pair_list L d) <= 3` => /=.
  have perm_darts := "let_RULE darts_of_list_split_same" f_size.
  rewrite (perm_eq_uniq perm_darts) uniqL andTb; split; last first.
    by move => y; rewrite !(perm_eq_mem perm_darts) => /symL.
  rewrite split_eq split_list_face -{1}f'_def size_rotr size_rot -f_def f_size /=.
  move: allL; rewrite {1}L_eq !all_cat !all /= => [] [_] [f_neq] _.
  by rewrite -size_eq0 -f'_def size_rotr size_rot size_eq0.
move: hyp; rewrite -f_def f_size /= => [] [n_mem] neq.
rewrite NOT_LE in f_size.
have perm_darts := "let_RULE darts_of_list_split" f_size.
split.
  rewrite (perm_eq_uniq perm_darts) !cat !"GEN_ALL uniq" uniqL MEM andbT; split; last first.
    by apply: contra n_mem => /symL; rewrite e_list SND FST -pair_expand.
  rewrite n_mem orbF.
  by apply: contra neq; rewrite e_list {1}pair_expand PAIR_EQ => ->.
split.
  move: allL; rewrite {1}L_eq split_eq !all_cat split_list_face.
  have f'_size: `3 < sizel f'` by rewrite -f'_def size_rotr size_rot -f_def f_size.
  rewrite leqNgt f'_size /= !all /= => _.
  by rewrite -!size_eq0 size_take f'_size /= size_cons; arith.
move => y; rewrite !(perm_eq_mem perm_darts) !mem_cat !MEM /= e_list.
set h := `list_hyp_diag L d`.
case; last by move/symL => ->.
by case => ->.
Qed.


Lemma list_of_darts_perm L1 L2: `perm_eq L1 L2 ==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
move => perm; rewrite !list_of_darts_alt !list_of_faces.
by rewrite perm_eq_flatten -map_MAP Seq2.perm_eq_map.
Qed.


Lemma good_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1 ==> good_list L2`.
Proof.
rewrite !good_list => [] [perm] [uniq1] [all1] sym1.
have perm_darts := list_of_darts_perm perm.
rewrite -(perm_eq_uniq perm_darts) uniq1 -(Seq2.all_perm_eq perm) all1 !andTb.
by move => d; rewrite -!(perm_eq_mem perm_darts) => /sym1.
Qed.


Lemma perm_eq_set_of_list_eq s1 s2: `perm_eq s1 s2 ==> set_of_list s1 = set_of_list s2`.
Proof. by rewrite EXTENSION !IN_SET_OF_LIST => perm x; rewrite (perm_eq_mem perm). Qed.


Lemma hypermap_of_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1
	==> hypermap_of_list L1 = hypermap_of_list L2`.
Proof.
move => [perm good1].
have good2 := good_list_perm perm good1.
have perm_darts := list_of_darts_perm perm.
have mem_eq := perm_eq_mem perm_darts.
rewrite !hypermap_of_list; congr `hypermap _`.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f1 (darts_of_list L1) = res f2 (darts_of_list L2)`.
  rewrite FUN_EQ_THM => eq d.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_d: `MEM d _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => d mem_d; rewrite !e_list.
have face_eq d: `MEM d (list_of_darts L1) ==> find_face L2 d = find_face L1 d`.
  move => mem_d; rewrite !find_face_alt; congr `list_pairs _`.
  move: (good1); rewrite good_list => [] [uniq1] _.
  apply: (find_pair_list_unique uniq1).
  rewrite -find_face_alt -dart_in_face -mem_eq mem_d andbT.
  by rewrite (perm_eq_mem perm) mem_find_pair_list -mem_eq.
split; rewrite !(n_list_ext, f_list_ext); apply: res_eq => d mem_d.
  by rewrite !n_list face_eq // !e_list.
by rewrite !f_list face_eq.
Qed.


Lemma find_face_cons h t d: 
	`find_face (h :: t) d = if MEM d (list_pairs h) then (list_pairs h) else find_face t d`.
Proof. by rewrite !find_face !list_of_faces MAP find_list. Qed.


Lemma find_face_rot L1 L2 d: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> ?n. find_face L2 d = rot n (find_face L1 d)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 //=.
  by rewrite find_face list_of_faces MAP find_list rot_nil.
move => [] [n] h2_eq all2; rewrite !find_face_cons.
case mem_d: `MEM d (list_pairs h1)` => /=.
  by exists n; rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d /= rot_list_pairs.
move: (Ih all2) => [m] eq; exists m.
by rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d.
Qed.


Lemma rot_list_of_darts_perm L1 L2: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 // ?list_of_darts_nil ?perm_eq_refl //=.
move => [] [n h2_eq] all2.
rewrite !list_of_darts_cons Seq2.perm_eq_cat Ih //.
by rewrite h2_eq perm_eq_sym list_pairs_rot.
Qed.


Lemma rot_hypermap_of_list_eq L1 L2: 
	`ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2 /\ uniq (list_of_darts L1)
	==> hypermap_of_list L2 = hypermap_of_list L1`.
Proof.
move => [all2 uniq1].
rewrite !hypermap_of_list; congr `hypermap _`.
have perm_darts := rot_list_of_darts_perm all2.
have mem_eq := perm_eq_mem perm_darts.
have face_eq := find_face_rot all2.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f2 (darts_of_list L2) = res f1 (darts_of_list L1)`.
  rewrite FUN_EQ_THM => eq y.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_y: `MEM y _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => y mem_y; rewrite !e_list.
split.
  rewrite !n_list_ext; apply: res_eq => d mem_d.
  move: (face_eq d) => [n] f_eq.
  rewrite !n_list f_eq prev_el_rot_eq ?e_list //.
  by rewrite uniq_find_face // -dart_in_face.
rewrite !f_list_ext; apply: res_eq => d mem_d.
move: (face_eq d) => [n] f_eq.
by rewrite !f_list f_eq next_el_rot_eq // uniq_find_face.
Qed.



Lemma hypermap_of_split_list_eq3 L d: `sizel (find_face L d) <= 3 /\ uniq (list_of_darts L)
	==> hypermap_of_list (split_list_hyp L d) = hypermap_of_list L`.
Proof.
move => [f_size uniq_darts].
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have all2_refl: `!s:((A)list)list. ALL2 (\f1 f2. ?n. f2 = rot n f1) s s`.
  by elim => [|h t Ih]; rewrite ALL2 //= Ih andbT; exists `0`; rewrite rot0.
apply: (rot_hypermap_of_list_eq uniq_darts).
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
move: f_size; rewrite find_face_alt size_list_pairs.
set f := `find_pair_list L d`.
set n := `indexl f L`.
move => f_size.
rewrite split_list_face size_rotr size_rot f_size /=.
rewrite !ALL2_cat // ?size_cons // !all2_refl /= !ALL2 /= rotr.
set i := `sizel _ - 1`; set j := `indexl d _`.
by move: (rot_rot_eq_rot i j f) => [k] ->; exists k.
Qed.


Lemma e_list_eq L1 L2: `e_list L1 = e_list L2`.
Proof. by rewrite FUN_EQ_THM !e_list. Qed.


Lemma next_el_rotr_eq s n: `uniq s ==> next_el (rotr n s) = next_el s`.
Proof. by move/next_el_rot_eq => eq; rewrite rotr eq. Qed.


Lemma prev_el_rotr_eq s n x: `MEM x s /\ uniq s ==> prev_el (rotr n s) x = prev_el s x`.
Proof. by move => [mem_x uniq_s]; rewrite rotr prev_el_rot_eq. Qed.


Lemma rotr_list_pairs s n: `rotr n (list_pairs s) = list_pairs (rotr n s)`.
Proof. by rewrite rotr rot_list_pairs size_list_pairs -rotr. Qed.


Lemma find_face_eq L d f: `uniq (list_of_darts L) /\ MEM d (list_of_darts L)
	==> (find_face L d = f <=> MEM f (list_of_faces L) /\ MEM d f)`.
Proof.
move => [uniqL mem_d]; split => [<- | ].
  by rewrite -dart_in_face mem_find_face.
rewrite list_of_faces -map_MAP mapP => [] [] [s] [mem_s] -> /(find_pair_list_unique uniqL) eq.
by rewrite find_face_alt -eq.
Qed.

"let HD = GEN_ALL HD".

Lemma next_el_hd h1 h2 t: `next_el (h1 :: (h2 :: t)) h1 = h2`.
Proof.
rewrite next_el Seq.index_head !size_cons.
case eq: `0 = _` => /=; first by move: eq; arith.
by rewrite addn1 !nth.
Qed.


Lemma next_el_cons_hd h t: `0 < sizel t ==> next_el (h :: t) h = HD t`.
Proof.
case: t => [|h2 t]; first by rewrite size_nil ltn0.
by rewrite next_el_hd HD.
Qed.


Lemma next_el_belast_hd h t: `1 < sizel t ==> next_el (belast h t) h = HD t`.
Proof.
case: t => [|h2 t]; first by rewrite size_nil ltn0.
rewrite belast HD size_cons ONE ltSS.
case: t => [|h3 t]; first by rewrite size_nil ltn0.
by rewrite belast next_el_hd.
Qed.


Lemma next_el_last x0 s: `0 < sizel s /\ uniq s ==> next_el s (last x0 s) = HD s`.
Proof.
case: s => [|h t [_] uniq_s]; first by rewrite size_nil ltn0.
by rewrite next_el last index_last // size_cons succnK /= head HD.
Qed.


Lemma prev_el_hd x0 s: `0 < sizel s ==> prev_el s (HD s) = last x0 s`.
Proof.
case: s => [|h t _]; rewrite ?size_nil ?ltn0 // HD.
by rewrite prev_el Seq.index_head /= !last.
Qed.


Lemma last_eq a b s: `0 < sizel s ==> last a s = last b s`.
Proof. by case: s => [|h t _]; rewrite ?size_nil ?ltn0 // !last. Qed.


Lemma last_drop x0 s n: `n < sizel s ==> last x0 (dropl n s) = last x0 s`.
Proof.
elim: s n => [|h t Ih [|n]]; rewrite (size_nil, size_cons) ?ltn0 // drop // ltSS => n_lt.
by rewrite Ih // last (last_eq x0 h) //; move: n_lt; arith.
Qed.


Lemma rotr1_eq_cons h t: `rotr 1 (h :: t) = last h t :: belast h t`.
Proof. by rewrite {1}lastI rotr1_rcons. Qed.


Lemma head_HD x0 s: `0 < sizel s ==> headl x0 s = HD s`.
Proof. by case: s => [|h t _]; rewrite (size_nil, head) (ltn0, HD). Qed.


Lemma f_split_list L d: `let L2 = split_list_hyp L d and g = list_hyp_diag L d and f = find_face L d in
		good_list L /\ 3 < sizel f
		/\ ~(MEM g (list_of_darts L)) 
		/\ ~(FST g = SND g)
	==> f_list L2 d = g
	/\ f_list L2 g = prev_el f d
	/\ f_list L2 (e_list L g) = f_list L d
	/\ f_list L2 (prev_el f (prev_el f d)) = e_list L g
	/\ (!x. MEM x (list_of_darts L2)
		/\ ~(x = d \/ x = g \/ x = e_list L g \/ x = prev_el f (prev_el f d))
			==> f_list L2 x = f_list L x)`.
Proof.
"CONV_TAC let_CONV".
move => [goodL] [f_size] [g_n_mem] g_neq.
have size_gt3: `3 < sizel (find_pair_list L d)`.
  by move: f_size; rewrite find_face_alt size_list_pairs.
have mem_d: `MEM d (list_of_darts L)`.
  apply: contraLR size_gt3; rewrite -find_pair_list_empty => ->.
  by rewrite size_nil; arith.
have := darts_of_list_split size_gt3.
have := "let_RULE split_list_hyp_alt" mem_d.
have := "let_RULE split_list_explicit" size_gt3.
have := good_list_split goodL d; "ANTS_TAC" => [//| goodL2].
rewrite -!find_face_alt.
set s := `find_pair_list L d`.
set n := `indexl s _`.
set k := `indexl d _`.
set s' := `rotr 1 _`.
set L2 := `split_list_hyp L d`.
set g := `list_hyp_diag L d`.
set f := `find_face L d`.
set s1 := `FST _ :: _2`.
set s2 := `cat _1 _2`.
move => [split_s'_eq darts_s'] L2_eq dartsL2.
move: (goodL2); rewrite good_list => [] [uniqL2] _.
move: (goodL); rewrite good_list => [] [uniqL] _.
have fs_eq: `list_pairs s = f` by rewrite -s_def -f_def find_face_alt.
have s1_pairs_eq: `list_pairs s1 = [prev_el f d; d; g]`.
  rewrite -s1_def list_pairs rot1_cons !rcons !zip.
  rewrite -pair_expand -{2}f_def -list_hyp_diag g_def; congr `[_; d; g]`.
  rewrite eq_sym {1}pair_expand PAIR_EQ /=.
  move: (prev_el_list_pairs_general `FST d` `SND d` s); "ANTS_TAC".
    by rewrite -pair_expand fs_eq -f_def -dart_in_face.
  by rewrite -pair_expand fs_eq => [] [z] ->.
have uniq_f: `uniq f` by rewrite -f_def uniq_find_face.
have s12_mem: `MEM s1 L2 /\ MEM s2 L2`.
  by rewrite L2_eq !mem_cat split_s'_eq !MEM.
have s12_pairs_mem: `MEM (list_pairs s1) (list_of_faces L2) /\ MEM (list_pairs s2) (list_of_faces L2)`.
  by rewrite list_of_faces -map_MAP !mapP; split; [exists s1 | exists s2].
have s12_pairs_uniq: `uniq (list_pairs s1) /\ uniq (list_pairs s2)`.
  by split; apply: (uniq_face goodL2).
have next_el_fs' x: `next_el f x = next_el (list_pairs s') x`.
  rewrite -s'_def -rotr_list_pairs -rot_list_pairs.
  by rewrite next_el_rotr_eq ?rot_uniq // next_el_rot_eq.
have prev_el_fs' x: `MEM x f ==> prev_el f x = prev_el (list_pairs s') x`.
  move => mem_x; rewrite -s'_def -rotr_list_pairs -rot_list_pairs.
  by rewrite prev_el_rotr_eq ?rot_uniq ?mem_rot // prev_el_rot_eq.
have mem_f_darts x: `MEM x f ==> MEM x (list_of_darts L)`.
  by rewrite -f_def => /mem_find_face_imp_mem_darts.
have mem_df: `MEM d f` by rewrite -f_def -dart_in_face.
have p_eq_f_s': `perm_eq (list_pairs s') f`.
  rewrite -s'_def -fs_eq -rotr_list_pairs -rot_list_pairs rotr.
  set r := `sizel _ - 1`.
  have [i ->] := rot_rot_eq_rot `list_pairs s` r k.
  by rewrite perm_eq_rot.
have size_s': `sizel s' = sizel s` by rewrite -s'_def size_rotr size_rot.
have s'_eq1: `s' = s1 ++ dropl 3 s'`.
  move: split_s'_eq; rewrite split_list_face size_s' leqNgt size_gt3 /=.
  by rewrite -{4}(cat_take_drop `3` s') "injectivity \"list\"" => ->.
have s'_pairs_eq: `list_pairs s' = prev_el f d :: d :: dropl 2 (list_pairs s')`.
  rewrite -{1}(cat_take_drop `2`) -cat1s -(cat1s d) catA cat1s; congr `_1 ++ _2` => //.
  rewrite s'_eq1 -s1_def !cat list_pairs rot1_cons !rcons !zip TWO ONE !take.
  move: (prev_el_list_pairs_general `FST d` `SND d` s); "ANTS_TAC".
    by rewrite -pair_expand fs_eq -f_def -dart_in_face.
  by move => [z]; rewrite -pair_expand fs_eq => ->.
have s2_pairs_eq: `list_pairs s2 = e_list L g :: dropl 2 (list_pairs s')`.
  rewrite s'_eq1 -s1_def -s2_def !cat !list_pairs !rot1_cons !rcons !zip.
  by rewrite TWO ONE !drop -g_def list_hyp_diag e_list /= f_def.
have size_uneqs: `0 < sizel (dropl 2 (list_pairs s')) /\ 1 < sizel (dropl 2 (list_pairs s')) 
	/\ 0 < sizel (list_pairs s') /\ 2 < sizel (list_pairs s')`.
  by rewrite size_drop size_list_pairs size_s'; move: size_gt3; arith.
have size_ineqs_s2: `sizel (list_pairs s2) = sizel (list_pairs s') - 1 /\ 0 < sizel (list_pairs s2)`.
  by rewrite s2_pairs_eq size_cons size_drop size_list_pairs size_s'; move: size_gt3; arith.
have last_s': `last d (list_pairs s') = prev_el f (prev_el f d)`.
  by rewrite -prev_el_hd // {2}s'_pairs_eq "GEN_ALL HD" -prev_el_fs' // mem_prev_el.
have last_s2: `last d (list_pairs s2) = prev_el f (prev_el f d)`.
  by rewrite -last_s' s2_pairs_eq last last_drop //; apply last_eq.
have memL2 x: `MEM x (list_of_darts L2) <=> x = g \/ x = e_list L g \/ MEM x (list_of_darts L)`.
  by rewrite (perm_eq_mem dartsL2) mem_cat !MEM orbF !orbA.
have find_s1: `find_face L2 d = list_pairs s1 /\ find_face L2 g = list_pairs s1
		/\ find_face L2 (prev_el f d) = list_pairs s1`.
  rewrite !find_face_eq ?(uniqL2, memL2, mem_d, s12_pairs_mem) /= ?mem_f_darts ?mem_prev_el //.
  by rewrite s1_pairs_eq !MEM.
have find_s2: `find_face L2 (e_list L g) = list_pairs s2 
	/\ find_face L2 (prev_el f (prev_el f d)) = list_pairs s2`.
  rewrite !find_face_eq ?(uniqL2, memL2) /= ?mem_f_darts ?mem_prev_el //.
  rewrite s12_pairs_mem s2_pairs_eq MEM /= -last_s' -(last_drop d `2`) //.
  by rewrite (last_eq d `e_list L g`) // mem_last.
rewrite !f_list !find_s1 !find_s2.
split.
  by rewrite -(next_el_rot_eq `1`) // s1_pairs_eq rot1_cons !rcons next_el_hd.
split.
  rewrite -(next_el_rotr_eq `1`) // s1_pairs_eq.
  by rewrite -cat1s -(cat1s d) catA cats1 rotr1_rcons cat1s next_el_hd.
split.
  rewrite s2_pairs_eq next_el_cons_hd // f_def next_el_fs'.
  rewrite -(next_el_rot_eq `1`) ?(perm_eq_uniq p_eq_f_s') //.
  rewrite {2}s'_pairs_eq rot1_cons rcons next_el_cons_hd ?size_rcons ?gtS0 //.
  by rewrite headI HD head_HD.
split.
  by rewrite -last_s2 next_el_last // s2_pairs_eq HD.
rewrite !negb_or => x [mem_x] x_neq.
move: mem_x; rewrite memL2 !x_neq !orFb => mem_x.
case mem_x_f: `MEM x f` => /=; last first.
  congr `next_el _ x`.
  rewrite find_face_eq // -dart_in_face mem_x andbT.
  have := "let_RULE list_eq_cat_find_pair_list" mem_d.
  rewrite s_def n_def => L_eq.
  move: (mem_find_face mem_x); rewrite {2}L_eq L2_eq !list_of_faces -map_MAP !mapP !mem_cat.
  move => [l] [mem_l] eq; exists l.
  case: mem_l => [-> | [|->]] //; rewrite mem_seq1 => l_eq.
  by move: eq mem_x_f; rewrite l_eq fs_eq => <-; rewrite -dart_in_face.
have ->: `find_face L x = f`.
  rewrite -f_def !find_face_alt eq_sym; congr `_1 _2` => //.
  by apply: (find_pair_list_unique uniqL); rewrite mem_find_pair_list.
case x_eq: `x = prev_el f d` => /=.
  by rewrite x_eq find_s1 s1_pairs_eq next_el_hd next_prev_id.
have mem_x_s2: `MEM x (list_pairs s2)`.
  move: (iffRL (perm_eq_mem darts_s' x)); rewrite mem_cat mem_x_f /=.
  rewrite split_s'_eq !list_of_darts_cons list_of_darts_nil cats0 mem_cat.
  by case => //; rewrite s1_pairs_eq !MEM.
have ->: `find_face L2 x = list_pairs s2` by rewrite find_face_eq // s12_pairs_mem.
rewrite next_el_fs' next_el.
set i := `indexl x _`.
have i_ineqs: `1 <= i /\ i < sizel (list_pairs s2) - 1`.
  move: (mem_x_s2); rewrite -index_mem i_def.
  suff: `~(i = 0) /\ ~(i = sizel (list_pairs s2) - 1)` by arith.
  apply: contraLR (x_eq, x_neq); rewrite !negb_and !negbK.
  case => i_eq; move: (nth_index d mem_x_s2); rewrite i_def i_eq.
    by rewrite s2_pairs_eq nth => ->.
  have i_eq2: `i = indexl (last d (list_pairs s2)) (list_pairs s2)`.
    by rewrite s2_pairs_eq last index_last -?s2_pairs_eq // i_eq size_drop size_ineqs_s2; arith.
  rewrite -i_eq i_eq2 -last_s2 nth_index //.
  by rewrite s2_pairs_eq last mem_last.
have -> /=: `~(i = sizel (list_pairs s2) - 1)` by move: i_ineqs; arith.
rewrite s2_pairs_eq addn1 nth eq_sym next_el.
suff ->: `indexl x (list_pairs s') = i + 1`.
  have -> /=: `~(i + 1 = sizel (list_pairs s') - 1)` by move: i_ineqs; rewrite size_ineqs_s2; arith.
  by rewrite !addn1 {1}s'_pairs_eq !nth.
suff nth_eq: `nth x (list_pairs s') (i + 1) = x`.
  rewrite -nth_eq index_uniq // (perm_eq_uniq p_eq_f_s') uniq_f.
  by move: i_ineqs; rewrite size_ineqs_s2; arith.
move: (nth_index d mem_x_s2); rewrite i_def addn1 s'_pairs_eq nth s2_pairs_eq.
case: i i_ineqs => [|j j_ineq]; first by arith.
rewrite !nth => {2}<-.
by apply set_nth_default; move: j_ineq; rewrite size_drop size_ineqs_s2; arith.
Qed.


End SplitListHyp.

(* MoreIso *)
Section MoreIso.

Variable H: `:(A)hypermap`.
Variable G: `:(B)hypermap`.
Variable f: `:A->B`.

Lemma hyp_iso_edge_face: `hyp_iso f (H,G) <=> BIJ f (dart H) (dart G) /\
	(!x. x IN dart H ==> edge_map G (f x) = f (edge_map H x)
			 /\ face_map G (f x) = f (face_map H x))`.
Proof.
rewrite hyp_iso; apply: andb_id2l => _; split => eq x x_in; rewrite !eq //=.
rewrite Hypermap.inverse2_hypermap_maps o_THM.
have hypG := Hypermap.hypermap_lemma G.
rewrite (PERMUTES_INVERSE_EQ `dart G`) // eq ?Hypermap.lemma_dart_invariant //.
rewrite EQ_SYM_EQ (PERMUTES_INVERSE_EQ `dart G`) // eq ?Hypermap.lemma_dart_invariant //.
by rewrite -(o_THM `edge_map H`) -(o_THM `face_map H`) Hypermap.hypermap_cyclic I_THM.
Qed.


Lemma hyp_iso_edge_node: `hyp_iso f (H,G) <=> BIJ f (dart H) (dart G) /\
	(!x. x IN dart H ==> edge_map G (f x) = f (edge_map H x)
			 /\ node_map G (f x) = f (node_map H x))`.
Proof.
rewrite hyp_iso; apply: andb_id2l => _; split => eq x x_in; rewrite !eq //=.
rewrite Hypermap.inverse2_hypermap_maps o_THM.
have hypG := Hypermap.hypermap_lemma G.
rewrite (PERMUTES_INVERSE_EQ `dart G`) // eq ?Hypermap.lemma_dart_invariant //.
rewrite EQ_SYM_EQ (PERMUTES_INVERSE_EQ `dart G`) // eq ?Hypermap.lemma_dart_invariant //.
by rewrite -(o_THM `node_map H`) -(o_THM `edge_map H`) Hypermap.hypermap_lemma I_THM.
Qed.


Hypothesis f_iso: `hyp_iso f (H,G)`.

Lemma hyp_iso_inverse_comm x: `x IN dart H
	==> inverse (edge_map G) (f x) = f (inverse (edge_map H) x)
	 /\ inverse (node_map G) (f x) = f (inverse (node_map H) x)
	 /\ inverse (face_map G) (f x) = f (inverse (face_map H) x)`.
Proof.
move => x_in.
rewrite !(PERMUTES_INVERSE_EQ `dart G`) ?Hypermap.hypermap_lemma //.
rewrite !(hyp_iso_comm f_iso) ?Hypermap.lemma_dart_inveriant_under_inverse_maps //.
by rewrite !(PERMUTES_INVERSES `dart H`) ?Hypermap.hypermap_lemma.
Qed.

Lemma hyp_iso_SURJ: `SURJ f (dart H) (dart G)`.
Proof.
rewrite SURJ; split => x x_in; first by rewrite (hyp_iso_dart f_iso).
by rewrite (hyp_iso_surj f_iso).
Qed.

Lemma hyp_iso_INJ: `INJ f (dart H) (dart G)`.
Proof.
rewrite INJ; split => [x x_in | x y]; first by rewrite (hyp_iso_dart f_iso).
exact: (hyp_iso_inj f_iso).
Qed.

Lemma hyp_iso_card_components x: `x IN dart H ==> 
	CARD (face H x) = CARD (face G (f x)) /\
	CARD (node H x) = CARD (node G (f x)) /\
	CARD (edge H x) = CARD (edge G (f x))`.
Proof.
move => x_in; rewrite !(iso_components f_iso) //.
rewrite !CARD_IMAGE_INJ // (EDGE_FINITE, FACE_FINITE, NODE_FINITE) andbT;
  move => a b [a_in] [b_in] eq; apply: (hyp_iso_inj f_iso eq).
(* 1 *)
by split; apply IN_TRANS; exists `face H x`; rewrite lemma_face_subset.
(* 2 *)
by split; apply IN_TRANS; exists `node H x`; rewrite lemma_node_subset.
(* 3 *)
by split; apply IN_TRANS; exists `edge H x`; rewrite lemma_edge_subset.
Qed.


End MoreIso.


(* Fan and list *)
Section FanAndList.


Lemma set_of_edge_subset V E E' x: `E SUBSET E' ==> set_of_edge x V E SUBSET set_of_edge x V E'`.
Proof. by rewrite !SUBSET !set_of_edge !inE => subE y [/subE] -> ->. Qed.

"let fan_list_nodes_iso = new_definition `fan_list_nodes_iso (f, (V,E)) x
	= FST (f (x, if set_of_edge x V E = {} then x else CHOICE (set_of_edge x V E)))`".

"let fan_list_iso = new_definition `fan_list_iso (f, (V,E)) (v,w) = 
		fan_list_nodes_iso (f, (V,E)) v, fan_list_nodes_iso (f, (V,E)) w`".

Lemma fan_list_iso_invariant F1 F2 f: 
	`fan_list_iso (fan_list_iso (f, F1), F2) = fan_list_iso (f, F1)`.
Proof.
move: F1 F2 => [V E] [V' E']; rewrite FUN_EQ_THM => [] [v w].
by rewrite !(fan_list_iso, fan_list_nodes_iso).
Qed.


Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.
Variable L: `:((A)list)list`.
Variable f: `:real^3#real^3 -> A#A`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis goodL: `good_list L`.
Hypothesis f_iso: `hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)`.

Lemma hyp_iso_eq_fan_list_iso y: `y IN dart_of_fan (V,E) ==> f y = fan_list_iso (f, (V,E)) y`.
Proof.
have [dartH mapsH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartG mapsG] := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have f_in d: `d IN dart_of_fan (V,E) ==> f d IN darts_of_list L`.
  by rewrite -dartH -dartG => d_in; rewrite (hyp_iso_dart f_iso).
case: y => [a b] ab_in.
rewrite fan_list_iso.
set h := `fan_list_nodes_iso _`.
suff [g f_eq]: `?g. !v w. (v,w) IN dart_of_fan (V,E) ==> f(v,w) = (h v:A, g (v,w):A)`.
  move: (IN_DART_OF_FAN fanV ab_in) => [v] [w] [vw_eq] vw_in.
  rewrite f_eq // PAIR_EQ /=.
  move: (hyp_iso_comm f_iso `a,b`); rewrite dartH ab_in /=.
  rewrite mapsG mapsH e_fan_pair_ext_explicit // e_list_ext res.
  rewrite -dartG (hyp_iso_dart f_iso) ?dartH //=.
  by rewrite !f_eq // 1?dart_switch // e_list SND PAIR_EQ => ->.
exists `\d. SND (f d)`.
move => v w vw_in; rewrite {1}(pair_expand `f (v,w)`) PAIR_EQ /= -h_def fan_list_nodes_iso.
case set_empty: `set_of_edge v V E = {}` => /=.
  move: vw_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
  case; first by move/(PAIR_IN_DART1_OF_FAN fanV); rewrite set_empty NOT_IN_EMPTY.
  by move => [u] [_] [eq1 eq2].
have vw_in1: `v,w IN dart1_of_fan (V,E)`.
  move: (vw_in); rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
  case => // [u] [empty] eq.
  by move: empty; rewrite -eq set_empty.
set w' := `CHOICE _`.
suff: `f (v,w') IN node G (f (v,w))`.
  rewrite Hypermap.node Hypermap.orbit_map IN_ELIM_THM /= mapsG.
  move => [n] [_] ->.
  rewrite {2}pair_expand fst_n_list_ext_power //.
  by rewrite -pair_expand -dartG (hyp_iso_dart f_iso).
rewrite (iso_components f_iso) ?dartH // FUN_IN_IMAGE.
rewrite -H_def NODE_HYPERMAP_OF_FAN_ALT // IN_ELIM_THM /=.
exists w'; split => //; rewrite -w'_def CHOICE_DEF -Ssrbool.implybF => eq.
have := PAIR_IN_DART1_OF_FAN fanV vw_in1.
by rewrite eq NOT_IN_EMPTY.
Qed.


Lemma fan_list_nodes_iso_surj: `SURJ (fan_list_nodes_iso (f,(V,E))) V (elements_of_list L)`.
Proof.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
have iso_eq := hyp_iso_eq_fan_list_iso.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
rewrite SURJ elements_of_list !IN_SET_OF_LIST !mem_list_of_elements.
split => [v | a [b]].
  move/(DART_EXISTS E) => [w] vw_in.
  exists `fan_list_nodes_iso (f,V,E) w`.
  rewrite -fan_list_iso -IN_SET_OF_LIST -darts_of_list -hypL -iso_eq //.
  by rewrite (hyp_iso_dart f_iso) hypV.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL => ab_in.
set d := `res_inv f (dart H) (a,b)`.
have := hyp_iso_dart (hyp_iso_inv f_iso) ab_in.
rewrite d_def hypV => d_in.
exists `FST d`; split.
  by rewrite (PAIR_IN_DART_OF_FAN fanV `FST d` `SND d`) -pair_expand.
suff: `f d = a,b`.
  by rewrite iso_eq // {1}(pair_expand d) fan_list_iso PAIR_EQ => ->.
by rewrite -d_def (surj_res_inv_right (hyp_iso_SURJ f_iso)).
Qed.


Lemma fan_list_nodes_to v: `v IN V ==> fan_list_nodes_iso (f,(V,E)) v IN elements_of_list L`.
Proof. by move: fan_list_nodes_iso_surj; rewrite SURJ => surj vV; rewrite surj. Qed.


Lemma fan_list_diag_eq v w: `(v,w) IN dart1_of_fan (V,E)
	==> fan_list_iso (f,(V,E)) (w, sigma_fan (vec 0) V E v w) = list_hyp_diag L (f (v,w))`.
Proof.
rewrite list_hyp_diag => vw_in1.
move: (goodL); rewrite good_list => [] [uniqL] _.
have vw_in: `v,w IN dart_of_fan (V,E)`.
  by rewrite dart_of_fan_eq IN_UNION vw_in1.
have fan_hyp := COMPONENTS_HYPERMAP_OF_FAN fanV.
have list_hyp := components_hypermap_of_list goodL.
have f_eq := hyp_iso_eq_fan_list_iso.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
set y := `FST _`.
have y_eq: `y = FST (inverse (face_map G) (f (v,w)))`.
  by rewrite list_hyp f_list_ext_inverse // res -list_hyp (hyp_iso_dart f_iso) ?fan_hyp.
rewrite f_eq // !fan_list_iso SND PAIR_EQ /= y_eq.
rewrite (hyp_iso_inverse_comm f_iso) fan_hyp //.
rewrite Hypermap_and_fan.INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /=.
set w' := `sigma_fan _ V E v w`.
by rewrite f_eq ?fan_list_iso // dart_switch in_dart1_in_dart -w'_def sigma_in_dart1.
Qed.


Hypothesis good_nodes: `good_list_nodes L`.


Lemma fan_list_nodes_iso_BIJ: `BIJ (fan_list_nodes_iso (f,(V,E))) V (elements_of_list L)`.
Proof.
rewrite -Fnjlbxs.finite_surj_eq_bij ?fan_list_nodes_iso_surj //.
rewrite (fan_imp_finite_set fanV) elements_of_list FINITE_SET_OF_LIST /=.
rewrite Seq2.card_set_of_list_uniq ?uniq_list_of_elements //.
rewrite -(iffLR (good_list_nodes_condition goodL)) //.
rewrite -number_of_nodes (iso_number_of_nodes f_iso) number_of_nodes.
have [f [inj] ->]:= NODE_SET_AS_IMAGE fanV.
by apply CARD_IMAGE_INJ; rewrite (fan_imp_finite_set fanV) /= => x y [_] [_] /inj.
Qed.


Lemma fan_list_nodes_iso_inj x y: `x IN V /\ y IN V 
	/\ fan_list_nodes_iso (f,(V,E)) x = fan_list_nodes_iso (f,(V,E)) y
	==> x = y`.
Proof.
move => [x_in] [y_in] eq.
move: fan_list_nodes_iso_BIJ; rewrite BIJ INJ => [] [] [_] inj _.
exact: inj.
Qed.



Hypothesis f_surr: `fully_surrounded (V,E)`.


Lemma iso_imp_good_conditions d: `MEM d (list_of_darts L) /\ 3 < sizel (find_face L d)
	==> ~MEM (list_hyp_diag L d) (list_of_darts L) /\
	~(FST (list_hyp_diag L d) = SND (list_hyp_diag L d))`.
Proof.
move => [mem_d f_size].
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
move: (mem_d); rewrite -IN_SET_OF_LIST -darts_of_list -hypL => d_in.
have [[v w] [d_eq vw_in]]: `?x. f x = d /\ x IN dart_of_fan (V,E)`.
  have [x [x_in f_eq]] := hyp_iso_surj f_iso d_in.
  by exists x; rewrite -hypV.
have vw_in1: `v,w IN dart1_of_fan (V,E) /\ v,w IN dart H`.
  by rewrite hypV vw_in /= -fully_surrounded_dart_of_fan_eq.
have card_f: `3 < CARD (face H (v,w))`.
  by rewrite (hyp_iso_card_components f_iso) // -G_def card_face_of_list d_eq.
rewrite -d_eq -fan_list_diag_eq //; split; last first.
  rewrite !fan_list_iso /= -implybF => /fan_list_nodes_iso_inj.
  rewrite sigma_fan_inV // (PAIR_IN_DART_OF_FAN v w fanV) //=.
  by rewrite -sigma_fan_not_fixed.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL.
move: (fully_surrounded_diag_not_in_dart fanV f_surr vw_in).
rewrite H_def card_f /=; apply: contra => ww'_in.
set w' := `sigma_fan _ V E v w`.
have [[a b]] := hyp_iso_surj f_iso ww'_in.
rewrite hypV => [] [ab_in].
have ab_inV: `a IN V /\ b IN V` by rewrite !(PAIR_IN_DART_OF_FAN a b fanV).
have ww'_inV: `w IN V /\ w' IN V`.
  by rewrite -w'_def sigma_fan_inV // (PAIR_IN_DART_OF_FAN v w fanV).
rewrite hyp_iso_eq_fan_list_iso // !fan_list_iso PAIR_EQ.
move => [/fan_list_nodes_iso_inj] eq1 /fan_list_nodes_iso_inj eq2.
by rewrite -eq1 // -eq2.
Qed.


Lemma iso_imp_good_list_split d: `good_list (split_list_hyp L d)`.
Proof.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
apply: (good_list_split goodL).
case f_size: `sizel (find_pair_list L d) <= 3` => /=.
apply iso_imp_good_conditions; rewrite find_face_alt size_list_pairs mem_d.
by move: f_size; arith.
Qed.


Lemma split_list_hyp_iso d: `d IN dart_of_fan (V,E) ==>
	hyp_iso (fan_list_iso (f,(V,E))) 
		(hypermap_of_fan (split_fan_face (V,E) d), hypermap_of_list (split_list_hyp L (f d)))`.
Proof.
move: d => [v w] vw_in.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have d1_eq := fully_surrounded_dart_of_fan_eq fanV f_surr.
have mem_fd: `MEM (f (v,w)) (list_of_darts L)`.
  by rewrite -IN_SET_OF_LIST -darts_of_list -hypL (hyp_iso_dart f_iso) hypV.
have card_f: `CARD (face H (v,w)) = sizel (find_face L (f (v,w)))`.
  by rewrite (hyp_iso_card_components f_iso) ?hypV // -card_face_of_list.
move: (goodL); rewrite good_list => [] [uniqL] _.
case f_size: `sizel (find_face L (f (v,w))) <= 3` => /=.
  rewrite (hypermap_of_split_list_eq3 f_size) // G_def.
  rewrite split_fan_face_eq H_def ?fanV ?vw_in.
    have := FULLY_SURROUNDED_IMP_CARD_FACE_GE_3 fanV f_surr vw_in.
    by move: f_size; rewrite H_def -card_f; arith.
  rewrite (hyp_iso_ext f_iso) hypV => x x_in.
  by rewrite hyp_iso_eq_fan_list_iso.
have card_f3: `3 < CARD (face (hypermap_of_fan (V,E)) (v,w))`.
  by move: f_size; rewrite H_def card_f; arith.
have [fan_split [dart_splitV_eq] f_split_surr] := fan_split_fan_face fanV f_surr vw_in.
set F1 := `split_fan_face (V,E) (v,w)`.
rewrite (pair_expand F1) in f_split_surr fan_split.
have /= := fully_surrounded_dart_of_fan_eq fan_split f_split_surr => split1_eq.
have good_split := iso_imp_good_list_split `f (v,w)`.
have vw_in1: `v,w IN dart1_of_fan (V,E)` by rewrite -d1_eq.
have diag_eq := fan_list_diag_eq vw_in1.
set w' := `sigma_fan (vec 0) V E v w`.
set R := `fan_list_iso _`.
have dart_splitL_eq: `dart (hypermap_of_list (split_list_hyp L (f (v,w))))
	= darts_of_list L UNION {R (w',w), R (w, w')}`.
  rewrite (components_hypermap_of_list good_split) darts_of_list.
  have gt3: `3 < sizel (find_pair_list L (f (v,w)))`.
    by move: f_size; rewrite find_face_alt size_list_pairs; arith.
  rewrite (perm_eq_set_of_list_eq (darts_of_list_split gt3)).
  rewrite -Seq2.APPEND_cat SET_OF_LIST_APPEND UNION_COMM darts_of_list.
  congr `_1 UNION _2` => //.
  rewrite !"GEN_ALL set_of_list" -diag_eq.
  by rewrite -{2}R_def fan_list_iso e_list /= -fan_list_iso R_def "GEN_ALL Collect_geom.PER_SET2".
have /= := COMPONENTS_HYPERMAP_OF_FAN fan_split.
have := components_hypermap_of_list good_split.
set H1 := `hypermap_of_fan _`.
set G1 := `hypermap_of_list _`.
move => hypL1 hypV1.
have dartG1_eq: `dart G1 = IMAGE R (dart H1)`.
  rewrite dart_splitL_eq hypV1 dart_splitV_eq -d1_eq -hypL -hypV.
  rewrite IMAGE_UNION !"GEN_ALL IMAGE_CLAUSES"; congr `_1 UNION _2` => //.
  by rewrite (iso_dart f_iso) hypV -R_def; apply image_ext_eq => x /hyp_iso_eq_fan_list_iso ->.
rewrite hyp_iso_edge_face; split.
  rewrite dartG1_eq BIJ Misc_defs_and_lemmas.IMAGE_SURJ andbT INJ.
  split; first by move => x x_in; rewrite IN_IMAGE; exists x.
  move => [v1 w1] [v2 w2] [vw1_in] [vw2_in] eq.
  suff inV: `v1 IN V /\ v2 IN V /\ w1 IN V /\ w2 IN V`.
    move: eq; rewrite -R_def !fan_list_iso PAIR_EQ.
    by move => [/fan_list_nodes_iso_inj] -> // /fan_list_nodes_iso_inj ->.
  move: vw1_in vw2_in; rewrite hypV1 (pair_expand F1).
  move => /(PAIR_IN_DART_OF_FAN fan_split) vw1_in /(PAIR_IN_DART_OF_FAN fan_split).
  by move: vw1_in; rewrite -F1_def split_fan_face /=.
case => a b ab_in.
have Rab_in: `R (a,b) IN dart G1`.
  by rewrite dartG1_eq IN_IMAGE; exists `a,b`.
split.
  rewrite hypV1 hypL1 e_list_ext res -hypL1 Rab_in /= e_list.
  rewrite -R_def !fan_list_iso /= -fan_list_iso.
  by rewrite (pair_expand F1) e_fan_pair_ext_explicit // -pair_expand -hypV1.
have := "let_RULE f_split_fan_face" fanV f_surr vw_in card_f3.
rewrite F1_def w'_def.
set u := `sigma_fan _ V E w' v`.
move => f_fan_eq.
have := "let_RULE f_split_list" goodL `f (v,w)`; "ANTS_TAC".
  rewrite ltnNge f_size /=; apply iso_imp_good_conditions.
  by rewrite ltnNge.
set L2 := `split_list_hyp L _`.
rewrite -diag_eq; move => f_list_eq.
rewrite hypV1 (pair_expand F1) f_fan_pair_ext /= -split1_eq -hypV1 ab_in /=.
rewrite hypL1 f_list_ext res -hypL1 Rab_in /=.
have R_eq_f x: `x IN dart_of_fan (V,E) ==> R x = f x`.
  by move/hyp_iso_eq_fan_list_iso; rewrite R_def eq_sym.
case eq1: `a,b = v,w` => /=; first by rewrite eq1 R_eq_f.
have w'v_eq: `w',v = inverse (face_map H) (v,w)`.
  by rewrite hypV INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /= w'_def.
have w'v_in: `w',v IN dart H`.
  by rewrite w'v_eq lemma_dart_inveriant_under_inverse_maps.
have uw'_eq: `u,w' = inverse (face_map H) (w',v)`.
  rewrite hypV INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res.
  by rewrite -d1_eq -hypV w'v_in /= u_def.
case eq2: `a,b = w,w'` => /=.
  rewrite eq2 f_list_eq f_fan_eq w'v_eq.
  rewrite R_eq_f -?hypV ?lemma_dart_inveriant_under_inverse_maps //.
  rewrite -(hyp_iso_inverse_comm f_iso) // hypL.
  by rewrite f_list_ext_inverse // res darts_of_list IN_SET_OF_LIST.
have Rw'w_eq: `R (w',w) = e_list L (R (w,w'))`.
  by rewrite -R_def eq_sym !fan_list_iso e_list.
case eq3: `a,b = w',w` => /=.
  rewrite eq3 f_fan_eq Rw'w_eq f_list_eq eq_sym.
  have ->: `f_fan_pair (V,E) (v,w) = face_map H (v,w)`.
    by rewrite hypV f_fan_pair_ext vw_in1.
  rewrite R_eq_f -?hypV ?lemma_dart_invariant //.
  by rewrite -(hyp_iso_comm f_iso) // hypL f_list_ext res darts_of_list IN_SET_OF_LIST.
set ff := `find_face L (f (v,w))`.
have Ruw'_eq: `R (u,w') = prev_el ff (prev_el ff (f (v,w)))`.
  rewrite uw'_eq R_eq_f -?hypV ?lemma_dart_inveriant_under_inverse_maps //.
  rewrite -(hyp_iso_inverse_comm f_iso) //.
  rewrite w'v_eq -(hyp_iso_inverse_comm f_iso) // hypL.
  rewrite {2}f_list_ext_inverse // res darts_of_list IN_SET_OF_LIST mem_fd /= ff_def.
  suff mem_ff: `prev_el ff (f (v,w)) IN darts_of_list L`.
    rewrite f_list_ext_inverse // res mem_ff /=.
    suff ->: `find_face L (prev_el ff (f (v,w))) = ff` by [].
    rewrite (find_face_eq uniqL) -?IN_SET_OF_LIST -?darts_of_list //.
    rewrite !IN_SET_OF_LIST mem_prev_el -ff_def -?dart_in_face //.
    by rewrite mem_find_face.
  rewrite darts_of_list IN_SET_OF_LIST; apply mem_find_face_imp_mem_darts.
  by exists `f (v,w)`; rewrite ff_def mem_prev_el -ff_def -dart_in_face.
case eq4: `a,b = u,w'` => /=.
  by rewrite eq4 f_fan_eq Ruw'_eq f_list_eq Rw'w_eq.
rewrite f_fan_eq; first by rewrite -hypV1 ab_in !negb_or.
have ab_in0: `a,b IN dart H`.
  move: ab_in; rewrite hypV1 dart_splitV_eq IN_UNION -d1_eq -hypV.
  by rewrite IN_INSERT IN_SING eq2 eq3.
rewrite f_list_eq; last first.
  have ->: `f_fan_pair (V,E) (a,b) = face_map H (a,b)`.
    by rewrite hypV f_fan_pair_ext -d1_eq -hypV ab_in0.
  rewrite eq_sym R_eq_f -?hypV ?lemma_dart_invariant //.
  rewrite -(hyp_iso_comm f_iso) // hypL f_list_ext res -hypL.
  by rewrite (hyp_iso_dart f_iso) //= R_eq_f // -hypV.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL1 Rab_in andTb.
rewrite -Ruw'_eq -Rw'w_eq -R_eq_f //.
have in_all: `a IN V /\ b IN V /\ u IN V /\ v IN V /\ w' IN V /\ w IN V`.
  move: ab_in0; rewrite hypV => /(PAIR_IN_DART_OF_FAN fanV) [-> ->] /=.
  move: (w'v_in); rewrite hypV => /(PAIR_IN_DART_OF_FAN fanV) [-> ->] /=.
  move: (lemma_dart_inveriant_under_inverse_maps w'v_in).
  rewrite -uw'_eq hypV => [] [_] [_] /(PAIR_IN_DART_OF_FAN fanV) ->.
  by rewrite (PAIR_IN_DART_OF_FAN fanV vw_in).
apply: contraL (eq1,eq2,eq3,eq4).
rewrite !negb_and !negbK -R_def !fan_list_iso !PAIR_EQ.
by do !case; move/fan_list_nodes_iso_inj => h1 /fan_list_nodes_iso_inj h2; rewrite h1 // h2.
Qed.


Lemma iso_imp_good_list_nodes_split d: `good_list_nodes (split_list_hyp L d)`.
Proof.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
move: mem_d; rewrite -IN_SET_OF_LIST -darts_of_list -(components_hypermap_of_list goodL) => d_in.
have [[v w] [vw_in <-]] := hyp_iso_surj f_iso d_in.
rewrite (COMPONENTS_HYPERMAP_OF_FAN fanV) in vw_in.
have iso_th := split_list_hyp_iso vw_in.
rewrite good_list_nodes_condition ?iso_imp_good_list_split //.
rewrite -number_of_nodes (iso_number_of_nodes iso_th).
rewrite -(perm_eq_size (list_of_elements_split L `f (v,w)`)).
have [fan_split _] := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face in fan_split *.
rewrite fan_number_of_nodes // -(fan_number_of_nodes fanV).
by rewrite -(iso_number_of_nodes f_iso) number_of_nodes -good_list_nodes_condition.
Qed.

End FanAndList.
