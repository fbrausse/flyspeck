"needs \"../formal_lp/hypermap/ssreflect/list_hypermap-compiled.hl\"".
"needs \"../formal_lp/hypermap/ssreflect/add_triangle-compiled.hl\"".

Module List_hypermap_iso.

"parse_as_infix (\"::\", (12, \"right\"))".
"override_interface (\"::\", `CONS`)".
"make_overloadable \"++\" `:A -> A -> A`".
"overload_interface (\"++\", `cat`)".

(* Main definitions *)
(* Given a list [1;2;3;4;...;n], yields two lists [[1;2;3]; [1;4;...;n]] *)
"let split_list_face = new_definition
	`split_list_face f = if sizel f <= 3 then [f] else [take 3 f; HD f :: dropl 2 f]`".

"let split_list_hyp = (GEN_ALL o define) 
	`split_list_hyp [] d = [] /\
	 split_list_hyp (f :: t) d = 
		if MEM d (list_pairs f) then
			split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f)) ++ t
		else
			f :: split_list_hyp t d`".

"let list_hyp_diag = new_definition `list_hyp_diag L d = (SND d, FST (prev_el (find_face L d) d))`".

"let fan_list_nodes_iso = new_definition `fan_list_nodes_iso (f, (V,E)) x
	= FST (f (x, if set_of_edge x V E = {} then x else CHOICE (set_of_edge x V E)))`".

"let fan_list_iso = new_definition `fan_list_iso (f, (V,E)) (v,w) = 
		fan_list_nodes_iso (f, (V,E)) v, fan_list_nodes_iso (f, (V,E)) w`".


"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Seq2".
"open Hypermap".
"open Hypermap_and_fan".
"open Fan_defs".
"open List_hypermap".
"open Add_triangle".
"open Hypermap_iso".



Section MoreFan.

Variable V : `:real^3->bool`.
Variable E : `:(real^3->bool)->bool`.

(* TODO: move to hypermap_and_fan.hl *)
Lemma fan_imp_finite_set V E: `FAN (vec 0,V,E) ==> FINITE V`.
Proof. by rewrite FAN fan1 => ->. Qed.


Lemma e_fan_pair_ext_explicit v w: `(v,w) IN dart_of_fan (V,E)
	==> e_fan_pair_ext (V,E) (v,w) = (w,v)`.
Proof.
rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM e_fan_pair_ext /=.
case vw_in: `v,w IN _` => /=; first by rewrite e_fan_pair.
by move => [z] [_]; rewrite PAIR_EQ => [] [-> ->].
Qed.


Lemma fan_number_of_nodes V E: `FAN (vec 0,V,E) 
	==> number_of_nodes (hypermap_of_fan (V,E)) = CARD V`.
Proof.
rewrite number_of_nodes => fanV.
move: (NODE_SET_AS_IMAGE fanV) => [f] [inj] ->.
by rewrite CARD_IMAGE_INJ // (fan_imp_finite_set fanV) /= => x y [_] [_] /inj.
Qed.

End MoreFan.



(* SplitListHyp *)
Section SplitListHyp.

Implicit Type d: `:A#A`.


Lemma split_list_hyp_alt L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list L d and
	         n = indexl (find_pair_list L d) L in
	split_list_hyp L d = take n L ++ 
		(split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f))) ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  rewrite Seq.index_head take cat add0n drop1 behead.
  by rewrite split_list_hyp mem_d.
move => mem_dt.
rewrite split_list_hyp mem_d /= Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop.
rewrite -m_def index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma d_not_in_dart_split_eq L d: `~(MEM d (list_of_darts L)) ==> split_list_hyp L d = L`.
Proof.
rewrite mem_list_of_darts NOT_EXISTS_THM negb_and.
elim: L => [|h t Ih]; rewrite split_list_hyp // => mem_d.
move: (mem_d h); rewrite "GEN_ALL MEM" /= Ih // => x.
move: (mem_d x); rewrite "GEN_ALL MEM" negb_or.
by case => ->.
Qed.


Lemma list_eq_cat_find_pair_list L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list L d and
	         n = indexl (find_pair_list L d) L in
	L = take n L ++ [f] ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  by rewrite Seq.index_head take cat add0n drop1 behead cat1s.
move => mem_dt; rewrite {1}Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop !cat.
rewrite -m_def index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma list_eq_cat_list_diag f d: `MEM d (list_pairs f) /\ 2 <= sizel f
	==> (let k = indexl d (list_pairs f) and
	     	y = FST (prev_el (list_pairs f) d) in
			rot k f = [FST d] ++ belast (SND d) (dropl 2 (rot k f)) ++ [y])`.
move => [mem_d f_size]; "CONV_TAC let_CONV".
set k := `indexl d _`.
set y := `FST (_1 _2 d)`.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
apply: (eq_from_nth y); rewrite size_rot !size_cat !size1 size_belast size_drop size_rot.
split => [|i]; first by move: f_size; arith.
have size_ineqs: `2 <= sizel f /\ 1 < sizel f /\ 0 < sizel f /\ k <= sizel f /\ 0 < sizel f - 1 /\ 1 <= sizel f`.
  by move: k_lt f_size; arith.
case: i => [_ | i].
  rewrite nth_rot // addn0 MOD_LT // cat1s nth.
  move: (nth_index `y,y` mem_d).
  by rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => ->.
case size_eq: `sizel f = 2` => /=.
  rewrite drop_oversize ?size_rot size_eq ?leqnn // belast !cat nth => i_lt.
  have ->: `i = 0` by move: i_lt; arith.
  rewrite nth nth_rot -?ONE //.
  rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
  rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
  rewrite list_pairs nth_zip ?size_rot // FST size_eq.
  by have ->: `2 - 1 + k = k + 1` by arith.
have size_ineqs2: `0 < sizel f - 2 /\ 2 < sizel f` by move: size_eq f_size; arith.
case: i => [_ | i].
  rewrite cat1s nth -ONE nth_rot // nth_cat size_belast size_drop size_rot size_ineqs2 /=.
  rewrite nth0 head_belast ?size_drop ?size_rot //.
  move: (nth_index `y,y` mem_d).
  rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => <-.
  by rewrite addnC nth_rot.
move => i_lt; rewrite cat1s nth.
case i_lt2: `SUC i < sizel f - 2` => /=.
  rewrite -{1}(cat_take_drop `2`) nth_cat size_take size_rot size_ineqs2 /=.
  have -> /=: `SUC (SUC i) < 2 <=> F` by arith.
  have ->: `SUC (SUC i) - 2 = i` by arith.
  rewrite nth_cat size_belast size_drop size_rot i_lt2 /=.
  by rewrite nth_belast ?succnK ?eqS0 // size_drop size_rot.
have ->: `SUC i = sizel f - 2` by move: i_lt2 i_lt; arith.
rewrite nth_cat size_belast size_drop size_rot ltnn /= subnn nth.
rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
rewrite list_pairs nth_zip ?size_rot // FST.
by have ->: `k + SUC (sizel f - 2) = sizel f - 1 + k` by move: f_size; arith.
Qed.


Lemma split_list_explicit L d: `let f = find_pair_list L d in
	(let y = FST (prev_el (list_pairs f) d) and
	     k = indexl d (list_pairs f) in
	3 < sizel f
	==> split_list_face (rotr 1 (rot k f)) 
		= [[y; FST d; SND d]; [y; SND d] ++ dropl 3 (rotr 1 (rot k f))]
	/\ perm_eq (list_of_darts (split_list_face (rotr 1 (rot k f)))) 
		([list_hyp_diag L d; e_list (list_hyp_diag L d)] ++ list_pairs f))`.
do !"CONV_TAC let_CONV".
case mem_d: `MEM d (list_of_darts L)` => /=; last first.
  move: mem_d; rewrite -find_pair_list_empty => ->.
  by rewrite size_nil; arith.
move => f_size.
set f := `find_pair_list L d`.
set y := `FST _`.
set k := `indexl d _`.
set f' := `rotr 1 _`.
have := "let_RULE list_eq_cat_list_diag" d f; "ANTS_TAC".
  by rewrite -{1}f_def -dart_in_find_pair_list mem_d; move: f_size; arith.
rewrite list_hyp_diag e_list /= find_face_alt f_def y_def k_def => rot_eq.
move/(congr1 `rotr 1`): (rot_eq); rewrite catA cats1 rotr1_rcons -cat1s catA cat1s f'_def EQ_SYM_EQ => f'_eq.
have eqX: `belast (SND d) (dropl 2 (rot k f)) = SND d :: dropl 3 f'`.
  have: `1 <= sizel (dropl 2 (rot k f))` by rewrite size_drop size_rot; move: f_size; arith.
  rewrite -f'_eq; case: `dropl 2 (rot k f)` => [|h t]; first by rewrite size_nil; arith.
  rewrite belast -(cat1s `SND d`) catA cats1 !rcons drop_size_cat ?cat //.
  by rewrite !size_cons size_nil; arith.
have h1: `_1 = _2`.
  rewrite split_list_face -{1}f'_def size_rotr size_rot leqNgt f_size /=.
  congr `[_1; _2]`.
    by rewrite -f'_eq eqX -(cat1s `SND d`) catA cats1 !rcons take_size_cat // !size_cons size_nil; arith.
  rewrite -f'_eq eqX drop_size_cat ?(size_cons, size_nil); first by arith.
  rewrite -{1}(cat1s y) -catA cat1s HD.
  by rewrite -{2}(cat1s `SND d`) catA drop_size_cat !cat // !size_cons size_nil; arith.
rewrite h1 /= !list_of_darts_cons list_of_darts_nil cats0 cat.
rewrite 2!list_pairs !rot1_cons !rcons cat1s rcons !zip.
rewrite perm_catC -cat1s perm_catC -cat1s -(cat1s `FST d,SND d`).
rewrite !catA perm_catC -!catA (cat1s `SND d,y`) !catA perm_catC perm_cat2l.
apply: (perm_eq_trans `list_pairs (rot k f)`).
rewrite list_pairs_rot andbT rot_eq eqX cat1s.
rewrite list_pairs rot1_cons cat rcons zip rcons_cat !rcons.
rewrite perm_catC cat1s perm_cons.
rewrite -(cat1s y `[FST d]`) -[`SND d :: _1 ++ [y]`]cat1s !catA zip_cat.
  by rewrite !size_cat !size_cons addnC.
by rewrite cat1s !cats1 !zip cats1 // perm_eq_refl.
Qed.


Lemma darts_of_list_split L d: `3 < sizel (find_pair_list L d)
	==> perm_eq (list_of_darts (split_list_hyp L d))
		   ([list_hyp_diag L d; e_list (list_hyp_diag L d)] ++ list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
have mem_d: `MEM d (list_of_darts L)`.
  by apply: contraLR f_size; rewrite -find_pair_list_empty => ->; rewrite size_nil; arith.
rewrite "let_RULE split_list_hyp_alt" // {3}("let_RULE list_eq_cat_find_pair_list" L d) //.
have [split_eq darts_perm] := "let_RULE split_list_explicit" f_size.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_catCA perm_cat2l catA perm_cat2r.
by rewrite perm_eq_sym list_of_darts_cons list_of_darts_nil cats0 darts_perm.
Qed.


Lemma darts_of_list_split_same L d: `sizel (find_pair_list L d) <= 3
	==> perm_eq (list_of_darts (split_list_hyp L d)) (list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
case mem_d: `MEM d (list_of_darts L)` => /=; last first.
  by rewrite d_not_in_dart_split_eq // perm_eq_refl.
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_cat2l perm_cat2r.
rewrite split_list_face -f'_def size_rotr size_rot f_size /=.
set k := `indexl d _`.
rewrite !list_of_darts !"GEN_ALL foldr" /= !cats0 rotr size_rot -!rot_list_pairs.
apply: (perm_eq_trans `rot k _`).
by rewrite !(perm_eq_rot, perm_eq_sym).
Qed.


Lemma list_of_elements_split L d: `perm_eq (list_of_elements L) (list_of_elements (split_list_hyp L d))`.
Proof.
apply uniq_perm_eq; rewrite !uniq_list_of_elements /= => i.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" mem_d).
set f := `find_pair_list L d`.
set n := `indexl f L`.
rewrite !list_of_elements !flatten_cat !mem_undup !mem_cat.
apply: orb_id2l => _; apply: orb_id2r => _.
rewrite flatten_cons flatten0 cats0.
rewrite split_list_face size_rotr size_rot.
case f_size: `_ <= 3` => /=; rewrite !flatten_cons flatten0 cats0.
  by rewrite mem_rotr mem_rot.
set s := `rotr 1 _`.
have [k ->]: `?k. s = rot k f`.
  rewrite -s_def rotr size_rot.
  have [k eq] := rot_rot_eq_rot f `sizel f - 1` `indexl d (list_pairs f)`.
  by exists k.
have ineqs: `3 < sizel f /\ 2 < 3` by move: f_size; arith.
rewrite -(mem_rot k f); split.
  rewrite -{1}(cat_take_drop `3`) !mem_cat MEM.
  case => /= mem_i; right; right.
  rewrite -(cat_take_drop `3` `rot k f`) drop_cat size_take size_rot ineqs /= ineqs /=.
  by rewrite mem_cat mem_i.
rewrite mem_cat MEM; case => [/mem_take | [-> | /mem_drop]] //.
have: `0 < sizel (rot k f)` by rewrite size_rot; move: ineqs; arith.
by case: `rot k f` => [|h t]; rewrite ?(size_nil, ltn0) // "GEN_ALL HD" MEM.
Qed.
  

Lemma mem_list_hyp_diag L d: `MEM d (list_of_darts L) /\ 
	(sizel (find_pair_list L d) = 1 \/ sizel (find_pair_list L d) = 3)
	==> MEM (list_hyp_diag L d) (find_face L d)`.
Proof.
move => [mem_d size_eq]; rewrite list_hyp_diag find_face_alt.
set f := `find_pair_list L d`.
set k := `indexl d (list_pairs f)`.
set y := `FST _`.
have mem_d2: `MEM d (list_pairs f)` by rewrite -f_def -dart_in_find_pair_list.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
case: size_eq => size_eq.
  move: size_eq; rewrite size1_eq => [] [x] f_eq.
  move: mem_d2; rewrite -y_def f_eq list_pairs rot1_cons rcons !zip mem_seq1 => ->.
  by rewrite SND prev_el !MEM /= Seq.index_head /= !last FST.
rewrite -(perm_eq_mem (list_pairs_rot f k)).
have size_ineq: `2 <= sizel f` by move: size_eq; arith.
have := "let_RULE list_eq_cat_list_diag" mem_d2 size_ineq.
rewrite k_def y_def => ->.
set l := `dropl 2 _`.
suff ->: `belast (SND d) l = [SND d]`.
  by rewrite !cat list_pairs rot1_cons !rcons !zip !MEM.
have: `sizel l = 1` by rewrite -l_def size_drop size_rot size_eq; arith.
by rewrite size1_eq => [] [x] ->; rewrite !belast.
Qed.

(* good_list (split_list_hyp L d) *)
Theorem good_list_split L d: `good_list L /\
	(sizel (find_pair_list L d) <= 3 \/
		~(MEM (list_hyp_diag L d) (list_of_darts L)) 
		/\ ~(FST (list_hyp_diag L d) = SND (list_hyp_diag L d)))
	==> good_list (split_list_hyp L d)`.
Proof.
move => [goodL hyp].
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have := "let_RULE split_list_hyp_alt" mem_d.
have := "let_RULE list_eq_cat_find_pair_list" mem_d.
set f := `find_pair_list L d`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
move: (goodL); rewrite !good_list => [] [uniqL] [allL] symL L_eq split_eq.
case f_size: `sizel (find_pair_list L d) <= 3` => /=.
  have perm_darts := "let_RULE darts_of_list_split_same" f_size.
  rewrite (perm_eq_uniq perm_darts) uniqL andTb; split; last first.
    by move => y; rewrite !(perm_eq_mem perm_darts) => /symL.
  rewrite split_eq split_list_face -{1}f'_def size_rotr size_rot -f_def f_size /=.
  move: allL; rewrite {1}L_eq !all_cat !all /= => [] [_] [f_neq] _.
  by rewrite -size_eq0 -f'_def size_rotr size_rot size_eq0.
move: hyp; rewrite -f_def f_size /= => [] [n_mem] neq.
rewrite NOT_LE in f_size.
have perm_darts := "let_RULE darts_of_list_split" f_size.
split.
  rewrite (perm_eq_uniq perm_darts) !cat !"GEN_ALL uniq" uniqL MEM andbT; split; last first.
    by apply: contra n_mem => /symL; rewrite e_list SND FST -pair_expand.
  rewrite n_mem orbF.
  by apply: contra neq; rewrite e_list {1}pair_expand PAIR_EQ => ->.
split.
  move: allL; rewrite {1}L_eq split_eq !all_cat split_list_face.
  have f'_size: `3 < sizel f'` by rewrite -f'_def size_rotr size_rot -f_def f_size.
  rewrite leqNgt f'_size /= !all /= => _.
  by rewrite -!size_eq0 size_take f'_size /= size_cons; arith.
move => y; rewrite !(perm_eq_mem perm_darts) !mem_cat !MEM /= e_list.
set h := `list_hyp_diag L d`.
case; last by move/symL => ->.
by case => ->.
Qed.


Lemma hypermap_of_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1
	==> hypermap_of_list L1 = hypermap_of_list L2`.
Proof.
move => [perm good1].
have good2 := good_list_perm perm good1.
have perm_darts := list_of_darts_perm perm.
have mem_eq := perm_eq_mem perm_darts.
rewrite !hypermap_of_list; congr `hypermap _`.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f1 (darts_of_list L1) = res f2 (darts_of_list L2)`.
  rewrite FUN_EQ_THM => eq d.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_d: `MEM d _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => d mem_d; rewrite !e_list.
have face_eq d: `MEM d (list_of_darts L1) ==> find_face L2 d = find_face L1 d`.
  move => mem_d; rewrite !find_face_alt; congr `list_pairs _`.
  move: (good1); rewrite good_list => [] [uniq1] _.
  apply: (find_pair_list_unique uniq1).
  rewrite -find_face_alt -dart_in_face -mem_eq mem_d andbT.
  by rewrite (perm_eq_mem perm) mem_find_pair_list -mem_eq.
split; rewrite !(n_list_ext, f_list_ext); apply: res_eq => d mem_d.
  by rewrite !n_list face_eq // !e_list.
by rewrite !f_list face_eq.
Qed.


Lemma find_face_rot L1 L2 d: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> ?n. find_face L2 d = rot n (find_face L1 d)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 //=.
  by rewrite find_face list_of_faces MAP find_list rot_nil.
move => [] [n] h2_eq all2; rewrite !find_face_cons.
case mem_d: `MEM d (list_pairs h1)` => /=.
  by exists n; rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d /= rot_list_pairs.
move: (Ih all2) => [m] eq; exists m.
by rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d.
Qed.


Lemma rot_list_of_darts_perm L1 L2: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 // ?list_of_darts_nil ?perm_eq_refl //=.
move => [] [n h2_eq] all2.
rewrite !list_of_darts_cons perm_eq_cat Ih //.
by rewrite h2_eq perm_eq_sym list_pairs_rot.
Qed.


Lemma rot_hypermap_of_list_eq L1 L2: 
	`ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2 /\ uniq (list_of_darts L1)
	==> hypermap_of_list L2 = hypermap_of_list L1`.
Proof.
move => [all2 uniq1].
rewrite !hypermap_of_list; congr `hypermap _`.
have perm_darts := rot_list_of_darts_perm all2.
have mem_eq := perm_eq_mem perm_darts.
have face_eq := find_face_rot all2.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f2 (darts_of_list L2) = res f1 (darts_of_list L1)`.
  rewrite FUN_EQ_THM => eq y.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_y: `MEM y _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => y mem_y; rewrite !e_list.
split.
  rewrite !n_list_ext; apply: res_eq => d mem_d.
  move: (face_eq d) => [n] f_eq.
  rewrite !n_list f_eq prev_el_rot_eq ?e_list //.
  by rewrite uniq_find_face // -dart_in_face.
rewrite !f_list_ext; apply: res_eq => d mem_d.
move: (face_eq d) => [n] f_eq.
by rewrite !f_list f_eq next_el_rot_eq // uniq_find_face.
Qed.


Lemma hypermap_of_split_list_eq3 L d: `sizel (find_face L d) <= 3 /\ uniq (list_of_darts L)
	==> hypermap_of_list (split_list_hyp L d) = hypermap_of_list L`.
Proof.
move => [f_size uniq_darts].
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have all2_refl: `!s:((A)list)list. ALL2 (\f1 f2. ?n. f2 = rot n f1) s s`.
  by elim => [|h t Ih]; rewrite ALL2 //= Ih andbT; exists `0`; rewrite rot0.
apply: (rot_hypermap_of_list_eq uniq_darts).
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
move: f_size; rewrite find_face_alt size_list_pairs.
set f := `find_pair_list L d`.
set n := `indexl f L`.
move => f_size.
rewrite split_list_face size_rotr size_rot f_size /=.
rewrite !ALL2_cat // ?size_cons // !all2_refl /= !ALL2 /= rotr.
set i := `sizel _ - 1`; set j := `indexl d _`.
by move: (rot_rot_eq_rot i j f) => [k] ->; exists k.
Qed.


(* face_map of split_list_hyp *)
Theorem f_split_list L d: `let L2 = split_list_hyp L d and g = list_hyp_diag L d and f = find_face L d in
		good_list L /\ 3 < sizel f
		/\ ~(MEM g (list_of_darts L)) 
		/\ ~(FST g = SND g)
	==> f_list L2 d = g
	/\ f_list L2 g = prev_el f d
	/\ f_list L2 (e_list g) = f_list L d
	/\ f_list L2 (prev_el f (prev_el f d)) = e_list g
	/\ (!x. MEM x (list_of_darts L2)
		/\ ~(x = d \/ x = g \/ x = e_list g \/ x = prev_el f (prev_el f d))
			==> f_list L2 x = f_list L x)`.
Proof.
"CONV_TAC let_CONV".
move => [goodL] [f_size] [g_n_mem] g_neq.
have size_gt3: `3 < sizel (find_pair_list L d)`.
  by move: f_size; rewrite find_face_alt size_list_pairs.
have mem_d: `MEM d (list_of_darts L)`.
  apply: contraLR size_gt3; rewrite -find_pair_list_empty => ->.
  by rewrite size_nil; arith.
have := darts_of_list_split size_gt3.
have := "let_RULE split_list_hyp_alt" mem_d.
have := "let_RULE split_list_explicit" size_gt3.
have := good_list_split goodL d; "ANTS_TAC" => [//| goodL2].
rewrite -!find_face_alt.
set s := `find_pair_list L d`.
set n := `indexl s _`.
set k := `indexl d _`.
set s' := `rotr 1 _`.
set L2 := `split_list_hyp L d`.
set g := `list_hyp_diag L d`.
set f := `find_face L d`.
set s1 := `FST _ :: _2`.
set s2 := `cat _1 _2`.
move => [split_s'_eq darts_s'] L2_eq dartsL2.
move: (goodL2); rewrite good_list => [] [uniqL2] _.
move: (goodL); rewrite good_list => [] [uniqL] _.
have fs_eq: `list_pairs s = f` by rewrite -s_def -f_def find_face_alt.
have s1_pairs_eq: `list_pairs s1 = [prev_el f d; d; g]`.
  rewrite -s1_def list_pairs rot1_cons !rcons !zip.
  rewrite -pair_expand -{2}f_def -list_hyp_diag g_def; congr `[_; d; g]`.
  rewrite eq_sym {1}pair_expand PAIR_EQ /=.
  move: (prev_el_list_pairs_general `FST d` `SND d` s); "ANTS_TAC".
    by rewrite -pair_expand fs_eq -f_def -dart_in_face.
  by rewrite -pair_expand fs_eq => [] [z] ->.
have uniq_f: `uniq f` by rewrite -f_def uniq_find_face.
have s12_mem: `MEM s1 L2 /\ MEM s2 L2`.
  by rewrite L2_eq !mem_cat split_s'_eq !MEM.
have s12_pairs_mem: `MEM (list_pairs s1) (list_of_faces L2) /\ MEM (list_pairs s2) (list_of_faces L2)`.
  by rewrite list_of_faces -map_MAP !mapP; split; [exists s1 | exists s2].
have s12_pairs_uniq: `uniq (list_pairs s1) /\ uniq (list_pairs s2)`.
  by split; apply: (uniq_face goodL2).
have next_el_fs' x: `next_el f x = next_el (list_pairs s') x`.
  rewrite -s'_def -rotr_list_pairs -rot_list_pairs.
  by rewrite next_el_rotr_eq ?rot_uniq // next_el_rot_eq.
have prev_el_fs' x: `prev_el f x = prev_el (list_pairs s') x`.
  rewrite -s'_def -rotr_list_pairs -rot_list_pairs.
  by rewrite prev_el_rotr_eq ?rot_uniq // prev_el_rot_eq.
have mem_f_darts x: `MEM x f ==> MEM x (list_of_darts L)`.
  by rewrite -f_def => /mem_find_face_imp_mem_darts.
have mem_df: `MEM d f` by rewrite -f_def -dart_in_face.
have p_eq_f_s': `perm_eq (list_pairs s') f`.
  rewrite -s'_def -fs_eq -rotr_list_pairs -rot_list_pairs rotr.
  set r := `sizel _ - 1`.
  have [i ->] := rot_rot_eq_rot `list_pairs s` r k.
  by rewrite perm_eq_rot.
have size_s': `sizel s' = sizel s` by rewrite -s'_def size_rotr size_rot.
have s'_eq1: `s' = s1 ++ dropl 3 s'`.
  move: split_s'_eq; rewrite split_list_face size_s' leqNgt size_gt3 /=.
  by rewrite -{4}(cat_take_drop `3` s') "injectivity \"list\"" => ->.
have s'_pairs_eq: `list_pairs s' = prev_el f d :: d :: dropl 2 (list_pairs s')`.
  rewrite -{1}(cat_take_drop `2`) -cat1s -(cat1s d) catA cat1s; congr `_1 ++ _2` => //.
  rewrite s'_eq1 -s1_def !cat list_pairs rot1_cons !rcons !zip TWO ONE !take.
  move: (prev_el_list_pairs_general `FST d` `SND d` s); "ANTS_TAC".
    by rewrite -pair_expand fs_eq -f_def -dart_in_face.
  by move => [z]; rewrite -pair_expand fs_eq => ->.
have s2_pairs_eq: `list_pairs s2 = e_list g :: dropl 2 (list_pairs s')`.
  rewrite s'_eq1 -s1_def -s2_def !cat !list_pairs !rot1_cons !rcons !zip.
  by rewrite TWO ONE !drop -g_def list_hyp_diag e_list /= f_def.
have size_uneqs: `0 < sizel (dropl 2 (list_pairs s')) /\ 1 < sizel (dropl 2 (list_pairs s')) 
	/\ 0 < sizel (list_pairs s') /\ 2 < sizel (list_pairs s')`.
  by rewrite size_drop size_list_pairs size_s'; move: size_gt3; arith.
have size_ineqs_s2: `sizel (list_pairs s2) = sizel (list_pairs s') - 1 /\ 0 < sizel (list_pairs s2)`.
  by rewrite s2_pairs_eq size_cons size_drop size_list_pairs size_s'; move: size_gt3; arith.
have last_s': `last d (list_pairs s') = prev_el f (prev_el f d)`.
  by rewrite -prev_el_hd // {2}s'_pairs_eq "GEN_ALL HD" -prev_el_fs' // mem_prev_el.
have last_s2: `last d (list_pairs s2) = prev_el f (prev_el f d)`.
  by rewrite -last_s' s2_pairs_eq last last_drop //; apply last_eq.
have memL2 x: `MEM x (list_of_darts L2) <=> x = g \/ x = e_list g \/ MEM x (list_of_darts L)`.
  by rewrite (perm_eq_mem dartsL2) mem_cat !MEM orbF !orbA.
have find_s1: `find_face L2 d = list_pairs s1 /\ find_face L2 g = list_pairs s1
		/\ find_face L2 (prev_el f d) = list_pairs s1`.
  rewrite !find_face_eq ?(uniqL2, memL2, mem_d, s12_pairs_mem) /= ?mem_f_darts ?mem_prev_el //.
  by rewrite s1_pairs_eq !MEM.
have find_s2: `find_face L2 (e_list g) = list_pairs s2 
	/\ find_face L2 (prev_el f (prev_el f d)) = list_pairs s2`.
  rewrite !find_face_eq ?(uniqL2, memL2) /= ?mem_f_darts ?mem_prev_el //.
  rewrite s12_pairs_mem s2_pairs_eq MEM /= -last_s' -(last_drop d `2`) //.
  by rewrite (last_eq d `e_list g`) // mem_last.
rewrite !f_list !find_s1 !find_s2.
split.
  by rewrite -(next_el_rot_eq `1`) // s1_pairs_eq rot1_cons !rcons next_el_hd_cons2.
split.
  rewrite -(next_el_rotr_eq `1`) // s1_pairs_eq.
  by rewrite -cat1s -(cat1s d) catA cats1 rotr1_rcons cat1s next_el_hd_cons2.
split.
  rewrite s2_pairs_eq next_el_hd_cons // f_def next_el_fs'.
  rewrite -(next_el_rot_eq `1`) ?(perm_eq_uniq p_eq_f_s') //.
  rewrite {2}s'_pairs_eq rot1_cons rcons next_el_hd_cons ?size_rcons ?gtS0 //.
  by rewrite headI HD head_HD.
split.
  by rewrite -last_s2 next_el_last // s2_pairs_eq HD.
rewrite !negb_or => x [mem_x] x_neq.
move: mem_x; rewrite memL2 !x_neq !orFb => mem_x.
case mem_x_f: `MEM x f` => /=; last first.
  congr `next_el _ x`.
  rewrite find_face_eq // -dart_in_face mem_x andbT.
  have := "let_RULE list_eq_cat_find_pair_list" mem_d.
  rewrite s_def n_def => L_eq.
  move: (mem_find_face mem_x); rewrite {2}L_eq L2_eq !list_of_faces -map_MAP !mapP !mem_cat.
  move => [l] [mem_l] eq; exists l.
  case: mem_l => [-> | [|->]] //; rewrite mem_seq1 => l_eq.
  by move: eq mem_x_f; rewrite l_eq fs_eq => <-; rewrite -dart_in_face.
have ->: `find_face L x = f`.
  rewrite -f_def !find_face_alt eq_sym; congr `_1 _2` => //.
  by apply: (find_pair_list_unique uniqL); rewrite mem_find_pair_list.
case x_eq: `x = prev_el f d` => /=.
  by rewrite x_eq find_s1 s1_pairs_eq next_el_hd_cons2 next_prev_id.
have mem_x_s2: `MEM x (list_pairs s2)`.
  move: (iffRL (perm_eq_mem darts_s' x)); rewrite mem_cat mem_x_f /=.
  rewrite split_s'_eq !list_of_darts_cons list_of_darts_nil cats0 mem_cat.
  by case => //; rewrite s1_pairs_eq !MEM.
have ->: `find_face L2 x = list_pairs s2` by rewrite find_face_eq // s12_pairs_mem.
rewrite next_el_fs' next_el.
set i := `indexl x _`.
have i_ineqs: `1 <= i /\ i < sizel (list_pairs s2) - 1`.
  move: (mem_x_s2); rewrite -index_mem i_def.
  suff: `~(i = 0) /\ ~(i = sizel (list_pairs s2) - 1)` by arith.
  apply: contraLR (x_eq, x_neq); rewrite !negb_and !negbK.
  case => i_eq; move: (nth_index d mem_x_s2); rewrite i_def i_eq.
    by rewrite s2_pairs_eq nth => ->.
  have i_eq2: `i = indexl (last d (list_pairs s2)) (list_pairs s2)`.
    by rewrite s2_pairs_eq last index_last -?s2_pairs_eq // i_eq size_drop size_ineqs_s2; arith.
  rewrite -i_eq i_eq2 -last_s2 nth_index /=.
  by rewrite s2_pairs_eq last mem_last.
have -> /=: `~(i = sizel (list_pairs s2) - 1)` by move: i_ineqs; arith.
rewrite s2_pairs_eq addn1 nth eq_sym next_el.
suff ->: `indexl x (list_pairs s') = i + 1`.
  have -> /=: `~(i + 1 = sizel (list_pairs s') - 1)` by move: i_ineqs; rewrite size_ineqs_s2; arith.
  by rewrite !addn1 {1}s'_pairs_eq !nth.
suff nth_eq: `nth x (list_pairs s') (i + 1) = x`.
  rewrite -nth_eq index_uniq // (perm_eq_uniq p_eq_f_s') uniq_f.
  by move: i_ineqs; rewrite size_ineqs_s2; arith.
move: (nth_index d mem_x_s2); rewrite i_def addn1 s'_pairs_eq nth s2_pairs_eq.
case: i i_ineqs => [|j j_ineq]; first by arith.
rewrite !nth => {2}<-.
by apply set_nth_default; move: j_ineq; rewrite size_drop size_ineqs_s2; arith.
Qed.

End SplitListHyp.



(* Fan and list *)
Section FanAndList.


Lemma set_of_edge_subset V E E' x: `E SUBSET E' ==> set_of_edge x V E SUBSET set_of_edge x V E'`.
Proof. by rewrite !SUBSET !set_of_edge !inE => subE y [/subE] -> ->. Qed.

Lemma fan_list_iso_invariant F1 F2 f: 
	`fan_list_iso (fan_list_iso (f, F1), F2) = fan_list_iso (f, F1)`.
Proof.
move: F1 F2 => [V E] [V' E']; rewrite FUN_EQ_THM => [] [v w].
by rewrite !(fan_list_iso, fan_list_nodes_iso).
Qed.


Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.
Variable L: `:((A)list)list`.
Variable f: `:real^3#real^3 -> A#A`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis goodL: `good_list L`.
Hypothesis f_iso: `hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)`.

Lemma hyp_iso_eq_fan_list_iso y: `y IN dart_of_fan (V,E) ==> f y = fan_list_iso (f, (V,E)) y`.
Proof.
have [dartH mapsH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartG mapsG] := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have f_in d: `d IN dart_of_fan (V,E) ==> f d IN darts_of_list L`.
  by rewrite -dartH -dartG => d_in; rewrite (hyp_iso_dart f_iso).
case: y => [a b] ab_in.
rewrite fan_list_iso.
set h := `fan_list_nodes_iso _`.
suff [g f_eq]: `?g. !v w. (v,w) IN dart_of_fan (V,E) ==> f(v,w) = (h v:A, g (v,w):A)`.
  move: (IN_DART_OF_FAN fanV ab_in) => [v] [w] [vw_eq] vw_in.
  rewrite f_eq // PAIR_EQ /=.
  move: (hyp_iso_comm f_iso `a,b`); rewrite dartH ab_in /=.
  rewrite mapsG mapsH e_fan_pair_ext_explicit // e_list_ext res.
  rewrite -dartG (hyp_iso_dart f_iso) ?dartH //=.
  by rewrite !f_eq // 1?dart_switch // e_list SND PAIR_EQ => ->.
exists `\d. SND (f d)`.
move => v w vw_in; rewrite {1}(pair_expand `f (v,w)`) PAIR_EQ /= -h_def fan_list_nodes_iso.
case set_empty: `set_of_edge v V E = {}` => /=.
  move: vw_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
  case; first by move/(PAIR_IN_DART1_OF_FAN fanV); rewrite set_empty NOT_IN_EMPTY.
  by move => [u] [_] [eq1 eq2].
have vw_in1: `v,w IN dart1_of_fan (V,E)`.
  move: (vw_in); rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
  case => // [u] [empty] eq.
  by move: empty; rewrite -eq set_empty.
set w' := `CHOICE _`.
suff: `f (v,w') IN node G (f (v,w))`.
  rewrite Hypermap.node Hypermap.orbit_map IN_ELIM_THM /= mapsG.
  move => [n] [_] ->.
  rewrite {2}pair_expand fst_n_list_ext_power //.
  by rewrite -pair_expand -dartG (hyp_iso_dart f_iso).
rewrite (iso_components f_iso) ?dartH // FUN_IN_IMAGE.
rewrite -H_def NODE_HYPERMAP_OF_FAN_ALT // IN_ELIM_THM /=.
exists w'; split => //; rewrite -w'_def CHOICE_DEF -Ssrbool.implybF => eq.
have := PAIR_IN_DART1_OF_FAN fanV vw_in1.
by rewrite eq NOT_IN_EMPTY.
Qed.


Lemma fan_list_nodes_iso_surj: `SURJ (fan_list_nodes_iso (f,(V,E))) V (elements_of_list L)`.
Proof.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
have iso_eq := hyp_iso_eq_fan_list_iso.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
rewrite SURJ elements_of_list !IN_SET_OF_LIST !mem_list_of_elements.
split => [v | a [b]].
  move/(DART_EXISTS E) => [w] vw_in.
  exists `fan_list_nodes_iso (f,V,E) w`.
  rewrite -fan_list_iso -IN_SET_OF_LIST -darts_of_list -hypL -iso_eq //.
  by rewrite (hyp_iso_dart f_iso) hypV.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL => ab_in.
set d := `res_inv f (dart H) (a,b)`.
have := hyp_iso_dart (hyp_iso_inv f_iso) ab_in.
rewrite d_def hypV => d_in.
exists `FST d`; split.
  by rewrite (PAIR_IN_DART_OF_FAN fanV `FST d` `SND d`) -pair_expand.
suff: `f d = a,b`.
  by rewrite iso_eq // {1}(pair_expand d) fan_list_iso PAIR_EQ => ->.
by rewrite -d_def (surj_res_inv_right (hyp_iso_SURJ f_iso)).
Qed.


Lemma fan_list_nodes_to v: `v IN V ==> fan_list_nodes_iso (f,(V,E)) v IN elements_of_list L`.
Proof. by move: fan_list_nodes_iso_surj; rewrite SURJ => surj vV; rewrite surj. Qed.


Lemma fan_list_diag_eq v w: `(v,w) IN dart1_of_fan (V,E)
	==> fan_list_iso (f,(V,E)) (w, sigma_fan (vec 0) V E v w) = list_hyp_diag L (f (v,w))`.
Proof.
rewrite list_hyp_diag => vw_in1.
move: (goodL); rewrite good_list => [] [uniqL] _.
have vw_in: `v,w IN dart_of_fan (V,E)`.
  by rewrite dart_of_fan_eq IN_UNION vw_in1.
have fan_hyp := COMPONENTS_HYPERMAP_OF_FAN fanV.
have list_hyp := components_hypermap_of_list goodL.
have f_eq := hyp_iso_eq_fan_list_iso.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
set y := `FST _`.
have y_eq: `y = FST (inverse (face_map G) (f (v,w)))`.
  by rewrite list_hyp f_list_ext_inverse // res -list_hyp (hyp_iso_dart f_iso) ?fan_hyp.
rewrite f_eq // !fan_list_iso SND PAIR_EQ /= y_eq.
rewrite (hyp_iso_inverse_comm f_iso) fan_hyp //.
rewrite Hypermap_and_fan.INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /=.
set w' := `sigma_fan _ V E v w`.
by rewrite f_eq ?fan_list_iso // dart_switch in_dart1_in_dart -w'_def sigma_in_dart1.
Qed.


Hypothesis good_nodes: `good_list_nodes L`.


Lemma fan_list_nodes_iso_BIJ: `BIJ (fan_list_nodes_iso (f,(V,E))) V (elements_of_list L)`.
Proof.
rewrite -finite_surj_eq_bij ?fan_list_nodes_iso_surj //.
rewrite (fan_imp_finite_set fanV) elements_of_list FINITE_SET_OF_LIST /=.
rewrite card_set_of_list_uniq ?uniq_list_of_elements //.
rewrite -(iffLR (good_list_nodes_condition goodL)) //.
rewrite -number_of_nodes (iso_number_of_nodes f_iso) number_of_nodes.
have [f [inj] ->]:= NODE_SET_AS_IMAGE fanV.
by apply CARD_IMAGE_INJ; rewrite (fan_imp_finite_set fanV) /= => x y [_] [_] /inj.
Qed.


Lemma fan_list_nodes_iso_inj x y: `x IN V /\ y IN V 
	/\ fan_list_nodes_iso (f,(V,E)) x = fan_list_nodes_iso (f,(V,E)) y
	==> x = y`.
Proof.
move => [x_in] [y_in] eq.
move: fan_list_nodes_iso_BIJ; rewrite BIJ INJ => [] [] [_] inj _.
exact: inj.
Qed.



Hypothesis f_surr: `fully_surrounded (V,E)`.


Lemma iso_imp_good_conditions d: `MEM d (list_of_darts L) /\ 3 < sizel (find_face L d)
	==> ~MEM (list_hyp_diag L d) (list_of_darts L) /\
	~(FST (list_hyp_diag L d) = SND (list_hyp_diag L d))`.
Proof.
move => [mem_d f_size].
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
move: (mem_d); rewrite -IN_SET_OF_LIST -darts_of_list -hypL => d_in.
have [[v w] [d_eq vw_in]]: `?x. f x = d /\ x IN dart_of_fan (V,E)`.
  have [x [x_in f_eq]] := hyp_iso_surj f_iso d_in.
  by exists x; rewrite -hypV.
have vw_in1: `v,w IN dart1_of_fan (V,E) /\ v,w IN dart H`.
  by rewrite hypV vw_in /= -fully_surrounded_dart_of_fan_eq.
have card_f: `3 < CARD (face H (v,w))`.
  by rewrite (hyp_iso_card_components f_iso) // -G_def card_face_of_list d_eq.
rewrite -d_eq -fan_list_diag_eq //; split; last first.
  rewrite !fan_list_iso /= -implybF => /fan_list_nodes_iso_inj.
  rewrite sigma_fan_inV // (PAIR_IN_DART_OF_FAN v w fanV) //=.
  by rewrite -sigma_fan_not_fixed.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL.
move: (fully_surrounded_diag_not_in_dart fanV f_surr vw_in).
rewrite H_def card_f /=; apply: contra => ww'_in.
set w' := `sigma_fan _ V E v w`.
have [[a b]] := hyp_iso_surj f_iso ww'_in.
rewrite hypV => [] [ab_in].
have ab_inV: `a IN V /\ b IN V` by rewrite !(PAIR_IN_DART_OF_FAN a b fanV).
have ww'_inV: `w IN V /\ w' IN V`.
  by rewrite -w'_def sigma_fan_inV // (PAIR_IN_DART_OF_FAN v w fanV).
rewrite hyp_iso_eq_fan_list_iso // !fan_list_iso PAIR_EQ.
move => [/fan_list_nodes_iso_inj] eq1 /fan_list_nodes_iso_inj eq2.
by rewrite -eq1 // -eq2.
Qed.


Lemma iso_imp_good_list_split d: `good_list (split_list_hyp L d)`.
Proof.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
apply: (good_list_split goodL).
case f_size: `sizel (find_pair_list L d) <= 3` => /=.
apply iso_imp_good_conditions; rewrite find_face_alt size_list_pairs mem_d.
by move: f_size; arith.
Qed.

(* Main isomorphism theorem *)
Theorem split_list_hyp_iso d: `d IN dart_of_fan (V,E) ==>
	hyp_iso (fan_list_iso (f,(V,E))) 
		(hypermap_of_fan (split_fan_face (V,E) d), hypermap_of_list (split_list_hyp L (f d)))`.
Proof.
move: d => [v w] vw_in.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have d1_eq := fully_surrounded_dart_of_fan_eq fanV f_surr.
have mem_fd: `MEM (f (v,w)) (list_of_darts L)`.
  by rewrite -IN_SET_OF_LIST -darts_of_list -hypL (hyp_iso_dart f_iso) hypV.
have card_f: `CARD (face H (v,w)) = sizel (find_face L (f (v,w)))`.
  by rewrite (hyp_iso_card_components f_iso) ?hypV // -card_face_of_list.
move: (goodL); rewrite good_list => [] [uniqL] _.
case f_size: `sizel (find_face L (f (v,w))) <= 3` => /=.
  rewrite (hypermap_of_split_list_eq3 f_size) // G_def.
  rewrite split_fan_face_eq H_def ?fanV ?vw_in.
    have := FULLY_SURROUNDED_IMP_CARD_FACE_GE_3 fanV f_surr vw_in.
    by move: f_size; rewrite H_def -card_f; arith.
  rewrite (hyp_iso_ext f_iso) hypV => x x_in.
  by rewrite hyp_iso_eq_fan_list_iso.
have card_f3: `3 < CARD (face (hypermap_of_fan (V,E)) (v,w))`.
  by move: f_size; rewrite H_def card_f; arith.
have [fan_split [dart_splitV_eq] f_split_surr] := fan_split_fan_face fanV f_surr vw_in.
set F1 := `split_fan_face (V,E) (v,w)`.
rewrite (pair_expand F1) in f_split_surr fan_split.
have /= := fully_surrounded_dart_of_fan_eq fan_split f_split_surr => split1_eq.
have good_split := iso_imp_good_list_split `f (v,w)`.
have vw_in1: `v,w IN dart1_of_fan (V,E)` by rewrite -d1_eq.
have diag_eq := fan_list_diag_eq vw_in1.
set w' := `sigma_fan (vec 0) V E v w`.
set R := `fan_list_iso _`.
have dart_splitL_eq: `dart (hypermap_of_list (split_list_hyp L (f (v,w))))
	= darts_of_list L UNION {R (w',w), R (w, w')}`.
  rewrite (components_hypermap_of_list good_split) darts_of_list.
  have gt3: `3 < sizel (find_pair_list L (f (v,w)))`.
    by move: f_size; rewrite find_face_alt size_list_pairs; arith.
  rewrite (perm_eq_set_of_list_eq (darts_of_list_split gt3)).
  rewrite -APPEND_cat SET_OF_LIST_APPEND UNION_COMM darts_of_list.
  congr `_1 UNION _2` => //.
  rewrite !"GEN_ALL set_of_list" -diag_eq.
  by rewrite -{2}R_def fan_list_iso e_list /= -fan_list_iso R_def "GEN_ALL Collect_geom.PER_SET2".
have /= := COMPONENTS_HYPERMAP_OF_FAN fan_split.
have := components_hypermap_of_list good_split.
set H1 := `hypermap_of_fan _`.
set G1 := `hypermap_of_list _`.
move => hypL1 hypV1.
have dartG1_eq: `dart G1 = IMAGE R (dart H1)`.
  rewrite dart_splitL_eq hypV1 dart_splitV_eq -d1_eq -hypL -hypV.
  rewrite IMAGE_UNION !"GEN_ALL IMAGE_CLAUSES"; congr `_1 UNION _2` => //.
  by rewrite (iso_dart f_iso) hypV -R_def; apply image_ext_eq => x /hyp_iso_eq_fan_list_iso ->.
rewrite hyp_iso_edge_face; split.
  rewrite dartG1_eq BIJ Misc_defs_and_lemmas.IMAGE_SURJ andbT INJ.
  split; first by move => x x_in; rewrite IN_IMAGE; exists x.
  move => [v1 w1] [v2 w2] [vw1_in] [vw2_in] eq.
  suff inV: `v1 IN V /\ v2 IN V /\ w1 IN V /\ w2 IN V`.
    move: eq; rewrite -R_def !fan_list_iso PAIR_EQ.
    by move => [/fan_list_nodes_iso_inj] -> // /fan_list_nodes_iso_inj ->.
  move: vw1_in vw2_in; rewrite hypV1 (pair_expand F1).
  move => /(PAIR_IN_DART_OF_FAN fan_split) vw1_in /(PAIR_IN_DART_OF_FAN fan_split).
  by move: vw1_in; rewrite -F1_def split_fan_face /=.
case => a b ab_in.
have Rab_in: `R (a,b) IN dart G1`.
  by rewrite dartG1_eq IN_IMAGE; exists `a,b`.
split.
  rewrite hypV1 hypL1 e_list_ext res -hypL1 Rab_in /= e_list.
  rewrite -R_def !fan_list_iso /= -fan_list_iso.
  by rewrite (pair_expand F1) e_fan_pair_ext_explicit // -pair_expand -hypV1.
have := "let_RULE f_split_fan_face" fanV f_surr vw_in card_f3.
rewrite F1_def w'_def.
set u := `sigma_fan _ V E w' v`.
move => f_fan_eq.
have := "let_RULE f_split_list" goodL `f (v,w)`; "ANTS_TAC".
  rewrite ltnNge f_size /=; apply iso_imp_good_conditions.
  by rewrite ltnNge.
set L2 := `split_list_hyp L _`.
rewrite -diag_eq; move => f_list_eq.
rewrite hypV1 (pair_expand F1) f_fan_pair_ext /= -split1_eq -hypV1 ab_in /=.
rewrite hypL1 f_list_ext res -hypL1 Rab_in /=.
have R_eq_f x: `x IN dart_of_fan (V,E) ==> R x = f x`.
  by move/hyp_iso_eq_fan_list_iso; rewrite R_def eq_sym.
case eq1: `a,b = v,w` => /=; first by rewrite eq1 R_eq_f.
have w'v_eq: `w',v = inverse (face_map H) (v,w)`.
  by rewrite hypV INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /= w'_def.
have w'v_in: `w',v IN dart H`.
  by rewrite w'v_eq lemma_dart_inveriant_under_inverse_maps.
have uw'_eq: `u,w' = inverse (face_map H) (w',v)`.
  rewrite hypV INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res.
  by rewrite -d1_eq -hypV w'v_in /= u_def.
case eq2: `a,b = w,w'` => /=.
  rewrite eq2 f_list_eq f_fan_eq w'v_eq.
  rewrite R_eq_f -?hypV ?lemma_dart_inveriant_under_inverse_maps //.
  rewrite -(hyp_iso_inverse_comm f_iso) // hypL.
  by rewrite f_list_ext_inverse // res darts_of_list IN_SET_OF_LIST.
have Rw'w_eq: `R (w',w) = e_list (R (w,w'))`.
  by rewrite -R_def eq_sym !fan_list_iso e_list.
case eq3: `a,b = w',w` => /=.
  rewrite eq3 f_fan_eq Rw'w_eq f_list_eq eq_sym.
  have ->: `f_fan_pair (V,E) (v,w) = face_map H (v,w)`.
    by rewrite hypV f_fan_pair_ext vw_in1.
  rewrite R_eq_f -?hypV ?lemma_dart_invariant //.
  by rewrite -(hyp_iso_comm f_iso) // hypL f_list_ext res darts_of_list IN_SET_OF_LIST.
set ff := `find_face L (f (v,w))`.
have Ruw'_eq: `R (u,w') = prev_el ff (prev_el ff (f (v,w)))`.
  rewrite uw'_eq R_eq_f -?hypV ?lemma_dart_inveriant_under_inverse_maps //.
  rewrite -(hyp_iso_inverse_comm f_iso) //.
  rewrite w'v_eq -(hyp_iso_inverse_comm f_iso) // hypL.
  rewrite {2}f_list_ext_inverse // res darts_of_list IN_SET_OF_LIST mem_fd /= ff_def.
  suff mem_ff: `prev_el ff (f (v,w)) IN darts_of_list L`.
    rewrite f_list_ext_inverse // res mem_ff /=.
    suff ->: `find_face L (prev_el ff (f (v,w))) = ff` by [].
    rewrite (find_face_eq uniqL) -?IN_SET_OF_LIST -?darts_of_list //.
    rewrite !IN_SET_OF_LIST mem_prev_el -ff_def -?dart_in_face //.
    by rewrite mem_find_face.
  rewrite darts_of_list IN_SET_OF_LIST; apply mem_find_face_imp_mem_darts.
  by exists `f (v,w)`; rewrite ff_def mem_prev_el -ff_def -dart_in_face.
case eq4: `a,b = u,w'` => /=.
  by rewrite eq4 f_fan_eq Ruw'_eq f_list_eq Rw'w_eq.
rewrite f_fan_eq; first by rewrite -hypV1 ab_in !negb_or.
have ab_in0: `a,b IN dart H`.
  move: ab_in; rewrite hypV1 dart_splitV_eq IN_UNION -d1_eq -hypV.
  by rewrite IN_INSERT IN_SING eq2 eq3.
rewrite f_list_eq; last first.
  have ->: `f_fan_pair (V,E) (a,b) = face_map H (a,b)`.
    by rewrite hypV f_fan_pair_ext -d1_eq -hypV ab_in0.
  rewrite eq_sym R_eq_f -?hypV ?lemma_dart_invariant //.
  rewrite -(hyp_iso_comm f_iso) // hypL f_list_ext res -hypL.
  by rewrite (hyp_iso_dart f_iso) //= R_eq_f // -hypV.
rewrite -IN_SET_OF_LIST -darts_of_list -hypL1 Rab_in andTb.
rewrite -Ruw'_eq -Rw'w_eq -R_eq_f //.
have in_all: `a IN V /\ b IN V /\ u IN V /\ v IN V /\ w' IN V /\ w IN V`.
  move: ab_in0; rewrite hypV => /(PAIR_IN_DART_OF_FAN fanV) [-> ->] /=.
  move: (w'v_in); rewrite hypV => /(PAIR_IN_DART_OF_FAN fanV) [-> ->] /=.
  move: (lemma_dart_inveriant_under_inverse_maps w'v_in).
  rewrite -uw'_eq hypV => [] [_] [_] /(PAIR_IN_DART_OF_FAN fanV) ->.
  by rewrite (PAIR_IN_DART_OF_FAN fanV vw_in).
apply: contraL (eq1,eq2,eq3,eq4).
rewrite !negb_and !negbK -R_def !fan_list_iso !PAIR_EQ.
by do !case; move/fan_list_nodes_iso_inj => h1 /fan_list_nodes_iso_inj h2; rewrite h1 // h2.
Qed.


Lemma iso_imp_good_list_nodes_split d: `good_list_nodes (split_list_hyp L d)`.
Proof.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
move: mem_d; rewrite -IN_SET_OF_LIST -darts_of_list -(components_hypermap_of_list goodL) => d_in.
have [[v w] [vw_in <-]] := hyp_iso_surj f_iso d_in.
rewrite (COMPONENTS_HYPERMAP_OF_FAN fanV) in vw_in.
have iso_th := split_list_hyp_iso vw_in.
rewrite good_list_nodes_condition ?iso_imp_good_list_split //.
rewrite -number_of_nodes (iso_number_of_nodes iso_th).
rewrite -(perm_eq_size (list_of_elements_split L `f (v,w)`)).
have [fan_split _] := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face in fan_split *.
rewrite fan_number_of_nodes // -(fan_number_of_nodes fanV).
by rewrite -(iso_number_of_nodes f_iso) number_of_nodes -good_list_nodes_condition.
Qed.

End FanAndList.

