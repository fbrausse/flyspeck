"needs \"../formal_lp/hypermap/ssreflect/list_hypermap-compiled.hl\"".
"needs \"../formal_lp/hypermap/ssreflect/add_triangle-compiled.hl\"".

Module List_hypermap_iso.

"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Hypermap_and_fan".
"open Fan_defs".
"open List_hypermap".
"open Add_triangle".
"open Hypermap_iso".



Section MoreFan.

Variable V : `:real^3->bool`.
Variable E : `:(real^3->bool)->bool`.

(* TODO: move to HypermapAndFan.hl *)
Lemma fst_node_hypermap_of_fan x y: `FAN (vec 0, V, E) /\ x IN node (hypermap_of_fan (V,E)) y
	==> FST x = FST y`.
Proof.
move => [fanV x_in].
apply: (FAN_NODE_EQ_lemma fanV).
by rewrite EQ_SYM_EQ; apply Hypermap.lemma_node_identity.
Qed.


Lemma e_fan_pair_ext_explicit v w: `(v,w) IN dart_of_fan (V,E)
	==> e_fan_pair_ext (V,E) (v,w) = (w,v)`.
Proof.
rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM e_fan_pair_ext /=.
case vw_in: `v,w IN _` => /=; first by rewrite e_fan_pair.
by move => [z] [_]; rewrite PAIR_EQ => [] [-> ->].
Qed.


End MoreFan.


(* res_inv *)
Section MoreResInv.

Lemma inj_res_inv_left f s t x: `INJ f s t /\ x IN s ==> res_inv f s (f x) = x`.
Proof. by rewrite INJ => [] h; rewrite res_inv_left //. Qed.

Lemma surj_res_inv_right f s t y: `SURJ f s t /\ y IN t ==>
	f (res_inv f s y) = y /\ res_inv f s y IN s`.
Proof. by rewrite SURJ => h; rewrite !(res_inv_right f s t) //. Qed.

End MoreResInv.


Lemma iso_fan_list_explicit V E L f: `FAN (vec 0,V,E) /\ good_list L
	/\ hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)
	==> ?h. !d. d IN dart_of_fan (V,E) ==> f d = (h (FST d), h (SND d))`.
Proof.
move => [fanV] [goodL] isoVL.
have [dartH mapsH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartG mapsG] := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have f_in d: `d IN dart_of_fan (V,E) ==> f d IN darts_of_list L`.
  by rewrite -dartH -dartG => d_in; rewrite (hyp_iso_dart isoVL).
set h := `\v. FST (f (v, if (v,v) IN dart_of_fan (V,E) then v else CHOICE (set_of_edge v V E)))`.
exists h.
have [g f_eq]: `?g. !v w. (v,w) IN dart_of_fan (V,E) ==> f(v,w) = (h v:A, g (v,w):A)`.
  exists `\d. SND (f d)`.
  move => v w vw_in; rewrite {1}(pair_expand `f (v,w)`) PAIR_EQ /= -h_def /=.
  case vv_in: `v,v IN _` => /=.
    have set_empty: `set_of_edge v V E = {}`.
      move: vv_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
      case; first by move/(PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV).
      by move => [u] [] h ->.
    move: vw_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
    case; first by move/(PAIR_IN_DART1_OF_FAN fanV); rewrite set_empty NOT_IN_EMPTY.
    by move => [u] [_] [-> ->].
  have vw_in1: `v,w IN dart1_of_fan (V,E)`.
    move: (vw_in); rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
    case => // [u] [_] eq.
    by move: vw_in vv_in; rewrite !eq /=.
  set w' := `CHOICE _`.
  suff: `f (v,w') IN node G (f (v,w))`.
    rewrite Hypermap.node Hypermap.orbit_map IN_ELIM_THM /= mapsG.
    move => [n] [_] ->.
    rewrite {2}pair_expand fst_n_list_ext_power //.
    by rewrite -pair_expand -dartG (hyp_iso_dart isoVL).
  rewrite (iso_components isoVL) ?dartH // FUN_IN_IMAGE.
  rewrite -H_def NODE_HYPERMAP_OF_FAN_ALT // IN_ELIM_THM /=.
  exists w'; split => //; rewrite -w'_def CHOICE_DEF -Ssrbool.implybF => eq.
  have := PAIR_IN_DART1_OF_FAN fanV vw_in1.
  by rewrite eq NOT_IN_EMPTY.
move => d d_in.
move: (IN_DART_OF_FAN fanV d_in) => [v] [w] [->] vw_in.
rewrite f_eq // FST SND PAIR_EQ /=.
move: (hyp_iso_comm isoVL `v,w`); rewrite dartH vw_in /=.
rewrite mapsG mapsH e_fan_pair_ext_explicit // e_list_ext res.
rewrite -dartG (hyp_iso_dart isoVL) ?dartH //=.
by rewrite !f_eq // 1?dart_switch // e_list SND PAIR_EQ => ->.
Qed.




(* MoreSeq *)
Section MoreSeq.


"let zip = GEN_ALL Seq.zip".
"let take = GEN_ALL Seq.take".
"let MEM = GEN_ALL MEM".

Lemma take_zip s1 s2 n: `take n (zip s1 s2) = zip (take n s1) (take n s2)`.
Proof.
elim: s1 s2 n => [| h1 t1 Ih1] [|h2 t2]; rewrite ?take zip ?take ?zip //.
by case => [|n]; rewrite !take zip.
Qed.

Lemma drop_zip s1 s2 n: `dropl n (zip s1 s2) = zip (dropl n s1) (dropl n s2)`.
Proof.
elim: s1 s2 n => [| h1 t2 Ih1] [|h2 t2]; rewrite ?drop zip ?drop ?zip //.
by case => [|n]; rewrite !drop ?zip.
Qed.

Lemma rot_zip s1 s2 n: `sizel s1 = sizel s2
	==> rot n (zip s1 s2) = zip (rot n s1) (rot n s2)`.
Proof.
move => size_eq.
by rewrite rot drop_zip take_zip -zip_cat -?rot // !size_drop size_eq.
Qed.

Lemma rotr_zip s1 s2 n: `sizel s1 = sizel s2
	==> rotr n (zip s1 s2) = zip (rotr n s1) (rotr n s2)`.
Proof.
move => size_eq.
by rewrite !rotr size1_zip size_eq ?leqnn // rot_zip.
Qed.

Lemma size1 x: `sizel [x] = 1`.
Proof. by rewrite size_cons size_nil ONE. Qed.

Lemma nth_rot x0 s k i: `k <= sizel s /\ i < sizel s
	==> nth x0 (rot k s) i = nth x0 s ((k + i) MOD sizel s)`.
Proof.
move => ineqs.
rewrite rot nth_cat size_drop.
case i_lt: `i:num < _` => /=.
  by rewrite nth_drop MOD_LT //; move: i_lt ineqs; arith.
have ->: `i - (sizel s - k) = (k + i) - sizel s` by move: i_lt ineqs; arith.
rewrite nth_take; first by move: i_lt ineqs; arith.
have {2}->: `k + i = 1 * sizel s + ((k + i) - sizel s)` by move: i_lt ineqs; arith.
rewrite MOD_MULT_ADD MOD_LT //.
by move: ineqs; arith.
Qed.

Lemma head_belast x0 x s: `0 < sizel s ==> headl x0 (belast x s) = x`.
Proof.
case: s => [|h t _]; first by rewrite size_nil ltn0.
by rewrite belast head.
Qed.

Lemma nth_belast x0 s x i: `i < sizel s ==> 
	nth x0 (belast x s) i = if i = 0 then x else nth x0 s (i - 1)`.
Proof.
elim: s i x => [|h t Ih] [|i x]; rewrite ?size_nil ?ltn0 //.
  by move => x lt; rewrite nth0 head_belast.
rewrite size_cons ltSS eqS0 /= => i_lt.
rewrite belast nth Ih // succnK.
by case: i => [|j] /=; rewrite nth // succnK eqS0.
Qed.

Lemma take_belast s x n: `n < sizel s /\ 0 < n ==> take n (belast x s) = x :: take (n - 1) s`.
Proof.
elim: s n x => [|h t Ih] [|n x]; rewrite ?size_nil ?ltn0 //.
rewrite belast take size_cons ltSS => ineqs.
case: n ineqs => [_|n ineqs]; first by rewrite -ONE subnn !take.
by rewrite Ih ?succnK ?take // gtS0.
Qed.

Lemma size1_eq s: `sizel s = 1 <=> ?x. s = [x]`.
Proof.
split => [| [x] ->]; last by rewrite size1.
case: s => [|h t]; first by rewrite size_nil; arith.
by rewrite size_cons ONE eqSS size_eq0 => ->; exists h.
Qed.


(* list_sumn *)
"let list_sumn = new_definition `list_sumn s f = foldr (\a b. f a + b) 0 s`".

"let foldr = GEN_ALL foldr".
"let map = GEN_ALL map".

Lemma list_sumn_nil f: `list_sumn [] f = 0`.
Proof. by rewrite list_sumn foldr. Qed.

Lemma list_sumn_cons h t f: `list_sumn (CONS h t) f = f h + list_sumn t f`.
Proof. by rewrite list_sumn foldr -list_sumn. Qed.

Lemma list_sum_eq_list_sumn s f: `list_sum s ((&) o f) = &(list_sumn s f)`.
Proof.
elim: s => [|h t Ih]; first by rewrite Seq2.list_sum_nil list_sumn_nil.
by rewrite list_sumn_cons Seq2.list_sum_cons -REAL_OF_NUM_ADD o_THM Ih.
Qed.

Lemma count_flatten s a: `count a (flatten s) = list_sumn (map (count a) s) I`.
Proof.
elim: s => [|h t Ih]; rewrite flatten foldr.
  by rewrite count map list_sumn_nil.
by rewrite -flatten map list_sumn_cons -Ih count_cat I_THM.
Qed.

Lemma perm_eq_flatten s1 s2: `perm_eq s1 s2 ==> perm_eq (flatten s1) (flatten s2)`.
Proof.
move => perm; rewrite perm_eqP => a.
rewrite !count_flatten -REAL_OF_NUM_EQ -!list_sum_eq_list_sumn.
by apply (Seq2.list_sum_perm_eq); rewrite Seq2.perm_eq_map.
Qed.


End MoreSeq.





(* Main definitions *)
(* Given a list [1;2;3;4;...;n], yields two lists [[1;2;3]; [1;4;...;n]] *)
"let split_list_face = new_definition
	`split_list_face f = if sizel f <= 3 then [f] else [take 3 f; HD f :: dropl 2 f]`".

"let split_list_hyp = (GEN_ALL o define) 
	`split_list_hyp [] d = [] /\
	 split_list_hyp (f :: t) d = 
		if MEM d (list_pairs f) then
			split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f)) ++ t
		else
			f :: split_list_hyp t d`".


"let list_hyp_diag = new_definition `list_hyp_diag L d = (SND d, FST (prev_el (find_face d L) d))`".

(* SplitListHyp *)
Section SplitListHyp.

Implicit Type d: `:A#A`.


Lemma list_of_darts_nil: `list_of_darts [] = []`.
Proof. by rewrite list_of_darts "GEN_ALL foldr". Qed.

Lemma list_of_darts_cons h t: `list_of_darts (h :: t) = list_pairs h ++ list_of_darts t`.
Proof. by rewrite list_of_darts "GEN_ALL foldr" /= -list_of_darts. Qed.

Lemma list_of_darts_cat s1 s2: `list_of_darts (s1 ++ s2) = list_of_darts s1 ++ list_of_darts s2`.
Proof.
elim: s1 => [|h t Ih]; rewrite cat ?(list_of_darts_nil, list_of_darts_cons) ?cat //.
by rewrite Ih catA.
Qed.

Lemma rot_list_pairs s n: `rot n (list_pairs s) = list_pairs (rot n s)`.
Proof. by rewrite list_pairs rot_zip ?size_rot // rot_rot -list_pairs. Qed.

Lemma list_pairs_rot s n: `perm_eq (list_pairs (rot n s)) (list_pairs s)`.
Proof. by rewrite -rot_list_pairs perm_eq_rot. Qed.

Lemma split_list_hyp_alt L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list d L and
	         n = indexl (find_pair_list d L) L in
	split_list_hyp L d = take n L ++ 
		(split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f))) ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  rewrite Seq.index_head take cat add0n drop1 behead.
  by rewrite split_list_hyp mem_d.
move => mem_dt.
rewrite split_list_hyp mem_d /= Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma d_not_in_dart_split_eq L d: `~(MEM d (list_of_darts L)) ==> split_list_hyp L d = L`.
Proof.
rewrite mem_list_of_darts NOT_EXISTS_THM negb_and.
elim: L => [|h t Ih]; rewrite split_list_hyp // => mem_d.
move: (mem_d h); rewrite "GEN_ALL MEM" /= Ih // => x.
move: (mem_d x); rewrite "GEN_ALL MEM" negb_or.
by case => ->.
Qed.


Lemma find_pair_list_empty L d: `find_pair_list d L = [] <=> ~(MEM d (list_of_darts L))`.
Proof.
elim: L => [| h t Ih]; rewrite find_pair_list ?list_of_darts_nil ?MEM //.
rewrite list_of_darts_cons mem_cat negb_or.
case mem_d: `MEM d _` => /=; last by rewrite Ih.
rewrite -implybF => h_eq.
by move: mem_d; rewrite h_eq list_pairs zip MEM.
Qed.


Lemma list_eq_cat_find_pair_list L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list d L and
	         n = indexl (find_pair_list d L) L in
	L = take n L ++ [f] ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  by rewrite Seq.index_head take cat add0n drop1 behead cat1s.
move => mem_dt; rewrite {1}Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop !cat.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma list_eq_cat_list_diag f d: `MEM d (list_pairs f) /\ 2 <= sizel f
	==> (let k = indexl d (list_pairs f) and
	     	y = FST (prev_el (list_pairs f) d) in
			rot k f = [FST d] ++ belast (SND d) (dropl 2 (rot k f)) ++ [y])`.
move => [mem_d f_size]; "CONV_TAC let_CONV".
set k := `indexl d _`.
set y := `FST (_1 _2 d)`.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
apply: (eq_from_nth y); rewrite size_rot !size_cat !size1 size_belast size_drop size_rot.
split => [|i]; first by move: f_size; arith.
have size_ineqs: `2 <= sizel f /\ 1 < sizel f /\ 0 < sizel f /\ k <= sizel f /\ 0 < sizel f - 1 /\ 1 <= sizel f`.
  by move: k_lt f_size; arith.
case: i => [_ | i].
  rewrite nth_rot // addn0 MOD_LT // cat1s nth.
  move: (nth_index `y,y` mem_d).
  by rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => ->.
case size_eq: `sizel f = 2` => /=.
  rewrite drop_oversize ?size_rot size_eq ?leqnn // belast !cat nth => i_lt.
  have ->: `i = 0` by move: i_lt; arith.
  rewrite nth nth_rot -?ONE //.
  rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
  rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
  rewrite list_pairs nth_zip ?size_rot // FST size_eq.
  by have ->: `2 - 1 + k = k + 1` by arith.
have size_ineqs2: `0 < sizel f - 2 /\ 2 < sizel f` by move: size_eq f_size; arith.
case: i => [_ | i].
  rewrite cat1s nth -ONE nth_rot // nth_cat size_belast size_drop size_rot size_ineqs2 /=.
  rewrite nth0 head_belast ?size_drop ?size_rot //.
  move: (nth_index `y,y` mem_d).
  rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => <-.
  by rewrite addnC nth_rot.
move => i_lt; rewrite cat1s nth.
case i_lt2: `SUC i < sizel f - 2` => /=.
  rewrite -{1}(cat_take_drop `2`) nth_cat size_take size_rot size_ineqs2 /=.
  have -> /=: `SUC (SUC i) < 2 <=> F` by arith.
  have ->: `SUC (SUC i) - 2 = i` by arith.
  rewrite nth_cat size_belast size_drop size_rot i_lt2 /=.
  by rewrite nth_belast ?succnK ?eqS0 // size_drop size_rot.
have ->: `SUC i = sizel f - 2` by move: i_lt2 i_lt; arith.
rewrite nth_cat size_belast size_drop size_rot ltnn /= subnn nth.
rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs k_lt; arith).
rewrite list_pairs nth_zip ?size_rot // FST.
by have ->: `k + SUC (sizel f - 2) = sizel f - 1 + k` by move: f_size; arith.
Qed.


Lemma darts_of_list_split L d: `3 < sizel (find_pair_list d L)
	==> perm_eq (list_of_darts (split_list_hyp L d))
		   ([list_hyp_diag L d; e_list L (list_hyp_diag L d)] ++ list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
have mem_d: `MEM d (list_of_darts L)`.
  by apply: contraLR f_size; rewrite -find_pair_list_empty => ->; rewrite size_nil; arith.
rewrite "let_RULE split_list_hyp_alt" // {4}("let_RULE list_eq_cat_find_pair_list" L d) //.
set f := `find_pair_list d L`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_catCA perm_cat2l catA perm_cat2r.
rewrite split_list_face -{1}f'_def size_rotr size_rot leqNgt f_size /=.
rewrite list_hyp_diag e_list SND FST find_face_alt f_def.
set y := `FST _`.
set k := `indexl d (list_pairs f)`.
have mem_d2: `MEM d (list_pairs f)` by rewrite -f_def -dart_in_find_pair_list.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
have size_ineq: `2 <= sizel f` by move: f_size; arith.
have := "let_RULE list_eq_cat_list_diag" mem_d2 size_ineq.
rewrite k_def y_def => rot_f_eq.
have f'_eq: `f' = cat [y; FST d] (belast (SND d) (dropl 2 (rot k f)))`.
  by rewrite -f'_def {1}rot_f_eq catA cats1 rotr1_rcons !cat.
rewrite !list_of_darts !"GEN_ALL foldr" /= !cats0.
have ->: `take 3 f' = [y; FST d; SND d]`.
  rewrite f'_eq take_cat !size_cons size_nil.
  have -> /=: `3 < SUC (SUC 0) <=> F` by arith.
  have ->: `3 - SUC (SUC 0) = 1` by arith.
  rewrite take_belast ?size_drop ?size_rot; first by move: f_size; arith.
  by rewrite subnn take cats1 !rcons.
have ->: `(HD f' :: dropl 2 f') = (y :: belast (SND d) (dropl 2 (rot k f)))`.
  by rewrite f'_eq {1}cat "GEN_ALL HD" drop_size_cat // !size_cons size_nil -ONE -TWO.
set X := `belast _1 _2`.
set R := `dropl 1 X`.
have X_eq: `X = SND d :: R`.
  rewrite -R_def -{1}(cat_take_drop `1` X) -{1}X_def.
  rewrite take_belast ?size_drop ?size_rot; first by move: f_size; arith.
  by rewrite subnn take cat1s.
rewrite perm_eq_sym 2!list_pairs !rot1_cons !rcons !zip.
rewrite perm_catC -cats1 X_eq cat zip cats1 -cat1s.
rewrite perm_eq_sym -cat1s -!catA perm_catCA perm_cat2l.
rewrite perm_eq_sym perm_catC -cat1s perm_catAC perm_catC -cat1s perm_catAC perm_catC perm_cat2l.
apply: (perm_eq_trans `list_pairs (rot k f)`).
rewrite list_pairs_rot andbT rot_f_eq perm_eq_sym.
rewrite list_pairs cat1s cats1 rot1_cons X_eq !rcons zip.
rewrite -cat1s perm_cat2l -!cats1 -cat1s catA zip_cat ?size_cat ?size_cons 1?addnC //.
by rewrite !zip perm_catC (cat1s `SND d`) perm_eq_refl.
Qed.


Lemma darts_of_list_split_same L d: `sizel (find_pair_list d L) <= 3
	==> perm_eq (list_of_darts (split_list_hyp L d)) (list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
case mem_d: `MEM d (list_of_darts L)` => /=; last first.
  by rewrite d_not_in_dart_split_eq // perm_eq_refl.
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
set f := `find_pair_list d L`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_cat2l perm_cat2r.
rewrite split_list_face -f'_def size_rotr size_rot f_size /=.
set k := `indexl d _`.
rewrite !list_of_darts !"GEN_ALL foldr" /= !cats0 rotr size_rot -!rot_list_pairs.
apply: (perm_eq_trans `rot k _`).
by rewrite !(perm_eq_rot, perm_eq_sym).
Qed.


Lemma mem_list_hyp_diag L d: `MEM d (list_of_darts L) /\ 
	(sizel (find_pair_list d L) = 1 \/ sizel (find_pair_list d L) = 3)
	==> MEM (list_hyp_diag L d) (find_face d L)`.
Proof.
move => [mem_d size_eq]; rewrite list_hyp_diag find_face_alt.
set f := `find_pair_list d L`.
set k := `indexl d (list_pairs f)`.
set y := `FST _`.
have mem_d2: `MEM d (list_pairs f)` by rewrite -f_def -dart_in_find_pair_list.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
case: size_eq => size_eq.
  move: size_eq; rewrite size1_eq => [] [x] f_eq.
  move: mem_d2; rewrite -y_def f_eq list_pairs rot1_cons rcons !zip mem_seq1 => ->.
  by rewrite SND prev_el Seq.index_head /= !last FST mem_seq1.
rewrite -(perm_eq_mem (list_pairs_rot f k)).
have size_ineq: `2 <= sizel f` by move: size_eq; arith.
have := "let_RULE list_eq_cat_list_diag" mem_d2 size_ineq.
rewrite k_def y_def => ->.
set l := `dropl 2 _`.
suff ->: `belast (SND d) l = [SND d]`.
  by rewrite !cat list_pairs rot1_cons !rcons !zip !MEM.
have: `sizel l = 1` by rewrite -l_def size_drop size_rot size_eq; arith.
by rewrite size1_eq => [] [x] ->; rewrite !belast.
Qed.


Lemma good_list_split L d: `~(MEM (list_hyp_diag L d) (list_of_darts L)) 
	/\ ~(FST (list_hyp_diag L d) = SND (list_hyp_diag L d)) /\ good_list L
	==> good_list (split_list_hyp L d)`.
Proof.
move => [n_mem] [neq] goodL.
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have := "let_RULE split_list_hyp_alt" mem_d.
have := "let_RULE list_eq_cat_find_pair_list" mem_d.
set f := `find_pair_list d L`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
move: (goodL); rewrite !good_list => [] [uniqL] [allL] symL L_eq split_eq.
case f_size: `sizel (find_pair_list d L) <= 3` => /=.
  have perm_darts := "let_RULE darts_of_list_split_same" f_size.
  rewrite (perm_eq_uniq perm_darts) uniqL andTb; split; last first.
    by move => y; rewrite !(perm_eq_mem perm_darts) => /symL.
  rewrite split_eq split_list_face -{1}f'_def size_rotr size_rot -f_def f_size /=.
  move: allL; rewrite {1}L_eq !all_cat !all /= => [] [_] [f_neq] _.
  by rewrite -size_eq0 -f'_def size_rotr size_rot size_eq0.
rewrite NOT_LE in f_size.
have perm_darts := "let_RULE darts_of_list_split" f_size.
split.
  rewrite (perm_eq_uniq perm_darts) !cat !"GEN_ALL uniq" uniqL MEM andbT; split; last first.
    by apply: contra n_mem => /symL; rewrite e_list SND FST -pair_expand.
  rewrite n_mem orbF.
  by apply: contra neq; rewrite e_list {1}pair_expand PAIR_EQ => ->.
split.
  move: allL; rewrite {1}L_eq split_eq !all_cat split_list_face.
  have f'_size: `3 < sizel f'` by rewrite -f'_def size_rotr size_rot -f_def f_size.
  rewrite leqNgt f'_size /= !all /= => _.
  by rewrite -!size_eq0 size_take f'_size /= size_cons; arith.
move => y; rewrite !(perm_eq_mem perm_darts) !mem_cat !MEM /= e_list.
set h := `list_hyp_diag L d`.
case; last by move/symL => ->.
by case => ->.
Qed.


Lemma good_list_uniq L: `good_list L ==> uniq L`.
Proof.
rewrite good_list => [] [uniqL] [allL] _.
elim: L allL uniqL => [|h t Ih]; rewrite "GEN_ALL uniq" //.
rewrite all /= list_of_darts_cons cat_uniq -hasPn /= => [] [h_neq] all_t [_] [mem_h] uniq_t.
rewrite Ih // andbT.
have [d mem_d]: `?d. MEM d (list_pairs h)`.
  case eq: `list_pairs h` => [|h' t']; last by exists h'; rewrite MEM.
  by move: eq; rewrite -size_eq0 size_list_pairs size_eq0 h_neq.
apply: contraL mem_h; rewrite NOT_FORALL_THM negb_imply negbK => mem_h.
exists d; rewrite mem_d andbT.
by rewrite mem_list_of_darts; exists h.
Qed.


Lemma list_of_darts_perm L1 L2: `perm_eq L1 L2 ==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
move => perm; rewrite !list_of_darts_alt !list_of_faces.
by rewrite perm_eq_flatten -map_MAP Seq2.perm_eq_map.
Qed.


Lemma good_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1 ==> good_list L2`.
Proof.
rewrite !good_list => [] [perm] [uniq1] [all1] sym1.
have perm_darts := list_of_darts_perm perm.
rewrite -(perm_eq_uniq perm_darts) uniq1 -(Seq2.all_perm_eq perm) all1 !andTb.
by move => d; rewrite -!(perm_eq_mem perm_darts) => /sym1.
Qed.


Lemma perm_eq_set_of_list_eq s1 s2: `perm_eq s1 s2 ==> set_of_list s1 = set_of_list s2`.
Proof. by rewrite EXTENSION !IN_SET_OF_LIST => perm x; rewrite (perm_eq_mem perm). Qed.


Lemma hypermap_of_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1
	==> hypermap_of_list L1 = hypermap_of_list L2`.
Proof.
move => [perm good1].
have good2 := good_list_perm perm good1.
have perm_darts := list_of_darts_perm perm.
have mem_eq := perm_eq_mem perm_darts.
rewrite !hypermap_of_list; congr `hypermap _`.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f1 (darts_of_list L1) = res f2 (darts_of_list L2)`.
  rewrite FUN_EQ_THM => eq d.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_d: `MEM d _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => d mem_d; rewrite !e_list.
have face_eq d: `MEM d (list_of_darts L1) ==> find_face d L2 = find_face d L1`.
  move => mem_d; rewrite !find_face_alt; congr `list_pairs _`.
  move: (good1); rewrite good_list => [] [uniq1] _.
  apply: (find_pair_list_unique uniq1).
  rewrite -find_face_alt -dart_in_face -mem_eq mem_d andbT.
  by rewrite (perm_eq_mem perm) mem_find_pair_list -mem_eq.
split; rewrite !(n_list_ext, f_list_ext); apply: res_eq => d mem_d.
  by rewrite !n_list face_eq // !e_list.
by rewrite !f_list face_eq.
Qed.


"let ALL2 = GEN_ALL ALL2".


Lemma find_face_cons h t d: 
	`find_face d (h :: t) = if MEM d (list_pairs h) then (list_pairs h) else find_face d t`.
Proof. by rewrite !find_face !list_of_faces MAP find_list. Qed.


Lemma find_face_rot L1 L2 d: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> ?n. find_face d L2 = rot n (find_face d L1)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 //=.
  by rewrite find_face list_of_faces MAP find_list rot_nil.
move => [] [n] h2_eq all2; rewrite !find_face_cons.
case mem_d: `MEM d (list_pairs h1)` => /=.
  by exists n; rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d /= rot_list_pairs.
move: (Ih all2) => [m] eq; exists m.
by rewrite h2_eq (perm_eq_mem (list_pairs_rot h1 n)) mem_d.
Qed.


Lemma rot_list_of_darts_perm L1 L2: `ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2
	==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
elim: L1 L2 => [|h1 t1 Ih] [|h2 t2]; rewrite ALL2 // ?list_of_darts_nil ?perm_eq_refl //=.
move => [] [n h2_eq] all2.
rewrite !list_of_darts_cons Seq2.perm_eq_cat Ih //.
by rewrite h2_eq perm_eq_sym list_pairs_rot.
Qed.


Lemma ALL2_cat f s1 t1 s2 t2: `sizel s1 = sizel s2 ==> 
	(ALL2 f (s1 ++ t1) (s2 ++ t2) <=> ALL2 f s1 s2 /\ ALL2 f t1 t2)`.
Proof.
elim: s1 s2 => [|h1 r1 Ih] [|h2 r2]; rewrite !(size_cons, size_nil) !cat !ALL2 //; try arith.
by rewrite eqSS => /Ih ->; rewrite andbA.
Qed.


Lemma rot_rot_eq_rot s m n: `?k. rot m (rot n s) = rot k s`.
Proof.
case m_le: `m <= sizel s` => /=; last first.
  by exists n; rewrite rot_oversize // size_rot; move: m_le; arith.
case n_le: `n <= sizel s` => /=; last first.
  by exists m; rewrite (rot_oversize n) //; move: n_le; arith.
rewrite rot_add_mod //.
set k := `if _ then _1 else _2`.
by exists k.
Qed.


Lemma index_take s n x: `indexl x (take n s) = if indexl x s < n then (indexl x s) else n`.
Proof.
elim: s n => [|h t Ih] [|n]; rewrite take ?index_nil; try arith.
rewrite !Seq2.index_cons.
case x_eq_h: `x = h` => /=; first by arith.
by rewrite ltSS Ih; case: `_1 < n:num`.
Qed.


Lemma index_drop_le s n x: `n <= indexl x s ==> indexl x (dropl n s) = indexl x s - n`.
Proof.
elim: s n => [|h t Ih] [|n]; rewrite drop ?index_nil; try arith.
rewrite !Seq2.index_cons.
case x_eq_h: `x = h` => /=; first by arith.
by rewrite leqSS subSS => /Ih ->.
Qed.


Lemma index_drop_uniq s n x: `uniq s ==>
	indexl x (dropl n s) = if n <= indexl x s then (indexl x s - n) else (sizel s - n)`.
Proof.
move => uniq_s.
case n_lt: `n < sizel s` => /=; last first.
  rewrite drop_oversize leqNgt // index_nil.
  by move: (index_size x s) n_lt; arith.
case n_le: `n:num <= _` => /=; first by rewrite index_drop_le.
rewrite -size_drop -index_eq_size.
apply: contraL uniq_s => mem_drop.
rewrite -(cat_take_drop n s) (mem_imp_not_uniq_cat x) // mem_drop.
rewrite -index_mem index_take size_take.
by rewrite NOT_LE in n_le; rewrite n_le /= n_lt.
Qed.


Lemma index_rot s n x: `uniq s /\ n < sizel s /\ MEM x s ==> 
  indexl x (rot n s) = if n <= indexl x s then (indexl x s - n) else (indexl x s + sizel s - n)`.
Proof.
move => [uniq_s] [n_lt] mem_x.
rewrite rot index_cat -index_mem size_drop index_drop_uniq // index_take.
set i := `indexl x s`.
have i_lt: `i < sizel s` by move: mem_x; rewrite -index_mem i_def.
by move: i_lt n_lt; arith.
Qed.


Lemma next_el_outside s x: `~(MEM x s) ==> next_el s x = x`.
Proof.
rewrite !index_eq_size => i_eq.
rewrite next_el i_eq.
case: s => [|h t]; first by rewrite size_nil sub0n /= head.
rewrite size_cons "ARITH_RULE `!n. ~(SUC n = SUC n - 1)`" /=.
by rewrite !nth_default // ?size_rot size_cons; arith.
Qed.


Lemma next_el_rot_eq s n: `uniq s ==> next_el (rot n s) = next_el s`.
Proof.
move => uniq_s; rewrite FUN_EQ_THM => x.
case n_lt: `n < sizel s` => /=; last first.
  by rewrite rot_oversize // -NOT_LT.
case mem_x: `MEM x s` => /=; last first.
  by rewrite !next_el_outside // mem_rot.
have mem_rot: `MEM x (rot n s)` by rewrite mem_rot.
rewrite !next_el_rot // -!nth0 index_rot //.
set i := `indexl x s`.
have i_lt: `i < sizel s` by move: mem_x; rewrite -index_mem.
have size_gt0: `0 < sizel s`.
  by case: s mem_x => [|h t]; rewrite MEM // size_cons gtS0.
have ineqs: `i + 1 <= sizel s /\ n <= sizel s /\ i - n + 1 <= sizel s /\ ~(0 = sizel s)`.
  by move: i_lt n_lt; arith.
case n_le: `n:num <= _` => /=.
  rewrite !nth_rot // ?size_rot // !addn0 -?DIVISION //.
  rewrite -{1}(MOD_LT n_lt) MOD_ADD_MOD //.
  by have ->: `n + i - n + 1 = i + 1` by move: n_le; arith.
have ineq2: `(i + sizel s - n) + 1 <= sizel s` by move: n_le i_lt; arith.
rewrite !nth_rot // ?size_rot // -?DIVISION // !addn0.
rewrite -{1}(MOD_LT n_lt) MOD_ADD_MOD //.
have ->: `n + (i + sizel s - n) + 1 = 1 * sizel s + (i + 1)` by move: n_lt; arith.
by rewrite MOD_MULT_ADD.
Qed.


Lemma next_el_inj s x y: `uniq s ==> (next_el s x = next_el s y <=> x = y)`.
Proof.
move => uniq_s; split => [| -> //].
case mem_x: `MEM x s` => /=; last first.
  rewrite next_el_outside // => x_eq.
  suff mem_y: `~MEM y s` by move: x_eq; rewrite next_el_outside.
  by apply: contra mem_x => /mem_next_el; rewrite -x_eq.
case mem_y: `MEM y s` => /=; last first.
  rewrite (next_el_outside mem_y) => y_eq.
  by move: (mem_next_el mem_x); rewrite y_eq mem_y.
by move/(congr1 `prev_el s`); rewrite !prev_next_id.
Qed.


Lemma prev_el_rot_eq s n x: `uniq s /\ MEM x s ==> prev_el (rot n s) x = prev_el s x`.
Proof.
move => [uniq_s mem_x].
rewrite -next_el_inj // -{1}(next_el_rot_eq n) // !next_prev_id //.
by rewrite rot_uniq mem_rot.
Qed.


Lemma rot_hypermap_of_list_eq L1 L2: 
	`ALL2 (\f1 f2. ?n. f2 = rot n f1) L1 L2 /\ uniq (list_of_darts L1)
	==> hypermap_of_list L2 = hypermap_of_list L1`.
Proof.
move => [all2 uniq1].
rewrite !hypermap_of_list; congr `hypermap _`.
have perm_darts := rot_list_of_darts_perm all2.
have mem_eq := perm_eq_mem perm_darts.
have face_eq := find_face_rot all2.
rewrite !darts_of_list (perm_eq_set_of_list_eq perm_darts) !PAIR_EQ /=.
have res_eq f1 f2: `(!d. MEM d (list_of_darts L1) ==> f1 d = f2 d)
	==> res f2 (darts_of_list L2) = res f1 (darts_of_list L1)`.
  rewrite FUN_EQ_THM => eq y.
  rewrite !res !darts_of_list !IN_SET_OF_LIST -mem_eq.
  by case mem_y: `MEM y _` => /=; rewrite eq.
split; first by rewrite !e_list_ext; apply: res_eq => y mem_y; rewrite !e_list.
split.
  rewrite !n_list_ext; apply: res_eq => d mem_d.
  move: (face_eq d) => [n] f_eq.
  rewrite !n_list f_eq prev_el_rot_eq ?e_list //.
  by rewrite uniq_find_face // -dart_in_face.
rewrite !f_list_ext; apply: res_eq => d mem_d.
move: (face_eq d) => [n] f_eq.
by rewrite !f_list f_eq next_el_rot_eq // uniq_find_face.
Qed.



Lemma hypermap_of_split_list_eq3 L d: `sizel (find_face d L) <= 3 /\ uniq (list_of_darts L)
	==> hypermap_of_list (split_list_hyp L d) = hypermap_of_list L`.
Proof.
move => [f_size uniq_darts].
case mem_d: `MEM d (list_of_darts L)` => /=; last by rewrite d_not_in_dart_split_eq.
have all2_refl: `!s:((A)list)list. ALL2 (\f1 f2. ?n. f2 = rot n f1) s s`.
  by elim => [|h t Ih]; rewrite ALL2 //= Ih andbT; exists `0`; rewrite rot0.
apply: (rot_hypermap_of_list_eq uniq_darts).
rewrite "let_RULE split_list_hyp_alt" // {1}("let_RULE list_eq_cat_find_pair_list" L d) //.
move: f_size; rewrite find_face_alt size_list_pairs.
set f := `find_pair_list d L`.
set n := `indexl f L`.
move => f_size.
rewrite split_list_face size_rotr size_rot f_size /=.
rewrite !ALL2_cat // ?size_cons // !all2_refl /= !ALL2 /= rotr.
set i := `sizel _ - 1`; set j := `indexl d _`.
by move: (rot_rot_eq_rot i j f) => [k] ->; exists k.
Qed.
