"needs \"../formal_lp/hypermap/ssreflect/list_hypermap-compiled.hl\"".
"needs \"../formal_lp/hypermap/ssreflect/add_triangle-compiled.hl\"".

Module List_hypermap_iso.

"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Hypermap_and_fan".
"open Fan_defs".
"open List_hypermap".
"open Add_triangle".
"open Hypermap_iso".



Section MoreFan.

Variable V : `:real^3->bool`.
Variable E : `:(real^3->bool)->bool`.

(* TODO: move to HypermapAndFan.hl *)
Lemma fst_node_hypermap_of_fan x y: `FAN (vec 0, V, E) /\ x IN node (hypermap_of_fan (V,E)) y
	==> FST x = FST y`.
Proof.
move => [fanV x_in].
apply: (FAN_NODE_EQ_lemma fanV).
by rewrite EQ_SYM_EQ; apply Hypermap.lemma_node_identity.
Qed.


Lemma e_fan_pair_ext_explicit v w: `(v,w) IN dart_of_fan (V,E)
	==> e_fan_pair_ext (V,E) (v,w) = (w,v)`.
Proof.
rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM e_fan_pair_ext /=.
case vw_in: `v,w IN _` => /=; first by rewrite e_fan_pair.
by move => [z] [_]; rewrite PAIR_EQ => [] [-> ->].
Qed.


End MoreFan.


(* res_inv *)
Section MoreResInv.

Lemma inj_res_inv_left f s t x: `INJ f s t /\ x IN s ==> res_inv f s (f x) = x`.
Proof. by rewrite INJ => [] h; rewrite res_inv_left //. Qed.

Lemma surj_res_inv_right f s t y: `SURJ f s t /\ y IN t ==>
	f (res_inv f s y) = y /\ res_inv f s y IN s`.
Proof. by rewrite SURJ => h; rewrite !(res_inv_right f s t) //. Qed.

End MoreResInv.


Lemma iso_fan_list_explicit V E L f: `FAN (vec 0,V,E) /\ good_list L
	/\ hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)
	==> ?h. !d. d IN dart_of_fan (V,E) ==> f d = (h (FST d), h (SND d))`.
Proof.
move => [fanV] [goodL] isoVL.
have [dartH mapsH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartG mapsG] := components_hypermap_of_list goodL.
set H := `hypermap_of_fan (V,E)`.
set G := `hypermap_of_list L`.
have f_in d: `d IN dart_of_fan (V,E) ==> f d IN darts_of_list L`.
  by rewrite -dartH -dartG => d_in; rewrite (hyp_iso_dart isoVL).
set h := `\v. FST (f (v, if (v,v) IN dart_of_fan (V,E) then v else CHOICE (set_of_edge v V E)))`.
exists h.
have [g f_eq]: `?g. !v w. (v,w) IN dart_of_fan (V,E) ==> f(v,w) = (h v:A, g (v,w):A)`.
  exists `\d. SND (f d)`.
  move => v w vw_in; rewrite {1}(pair_expand `f (v,w)`) PAIR_EQ /= -h_def /=.
  case vv_in: `v,v IN _` => /=.
    have set_empty: `set_of_edge v V E = {}`.
      move: vv_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
      case; first by move/(PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV).
      by move => [u] [] h ->.
    move: vw_in; rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
    case; first by move/(PAIR_IN_DART1_OF_FAN fanV); rewrite set_empty NOT_IN_EMPTY.
    by move => [u] [_] [-> ->].
  have vw_in1: `v,w IN dart1_of_fan (V,E)`.
    move: (vw_in); rewrite dart_of_fan_eq IN_UNION IN_ELIM_THM /= PAIR_EQ.
    case => // [u] [_] eq.
    by move: vw_in vv_in; rewrite !eq /=.
  set w' := `CHOICE _`.
  suff: `f (v,w') IN node G (f (v,w))`.
    rewrite Hypermap.node Hypermap.orbit_map IN_ELIM_THM /= mapsG.
    move => [n] [_] ->.
    rewrite {2}pair_expand fst_n_list_ext_power //.
    by rewrite -pair_expand -dartG (hyp_iso_dart isoVL).
  rewrite (iso_components isoVL) ?dartH // FUN_IN_IMAGE.
  rewrite -H_def NODE_HYPERMAP_OF_FAN_ALT // IN_ELIM_THM /=.
  exists w'; split => //; rewrite -w'_def CHOICE_DEF -Ssrbool.implybF => eq.
  have := PAIR_IN_DART1_OF_FAN fanV vw_in1.
  by rewrite eq NOT_IN_EMPTY.
move => d d_in.
move: (IN_DART_OF_FAN fanV d_in) => [v] [w] [->] vw_in.
rewrite f_eq // FST SND PAIR_EQ /=.
move: (hyp_iso_comm isoVL `v,w`); rewrite dartH vw_in /=.
rewrite mapsG mapsH e_fan_pair_ext_explicit // e_list_ext res.
rewrite -dartG (hyp_iso_dart isoVL) ?dartH //=.
by rewrite !f_eq // 1?dart_switch // e_list SND PAIR_EQ => ->.
Qed.




(* MoreSeq *)
Section MoreSeq.


"let zip = GEN_ALL Seq.zip".
"let take = GEN_ALL Seq.take".
"let MEM = GEN_ALL MEM".

Lemma take_zip s1 s2 n: `take n (zip s1 s2) = zip (take n s1) (take n s2)`.
Proof.
elim: s1 s2 n => [| h1 t1 Ih1] [|h2 t2]; rewrite ?take zip ?take ?zip //.
by case => [|n]; rewrite !take zip.
Qed.

Lemma drop_zip s1 s2 n: `dropl n (zip s1 s2) = zip (dropl n s1) (dropl n s2)`.
Proof.
elim: s1 s2 n => [| h1 t2 Ih1] [|h2 t2]; rewrite ?drop zip ?drop ?zip //.
by case => [|n]; rewrite !drop ?zip.
Qed.

Lemma rot_zip s1 s2 n: `sizel s1 = sizel s2
	==> rot n (zip s1 s2) = zip (rot n s1) (rot n s2)`.
Proof.
move => size_eq.
by rewrite rot drop_zip take_zip -zip_cat -?rot // !size_drop size_eq.
Qed.

Lemma rotr_zip s1 s2 n: `sizel s1 = sizel s2
	==> rotr n (zip s1 s2) = zip (rotr n s1) (rotr n s2)`.
Proof.
move => size_eq.
by rewrite !rotr size1_zip size_eq ?leqnn // rot_zip.
Qed.

Lemma size1 x: `sizel [x] = 1`.
Proof. by rewrite size_cons size_nil ONE. Qed.

Lemma nth_rot x0 s k i: `k < sizel s /\ i < sizel s
	==> nth x0 (rot k s) i = nth x0 s ((k + i) MOD sizel s)`.
Proof.
move => ineqs.
rewrite rot nth_cat size_drop.
case i_lt: `i:num < _` => /=.
  by rewrite nth_drop MOD_LT //; move: i_lt ineqs; arith.
have ->: `i - (sizel s - k) = (k + i) - sizel s` by move: i_lt ineqs; arith.
rewrite nth_take; first by move: i_lt ineqs; arith.
have {2}->: `k + i = 1 * sizel s + ((k + i) - sizel s)` by move: i_lt ineqs; arith.
rewrite MOD_MULT_ADD MOD_LT //.
by move: ineqs; arith.
Qed.

Lemma head_belast x0 x s: `0 < sizel s ==> headl x0 (belast x s) = x`.
Proof.
case: s => [|h t _]; first by rewrite size_nil ltn0.
by rewrite belast head.
Qed.

Lemma nth_belast x0 s x i: `i < sizel s ==> 
	nth x0 (belast x s) i = if i = 0 then x else nth x0 s (i - 1)`.
Proof.
elim: s i x => [|h t Ih] [|i x]; rewrite ?size_nil ?ltn0 //.
  by move => x lt; rewrite nth0 head_belast.
rewrite size_cons ltSS eqS0 /= => i_lt.
rewrite belast nth Ih // succnK.
by case: i => [|j] /=; rewrite nth // succnK eqS0.
Qed.

Lemma take_belast s x n: `n < sizel s /\ 0 < n ==> take n (belast x s) = x :: take (n - 1) s`.
Proof.
elim: s n x => [|h t Ih] [|n x]; rewrite ?size_nil ?ltn0 //.
rewrite belast take size_cons ltSS => ineqs.
case: n ineqs => [_|n ineqs]; first by rewrite -ONE subnn !take.
by rewrite Ih ?succnK ?take // gtS0.
Qed.


End MoreSeq.


(* Main definitions *)
(* Given a list [1;2;3;4;...;n], yields two lists [[1;2;3]; [1;4;...;n]] *)
"let split_list_face = new_definition
	`split_list_face f = if sizel f <= 3 then [f] else [take 3 f; HD f :: dropl 2 f]`".

"let split_list_hyp = (GEN_ALL o define) 
	`split_list_hyp [] d = [] /\
	 split_list_hyp (f :: t) d = 
		if MEM d (list_pairs f) then
			split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f)) ++ t
		else
			f :: split_list_hyp t d`".


"let list_hyp_diag = new_definition `list_hyp_diag L d = (SND d, FST (prev_el (find_face d L) d))`".

(* SplitListHyp *)
Section SplitListHyp.

Implicit Type d: `:A#A`.


Lemma list_of_darts_nil: `list_of_darts [] = []`.
Proof. by rewrite list_of_darts "GEN_ALL foldr". Qed.

Lemma list_of_darts_cons h t: `list_of_darts (h :: t) = list_pairs h ++ list_of_darts t`.
Proof. by rewrite list_of_darts "GEN_ALL foldr" /= -list_of_darts. Qed.

Lemma list_of_darts_cat s1 s2: `list_of_darts (s1 ++ s2) = list_of_darts s1 ++ list_of_darts s2`.
Proof.
elim: s1 => [|h t Ih]; rewrite cat ?(list_of_darts_nil, list_of_darts_cons) ?cat //.
by rewrite Ih catA.
Qed.

Lemma list_pairs_rot s n: `perm_eq (list_pairs (rot n s)) (list_pairs s)`.
Proof. by rewrite list_pairs rot_rot -rot_zip ?size_rot // -list_pairs perm_eq_rot. Qed.


Lemma split_list_hyp_alt L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list d L and
	         n = indexl (find_pair_list d L) L in
	split_list_hyp L d = take n L ++ 
		(split_list_face (rotr 1 (rot (indexl d (list_pairs f)) f))) ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  rewrite Seq.index_head take cat add0n drop1 behead.
  by rewrite split_list_hyp mem_d.
move => mem_dt.
rewrite split_list_hyp mem_d /= Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma d_not_in_dart_split_eq L d: `~(MEM d (list_of_darts L)) ==> split_list_hyp L d = L`.
Proof.
rewrite mem_list_of_darts NOT_EXISTS_THM negb_and.
elim: L => [|h t Ih]; rewrite split_list_hyp // => mem_d.
move: (mem_d h); rewrite "GEN_ALL MEM" /= Ih // => x.
move: (mem_d x); rewrite "GEN_ALL MEM" negb_or.
by case => ->.
Qed.


Lemma find_pair_list_empty L d: `find_pair_list d L = [] <=> ~(MEM d (list_of_darts L))`.
Proof.
elim: L => [| h t Ih]; rewrite find_pair_list ?list_of_darts_nil ?MEM //.
rewrite list_of_darts_cons mem_cat negb_or.
case mem_d: `MEM d _` => /=; last by rewrite Ih.
rewrite -implybF => h_eq.
by move: mem_d; rewrite h_eq list_pairs zip MEM.
Qed.


Lemma list_eq_cat_find_pair_list L d: `MEM d (list_of_darts L)
	==> (let f = find_pair_list d L and
	         n = indexl (find_pair_list d L) L in
	L = take n L ++ [f] ++ dropl (n + 1) L)`.
Proof.
move => mem_d; "CONV_TAC let_CONV"; move: mem_d.
elim: L => [|h t Ih]; first by rewrite list_of_darts_nil MEM.
rewrite list_of_darts_cons mem_cat find_pair_list.
case mem_d: `MEM d _` => /=.
  by rewrite Seq.index_head take cat add0n drop1 behead cat1s.
move => mem_dt; rewrite {1}Ih //.
set n := `indexl _1 _2`.
set m := `indexl _1 (CONS h t)`.
suff ->: `m = SUC n` by rewrite take cat addSn drop !cat.
rewrite -m_def Seq2.index_cons n_def.
case eq: `_ = h` => /=.
by move: mem_dt; rewrite dart_in_find_pair_list eq mem_d.
Qed.


Lemma darts_of_list_split L d: `3 < sizel (find_pair_list d L)
	==> perm_eq (list_of_darts (split_list_hyp L d))
		   ([list_hyp_diag L d; e_list L (list_hyp_diag L d)] ++ list_of_darts L)`.
Proof.
move => f_size; rewrite perm_eq_sym.
have mem_d: `MEM d (list_of_darts L)`.
  by apply: contraLR f_size; rewrite -find_pair_list_empty => ->; rewrite size_nil; arith.
rewrite "let_RULE split_list_hyp_alt" // {4}("let_RULE list_eq_cat_find_pair_list" L d) //.
set f := `find_pair_list d L`.
set n := `indexl f L`.
set f' := `rotr 1 _`.
rewrite !list_of_darts_cat perm_catCA perm_cat2l catA perm_cat2r.
rewrite split_list_face -{1}f'_def size_rotr size_rot leqNgt f_size /=.
rewrite list_hyp_diag e_list SND FST find_face_alt f_def.
set y := `FST _`.
set k := `indexl d (list_pairs f)`.
have mem_d2: `MEM d (list_pairs f)` by rewrite -f_def -dart_in_find_pair_list.
have k_lt: `k < sizel f` by rewrite -size_list_pairs -k_def index_mem.
have rot_f_eq: `rot k f = [FST d] ++ belast (SND d) (dropl 2 (rot k f)) ++ [y]`.
  apply: (eq_from_nth y); rewrite size_rot !size_cat !size1 size_belast size_drop size_rot.
  split => [|i]; first by move: f_size; arith.
  have size_ineqs: `2 < sizel f /\ 1 < sizel f /\ 0 < sizel f /\ k < sizel f /\ 0 < sizel f - 2`.
    by move: k_lt f_size; arith.
  case: i => [_ | i].
    rewrite nth_rot // addn0 MOD_LT // cat1s nth.
    move: (nth_index `y,y` mem_d2).
    by rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => ->.
  case: i => [_ | i].
    rewrite cat1s nth -ONE nth_rot // nth_cat size_belast size_drop size_rot size_ineqs /=.
    rewrite nth0 head_belast ?size_drop ?size_rot //.
    move: (nth_index `y,y` mem_d2).
    rewrite k_def list_pairs nth_zip ?size_rot // {1}(pair_expand d) PAIR_EQ => <-.
    by rewrite addnC nth_rot.
  move => i_lt; rewrite cat1s nth.
  case i_lt2: `SUC i < sizel f - 2` => /=.
    rewrite -{1}(cat_take_drop `2`) nth_cat size_take size_rot size_ineqs /=.
    have -> /=: `SUC (SUC i) < 2 <=> F` by arith.
    have ->: `SUC (SUC i) - 2 = i` by arith.
    rewrite nth_cat size_belast size_drop size_rot i_lt2 /=.
    by rewrite nth_belast ?succnK ?eqS0 // size_drop size_rot.
  have ->: `SUC i = sizel f - 2` by move: i_lt2 i_lt; arith.
  rewrite nth_cat size_belast size_drop size_rot ltnn /= subnn nth.
  rewrite -{2}y_def (prev_el_alt `y,y`) // k_def rotr.
  rewrite !nth_rot ?size_list_pairs; try (move: size_ineqs; arith).
  rewrite list_pairs nth_zip ?size_rot // FST.
  by have ->: `k + SUC (sizel f - 2) = sizel f - 1 + k` by move: f_size; arith.
have f'_eq: `f' = cat [y; FST d] (belast (SND d) (dropl 2 (rot k f)))`.
  by rewrite -f'_def {1}rot_f_eq catA cats1 rotr1_rcons !cat.
rewrite !list_of_darts !"GEN_ALL foldr" /= !cats0.
have ->: `take 3 f' = [y; FST d; SND d]`.
  rewrite f'_eq take_cat !size_cons size_nil.
  have -> /=: `3 < SUC (SUC 0) <=> F` by arith.
  have ->: `3 - SUC (SUC 0) = 1` by arith.
  rewrite take_belast ?size_drop ?size_rot; first by move: f_size; arith.
  by rewrite subnn take cats1 !rcons.
have ->: `(HD f' :: dropl 2 f') = (y :: belast (SND d) (dropl 2 (rot k f)))`.
  by rewrite f'_eq {1}cat "GEN_ALL HD" drop_size_cat // !size_cons size_nil -ONE -TWO.
set X := `belast _1 _2`.
set R := `dropl 1 X`.
have X_eq: `X = SND d :: R`.
  rewrite -R_def -{1}(cat_take_drop `1` X) -{1}X_def.
  rewrite take_belast ?size_drop ?size_rot; first by move: f_size; arith.
  by rewrite subnn take cat1s.
rewrite perm_eq_sym 2!list_pairs !rot1_cons !rcons !zip.
rewrite perm_catC -cats1 X_eq cat zip cats1 -cat1s.
rewrite perm_eq_sym -cat1s -!catA perm_catCA perm_cat2l.
rewrite perm_eq_sym perm_catC -cat1s perm_catAC perm_catC -cat1s perm_catAC perm_catC perm_cat2l.
apply: (perm_eq_trans `list_pairs (rot k f)`).
rewrite list_pairs_rot andbT rot_f_eq perm_eq_sym.
rewrite list_pairs cat1s cats1 rot1_cons X_eq !rcons zip.
rewrite -cat1s perm_cat2l -!cats1 -cat1s catA zip_cat ?size_cat ?size_cons 1?addnC //.
by rewrite !zip perm_catC (cat1s `SND d`) perm_eq_refl.
Qed.


Lemma good_list_split L d: `~(MEM (SND d, FST (inverse (f_list_ext L) d)) (list_of_darts L))
	/\ good_list L
	==> good_list (split_list_hyp L d)`.
Proof.
move => [n_mem] goodL.
move: (goodL); rewrite !good_list => [] [uniqL] [allL] symL.


