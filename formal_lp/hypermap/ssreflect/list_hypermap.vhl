"needs \"tame/ssreflect/seq2-compiled.hl\"".
"needs \"hypermap/hypermap.hl\"".
"needs \"fan/hypermap_and_fan.hl\"".
(* Some lemmas about BIJ, IN_TRANS, inE *)
"needs \"fan/hypermap_iso-compiled.hl\"".

Module List_hypermap.

"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Seq2".
"open Hypermap".
"open Hypermap_and_fan".

"parse_as_infix (\"::\", (12, \"right\"))".
"override_interface (\"::\", `CONS`)".
"make_overloadable \"++\" `:A -> A -> A`".
"overload_interface (\"++\", `cat`)".

(* General hypermap definitions *)
"let darts_k = new_definition `darts_k k H = {d:A | d IN dart H /\ CARD (face H d) = k}`".

"let face_set_k = 
	new_definition `face_set_k k (H:(A)hypermap) = {f | f IN face_set H /\ CARD f = k}`".


(* list_pairs [1;2;3] = {(1,2), (2,3), (3,1)} *)
"let list_pairs = new_definition `list_pairs list = zip list (rot 1 list)`".

"let list_of_darts = new_definition 
	`list_of_darts L = foldr (\list a. (list_pairs list) ++ a) [] L`".

"let darts_of_list = new_definition `darts_of_list L = set_of_list (list_of_darts L)`".

"let list_of_faces = new_definition `list_of_faces L = MAP list_pairs L`".

"let faces_of_list = new_definition `faces_of_list L = MAP set_of_list (list_of_faces L)`".

"let list_of_elements = new_definition `list_of_elements L = undup (flatten L)`".

"let elements_of_list = new_definition `elements_of_list L = set_of_list (list_of_elements L)`".

"let list_of_nodes = new_definition 
  `list_of_nodes L = MAP (\x. filter (\d. FST d = x) (list_of_darts L)) (list_of_elements L)`".

"let nodes_of_list = new_definition `nodes_of_list L = MAP set_of_list (list_of_nodes L)`".


(* Special lists *)

"let list_of_faces3 = new_definition `list_of_faces3 (L:((A)list)list) =
  filter (\f. LENGTH f = 3) (list_of_faces L)`".

"let list_of_faces4 = new_definition `list_of_faces4 (L:((A)list)list) =
  filter (\f. LENGTH f = 4) (list_of_faces L)`".

"let list_of_faces5 = new_definition `list_of_faces5 (L:((A)list)list) =
  filter (\f. LENGTH f = 5) (list_of_faces L)`".

"let list_of_faces6 = new_definition `list_of_faces6 (L:((A)list)list) =
  filter (\f. LENGTH f = 6) (list_of_faces L)`".

"let list_of_darts3 = new_definition `list_of_darts3 (L:((A)list)list) = 
  flatten (list_of_faces3 L)`".

"let list_of_darts4 = new_definition `list_of_darts4 (L:((A)list)list) =
  flatten (list_of_faces4 L)`".

"let list_of_darts5 = new_definition `list_of_darts5 (L:((A)list)list) = 
  flatten (list_of_faces5 L)`".

"let list_of_darts6 = new_definition `list_of_darts6 (L:((A)list)list) =
  flatten (list_of_faces6 L)`".

(* Faces *)

"let find_list = (GEN_ALL o define) `find_list [] x = []
	/\ find_list (CONS h t) x = if (MEM x h) then h else find_list t x`".

"let find_pair_list = (GEN_ALL o define) `find_pair_list [] d = [] 
   /\ find_pair_list (CONS h t) d = if (MEM d (list_pairs h)) then h else find_pair_list t d`".

"let find_face = new_definition `find_face L d = find_list (list_of_faces L) d`".


(* Hypermap maps *)

"let f_list = new_definition `f_list L d = next_el (find_face L d) d`".

"let e_list = new_definition `e_list d = (SND d, FST d)`".

"let n_list = new_definition `n_list L d = e_list (prev_el (find_face L d) d)`".


(* Hypermap definition *)

"let f_list_ext = new_definition `f_list_ext L = res (f_list L) (darts_of_list L)`".
"let e_list_ext = new_definition `e_list_ext L = res (e_list) (darts_of_list L)`".
"let n_list_ext = new_definition `n_list_ext L = res (n_list L) (darts_of_list L)`".


"let hypermap_of_list = new_definition 
	`hypermap_of_list (L:((A)list)list) = 
		hypermap (darts_of_list L, e_list_ext L, n_list_ext L, f_list_ext L)`".


(* Define "good" lists *)
"let good_list = new_definition `good_list L <=> 
	uniq (list_of_darts L) /\
         all (\l. ~(l = [])) L /\
         (!d. MEM d (list_of_darts L) ==> MEM (SND d, FST d) (list_of_darts L))`".

(* Define nodes of a good hypermap *)
"let good_list_nodes = new_definition `good_list_nodes L <=> 
	node_set (hypermap_of_list L) = set_of_list (nodes_of_list L)`".


(****************************)

(* lists *)

Lemma list_pairs_empty s: `list_pairs s = [] <=> s = []`.
Proof. by rewrite list_pairs -!size_eq0 size1_zip // size_rot leqnn. Qed.

Lemma list_of_darts_alt L: `list_of_darts L = flatten (list_of_faces L)`.
Proof.
rewrite list_of_darts flatten list_of_faces.
by elim: L => [|h t Ih]; rewrite MAP !foldr.
Qed.


(* Faces *)

Lemma find_face_alt L d: `find_face L d = list_pairs (find_pair_list L d)`.
Proof.
rewrite find_face list_of_faces.
elim: L => [| h t Ih].
  by rewrite MAP find_list find_pair_list list_pairs zip.
rewrite MAP find_pair_list find_list.
by case mem_d: `MEM d _` => /=; rewrite Ih.
Qed.

Lemma mem_find_list x L: `MEM x (flatten L) ==> MEM (find_list L x) L`.
Proof.
rewrite mem_flatten => [] [l].
elim: L => [|h t Ih]; rewrite MEM // find_list.
move => [[<- | lt] xl]; first by rewrite xl /= MEM.
by case xh: `MEM x h` => /=; rewrite MEM // Ih.
Qed.

Lemma mem_find_face d L: `MEM d (list_of_darts L) 
	==> MEM (find_face L d) (list_of_faces L)`.
Proof.
rewrite list_of_darts_alt => h.
by rewrite find_face mem_find_list.
Qed.

Lemma find_list_empty d L: `find_list L d = [] <=> ~(MEM d (flatten L))`.
Proof.
rewrite mem_flatten NOT_EXISTS_THM negb_and.
elim: L => [|h t Ih]; rewrite MEM find_list //.
case dh: `MEM d h` => /=.
  have -> /=: `~(h = [])` by apply: contraL dh => ->; rewrite MEM.
  by rewrite NOT_FORALL_THM negb_or !negbK; exists h.
rewrite Ih; split => h1 x.
  by case eq: `x = h` => /=; rewrite (eq, h1).
by case: (h1 x) => /=; rewrite negb_or /=.
Qed.


Lemma mem_find_list_nonempty x L: `all (\l. ~(l = [])) L
	==> (MEM x (flatten L) <=> MEM (find_list L x) L)`.
rewrite -allP /= => h1.
split => [|h2]; first by apply mem_find_list.
by move: (h1 h2); rewrite find_list_empty negbK.
Qed.


Lemma mem_find_face_nonempty d L: `all (\l. ~(l = [])) L
	==> (MEM d (list_of_darts L) <=> MEM (find_face L d) (list_of_faces L))`.
Proof.
move => h1.
rewrite find_face -mem_find_list_nonempty ?list_of_darts_alt //.
rewrite -!allP /= in h1 *; rewrite list_of_faces => s.
rewrite MEM_MAP => [] [l] [l_L] ->.
by rewrite EQ_SYM_EQ list_pairs_empty h1.
Qed.


(* Hypermap maps properties *)    


(* e_list_ext permutes darts *)

Lemma e_list_ext_involution L: `good_list L ==> e_list_ext L o e_list_ext L = I`.
Proof.
rewrite FUN_EQ_THM o_THM I_THM e_list_ext good_list => [] [h_uniq] [all_n] mem_snd [x y].
rewrite !res e_list FST SND darts_of_list !IN_SET_OF_LIST.
case xy_in: `MEM (x,y) _` => /=.
  by move: (mem_snd xy_in) => /=; rewrite e_list.
by rewrite xy_in.
Qed.


"let INVERSE_EXISTS_IMP_BIJECTIVE = prove(`!(f:A->B) g. f o g = I /\ g o f = I ==> (!y. ?!x. f x = y)`,
   REWRITE_TAC[FUN_EQ_THM; o_THM; I_THM] THEN			
     REPEAT STRIP_TAC THEN REWRITE_TAC[EXISTS_UNIQUE] THEN
     EXISTS_TAC `(g:B->A) y` THEN
     ASM_REWRITE_TAC[] THEN
     REPEAT STRIP_TAC THEN
     POP_ASSUM (MP_TAC o AP_TERM `g:B->A`) THEN
     ASM_REWRITE_TAC[])".


Lemma e_list_ext_permutes_darts L: `good_list L 
	==> (e_list_ext L) permutes (darts_of_list L)`.
Proof.
rewrite permutes => good_l; split.
  by move => x x_n; rewrite e_list_ext res x_n.
apply INVERSE_EXISTS_IMP_BIJECTIVE.
by exists `e_list_ext L`; rewr ETA_AX; rewrite e_list_ext_involution.
Qed.


(* f_list_ext permutes darts *)

Lemma dart_in_darts d l L: `MEM d (list_pairs l) /\ MEM l L
	==> MEM d (list_of_darts L)`.
Proof.
rewrite list_of_darts_alt mem_flatten list_of_faces MEM_MAP => h.
by exists `list_pairs l`; rewrite h andbT; exists l.
Qed.


Lemma mem_find_pair_list d L: `MEM d (list_of_darts L) ==> MEM (find_pair_list L d) L`.
Proof.
elim: L => [|h t Ih]; rewrite list_of_darts foldr MEM // find_pair_list /=.
case mem_d: `MEM d (list_pairs h)` => /=.
by rewrite mem_cat mem_d orFb -list_of_darts => /Ih ->.
Qed.


Lemma dart_in_find_pair_list d L: 
	`MEM d (list_of_darts L) <=> MEM d (list_pairs (find_pair_list L d))`.
Proof.
elim: L => [|h t Ih]; rewrite list_of_darts find_pair_list foldr.
  by rewrite list_pairs zip.
case mem_d: `MEM d (list_pairs h)` => /=; rewrite mem_cat mem_d // orFb.
by rewrite -list_of_darts Ih.
Qed.


Lemma dart_in_face d L: `MEM d (list_of_darts L) <=> MEM d (find_face L d)`.
Proof. by rewrite find_face_alt dart_in_find_pair_list. Qed.


Lemma uniq_imp_unique_list l1 l2 d L: 
	`uniq (list_of_darts L) /\ MEM l1 L /\ MEM l2 L
	/\ MEM d (list_pairs l1) /\ MEM d (list_pairs l2)
	==> l1 = l2`.
Proof.
elim: L => [|h t Ih]; rewrite !MEM //.
rewrite list_of_darts foldr /= -list_of_darts.
rewrite cat_uniq -hasP /= NOT_EXISTS_THM negb_and.
move => [] [uniq_h] [not_mem] uniq_t [h1] [h2] [d_l1] d_l2.
case: h1 h2 => h1 [] h2 //; last exact: Ih.
  move: (not_mem d); rewrite -h1 d_l1 /=.
  by rewrite (dart_in_darts d_l2).
move: (not_mem d); rewrite -h2 d_l2 /=.
by rewrite (dart_in_darts d_l1).
Qed.


Lemma find_pair_list_unique l d L: `uniq (list_of_darts L) /\ MEM l L /\ MEM d (list_pairs l) 
	==> l = find_pair_list L d`.
Proof.
move => [uniq_darts] [l_L] mem_d.
apply: (uniq_imp_unique_list uniq_darts mem_d).
by rewrite l_L -find_face_alt -dart_in_face mem_find_pair_list (dart_in_darts mem_d).
Qed.


Lemma uniq_find_face d L: `uniq (list_of_darts L) ==> uniq (find_face L d)`.
Proof.
elim: L => [|h t Ih]; rewrite list_of_darts foldr find_face list_of_faces MAP find_list //=.
rewrite -list_of_darts -list_of_faces -find_face cat_uniq => [] [uniq_h] [_] uniq_t.
by case: `MEM d _` => //=; rewrite Ih.
Qed.


Lemma size_list_pairs l: `sizel (list_pairs l) = sizel l`.
Proof. by rewrite list_pairs size1_zip // size_rot leqnn. Qed.

Lemma mem_list_pairs x y l: `MEM (x,y) (list_pairs l) ==> MEM x l /\ MEM y l`.
Proof. by rewrite list_pairs => /mem_zip; rewrite mem_rot. Qed.

Lemma mem_f_list d L: `MEM d (list_of_darts L) ==> MEM (f_list L d) (find_face L d)`.
Proof. by move => mem_d; rewrite f_list mem_next_el -dart_in_face. Qed.

Lemma nth_list_pairs x0 i s: `i < sizel s
	==> nth (x0, x0) (list_pairs s) i
		= (nth x0 s i, nth x0 s (if i = sizel s - 1 then 0 else i + 1))`.
Proof.
move => i_lt; rewrite list_pairs nth_zip ?size_rot //.
by rewrite nth_shift_left // -fun_if.
Qed.

Lemma uniq_list_pairs s: `uniq s ==> uniq (list_pairs s)`.
Proof.
set x0 := `HD s`.
rewrite (uniq_nthP x0) (uniq_nthP `x0, x0`) size_list_pairs => h i j [i_lt_j] j_lt.
apply: contra (h i_lt_j j_lt).
rewrite !nth_list_pairs // ?PAIR_EQ /=.
by move: i_lt_j j_lt; arith.
Qed.


Lemma mem_list_pairs_explicit x y s: `uniq s /\ MEM (x,y) (list_pairs s)
	==> y = next_el s x`.
Proof.
rewrite -(nthP `x,y` `x,x`) size_list_pairs => [] [uniq_s] [i].
rewrite list_pairs nth_zip ?size_rot // !PAIR_EQ => [] [i_lt] [x_eq] y_eq.
rewrite (next_el_alt x); first by rewrite -(nthP x x); exists i.
by rewrite -y_eq -{3}x_eq index_uniq.
Qed.


Lemma index_fst_snd x0 i x y s: `uniq s /\ i < sizel s /\ nth (x0,x0) (list_pairs s) i = (x,y)
	==> indexl x s = i /\ indexl y s = if (i = sizel s - 1) then 0 else i + 1`.
Proof.
move => [uniq_s] [i_lt] /=.
rewrite nth_list_pairs // PAIR_EQ => [] [<- <-].
by rewrite !index_uniq // uniq_s; move: i_lt; arith.
Qed.


Lemma next_el_list_pairs x y s: `uniq s /\ MEM (x,y) (list_pairs s)
	==> next_el (list_pairs s) (x,y) = (y, next_el s y)`.
Proof.
move => [uniq_s mem_d].
have ys: `MEM y s` by rewrite (mem_list_pairs mem_d).
rewrite (next_el_alt `x,x`) // (next_el_alt x) //.
set i := `indexl _1 _2`.
have nth_i: `nth (x,x) (list_pairs s) i = x,y`.
  by rewrite -i_def nth_index.
have i_lt: `i < sizel s`.
  by rewrite -i_def -size_list_pairs index_mem.
rewrite !nth_shift_left ?size_list_pairs // ?index_mem //.
rewrite (index_fst_snd uniq_s i_lt x x y) //.
case eq: `i = sizel s - 1` => /=.
  rewrite nth_list_pairs; first by move: i_lt; arith.
  rewrite PAIR_EQ; split.
    by rewrite -(nth_index x y s) // (index_fst_snd uniq_s i_lt x x y).
  by case eq2: `0 = sizel s - 1` => /=; rewrite -eq2.
rewrite nth_list_pairs; first by move: i_lt eq; arith.
rewrite PAIR_EQ; split.
  by rewrite -(nth_index x y s) // (index_fst_snd uniq_s i_lt x x y).
by case eq2: `i + 1 = _`.
Qed.


Lemma prev_el_list_pairs x y s: `uniq s /\ MEM (x,y) (list_pairs s)
	==> prev_el (list_pairs s) (x,y) = (prev_el s x, x)`.
Proof.
move => [uniq_s mem_d].
set t := `prev_el _1 _2`.
have mem_t: `MEM t (list_pairs s)`.
  by rewrite -t_def mem_prev_el.
case: t mem_t t_def => a b mem_t t_def.
have: `b = next_el s a`.
  by rewrite (mem_list_pairs_explicit uniq_s mem_t).
move/(congr1 `prev_el s`).
rewrite prev_next_id ?(mem_list_pairs mem_t) // => <-.
suff -> //: `b = x`.
move: (congr1 `next_el (list_pairs s)` t_def).
by rewrite next_prev_id ?uniq_list_pairs // next_el_list_pairs // PAIR_EQ => ->.
Qed.


Lemma f_list_inverse d L: `uniq (list_of_darts L) /\ MEM d (list_of_darts L)
	==> f_list L (prev_el (find_face L d) d) = d 
	/\ prev_el (find_face L (f_list L d)) (f_list L d) = d`.
Proof.
move => [uniq_s mem_d]; rewrite !f_list; split.
  set f := `find_face L d`.
  suff ->: `find_face L (prev_el f d) = f`.
    by rewrite next_prev_id // -f_def uniq_find_face // -dart_in_face.
  rewrite -{2}f_def !find_face_alt eq_sym; congr `_1 _2` => //.
  apply: (find_pair_list_unique uniq_s).
  rewrite mem_find_pair_list // -find_face_alt f_def mem_prev_el //.
  by rewrite -f_def -dart_in_face.
set f := `find_face L d`.
suff ->: `find_face L (next_el f d) = f`.
  by rewrite prev_next_id // -f_def uniq_find_face // -dart_in_face.
rewrite -{2}f_def !find_face_alt eq_sym; congr `_1 _2` => //.
apply: (find_pair_list_unique uniq_s).
rewrite mem_find_pair_list // -find_face_alt f_def mem_next_el //.
by rewrite -f_def -dart_in_face.
Qed.


Lemma find_face_f_list d L: `uniq (list_of_darts L) /\ MEM d (list_of_darts L)
	==> find_face L (f_list L d) = find_face L d`.
Proof.
move => [uniq_s mem_d].
rewrite !find_face_alt eq_sym; congr `_1 _2` => //.
apply: (find_pair_list_unique uniq_s).
by rewrite mem_find_pair_list // -find_face_alt mem_f_list.
Qed.


Lemma f_list_ext_permutes_darts L: `uniq (list_of_darts L)
	==> (f_list_ext L) permutes (darts_of_list L)`.
Proof.
move => uniq_s.
rewrite f_list_ext Hypermap_and_fan.RES_PERMUTES darts_of_list !IN_SET_OF_LIST.
split => [d mem_d | ].
  by rewrite dart_in_face find_face_f_list // mem_f_list.
split => [d mem_d | d1 d2 [mem_d1] [mem_d2] eq]; last first.
  have [_ <-] := f_list_inverse uniq_s mem_d1.
  by rewrite eq (f_list_inverse uniq_s mem_d2).
exists `prev_el (find_face L d) d`.
rewrite f_list_inverse //= dart_in_face.
set f := `find_face L d`.
suff ->: `find_face L (prev_el f d) = f`.
  by rewrite mem_prev_el // -f_def -dart_in_face.
rewrite -{2}f_def !find_face_alt eq_sym; congr `_1 _2` => //.
apply: (find_pair_list_unique uniq_s).
rewrite mem_find_pair_list // -find_face_alt f_def mem_prev_el //.
by rewrite -f_def -dart_in_face.
Qed.


(* e o n o f = I *)

Lemma find_face_empty d L: `find_face L d = [] <=> ~MEM d (list_of_darts L)`.
Proof. by rewrite find_face find_list_empty list_of_darts_alt. Qed.


Lemma mem_find_face_imp_faces_eq d1 d2 L: `uniq (list_of_darts L) /\ MEM d1 (find_face L d2)
	==> find_face L d1 = find_face L d2`.
Proof.
move => [uniq_s mem_d1].
rewrite !find_face_alt eq_sym; congr `_1 _2` => //.
apply: (find_pair_list_unique uniq_s).
rewrite -find_face_alt mem_d1 mem_find_pair_list //.
apply: contraLR mem_d1.
by rewrite -find_face_empty => ->; rewrite MEM.
Qed.


Lemma mem_find_face_imp_mem_darts d y L: `MEM d (find_face L y) ==> MEM d (list_of_darts L)`.
Proof.
elim: L => [| h t Ih]; rewrite find_face list_of_darts foldr list_of_faces MAP find_list //.
rewrite -list_of_darts /= mem_cat.
case mem_y: `MEM y _` => /=.
by rewrite -list_of_faces -find_face => /Ih ->.
Qed.


Lemma f_list_ext_inverse L: `uniq (list_of_darts L)
	==> inverse (f_list_ext L) = res (\d. prev_el (find_face L d) d) (darts_of_list L)`.
Proof.
rewrite FUN_EQ_THM => uniq_s d.
rewrite (PERMUTES_INVERSE_EQ (f_list_ext_permutes_darts uniq_s)).
rewrite f_list_ext !res /= darts_of_list !IN_SET_OF_LIST.
case mem_d: `MEM d _` => /=; last by rewrite mem_d.
suff -> /=: `MEM _1 _2` by rewrite f_list_inverse.
apply mem_find_face_imp_mem_darts; exists d.
by rewrite mem_prev_el -dart_in_face.
Qed.


Lemma f_list_ext_inverse_works L: `uniq (list_of_darts L)
	==> f_list_ext L o inverse (f_list_ext L) = I
	/\ inverse (f_list_ext L) o f_list_ext L = I`.
Proof.
move => uniq_s.
exact: (PERMUTES_INVERSES_o (f_list_ext_permutes_darts uniq_s)).
Qed.


Lemma n_eq_e_fi L: `uniq (list_of_darts L)
	==> n_list_ext L = e_list_ext L o inverse (f_list_ext L)`.
Proof.
move => uniq_s.
rewrite f_list_ext_inverse // -eq_ext o_THM n_list_ext e_list_ext !res /= => d.
rewrite darts_of_list !IN_SET_OF_LIST.
case mem_d: `MEM d _` => /=; last by rewrite mem_d.
suff -> /=: `MEM _1 _2` by rewrite n_list.
apply mem_find_face_imp_mem_darts; exists d.
by rewrite mem_prev_el -dart_in_face.
Qed.


Lemma n_list_ext_permutes_darts L: `good_list L
	==> (n_list_ext L) permutes (darts_of_list L)`.
Proof.
move => good_s; move: (good_s); rewrite good_list => [] [uniq_s] _.
rewrite n_eq_e_fi // PERMUTES_COMPOSE.
rewrite e_list_ext_permutes_darts // PERMUTES_INVERSE //.
exact: (f_list_ext_permutes_darts uniq_s).
Qed.


Lemma e_n_f_id L: `good_list L
	==> e_list_ext L o n_list_ext L o f_list_ext L = I`.
Proof.
move => good_s; move: (good_s); rewrite good_list => [] [uniq_s] _.
by rewrite n_eq_e_fi // !o_ASSOC e_list_ext_involution // I_O_ID f_list_ext_inverse_works.
Qed.


(* hypermap_of_list is a hypermap *)

Lemma tuple_hypermap_of_list L: `good_list L
	==> tuple_hypermap (hypermap_of_list L) =
	darts_of_list L, e_list_ext L, n_list_ext L, f_list_ext L`.
Proof.
move => good_s; move: (good_s); rewrite good_list => [] [uniq_s] _.
rewrite hypermap_of_list -"CONJUNCT2 hypermap_tybij" /=.
rewrite e_list_ext_permutes_darts // n_list_ext_permutes_darts // f_list_ext_permutes_darts //.
by rewrite e_n_f_id // darts_of_list FINITE_SET_OF_LIST.
Qed.


(* Set of faces *)

Lemma f_list_ext_orbit L x: `MEM x (list_of_darts L) /\ uniq (list_of_darts L)
	==> orbit_map (f_list_ext L) x = set_of_list (find_face L x)`.
Proof.
move => [mem_x uniq_l].
rewrite f_list_ext ORBIT_MAP_RES.
  by rewrite -f_list_ext f_list_ext_permutes_darts // darts_of_list IN_SET_OF_LIST.
have x_in_face: `MEM x (find_face L x)` by rewrite -dart_in_face.
suff ->: `orbit_map (f_list L) x = orbit_map (next_el (find_face L x)) x`.
  by rewrite next_el_orbit // uniq_find_face.
suff eq n: `(f_list L POWER n) x = (next_el (find_face L x) POWER n) x`.
  by rewrite !orbit_map eq.
elim: n => [|n Ih]; first by rewrite !POWER_0.
rewrite !COM_POWER !o_THM Ih f_list.
congr `next_el _1 _2` => //.
apply: (mem_find_face_imp_faces_eq uniq_l).
rewrite (next_el_power x) ?uniq_find_face //.
rewrite mem_nth -DIVISION.
by move: x_in_face; rewrite -index_mem; arith.
Qed.


Lemma uniq_flatten L: `uniq (flatten L) /\ all (\l. ~(l = [])) L ==> uniq L`.
Proof.
elim: L => [|h t Ih]; rewrite uniq // flatten all foldr cat_uniq -flatten.
move => [] [uniq_h] [not_has] uniq_t [h_n0] all_t.
rewrite Ih // andbT.
apply: contra not_has; rewrite -hasP /= => ht.
move: h_n0; rewrite -size_eq0 -lt0n -has_predT -hasP => [] [x] [xh] _.
exists x; rewrite xh andbT.
by rewrite mem_flatten; exists h.
Qed.


Lemma flatten_filter_empty L: `flatten (filter (\l. ~(l = [])) L) = flatten L`.
Proof.
elim: L => [|h t Ih]; rewrite flatten filter // foldr -flatten /=.
case eq: `h = []` => /=.
  by rewrite Ih eq cat.
by rewrite flatten foldr -flatten Ih.
Qed.


Lemma uniq_sublist_unique l1 l2 L x: `uniq (flatten L) /\ MEM l1 L /\ MEM l2 L
	/\ MEM x l1 /\ MEM x l2
	==> l1 = l2`.
elim: L => [|h t Ih]; rewrite !MEM // flatten_cons cat_uniq.
move => [] [uniq_h] [not_has] uniq_t [c1] [c2] [x_l1] x_l2.
case: c1 c2 => [eq1 | l1t] [eq2 | l2t] //; last by rewrite Ih.
  apply: contraR not_has => _; rewrite -hasP /=.
  by exists x; rewrite mem_flatten -eq1 x_l1 andbT; exists l2.
apply: contraR not_has => _; rewrite -hasP /=.
by exists x; rewrite mem_flatten -eq2 x_l2 andbT; exists l1.
Qed.


Lemma uniq_face_unique f1 f2 d L: `uniq (list_of_darts L)
	/\ MEM f1 (list_of_faces L) /\ MEM f2 (list_of_faces L) /\ MEM d f1 /\ MEM d f2
	==> f1 = f2`.
Proof.
move => [uniq_l] [mem_f1] [mem_f2] [mem_d1] mem_d2.
apply uniq_sublist_unique.
exists `list_of_faces L` d.
by rewrite -list_of_darts_alt.
Qed.


Lemma mem_face_lemma f L: `good_list L /\ MEM f (list_of_faces L)
	==> ?d. MEM d (list_of_darts L) /\ f = find_face L d`.
Proof.
rewrite good_list => [] [] [uniq_s] [all_n0] _ mem_f.
exists `HD f`.
have f_n0: `~(f = [])`.
  suff: `all (\l. ~(l = [])) (list_of_faces L)`.
    by apply: contraL; rewrite -allPn /= => f_eq; exists f.
  rewrite list_of_faces -map_MAP all_map preim /= -allP => x x_L /=.
  rewrite list_pairs_empty.
  by move: all_n0; rewrite -allP => /(_ x_L).
have mem_hd: `MEM (HD f) f`.
  by case: f f_n0 => // h t; rewrite HD MEM.
rewrite dart_in_face.
suff ->: `find_face L (HD f) = f` by [].
apply: (uniq_face_unique uniq_s `HD f`).
suff mem_hd2: `MEM (HD f) (list_of_darts L)`.
  by rewrite mem_find_face // -dart_in_face.
by rewrite list_of_darts_alt mem_flatten; exists f.
Qed.


Lemma face_set_eq_list L: `good_list L
	==> face_set (hypermap_of_list L) = set_of_list (faces_of_list L)`.
Proof.
move => good_s; move: (good_s); rewrite good_list => [] [uniq_s] [all_n0] _.
rewrite face_set face_map dart tuple_hypermap_of_list //=.
rewrite set_of_orbits EXTENSION IN_ELIM_THM IN_SET_OF_LIST /= => f.
rewrite darts_of_list IN_SET_OF_LIST.
split => [[d] [mem_d] -> | ].
  rewrite f_list_ext_orbit // faces_of_list MEM_MAP.
  by exists `find_face L d`; rewrite mem_find_face.
rewrite faces_of_list MEM_MAP => [] [ff] [mem_ff] ->.
have [d [mem_d] ->] := mem_face_lemma good_s mem_ff.
by exists d; rewrite f_list_ext_orbit.
Qed.


Lemma components_hypermap_of_list L: `good_list L
	==> dart (hypermap_of_list L) = darts_of_list L
	/\ edge_map (hypermap_of_list L) = e_list_ext L
 	/\ node_map (hypermap_of_list L) = n_list_ext L
	/\ face_map (hypermap_of_list L) = f_list_ext L`.
Proof.
move => good_s.
rewrite dart edge_map node_map face_map.
by rewrite tuple_hypermap_of_list.
Qed.


Lemma node_of_list_lemma x L: `set_of_list (filter (\d. FST d = x) (list_of_darts L))
	= {(x, y) | y | (x, y) IN darts_of_list L}`.
Proof.
rewrite set_of_list_filter darts_of_list IN_SET_OF_LIST EXTENSION !IN_ELIM_THM /= => d.
split => [[y] h | [y] h].
  by exists `SND d`; rewrite h -h PAIR.
by exists d.
Qed.


Lemma image_lemma f s: `{f x | x IN s} = IMAGE f s`.
Proof. by rewrite EXTENSION IN_ELIM_THM IN_IMAGE /= andbC. Qed.


Lemma set_nodes_of_list L: `set_of_list (nodes_of_list L)
	= {{(x, y) | y | (x, y) IN darts_of_list L} | x | x IN elements_of_list L}`.
Proof.
rewrite nodes_of_list list_of_nodes !SET_OF_LIST_MAP.
rewrite -!image_lemma IN_ELIM_THM /= -elements_of_list.
rewrite EXTENSION !IN_ELIM_THM /= => y.
split => [[n] [] [i] h -> | [i] h].
  by exists i; rewrite !h node_of_list_lemma.
exists `filter (\d. FST d = i) (list_of_darts L)`.
rewrite node_of_list_lemma -h /=.
by exists i.
Qed.


Lemma good_list_node L d: `good_list L /\ good_list_nodes L /\ d IN darts_of_list L
	==> node (hypermap_of_list L) d = {(FST d, y) | y | (FST d, y) IN darts_of_list L}`.
Proof.
rewrite good_list_nodes node_set set_of_orbits -node.
rewrite set_nodes_of_list EXTENSION !IN_ELIM_THM /= => [] [good_s] [eq] d_in.
move: (eq `node (hypermap_of_list L) d`).
have -> /=: `?x. _ x`.
  by exists d; rewrite components_hypermap_of_list.
move => [x] [x_in] eq; rewrite eq.
suff ->: `x = FST d` by [].
have := node_refl `hypermap_of_list L` d.
by rewrite eq IN_ELIM_THM /= => [] [y] ->.
Qed.


Lemma prev_el_list_pairs_general x y s: `MEM (x,y) (list_pairs s)
	==> ?z. prev_el (list_pairs s) (x,y) = (z,x) /\ MEM (z,x) (list_pairs s)`.
Proof.
move => mem_xy.
set z := `FST (prev_el (list_pairs s) (x,y))`.
exists z.
suff eq: `_1 = _2` by rewrite -eq mem_prev_el.
suff {2}<-: `SND (prev_el (list_pairs s) (x,y)) = x` by rewrite -z_def PAIR.
rewrite (prev_el_alt `x,x`) //.
set k := `indexl (x,y) _`.
set n := `sizel s`.
have k_lt: `k < n:num`.
  by rewrite -k_def -n_def -size_list_pairs index_mem.
have nth_s: `nth x s k = x`.
  have := nth_index mem_xy `x,x`.
  by rewrite k_def list_pairs nth_zip ?size_rot // PAIR_EQ => ->.
rewrite nth_shift_right ?size_list_pairs // list_pairs.
case eq: `k = 0` => /=.
  rewrite nth_zip ?size_rot // SND nth_shift_left /=; last by rewrite -eq nth_s.
  by rewrite n_def; move: k_lt; arith.
rewrite nth_zip ?size_rot // SND nth_shift_left; first by rewrite n_def; move: k_lt; arith.
rewrite subnK; first by move: eq; arith.
by rewrite nth_s n_def; move: eq k_lt; arith.
Qed.


Lemma n_list_ext_fst x y L: `good_list L /\ (x,y) IN darts_of_list L
	==> ?z. n_list_ext L (x,y) = (x,z) /\ (x,z) IN darts_of_list L`.
Proof.
move => [good_s xy_in].
move: (xy_in); rewrite darts_of_list IN_SET_OF_LIST dart_in_face find_face_alt => mem_xy.
have [z [eq mem_zx]] := prev_el_list_pairs_general mem_xy.
exists z.
have n_eq: `_1 = _2`.
  by rewrite n_list_ext res n_list xy_in /= find_face_alt eq e_list.
rewrite n_eq /= -n_eq -darts_of_list -!components_hypermap_of_list //.
by rewrite lemma_dart_invariant // components_hypermap_of_list.
Qed.


Lemma list_ext_power_in_darts d L n: `good_list L /\ d IN darts_of_list L
	==> (e_list_ext L POWER n) d IN darts_of_list L /\
	    (n_list_ext L POWER n) d IN darts_of_list L /\
	    (f_list_ext L POWER n) d IN darts_of_list L`.
Proof.
move => [good_s]; rewrite -!components_hypermap_of_list // => d_in.
rewrite lemma_dart_invariant_power_node //.
rewrite lemma_dart_invariant_power_face // !andbT.
apply Hypermap_iso.IN_TRANS; exists `edge (hypermap_of_list L) d`.
by rewrite lemma_edge_subset // lemma_in_edge2.
Qed.


Lemma fst_n_list_ext_power x y L n: `good_list L /\ x,y IN darts_of_list L
	==> FST ((n_list_ext L POWER n) (x,y)) = x`.
Proof.
move => [good_s xy_in].
elim: n => [|n Ih]; first by rewrite POWER_0 I_THM.
set d := `(n_list_ext L POWER n) (x,y)`.
rewrite COM_POWER o_THM d_def.
have := n_list_ext_fst good_s `FST d` `SND d`.
rewrite PAIR; "ANTS_TAC".
  by rewrite -d_def list_ext_power_in_darts.
by move => [z] ->.
Qed.


Lemma mem_list_pairs_exists x l: `MEM x l <=> ?y. MEM (x,y) (list_pairs l)`.
Proof.
split => [mem_x | [y] /mem_list_pairs /=].
exists `next_el l x`.
rewrite -(nthP `x,next_el l x` `x,x`).
exists `indexl x l`.
rewrite size_list_pairs index_mem mem_x andTb.
rewrite nth_list_pairs ?index_mem // nth_index // PAIR_EQ /=.
rewrite next_el -nth0.
by case: `indexl x l = _` => /=.
Qed.


Lemma mem_list_of_darts d L: `MEM d (list_of_darts L)
	<=> ?l. MEM l L /\ MEM d (list_pairs l)`.
Proof.
split => [|[l] [mem_l mem_d]]; last by apply dart_in_darts; exists l.
elim: L => [|h t Ih]; rewrite list_of_darts foldr MEM //.
rewrite -list_of_darts /= mem_cat.
case => mem_d; first by exists h.
move: (Ih mem_d) => [l] [mem_l] mem_d2.
by exists l.
Qed.


Lemma mem_list_of_elements x L: `MEM x (list_of_elements L)
	<=> ?y. MEM (x,y) (list_of_darts L)`.
Proof.
rewrite list_of_elements mem_undup mem_flatten mem_list_of_darts.
rewrite SWAP_EXISTS_THM; rewr RIGHT_EXISTS_AND_THM.
by rewrite -mem_list_pairs_exists.
Qed.


Lemma uniq_node L n: `good_list L /\ MEM n (list_of_nodes L) ==> uniq n`.
Proof.
rewrite good_list list_of_nodes MEM_MAP => [] [] [uniq_s] _ [d] [mem_d] -> /=.
by rewrite filter_uniq.
Qed.


Lemma uniq_face L f: `good_list L /\ MEM f (list_of_faces L) ==> uniq f`.
Proof.
move => [good_s mem_f]; move: (good_s); rewrite good_list => h.
have [d [mem_d] ->] := mem_face_lemma mem_f good_s.
by rewrite uniq_find_face.
Qed.


Lemma list_of_darts_nil: `list_of_darts [] = []`.
Proof. by rewrite list_of_darts "GEN_ALL foldr". Qed.


Lemma list_of_darts_cons h t: `list_of_darts (h :: t) = list_pairs h ++ list_of_darts t`.
Proof. by rewrite list_of_darts "GEN_ALL foldr" /= -list_of_darts. Qed.


Lemma list_of_darts_cat s1 s2: `list_of_darts (s1 ++ s2) = list_of_darts s1 ++ list_of_darts s2`.
Proof.
elim: s1 => [|h t Ih]; rewrite cat ?(list_of_darts_nil, list_of_darts_cons) ?cat //.
by rewrite Ih catA.
Qed.


Lemma good_list_uniq L: `good_list L ==> uniq L`.
Proof.
rewrite good_list => [] [uniqL] [allL] _.
elim: L allL uniqL => [|h t Ih]; rewrite "GEN_ALL uniq" //.
rewrite all /= list_of_darts_cons cat_uniq -hasPn /= => [] [h_neq] all_t [_] [mem_h] uniq_t.
rewrite Ih // andbT.
have [d mem_d]: `?d. MEM d (list_pairs h)`.
  case eq: `list_pairs h` => [|h' t']; last by exists h'; rewrite MEM.
  by move: eq; rewrite -size_eq0 size_list_pairs size_eq0 h_neq.
apply: contraL mem_h; rewrite NOT_FORALL_THM negb_imply negbK => mem_h.
exists d; rewrite mem_d andbT.
by rewrite mem_list_of_darts; exists h.
Qed.


Lemma list_pairs_inj s1 s2: `list_pairs s1 = list_pairs s2 ==> s1 = s2`.
Proof.
rewrite !list_pairs => /(congr1 `unzip1`).
by rewrite !unzip1_zip // size_rot leqnn.
Qed.


Lemma uniq_list_of_faces L: `good_list L ==> uniq (list_of_faces L)`.
Proof.
rewrite list_of_faces => goodL.
by rewrite -map_MAP map_inj_uniq ?good_list_uniq // => x y /list_pairs_inj.
Qed.


Lemma uniq_faces_of_list L: `good_list L ==> uniq (faces_of_list L)`.
Proof.
rewrite faces_of_list => goodL.
rewrite -map_MAP map_inj_in_uniq ?uniq_list_of_faces // => f1 f2 [] [mem1 mem2] eq.
have [d] := mem_face_lemma goodL mem1.
rewrite dart_in_face => [] [mem_d] f1_eq.
apply: (uniq_face_unique mem1 mem2 d).
rewrite f1_eq mem_d /=; split; first by move: goodL; rewrite good_list => ->.
by rewrite -IN_SET_OF_LIST -eq IN_SET_OF_LIST f1_eq.
Qed.


Lemma card_faces_of_list L: `good_list L
	==> CARD (face_set (hypermap_of_list L)) = sizel (list_of_faces L)`.
Proof.
move => goodL; rewrite face_set_eq_list //.
rewrite card_set_of_list_uniq ?uniq_faces_of_list //.
by rewrite faces_of_list -map_MAP size_map.
Qed.


Lemma card_darts_of_list L: `good_list L 
	==> CARD (dart (hypermap_of_list L)) = sizel (list_of_darts L)`.
Proof.
move => goodL.
rewrite components_hypermap_of_list // darts_of_list card_set_of_list_uniq //.
by move: goodL; rewrite good_list => ->.
Qed.


Lemma uniq_list_of_elements L: `uniq (list_of_elements L)`.
Proof. by rewrite list_of_elements undup_uniq. Qed.


Lemma uniq_list_of_nodes L: `uniq (list_of_nodes L)`.
Proof.
rewrite list_of_nodes -map_MAP map_inj_in_uniq ?uniq_list_of_elements //= => a b.
rewrite !mem_list_of_elements => [] [] [] [c mem_a] [d mem_b].
by move/(congr1 `MEM (a,c)`) => /EQ_IMP; rewrite !mem_filter /= mem_a.
Qed.


Lemma mem_not_nil s: `~(s = []) <=> (?x. MEM x s)`.
Proof. by case: s => [|h t]; rewrite MEM /= NOT_CONS_NIL /=; exists h. Qed.


Lemma node_of_list_not_nil L n: `MEM n (list_of_nodes L) ==> ~(n = [])`.
Proof.
rewrite list_of_nodes -map_MAP mapP mem_list_of_elements => [] [a] [] [b] mem_ab ->.
rewrite mem_not_nil /=; exists `a,b`.
by rewrite mem_filter /= mem_ab.
Qed.


Lemma nodes_of_list_eq L n1 n2 a: `MEM n1 (list_of_nodes L) /\ MEM n2 (list_of_nodes L) /\
	MEM a n1 /\ MEM a n2 ==> n1 = n2`.
Proof.
rewrite list_of_nodes /= -map_MAP !mapP /= mem_list_of_elements.
move => [] [x] [] [y] mem_xy -> [] [u] [] [v] mem_uv ->.
by rewrite !mem_filter /= => [] [] <- <-.
Qed.


Lemma uniq_nodes_of_list L: `uniq (nodes_of_list L)`.
Proof.
rewrite nodes_of_list -map_MAP map_inj_in_uniq ?uniq_list_of_nodes // => n1 n2 [] [mem1 mem2] eq.
have [d d_in]: `?d. d IN set_of_list n1`.
  by rewrite IN_SET_OF_LIST -mem_not_nil (node_of_list_not_nil mem1).
by apply: (nodes_of_list_eq mem1 mem2); exists d; rewrite -!IN_SET_OF_LIST -eq.
Qed.


Lemma size_list_of_nodes L: `sizel (list_of_nodes L) = sizel (list_of_elements L)`.
Proof. by rewrite list_of_nodes -map_MAP size_map. Qed.


Lemma card_nodes_of_list L: `CARD (set_of_list (nodes_of_list L)) = sizel (list_of_elements L)`.
Proof.
rewrite card_set_of_list_uniq ?uniq_nodes_of_list //.
by rewrite nodes_of_list -map_MAP size_map size_list_of_nodes.
Qed.


Lemma surj_delete f s t a b: `SURJ f s t /\ f a = f b /\ a IN s /\ b IN s /\ ~(a = b)
	==> SURJ f (s DELETE a) t`.
Proof.
rewrite !SURJ !IN_DELETE => [] [] [f_in f_surj] [eq] [a_in] [b_in] neq; split.
  by move => x [/f_in] ->.
move => x /f_surj [y] [y_in] f_eq.
case y_eq: `y = a` => /=; last by exists y.
by exists b; rewrite b_in -neq -eq -y_eq f_eq.
Qed.


Lemma fst_node_hypermap_of_list L d: `good_list L
	==> (!x. x IN node (hypermap_of_list L) d ==> FST x = FST d)`.
Proof.
move: d => [a b] goodL x.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_list L`.
case ab_in: `a,b IN darts_of_list L` => /=; last first.
  by rewrite lemma_node_exception ?hypL // IN_SING => ->.
rewrite node orbit_map IN_ELIM_THM /= => [] [k] [_] ->.
by rewrite hypL fst_n_list_ext_power.
Qed.


Lemma fst_choice_node_hypermap_of_list L d: `good_list L
	==> FST (CHOICE (node (hypermap_of_list L) d)) = FST d`.
Proof.
move => goodL; apply: (fst_node_hypermap_of_list goodL).
rewrite CHOICE_DEF -MEMBER_NOT_EMPTY.
by exists d; rewrite node_refl.
Qed.


Lemma surj_fst_nodes_hypermap_of_list L: `good_list L
	==> SURJ (\n. FST (CHOICE n)) (node_set (hypermap_of_list L)) (elements_of_list L)`.
Proof.
rewrite SURJ elements_of_list !IN_SET_OF_LIST => goodL.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_list L`.
split => [x /lemma_node_representation [d] [d_in] -> | a] /=.
  rewrite -H_def fst_choice_node_hypermap_of_list // mem_list_of_elements.
  by exists `SND d`; rewrite -IN_SET_OF_LIST -darts_of_list -hypL -pair_expand.
rewrite mem_list_of_elements => [] [b].
rewrite -IN_SET_OF_LIST -darts_of_list -hypL => ab_in.
exists `node H (a,b)`.
rewrite -H_def (fst_choice_node_hypermap_of_list goodL) /= H_def.
by rewrite -lemma_in_node_set.
Qed.


Lemma good_list_nodes_condition L: `good_list L
   ==> (good_list_nodes L <=> CARD (node_set (hypermap_of_list L)) = sizel (list_of_elements L))`.
Proof.
rewrite good_list_nodes => goodL; split => eq; first by rewrite eq card_nodes_of_list.
rewrite -SUBSET_CARD_EQ ?card_nodes_of_list // FINITE_SET_OF_LIST andTb SUBSET => n.
have hypL := components_hypermap_of_list goodL.
set H := `hypermap_of_list L`.
move/lemma_node_representation => [r] [r_in] n_eq.
have mem_r: `MEM r (list_of_darts L)` by rewrite -IN_SET_OF_LIST -darts_of_list -hypL.
rewrite IN_SET_OF_LIST nodes_of_list -map_MAP mapP.
exists `filter (\y. FST y = FST r) (list_of_darts L)`; split.
  rewrite list_of_nodes -map_MAP mapP.
  exists `FST r` => /=; rewrite mem_list_of_elements.
  by exists `SND r`; rewrite -pair_expand.
set s := `set_of_list _`.
apply: contraLR eq => neq.
have: `n PSUBSET s`.
  rewrite PSUBSET neq /= SUBSET n_eq -s_def -H_def => x x_in.
  rewrite IN_SET_OF_LIST mem_filter /= -IN_SET_OF_LIST -darts_of_list -hypL.
  rewrite (fst_node_hypermap_of_list goodL x_in) /=.
  apply Hypermap_iso.IN_TRANS; exists `node H r`.
  by rewrite lemma_node_subset // -H_def.
rewrite PSUBSET_ALT => [] [_] [a] [a_in] a_n_in.
have size_gt0: `~(sizel (list_of_elements L) = 0)`.
  rewrite size_eq0 mem_not_nil.
  exists `FST r`; rewrite mem_list_of_elements.
  by exists `SND r`; rewrite -pair_expand.
suff: `sizel (list_of_elements L) <= CARD (node_set H DELETE n) `.
  rewrite CARD_DELETE ?FINITE_HYPERMAP_ORBITS // n_eq -lemma_in_node_set r_in /=.
  by move: size_gt0; arith.
rewrite -card_set_of_list_uniq ?uniq_list_of_elements // -elements_of_list.
apply (Hypermap_iso.surj_imp_card_le `\x. FST (CHOICE x)`).
rewrite FINITE_DELETE FINITE_HYPERMAP_ORBITS andTb.
apply surj_delete; exists `node H a` => /=.
rewrite -{1 2}H_def surj_fst_nodes_hypermap_of_list // andTb fst_choice_node_hypermap_of_list //.
have a_in2: `a IN dart H`.
  rewrite hypL darts_of_list IN_SET_OF_LIST.
  by move: a_in; rewrite -s_def IN_SET_OF_LIST mem_filter => ->.
rewrite n_eq -!lemma_in_node_set a_in2 r_in /= -{1}H_def fst_choice_node_hypermap_of_list //.
rewrite -lemma_different_nodes -?n_eq //=.
by move: a_in; rewrite -s_def IN_SET_OF_LIST mem_filter /=.
Qed.


Lemma plain_hypermap_of_list L: `good_list L ==> plain_hypermap (hypermap_of_list L)`.
Proof.
move => goodL; have hypL := components_hypermap_of_list goodL.
by rewrite plain_hypermap hypL e_list_ext_involution.
Qed.

Lemma edge_CARD_dart H: `plain_hypermap H /\ is_edge_nondegenerate H
	==> CARD (dart H) = 2 * number_of_edges H`.
Proof.
rewrite plain_hypermap is_edge_nondegenerate => [] [plain edge_nd].
rewrite number_of_edges edge_set.
rewrite (lemma_card_eq `edge_map H` `2`) ?number_of_orbits //.
rewrite !edge_map_and_darts /= => x x_in.
rewrite ("GEN_ALL lemma_orbit_of_size_2" x `dart H`) ?edge_map_and_darts //.
by rewrite edge_nd // -(o_THM `edge_map H`) plain I_THM.
Qed.

Lemma good_list_nodes_size_condition L: `good_list L /\ planar_hypermap (hypermap_of_list L)
     /\ connected_hypermap (hypermap_of_list L) /\ is_edge_nondegenerate (hypermap_of_list L)
	==> (good_list_nodes L <=> 
		2 * (sizel (list_of_elements L) + sizel (list_of_faces L)) =
			sizel (list_of_darts L) + 4)`.
Proof.
move => [goodL] [planarL] [connL] nondL.
rewrite good_list_nodes_condition //.
set H := `hypermap_of_list L`.
rewrite -number_of_nodes -(eqn_pmul2l `2`); first by arith.
move: connL planarL; rewrite planar_hypermap connected_hypermap => ->.
rewrite -(eqn_pmul2l `2`); first by arith.
rewrite !muln_addr -edge_CARD_dart.
  by rewrite -{1}H_def plain_hypermap_of_list.
rewrite -card_faces_of_list // H_def -number_of_faces.
rewrite -card_darts_of_list // H_def.
by arith.
Qed.


Lemma face_of_list L d: `good_list L /\ MEM d (list_of_darts L)
	==> face (hypermap_of_list L) d = set_of_list (find_face L d)`.
Proof.
move => [good_s mem_d].
have := face_set_eq_list good_s.
rewrite face_set set_of_orbits -face.
rewrite components_hypermap_of_list // darts_of_list !IN_SET_OF_LIST.
rewrite EXTENSION => /(_ `face (hypermap_of_list L) d`).
have -> /=: `face _1 d IN _2` by rewrite IN_ELIM_THM /=; exists d.
rewrite IN_SET_OF_LIST faces_of_list MEM_MAP => [] [f] [mem_f] face_eq.
have [d2 [mem_d2] f_eq] := mem_face_lemma good_s mem_f.
rewrite face_eq f_eq; congr `_1 _2` => //; rewrite eq_sym.
apply mem_find_face_imp_faces_eq.
move: good_s; rewrite good_list => -> /=.
by rewrite -f_eq -IN_SET_OF_LIST -face_eq face_refl.
Qed.


Lemma card_face_of_list L d: `good_list L /\ MEM d (list_of_darts L)
	==> CARD (face (hypermap_of_list L) d) = sizel (find_face L d)`.
Proof.
move => [good_s mem_d].
rewrite face_of_list // card_set_of_list_uniq // uniq_find_face.
by move: good_s; rewrite good_list => ->.
Qed.


Lemma list_of_faces_k L k: `good_list L
	==> face_set_k k (hypermap_of_list L) =
		set_of_list (MAP set_of_list (filter (\f. sizel f = k) (list_of_faces L)))`.
Proof.
move => good_s; move: (good_s); rewrite good_list => [] [uniq_s] _.
rewrite face_set_k face_set set_of_orbits -face IN_ELIM_THM /=.
rewrite components_hypermap_of_list // darts_of_list IN_SET_OF_LIST.
rewrite EXTENSION IN_ELIM_THM IN_SET_OF_LIST /= MEM_MAP mem_filter => f /=.
split => [[g] [] [] [d] [mem_d] -> card_eq -> | [g] [] [size_g] mem_g ->].
  exists `find_face L d`.
  by rewrite mem_find_face // face_of_list // -card_face_of_list.
have [d [mem_d] g_eq] := mem_face_lemma good_s mem_g.
exists `set_of_list g` => /=; split.
  by exists d; rewrite face_of_list.
by rewrite card_set_of_list_uniq // g_eq uniq_find_face.
Qed.


Lemma darts_k_union_face_set_k H k: `darts_k k H = UNIONS (face_set_k k H)`.
Proof.
rewrite EXTENSION IN_UNIONS darts_k face_set_k !Hypermap_iso.inE => d.
split => [h | [t] [] [/lemma_face_representation] [x] [x_in] -> card_eq d_in].
  by exists `face H d`; rewrite -lemma_in_face_set face_refl.
suff eq: `face H x = face H d`.
  by rewrite -eq card_eq /= (Hypermap_iso.IN_TRANS d_in) lemma_face_subset.
exact: (lemma_face_identity d_in).
Qed.


Lemma set_of_list_flatten_map s: `set_of_list (flatten s) 
	= UNIONS (set_of_list (map set_of_list s))`.
Proof.
rewrite EXTENSION IN_UNIONS !IN_SET_OF_LIST mem_flatten mapP => x.
split => [[l] h | [t] [] [l2] [mem_l2] ->].
  by exists `set_of_list l`; rewrite IN_SET_OF_LIST h andbT; exists l.
by rewrite IN_SET_OF_LIST => mem_x; exists l2.
Qed.


Lemma list_of_darts_k L k: `good_list L
	==> darts_k k (hypermap_of_list L) 
		= set_of_list (flatten (filter (\f. sizel f = k) (list_of_faces L)))`.
Proof.
move => goodL; rewrite darts_k_union_face_set_k.
by rewrite list_of_faces_k // -map_MAP -set_of_list_flatten_map.
Qed.


Lemma darts3_eq_list_of_darts3 L: `good_list L
	==> darts_k 3 (hypermap_of_list L) = set_of_list (list_of_darts3 L)`.
Proof. by move/(list_of_darts_k `3`) => ->; rewrite list_of_darts3 list_of_faces3 Seq.size. Qed.

Lemma darts4_eq_list_of_darts4 L: `good_list L
	==> darts_k 4 (hypermap_of_list L) = set_of_list (list_of_darts4 L)`.
Proof. by move/(list_of_darts_k `4`) => ->; rewrite list_of_darts4 list_of_faces4 Seq.size. Qed.

Lemma darts5_eq_list_of_darts5 L: `good_list L
	==> darts_k 5 (hypermap_of_list L) = set_of_list (list_of_darts5 L)`.
Proof. by move/(list_of_darts_k `5`) => ->; rewrite list_of_darts5 list_of_faces5 Seq.size. Qed.

Lemma darts6_eq_list_of_darts6 L: `good_list L
	==> darts_k 6 (hypermap_of_list L) = set_of_list (list_of_darts6 L)`.
Proof. by move/(list_of_darts_k `6`) => ->; rewrite list_of_darts6 list_of_faces6 Seq.size. Qed.


Lemma rot_list_pairs s n: `rot n (list_pairs s) = list_pairs (rot n s)`.
Proof. by rewrite list_pairs rot_zip ?size_rot // rot_rot -list_pairs. Qed.

Lemma rotr_list_pairs s n: `rotr n (list_pairs s) = list_pairs (rotr n s)`.
Proof. by rewrite rotr rot_list_pairs size_list_pairs -rotr. Qed.

Lemma list_pairs_rot s n: `perm_eq (list_pairs (rot n s)) (list_pairs s)`.
Proof. by rewrite -rot_list_pairs perm_eq_rot. Qed.

Lemma find_pair_list_empty L d: `find_pair_list L d = [] <=> ~(MEM d (list_of_darts L))`.
Proof.
elim: L => [| h t Ih]; rewrite find_pair_list ?list_of_darts_nil ?MEM //.
rewrite list_of_darts_cons mem_cat negb_or.
case mem_d: `MEM d _` => /=; last by rewrite Ih.
rewrite -implybF => h_eq.
by move: mem_d; rewrite h_eq list_pairs zip MEM.
Qed.

Lemma list_of_darts_perm L1 L2: `perm_eq L1 L2 ==> perm_eq (list_of_darts L1) (list_of_darts L2)`.
Proof.
move => perm; rewrite !list_of_darts_alt !list_of_faces.
by rewrite perm_eq_flatten -map_MAP perm_eq_map.
Qed.

Lemma good_list_perm L1 L2: `perm_eq L1 L2 /\ good_list L1 ==> good_list L2`.
Proof.
rewrite !good_list => [] [perm] [uniq1] [all1] sym1.
have perm_darts := list_of_darts_perm perm.
rewrite -(perm_eq_uniq perm_darts) uniq1 -(all_perm_eq perm) all1 !andTb.
by move => d; rewrite -!(perm_eq_mem perm_darts) => /sym1.
Qed.

Lemma find_face_cons h t d: 
	`find_face (h :: t) d = if MEM d (list_pairs h) then (list_pairs h) else find_face t d`.
Proof. by rewrite !find_face !list_of_faces MAP find_list. Qed.

Lemma find_face_eq L d f: `uniq (list_of_darts L) /\ MEM d (list_of_darts L)
	==> (find_face L d = f <=> MEM f (list_of_faces L) /\ MEM d f)`.
Proof.
move => [uniqL mem_d]; split => [<- | ].
  by rewrite -dart_in_face mem_find_face.
rewrite list_of_faces -map_MAP mapP => [] [] [s] [mem_s] -> /(find_pair_list_unique uniqL) eq.
by rewrite find_face_alt -eq.
Qed.

