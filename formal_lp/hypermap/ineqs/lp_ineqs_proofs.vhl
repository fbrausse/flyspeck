"needs \"../formal_lp/hypermap/ineqs/lp_ineqs_defs.hl\"".
"needs \"tame/ssreflect/tame_lemmas-compiled.hl\"".


Module Lp_ineqs_proofs.

"let lp_fan = new_definition `lp_fan (V,E) <=> FAN (vec 0,V,E) 
  /\ fully_surrounded (V,E) 
  /\ V SUBSET ball_annulus 
  /\ packing V`".

"let lp_cond = new_definition `lp_cond (L:((A)list)list,g,h) (V,E) 
  <=> lp_fan (V,E)
  /\ good_list L
  /\ good_list_nodes L
  /\ hyp_iso g (hypermap_of_list L, hypermap_of_fan (V,E))
  /\ BIJ h (elements_of_list L) V
  /\ (!d. g d = h (FST d), h (SND d))
  /\ (!x. x IN elements_of_list L <=> h x IN V)`".

"let add_diag = new_definition `add_diag (V,E) (v,w)
			= if (v,w) IN dart1_of_fan (V,E) then
				{w, sigma_fan (vec 0) V E v w} INSERT E 
				else E`".

"let add_diag_list = new_definition 
	`add_diag_list (g,V,E) diags = foldr (\d E'. add_diag (V,E') (g d)) E diags`".

"let split_list_list = new_definition
	`split_list_list L ds = foldr (\d L. split_list_hyp L d) L ds`".


"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Seq2".
"open Fan_defs".
"open Hypermap".
"open Hypermap_and_fan".
"open Pack_defs".
"open Tame_defs".
"open Hypermap_iso".
"open Add_triangle".
"open List_hypermap".
"open List_hypermap_iso".
"open Tame_general".
"open Tame_lemmas".
"open Lp_ineqs_def".

Lemma const1_gt0: `&0 < const1`.
Proof. by rewrite -sol0_over_pi_EQ_const1 real_div REAL_LT_MUL sol0_POS REAL_LT_INV // PI_POS. Qed.

Lemma const1_ge0: `&0 <= const1`.
Proof. by rewrite REAL_LT_IMP_LE const1_gt0. Qed.

(* FunctionPair *)
Section FunctionPair.

Lemma res_inv_subset f s s' t x: `s' SUBSET s /\ BIJ f s t /\ x IN IMAGE f s'
	==> res_inv f s' x = res_inv f s x`.
Proof.
rewrite SUBSET IN_IMAGE => [] [s'_sub] [bij_f] [y] [->] y_in.
rewrite (res_inv_bij bij_f) ?s'_sub //.
rewrite (res_inv_left y_in) // => a b h.
move: (bij_f); rewrite BIJ INJ => [] [] [_ f_inj] _.
by apply: f_inj; rewrite h /= !s'_sub.
Qed.


Variable h1: `:A->B`.
Variable h2: `:C->D`.
Variable g: `:A#C -> B#D`.

Hypothesis g_eq: `!x. g x = h1 (FST x), h2 (SND x)`.

Lemma INJ_pair s1 t1 s2 t2: `INJ h1 s1 t1 /\ INJ h2 s2 t2
	==> INJ g (s1 CROSS s2) (t1 CROSS t2)`.
Proof.
rewrite !INJ => [] [[h1_in h1_inj]] [h2_in h2_inj].
split => [[a b] | [a b] [c d]]; rewrite !g_eq /= !IN_CROSS ?PAIR_EQ.
  by move => ab_in; rewrite h1_in // h2_in.
by move => [ab_in] [cd_in] [/h1_inj] -> // /h2_inj ->.
Qed.

Lemma SURJ_pair s1 t1 s2 t2: `SURJ h1 s1 t1 /\ SURJ h2 s2 t2
	==> SURJ g (s1 CROSS s2) (t1 CROSS t2)`.
rewrite !SURJ => [] [[h1_in h1_surj]] [h2_in h2_surj].
split => [] [a b]; rewrite !g_eq /= !IN_CROSS ?PAIR_EQ.
  by move => ab_in; rewrite h1_in // h2_in.
move => [/h1_surj] [y1] y1_eq /h2_surj [y2] y2_eq.
by exists `y1,y2`; rewrite IN_CROSS /= !y1_eq !y2_eq.
Qed.

Lemma BIJ_pair s1 t1 s2 t2: `BIJ h1 s1 t1 /\ BIJ h2 s2 t2
	==> BIJ g (s1 CROSS s2) (t1 CROSS t2)`.
Proof. by rewrite !BIJ => h; rewrite INJ_pair // SURJ_pair. Qed.

Lemma res_inv_pair s1 t1 s2 t2: `BIJ h1 s1 t1 /\ BIJ h2 s2 t2
   ==> (!a b. a IN t1 /\ b IN t2 
	==> res_inv g (s1 CROSS s2) (a,b) = res_inv h1 s1 a, res_inv h2 s2 b)`.
Proof.
move => [bij_h1 bij_h2] a b [a_in b_in].
have bij_g := BIJ_pair bij_h1 bij_h2.
move: (bij_g); rewrite BIJ INJ => [] [] [g_in g_inj] _.
apply: g_inj.
rewrite !(res_inv_bij bij_g) ?IN_CROSS //.
by rewrite g_eq /= !(res_inv_bij bij_h1) // !(res_inv_bij bij_h2).
Qed.

End FunctionPair.


Lemma darts_of_list_subset L v w: 
	`v,w IN darts_of_list L ==> v IN elements_of_list L /\ w IN elements_of_list L`.
Proof.
rewrite darts_of_list elements_of_list !IN_SET_OF_LIST.
rewrite mem_list_of_darts => [] [l] [mem_l] /mem_list_pairs mem_vw.
rewrite !list_of_elements !mem_undup !mem_flatten.
by split; exists l.
Qed.


(* Lp_cond *)
Section Lp_cond.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.
Variable L: `:((A)list)list`.


Lemma lp_cond_lemma f: `lp_fan (V,E) /\ good_list L /\ good_list_nodes L
	/\ hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)
	==> ?g h. lp_cond (L, g, h) (V,E) 
	       /\ (!x. h x = if x IN elements_of_list L then 
			res_inv (fan_list_nodes_iso (f,V,E)) V x else vec 0)`.
Proof.
rewrite lp_cond lp_fan => [] [] [fanV] [f_surr] [subV packV] [goodL] [good_nodes] iso_f.
rewrite fanV f_surr subV packV goodL good_nodes !andTb.
set f' := `fan_list_iso (f, V, E)`.
set h' := `fan_list_nodes_iso (f, V, E)`.
have f'_eq d: `f' d = h' (FST d), h' (SND d)`.
  by case: d => v w; rewrite -f'_def fan_list_iso h'_def.
have [dartV _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartL _] := components_hypermap_of_list goodL.
have iso_f': `hyp_iso f' (hypermap_of_fan (V,E), hypermap_of_list L)`.
  apply: (hyp_iso_ext iso_f); rewrite dartV => d d_in.
  by rewrite -f'_def -(hyp_iso_eq_fan_list_iso goodL fanV iso_f).
have bij_h': `BIJ h' V (elements_of_list L)`.
  by rewrite -h'_def (fan_list_nodes_iso_BIJ fanV iso_f).
set h := `\x. if x IN elements_of_list L then res_inv h' V x else vec 0`.
set g := `\d. h (FST d), h (SND d)`.
exists g h.
split; last by move => x; rewrite -h_def /=.
split; last first.
  rewrite -g_def /=; split.
    by apply: (bij_ext (bij_res_inv bij_h')) => x x_in; rewrite -h_def /= x_in.
  rewrite -h_def /= => x.
  case x_in: `x IN _` => /=; first by rewrite (res_inv_bij bij_h').
  apply: contraL subV; rewrite SUBSET NOT_FORALL_THM NOT_IMP => v0.
  by exists `vec 0`; rewrite Ckqowsa_3_points.in_ball_annulus !negb_and negbK.
apply: (hyp_iso_ext (hyp_iso_inv iso_f')).
rewrite dartL -g_def => [] [v w] vw_in /=.
have bij_f' := BIJ_pair bij_h' bij_h' f'_eq.
rewrite (res_inv_subset bij_f'); last first.
  have vw_in2 := darts_of_list_subset vw_in.
  by rewrite (res_inv_pair f'_eq bij_h' bij_h') // -h_def /= !vw_in2.
rewrite -(iso_dart iso_f') dartL vw_in andbT dartV SUBSET.
by move => [a b] /(PAIR_IN_DART_OF_FAN fanV); rewrite IN_CROSS.
Qed.


Lemma lp_cond_trans1 g h d: `lp_cond (L,g,h) (V,E) 
	==> lp_cond (split_list_hyp L d,g,h) (V, add_diag (V,E) (g d))`.
Proof.
case: d => v w.
rewrite !lp_cond => [] [fan_cond] [goodL] [good_nodes] [iso_g] [bij_h] [g_eq] h_cond.
move: (fan_cond); rewrite lp_fan => [] [fanV] [f_surr] [subV packV].
have dart1_eq := fully_surrounded_dart_of_fan_eq fanV f_surr.
have [dartV _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartL _] := components_hypermap_of_list goodL.
case vw_in: `v,w IN darts_of_list L` => /=; last first.
  rewrite d_not_in_dart_split_eq -?IN_SET_OF_LIST -?darts_of_list //.
  suff ->: `add_diag (V,E) (g (v,w)) = E` by [].
  rewrite g_eq /= add_diag -dart1_eq.
  suff ->: `~(h v, h w IN dart_of_fan (V,E))` by [].
  apply: contra vw_in => hvw_in.
  suff <-: `res_inv g (darts_of_list L) (h v, h w) = v,w`.
    move: (hyp_iso_dart (hyp_iso_inv iso_g)).
    by rewrite dartV dartL => ->.
  have hvw_inV := PAIR_IN_DART_OF_FAN fanV hvw_in.
  have vw_in: `v IN elements_of_list L /\ w IN elements_of_list L` by rewrite !h_cond.
  have bij_g := BIJ_pair bij_h bij_h g_eq.
  rewrite (res_inv_subset bij_g); last first.
    by rewrite (res_inv_pair bij_h bij_h g_eq) // !(res_inv_bij bij_h).
  rewrite -{2}dartL -(iso_dart iso_g) dartV hvw_in andbT SUBSET.
  by move => [a b] /darts_of_list_subset; rewrite IN_CROSS.
have els_eq: `elements_of_list (split_list_hyp L (v,w)) = elements_of_list L`.
  rewrite !elements_of_list eq_sym; apply perm_eq_set_of_list_eq.
  by rewrite list_of_elements_split.
have iso_inv_g := hyp_iso_inv iso_g.
have good_split := iso_imp_good_list_split iso_inv_g fanV goodL good_nodes f_surr.
rewrite good_split // (iso_imp_good_list_nodes_split iso_inv_g) //.
rewrite els_eq h_cond bij_h -g_eq lp_fan subV packV /= g_eq /=.
have hvw_eq: `g (v,w) = h v, h w` by [].
have hvw_in: `h v, h w IN dart_of_fan (V,E)`.
  by rewrite -hvw_eq -dartV (hyp_iso_dart iso_g) dartL.
have add_eq: `V, add_diag (V,E) (h v,h w) = split_fan_face (V,E) (h v,h w)`.
  by rewrite add_diag split_fan_face -dart1_eq hvw_in.
have [fan2 [_] f_surr2] := fan_split_fan_face fanV f_surr hvw_in.
rewrite add_eq fan2 f_surr2 !andTb.
set f := `fan_list_iso (res_inv g (dart (hypermap_of_list L)), V, E)`.
have iso_f: `hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)`.
  apply: (hyp_iso_ext iso_inv_g) => d d_in.
  by rewrite -f_def -(hyp_iso_eq_fan_list_iso) // -dartV.
set h' := `fan_list_nodes_iso (res_inv g (dart (hypermap_of_list L)),V,E)`.
have bij_g := BIJ_pair bij_h bij_h g_eq.
have h'_eq x: `x IN elements_of_list L ==> h' (h x) = x`.
  rewrite h_cond => x_in; move: (DART_EXISTS x_in E) => [hy] hxy_in.
  have := hyp_iso_eq_fan_list_iso fanV goodL iso_inv_g hxy_in.
  rewrite fan_list_iso h'_def (res_inv_subset bij_g).
    rewrite -(iso_dart iso_g) dartV hxy_in andbT SUBSET dartL.
    by case => a b /darts_of_list_subset; rewrite IN_CROSS.
  rewrite (res_inv_pair bij_h bij_h g_eq) ?(PAIR_IN_DART_OF_FAN fanV hxy_in) //.
  by rewrite (res_inv_bij bij_h) // PAIR_EQ => <-.
have fh_eq: `f (h v, h w) = v,w`.
  by rewrite -f_def fan_list_iso h'_def !h'_eq // (darts_of_list_subset vw_in).
have := split_list_hyp_iso fanV goodL iso_f good_nodes f_surr hvw_in.
rewrite -{1}f_def fan_list_iso_invariant f_def fh_eq => iso2_f.
apply: (hyp_iso_ext (hyp_iso_inv iso2_f)) => [[a b]] ab_in.
have := fan_list_nodes_iso_BIJ fanV goodL iso_inv_g good_nodes.
rewrite h'_def => bij_h'.
have := BIJ_pair bij_h' bij_h' f; "ANTS_TAC".
  by case => x y; rewrite -f_def fan_list_iso h'_def.
move => bij_f'; rewrite (res_inv_subset bij_f').
  rewrite -(iso_dart iso2_f) ab_in andbT SUBSET => [] [x y].
  rewrite -add_eq in fan2 *; rewrite COMPONENTS_HYPERMAP_OF_FAN // IN_CROSS.
  by move/(PAIR_IN_DART_OF_FAN fan2).
move: ab_in; rewrite (components_hypermap_of_list (good_split `v,w`)).
move/darts_of_list_subset; rewrite els_eq => ab_in2.
rewrite (res_inv_pair bij_h' bij_h').
  by rewrite !ab_in2 !andbT; case => x y; rewrite -f_def fan_list_iso h'_def.
have hab_inV: `h a IN V /\ h b IN V`.
  by move: bij_h; rewrite BIJ INJ => [] [] [h_in] _ _; rewrite !h_in.
by rewrite -{1}(h'_eq a) // -{1}(h'_eq b) // !(res_inv_bij bij_h').
Qed.


End Lp_cond.


Lemma lp_cond_trans L V E g h ds: `lp_cond (L,g,h) (V,E)
	==> lp_cond (split_list_list L ds, g, h) (V, add_diag_list (g,V,E) ds)`.
Proof.
move => cond.
elim: ds => [|h t Ih]; rewrite split_list_list add_diag_list !foldr //.
by rewrite -split_list_list -add_diag_list /= lp_cond_trans1.
Qed.


(* Contravening *)
Section Contravening.

Variable V: `:real^3->bool`.
Hypothesis cV: `contravening V`.

Let fanV: `FAN (vec 0,V,ESTD V)`. Proof. by rewrite CONTRAVENING_FAN. Qed.

Lemma contravening_lp_fan: `lp_fan (V,ESTD V)`.
Proof.
rewrite lp_fan fanV CONTRAVENING_IMP_FULLY_SURROUNDED //.
by rewrite contravening in cV; rewrite !cV.
Qed.

Lemma contravening_lp_cond L f: `good_list L /\ good_list_nodes L
	/\ hyp_iso f (hypermap_of_fan (V,ESTD V), hypermap_of_list L)
	==> ?g h. lp_cond (L, g, h) (V, ESTD V)`.
Proof.
move => [goodL] [good_nodes] iso_f.
have [g [h] [cond] _] := lp_cond_lemma contravening_lp_fan goodL good_nodes iso_f.
by exists g h.
Qed.

Lemma contravening_lp_cond_alt L: `good_list L 
	/\ 2 * (sizel (list_of_elements L) + sizel (list_of_faces L)) = sizel (list_of_darts L) + 4
	/\ (iso) (hypermap_of_fan (V,ESTD V)) (hypermap_of_list L)
	==> ?g h. lp_cond (L, g, h) (V, ESTD V)`.
Proof.
move => [goodL] [eq] iso.
have [f iso_f] := iso_imp_hyp_iso iso.
apply: (contravening_lp_cond goodL iso_f).
rewrite (good_list_nodes_size_condition goodL) //.
rewrite -(iso_planar iso) -(iso_connected iso) -(iso_edge_nondegenerate iso).
by rewrite Jgtdebu.JGTDEBU5 // Jgtdebu.JGTDEBU3 // Jgtdebu.JGTDEBU1.
Qed.


End Contravening.


Lemma lnsum_ineq V L h: `BIJ h (elements_of_list L) V /\ contravening V
	==> &12 <= list_sum (list_of_elements L) (ln_list h)`.
Proof.
rewrite contravening => [] [bij_h] [_] [_] [ineq] _.
suff ->: `list_sum (list_of_elements L) (ln_list h) = scriptL V` by move: ineq; arith.
rewrite list_sum_set_of_list ?uniq_list_of_elements -elements_of_list.
rewrite scriptL "end_itlist CONJ list_defs" (Basics.BIJ_SUM bij_h).
by apply SUM_EQ => v vV /=; rewrite ln_fan yn_fan.
Qed.


Section Fan.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis f_surr: `fully_surrounded (V,E)`.
Hypothesis packV: `packing V`.
Hypothesis subV: `V SUBSET ball_annulus`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by rewrite fully_surrounded_dart_of_fan_eq. Qed.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let fH: `face_map (hypermap_of_fan (V,E)) = f_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let nH: `node_map (hypermap_of_fan (V,E)) = n_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let norm_v v: `v IN V ==> &2 <= norm v /\ norm v <= #2.52`.
Proof.
rewrite SUBSET in subV; move/subV.
by rewrite Fnjlbxs.in_ball_annulus h0; arith.
Qed.

Let pack_dist x: `x IN dart_of_fan (V,E) ==> &2 <= dist x`.
Proof.
case: x => v w; rewrite -dart1_eq => vw_in.
apply: (iffLR (Fnjlbxs.packing V) packV v w).
by rewrite !(PAIR_IN_DART1_OF_FAN fanV vw_in) (PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV vw_in).
Qed.


Lemma rho_pos v: `v IN V ==> &0 <= &1 + const1 * (&1 - ln_fan v)`.
Proof.
move => vV; rewrite REAL_LE_ADD REAL_LE_MUL; last by arith.
rewrite const1_ge0 ln_fan lmfun yn_fan h0.
by move: (norm_v vV); arith.
Qed.


(* V *)
Section V.

Variable v: `:real^3`.
Hypothesis vV: `v IN V`.

Lemma ln_def: `ln_fan v = (#2.52 - yn_fan v) / #0.52`.
Proof.
rewrite ln_fan yn_fan lmfun h0.
by move: (norm_v vV); arith.
Qed.

Lemma rho_def: `rho_fan v = (&1 + sol0 / pi) - ln_fan v * sol0 / pi`.
Proof.
rewrite rho_fan sol0_over_pi_EQ_const1.
suff: `&0 <= &1 + const1 * (&1 - ln_fan v)` by arith.
by rewrite rho_pos.
Qed.

Lemma ln_lo: `&0 <= ln_fan v`.
Proof. by rewrite ln_fan Fnjlbxs.lmfun_ge0. Qed.

Lemma ln_hi: `ln_fan v <= &1`.
Proof. by rewrite ln_fan yn_fan lmfun h0; move: (norm_v vV); arith. Qed.

Lemma yn_lo: `&2 <= yn_fan v`.
Proof. by rewrite yn_fan norm_v. Qed.

Lemma yn_hi: `yn_fan v <= #2.52`.
Proof. by rewrite yn_fan norm_v. Qed.

Lemma rho_lo: `&1 <= rho_fan v`.
Proof.
rewrite rho_fan.
suff: `&0 <= const1 * (&1 - ln_fan v)` by arith.
by rewrite REAL_LE_MUL const1_ge0; move: ln_hi; arith.
Qed.

Lemma rho_hi: `rho_fan v <= &1 + sol0 / pi`.
Proof.
rewrite rho_fan.
set x := `&1 + _`.
have ->: `abs x = x` by rewrite REAL_ABS_REFL -x_def rho_pos.
rewrite -x_def REAL_LE_LADD sol0_over_pi_EQ_const1.
rewrite -{2}(REAL_MUL_RID `const1`) REAL_LE_MUL2 const1_ge0 REAL_LE_REFL.
by rewrite ln_fan yn_fan lmfun h0; move: (norm_v vV); arith.
Qed.

End V.


(* Dart *)
Section Dart.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.

Lemma edge_sym: `ye_fan d = ye_fan (e_fan_pair_ext (V,E) d)`.
Proof.
case: d d_in => v w vw_in.
by rewrite e_fan_pair_ext dart1_eq vw_in /= e_fan_pair !ye_fan DIST_SYM.
Qed.

Lemma y1_def: `y1_fan d = yn_fan (FST d)`.
Proof. by rewrite y1_fan yn_fan. Qed.

Lemma y2_def: `y2_fan d = yn_fan (FST (f_fan_pair_ext (V,E) d))`.
Proof.
case: d d_in => v w d_in.
by rewrite f_fan_pair_ext dart1_eq d_in /= f_fan_pair y2_fan yn_fan.
Qed.

Lemma y3_def: `y3_fan (V,E) d = yn_fan (FST (inverse (f_fan_pair_ext (V,E)) d))`.
Proof. by rewrite y3_fan yn_fan. Qed.

Lemma y4_def: `y4_fan (V,E) d = ye_fan (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite y4_fan ye_fan. Qed.

Lemma y5_def: `y5_fan (V,E) d = ye_fan (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite y5_fan ye_fan. Qed.

Lemma y6_def: `y6_fan d = ye_fan d`.
Proof. by rewrite y6_fan ye_fan. Qed.

Lemma y8_def: `y8_fan (V,E) d = y5_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite y8_fan. Qed.

Lemma y9_def: `y9_fan (V,E) d = ye_fan (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite y9_fan ye_fan. Qed.

Lemma azim_lo: `&0 <= azim_dart (V,E) d`.
Proof. by rewrite "GEN_ALL AZIM_DART_POS". Qed.

Lemma azim_hi: `azim_dart (V,E) d <= pi`.
Proof. by rewrite REAL_LT_IMP_LE; move: f_surr; rewrite fully_surrounded => ->. Qed.

Lemma rhazim_lo: `&0 <= rhazim_fan (V,E) d`.
Proof. by rewrite rhazim_fan REAL_LE_MUL REAL_ABS_POS azim_lo. Qed.

Lemma rhazim_hi: `rhazim_fan (V,E) d <= pi + sol0`.
Proof.
rewrite rhazim_fan -(REAL_MUL_RID `pi + sol0`).
rewrite -{3}(REAL_MUL_LINV PI_NZ) REAL_MUL_ASSOC REAL_LE_MUL2.
rewrite azim_hi REAL_ABS_POS azim_lo /=.
rewrite REAL_ADD_RDISTRIB (REAL_MUL_RINV PI_NZ) -real_div.
have ->: `lmfun (h_dart d) = ln_fan (FST d)` by rewrite ln_fan h_dart yn_fan.
set x := `abs _`.
have fst_in: `FST d IN V`.
  by case: d d_in => v w d_in /=; rewrite (PAIR_IN_DART_OF_FAN fanV d_in).
have ->: `x = &1 + const1 * (&1 - ln_fan (FST d))`.
  by rewrite -x_def REAL_ABS_REFL rho_pos.
rewrite REAL_LE_LADD sol0_over_pi_EQ_const1 -{2}(REAL_MUL_RID `const1`).
rewrite REAL_LE_MUL2 const1_ge0 REAL_LE_REFL /=.
rewrite ln_fan yn_fan lmfun h0.
by move: (norm_v fst_in); arith.
Qed.

Lemma ye_lo: `&2 <= ye_fan d`.
Proof. by rewrite ye_fan pack_dist. Qed.

Let d_inV: `FST d IN V /\ SND d IN V`.
Proof. by apply: (PAIR_IN_DART_OF_FAN fanV); rewrite -pair_expand. Qed.

Lemma y1_lo: `&2 <= y1_fan d`.
Proof. by rewrite y1_fan norm_v. Qed.

Lemma y2_lo: `&2 <= y2_fan d`.
Proof. by rewrite y2_fan norm_v. Qed.

Lemma y1_hi: `y1_fan d <= #2.52`.
Proof. by rewrite y1_fan norm_v. Qed.

Lemma y2_hi: `y2_fan d <= #2.52`.
Proof. by rewrite y2_fan norm_v. Qed.

Lemma y6_lo: `&2 <= y6_fan d`.
Proof. by rewrite y6_fan pack_dist. Qed.

End Dart.


Let fd_in d: `d IN dart_of_fan (V,E) ==> f_fan_pair_ext (V,E) d IN dart_of_fan (V,E)`.
Proof. by rewrite -dartH -fH => d_in; rewrite Hypermap.lemma_dart_invariant. Qed.

Let ifd_in d: `d IN dart_of_fan (V,E) ==> inverse (f_fan_pair_ext (V,E)) d IN dart_of_fan (V,E)`.
Proof. 
by rewrite -dartH -fH => d_in; rewrite Hypermap.lemma_dart_inveriant_under_inverse_maps.
Qed.

Let in_dart_inV d: `d IN dart_of_fan (V,E) ==> FST d IN V /\ SND d IN V`.
Proof. by case: d => v w /(PAIR_IN_DART_OF_FAN fanV). Qed.

(* StdDart *)
Section StdDart.

Hypothesis std: `E = ESTD V`.

Let in_std d: `d IN dart_of_fan (V,E) ==> dist d <= #2.52 /\ dist d <= &3`.
Proof. by case: d => v w; rewrite -dart1_eq -inE_eq_in_dart1 std IN_ESTD; arith. Qed.

Section Inner.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.


Lemma ye_hi_std: `ye_fan d <= &3`.
Proof. by rewrite ye_fan in_std. Qed.

Lemma y4_hi_std: `y4_fan (V,E) d <= &3`.
Proof. by rewrite y4_fan in_std fd_in. Qed.

Lemma y5_hi_std: `y5_fan (V,E) d <= &3`.
Proof. by rewrite y5_fan in_std ifd_in. Qed.

Lemma y6_hi_std: `y6_fan d <= &3`.
Proof. by rewrite y6_fan in_std. Qed.

Lemma y8_hi_std: `y8_fan (V,E) d <= #2.52`.
Proof. by rewrite y8_fan y5_fan in_std !ifd_in. Qed.

Lemma y9_hi_std: `y9_fan (V,E) d <= #2.52`.
Proof. by rewrite y9_fan in_std fd_in. Qed.

Lemma yy10_std: `ye_fan d <= #2.52`.
Proof. by rewrite ye_fan in_std. Qed.

End Inner.

End StdDart.



(* Dart2 *)
Section Dart2.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.


Lemma azim2_lo: `&0 <= azim2_fan (V,E) d`.
Proof. by rewrite azim2_fan azim_lo fd_in. Qed.

Lemma azim2_hi: `azim2_fan (V,E) d <= pi`.
Proof. by rewrite azim2_fan azim_hi fd_in. Qed.

Lemma azim3_lo: `&0 <= azim3_fan (V,E) d`.
Proof. by rewrite azim3_fan azim_lo ifd_in. Qed.

Lemma azim3_hi: `azim3_fan (V,E) d <= pi`.
Proof. by rewrite azim3_fan azim_hi ifd_in. Qed.

Lemma rhazim2_lo: `&0 <= rhazim2_fan (V,E) d`.
Proof. by rewrite rhazim2_fan rhazim_lo fd_in. Qed.

Lemma rhazim2_hi: `rhazim2_fan (V,E) d <= pi + sol0`.
Proof. by rewrite rhazim2_fan rhazim_hi fd_in. Qed.

Lemma rhazim3_lo: `&0 <= rhazim3_fan (V,E) d`.
Proof. by rewrite rhazim3_fan rhazim_lo ifd_in. Qed.

Lemma rhazim3_hi: `rhazim3_fan (V,E) d <= pi + sol0`.
Proof. by rewrite rhazim3_fan rhazim_hi ifd_in. Qed.

Lemma y3_lo: `&2 <= y3_fan (V,E) d`.
Proof. by rewrite y3_fan norm_v in_dart_inV ifd_in. Qed.

Lemma y3_hi: `y3_fan (V,E) d <= #2.52`.
Proof. by rewrite y3_fan norm_v in_dart_inV ifd_in. Qed.

Lemma y4_lo: `&2 <= y4_fan (V,E) d`.
Proof. by rewrite y4_fan pack_dist fd_in. Qed.

Lemma y5_lo: `&2 <= y5_fan (V,E) d`.
Proof. by rewrite y5_fan pack_dist ifd_in. Qed.

Lemma y8_lo: `&2 <= y8_fan (V,E) d`.
Proof. by rewrite y8_fan y5_fan pack_dist !ifd_in. Qed.

Lemma y9_lo: `&2 <= y9_fan (V,E) d`.
Proof. by rewrite y9_fan pack_dist fd_in. Qed.

Lemma azim2c: `azim2_fan (V,E) d = azim_dart (V,E) (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite azim2_fan. Qed.

Lemma azim3c: `azim3_fan (V,E) d = azim_dart (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite azim3_fan. Qed.

Lemma rhazim2c: `rhazim2_fan (V,E) d = rhazim_fan (V,E) (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite rhazim2_fan. Qed.

Lemma rhazim3c: `rhazim3_fan (V,E) d = rhazim_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite rhazim3_fan. Qed.

Lemma RHA: `rhazim_fan (V,E) d >= azim_dart (V,E) d`.
Proof.
rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan.
rewrite real_ge -{1}(REAL_MUL_LID `azim_dart _ d`) REAL_LE_RMUL azim_lo // andbT.
by rewrite rho_lo in_dart_inV.
Qed.

Lemma RHB: `rhazim_fan (V,E) d <= azim_dart (V,E) d * (&1 + sol0 / pi)`.
Proof.
rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan REAL_MUL_SYM.
by rewrite REAL_LE_LMUL azim_lo // rho_hi // in_dart_inV.
Qed.

End Dart2.


(* Node *)
Section Node.

Variable n: `:real^3#real^3->bool`.
Hypothesis n_in: `n IN node_set (hypermap_of_fan (V,E))`.

Let n_repr: `?v w. v,w IN dart_of_fan (V,E) /\ n = node (hypermap_of_fan (V,E)) (v,w)`.
Proof.
move/lemma_node_representation: n_in => [[v w]] h.
by exists v w; rewrite -dartH.
Qed.

Lemma azim_sum: `sum n (azim_dart (V,E)) = &2 * pi`.
Proof.
move: n_repr => [v] [w] [vw_in] ->.
by rewrite SUM_AZIM_DART.
Qed.

Lemma rhazim_sum: `sum n (rhazim_fan (V,E)) = &2 * pi * rho_fan (FST (CHOICE n))`.
Proof.
rewrite REAL_MUL_ASSOC -azim_sum -SUM_RMUL.
apply SUM_EQ => d d_in /=; rewrite rhazim_fan REAL_MUL_SYM REAL_EQ_MUL_LCANCEL; right.
rewrite h_dart -yn_fan -ln_fan -rho_fan; congr `rho_fan _`.
move: n_repr d_in => [v] [w] [vw_in] -> d_in.
rewrite eq_sym; apply: (fst_node_hypermap_of_fan fanV).
rewrite (lemma_node_identity d_in) CHOICE_DEF.
by rewrite -MEMBER_NOT_EMPTY; exists d; rewrite node_refl.
Qed.


End Node.



(* Face *)
Section Face.

Variable f: `:real^3#real^3->bool`.
Hypothesis f_in: `f IN face_set (hypermap_of_fan (V,E))`.

Let f_repr: `?v w. v,w IN dart_of_fan (V,E) /\ f = face (hypermap_of_fan (V,E)) (v,w)`.
Proof.
move/lemma_face_representation: f_in => [[v w]] h.
by exists v w; rewrite -dartH.
Qed.


Lemma sol_lo: `&0 <= sol_fan (V,E) f`.
Proof. by rewrite sol_fan REAL_ABS_POS. Qed.

Lemma tau_lo: `&0 <= tau_fan (V,E) f`.
Proof. by rewrite tau_fan REAL_ABS_POS. Qed.

Lemma sol_sum: `sum f (azim_dart (V,E)) = sol_fan (V,E) f + &(CARD f - 2) * pi`.
Proof.
rewrite sol_fan.
Abort.

End Face.



(* Test *)
Section Test.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.

Let y123_bounds: `&2 <= y1_fan d /\ y1_fan d <= #2.52
	/\ &2 <= y2_fan d /\ y2_fan d <= #2.52
	/\ &2 <= y3_fan (V,E) d /\ y3_fan (V,E) d <= #2.52`.
Proof. by rewrite y1_lo // y2_lo // y3_lo // y1_hi // y2_hi // y3_hi. Qed.

Let y456_bounds: `&2 <= y4_fan (V,E) d /\ &2 <= y5_fan (V,E) d /\ &2 <= y6_fan d`.
Proof. by rewrite y4_lo // y5_lo // y6_lo. Qed.

Hypothesis ineqs: "(hd (Ineq.getprefix \"3318775219\")).ineq".

(* TODO: introduce the dart3 set and eliminate the cardinality assumption *)
Lemma ineq101: `CARD (face (hypermap_of_fan (V,E)) d) = 3
	/\ #2.52 <= y4_fan (V,E) d /\ y4_fan (V,E) d <= sqrt8
	/\ y5_fan (V,E) d <= #2.52 /\ y6_fan d <= #2.52
	==> (((azim_dart (V,E) d) - #1.629) + (((#0.414 * (y2_fan d + 
	  (y3_fan (V,E) d + (y5_fan (V,E) d + (y6_fan d - #8.0))))) 
		- (#0.763 * (y4_fan (V,E) d - #2.52))) - 
		(#0.315 * (y1_fan d - #2.0)))) >= #0.0`.
Proof.
case: d d_in y123_bounds y456_bounds => v w vw_in y123_bounds y456_bounds [card_f bounds].
rewrite "let_RULE fully_surrounded_azim_eq_dih_y" //.
set w' := `sigma_fan _ V E v w`.
have ->: `norm v = y1_fan (v,w)` by rewrite y1_fan.
have ->: `norm w = y2_fan (v,w)` by rewrite y2_fan.
have ->: `norm w' = y3_fan (V,E) (v,w)`.
  rewrite y3_fan INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite res dart1_eq vw_in /= w'_def.
have ->: `dist (w,w') = y4_fan (V,E) (v,w)`.
  by rewrite y4_fan f_fan_pair_ext dart1_eq vw_in /= f_fan_pair3.
have ->: `dist (v,w') = y5_fan (V,E) (v,w)`.
  rewrite y5_fan INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite res dart1_eq vw_in /= w'_def DIST_SYM.
have ->: `dist (v,w) = y6_fan (v,w)` by rewrite y6_fan.
rewrite real_ge REAL_LT_IMP_LE -real_gt.
rewrite INEQ_ALT Ineq.apex_flat in ineqs; apply: ineqs.
have ->: `#2.0 = &2` by arith.
by rewrite !"GEN_ALL ALL".
Qed.


End Test.


End Fan.

