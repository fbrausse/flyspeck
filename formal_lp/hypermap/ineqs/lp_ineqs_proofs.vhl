"needs \"../formal_lp/hypermap/ssreflect/list_hypermap_iso-compiled.hl\"".
"needs \"../formal_lp/hypermap/ineqs/lp_ineqs_defs.hl\"".
(* We need to prove: 4 * pi - 20 * sol0 <= tgt *)
"needs \"../formal_lp/ineqs/constants_approx.hl\"".
"needs \"tame/ssreflect/tame_lemmas-compiled.hl\"".


Module Lp_ineqs_proofs.

"let lp_fan = new_definition `lp_fan (V,E) <=> FAN (vec 0,V,E)
  /\ fully_surrounded (V,E)
  /\ (!v w. v IN V /\ w IN V /\ ~(v = w) /\ ~({v,w} IN E) ==> #2.52 <= dist (v,w))
  /\ V SUBSET ball_annulus
  /\ packing V`".

"let lp_cond = new_definition `lp_cond (L:((A)list)list,g,h) (V,E)
  <=> lp_fan (V,E)
  /\ good_list L
  /\ good_list_nodes L
  /\ hyp_iso g (hypermap_of_list L, hypermap_of_fan (V,E))
  /\ BIJ h (elements_of_list L) V
  /\ (!d. g d = h (FST d), h (SND d))
  /\ (!x. x IN elements_of_list L <=> h x IN V)`".

"let lp_tau = new_definition `lp_tau (V,E) <=>
        (!f. f IN face_set (hypermap_of_fan (V,E)) ==> &0 <= tauVEF (V,E,f))`".

"let add_diag = new_definition `add_diag (V,E) (v,w)
                        = if (v,w) IN dart1_of_fan (V,E) then
                                {w, sigma_fan (vec 0) V E v w} INSERT E
                                else E`".

"let add_diag_list = new_definition
        `add_diag_list (g,V,E) diags = foldr (\d E'. add_diag (V,E') (g d)) E diags`".

"let split_list_list = new_definition
        `split_list_list L ds = foldr (\d L. split_list_hyp L d) L ds`".


"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Seq2".
"open Sphere".
"open Fan_defs".
"open Hypermap".
"open Hypermap_and_fan".
"open Pack_defs".
"open Tame_defs".
"open Hypermap_iso".
"open Add_triangle".
"open List_hypermap".
"open List_hypermap_iso".
"open Tame_general".
"open Tame_lemmas".
"open Constants_approx".
"open Lp_ineqs_def".

Lemma const1_gt0: `&0 < const1`.
Proof. by rewrite -sol0_over_pi_EQ_const1 real_div REAL_LT_MUL sol0_POS REAL_LT_INV // PI_POS. Qed.

Lemma const1_ge0: `&0 <= const1`.
Proof. by rewrite REAL_LT_IMP_LE const1_gt0. Qed.

Lemma tau_fan_eq_tauVEF V E f: `lp_tau (V,E) /\ f IN face_set (hypermap_of_fan (V,E))
        ==> tau_fan (V,E) f = tauVEF (V,E,f)`.
Proof.
rewrite lp_tau => [] [tau_h]; move/tau_h.
by rewrite tau_fan REAL_ABS_REFL.
Qed.

Lemma face_map_in_darts_k H k d: `d IN darts_k k H
        ==> face_map H d IN darts_k k H /\ inverse (face_map H) d IN darts_k k H`.
Proof.
rewrite darts_k !inE => [] [d_in <-].
rewrite lemma_dart_invariant // lemma_dart_inveriant_under_inverse_maps //=.
split; congr `CARD _`; rewrite eq_sym; apply lemma_face_identity.
  by rewrite -POWER_1 lemma_in_face.
by rewrite -POWER_1 lemma_power_inverse_in_face face_refl.
Qed.

Lemma f_fan_pair_ext_in_darts_k V E k d: `FAN (vec 0,V,E)
                /\ d IN darts_k k (hypermap_of_fan (V,E))
        ==> f_fan_pair_ext (V,E) d IN darts_k k (hypermap_of_fan (V,E))
                /\ inverse (f_fan_pair_ext (V,E)) d IN darts_k k (hypermap_of_fan (V,E))`.
Proof.
move => [fanV d_in].
by rewrite -(COMPONENTS_HYPERMAP_OF_FAN fanV) !face_map_in_darts_k.
Qed.


(* FunctionPair *)
Section FunctionPair.

Lemma res_inv_subset f s s' t x: `s' SUBSET s /\ BIJ f s t /\ x IN IMAGE f s'
        ==> res_inv f s' x = res_inv f s x`.
Proof.
rewrite SUBSET IN_IMAGE => [] [s'_sub] [bij_f] [y] [->] y_in.
rewrite (res_inv_bij bij_f) ?s'_sub //.
rewrite (res_inv_left y_in) // => a b h.
move: (bij_f); rewrite BIJ INJ => [] [] [_ f_inj] _.
by apply: f_inj; rewrite h /= !s'_sub.
Qed.


Variable h1: `:A->B`.
Variable h2: `:C->D`.
Variable g: `:A#C -> B#D`.

Hypothesis g_eq: `!x. g x = h1 (FST x), h2 (SND x)`.

Lemma INJ_pair s1 t1 s2 t2: `INJ h1 s1 t1 /\ INJ h2 s2 t2
        ==> INJ g (s1 CROSS s2) (t1 CROSS t2)`.
Proof.
rewrite !INJ => [] [[h1_in h1_inj]] [h2_in h2_inj].
split => [[a b] | [a b] [c d]]; rewrite !g_eq /= !IN_CROSS ?PAIR_EQ.
  by move => ab_in; rewrite h1_in // h2_in.
by move => [ab_in] [cd_in] [/h1_inj] -> // /h2_inj ->.
Qed.

Lemma SURJ_pair s1 t1 s2 t2: `SURJ h1 s1 t1 /\ SURJ h2 s2 t2
        ==> SURJ g (s1 CROSS s2) (t1 CROSS t2)`.
rewrite !SURJ => [] [[h1_in h1_surj]] [h2_in h2_surj].
split => [] [a b]; rewrite !g_eq /= !IN_CROSS ?PAIR_EQ.
  by move => ab_in; rewrite h1_in // h2_in.
move => [/h1_surj] [y1] y1_eq /h2_surj [y2] y2_eq.
by exists `y1,y2`; rewrite IN_CROSS /= !y1_eq !y2_eq.
Qed.

Lemma BIJ_pair s1 t1 s2 t2: `BIJ h1 s1 t1 /\ BIJ h2 s2 t2
        ==> BIJ g (s1 CROSS s2) (t1 CROSS t2)`.
Proof. by rewrite !BIJ => h; rewrite INJ_pair // SURJ_pair. Qed.

Lemma res_inv_pair s1 t1 s2 t2: `BIJ h1 s1 t1 /\ BIJ h2 s2 t2
   ==> (!a b. a IN t1 /\ b IN t2
        ==> res_inv g (s1 CROSS s2) (a,b) = res_inv h1 s1 a, res_inv h2 s2 b)`.
Proof.
move => [bij_h1 bij_h2] a b [a_in b_in].
have bij_g := BIJ_pair bij_h1 bij_h2.
move: (bij_g); rewrite BIJ INJ => [] [] [g_in g_inj] _.
apply: g_inj.
rewrite !(res_inv_bij bij_g) ?IN_CROSS //.
by rewrite g_eq /= !(res_inv_bij bij_h1) // !(res_inv_bij bij_h2).
Qed.

End FunctionPair.


Lemma darts_of_list_subset L v w:
        `v,w IN darts_of_list L ==> v IN elements_of_list L /\ w IN elements_of_list L`.
Proof.
rewrite darts_of_list elements_of_list !IN_SET_OF_LIST.
rewrite mem_list_of_darts => [] [l] [mem_l] /mem_list_pairs mem_vw.
rewrite !list_of_elements !mem_undup !mem_flatten.
by split; exists l.
Qed.


(* Lp_cond *)
Section Lp_cond.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.
Variable L: `:((A)list)list`.


Lemma lp_cond_lemma f: `lp_fan (V,E) /\ good_list L /\ good_list_nodes L
        /\ hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)
        ==> ?g h. lp_cond (L, g, h) (V,E)
               /\ (!x. h x = if x IN elements_of_list L then
                        res_inv (fan_list_nodes_iso (f,V,E)) V x else vec 0)`.
Proof.
rewrite lp_cond lp_fan => [] [] [fanV] [f_surr] [diag_dist] [subV packV] [goodL] [good_nodes] iso_f.
rewrite fanV f_surr subV packV goodL good_nodes !andTb.
set f' := `fan_list_iso (f, V, E)`.
set h' := `fan_list_nodes_iso (f, V, E)`.
have f'_eq d: `f' d = h' (FST d), h' (SND d)`.
  by case: d => v w; rewrite -f'_def fan_list_iso h'_def.
have [dartV _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartL _] := components_hypermap_of_list goodL.
have iso_f': `hyp_iso f' (hypermap_of_fan (V,E), hypermap_of_list L)`.
  apply: (hyp_iso_ext iso_f); rewrite dartV => d d_in.
  by rewrite -f'_def -(hyp_iso_eq_fan_list_iso goodL fanV iso_f).
have bij_h': `BIJ h' V (elements_of_list L)`.
  by rewrite -h'_def (fan_list_nodes_iso_BIJ fanV iso_f).
set h := `\x. if x IN elements_of_list L then res_inv h' V x else vec 0`.
set g := `\d. h (FST d), h (SND d)`.
exists g h.
split; last by move => x; rewrite -h_def /=.
split; first by rewrite andbT => v w /diag_dist.
split; last first.
  rewrite -g_def /=; split.
    by apply: (bij_ext (bij_res_inv bij_h')) => x x_in; rewrite -h_def /= x_in.
  rewrite -h_def /= => x.
  case x_in: `x IN _` => /=; first by rewrite (res_inv_bij bij_h').
  apply: contraL subV; rewrite SUBSET NOT_FORALL_THM NOT_IMP => v0.
  by exists `vec 0`; rewrite Ckqowsa_3_points.in_ball_annulus !negb_and negbK.
apply: (hyp_iso_ext (hyp_iso_inv iso_f')).
rewrite dartL -g_def => [] [v w] vw_in /=.
have bij_f' := BIJ_pair bij_h' bij_h' f'_eq.
rewrite (res_inv_subset bij_f'); last first.
  have vw_in2 := darts_of_list_subset vw_in.
  by rewrite (res_inv_pair f'_eq bij_h' bij_h') // -h_def /= !vw_in2.
rewrite -(iso_dart iso_f') dartL vw_in andbT dartV SUBSET.
by move => [a b] /(PAIR_IN_DART_OF_FAN fanV); rewrite IN_CROSS.
Qed.


Lemma lp_fan_trans1 d: `lp_fan (V,E) ==> lp_fan (V, add_diag (V,E) d)`.
Proof.
rewrite !lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
case: d => v w.
case vw_in1: `v,w IN dart1_of_fan (V,E)` => /=; last by rewrite add_diag vw_in1.
rewrite packV subV !andbT.
have dart1_eq := fully_surrounded_dart_of_fan_eq fanV f_surr.
have add_eq: `V, add_diag (V,E) (v,w) = split_fan_face (V,E) (v,w)`.
  by rewrite add_diag split_fan_face vw_in1.
move: (vw_in1); rewrite -dart1_eq => vw_in.
have [fan2 [_] f_surr2] := fan_split_fan_face fanV f_surr vw_in.
rewrite add_eq fan2 f_surr2 !andTb.
move => a b.
rewrite add_diag vw_in1 /= IN_INSERT negb_or => cond.
by apply: diag.
Qed.


Lemma lp_cond_trans1 g h d: `lp_cond (L,g,h) (V,E)
        ==> lp_cond (split_list_hyp L d,g,h) (V, add_diag (V,E) (g d))`.
Proof.
case: d => v w.
rewrite !lp_cond => [] [fan_cond] [goodL] [good_nodes] [iso_g] [bij_h] [g_eq] h_cond.
rewrite lp_fan_trans1 // andTb.
move: (fan_cond); rewrite lp_fan => [] [fanV] [f_surr] [diag_dist] [subV packV].
have dart1_eq := fully_surrounded_dart_of_fan_eq fanV f_surr.
have [dartV _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have [dartL _] := components_hypermap_of_list goodL.
case vw_in: `v,w IN darts_of_list L` => /=; last first.
  rewrite d_not_in_dart_split_eq -?IN_SET_OF_LIST -?darts_of_list //.
  suff ->: `add_diag (V,E) (g (v,w)) = E` by [].
  rewrite g_eq /= add_diag -dart1_eq.
  suff ->: `~(h v, h w IN dart_of_fan (V,E))` by [].
  apply: contra vw_in => hvw_in.
  suff <-: `res_inv g (darts_of_list L) (h v, h w) = v,w`.
    move: (hyp_iso_dart (hyp_iso_inv iso_g)).
    by rewrite dartV dartL => ->.
  have hvw_inV := PAIR_IN_DART_OF_FAN fanV hvw_in.
  have vw_in: `v IN elements_of_list L /\ w IN elements_of_list L` by rewrite !h_cond.
  have bij_g := BIJ_pair bij_h bij_h g_eq.
  rewrite (res_inv_subset bij_g); last first.
    by rewrite (res_inv_pair bij_h bij_h g_eq) // !(res_inv_bij bij_h).
  rewrite -{2}dartL -(iso_dart iso_g) dartV hvw_in andbT SUBSET.
  by move => [a b] /darts_of_list_subset; rewrite IN_CROSS.
have els_eq: `elements_of_list (split_list_hyp L (v,w)) = elements_of_list L`.
  rewrite !elements_of_list eq_sym; apply perm_eq_set_of_list_eq.
  by rewrite list_of_elements_split.
have iso_inv_g := hyp_iso_inv iso_g.
have good_split := iso_imp_good_list_split iso_inv_g fanV goodL good_nodes f_surr.
rewrite good_split // (iso_imp_good_list_nodes_split iso_inv_g) //.
rewrite els_eq h_cond bij_h -g_eq /= g_eq /=.
have hvw_eq: `g (v,w) = h v, h w` by [].
have hvw_in: `h v, h w IN dart_of_fan (V,E)`.
  by rewrite -hvw_eq -dartV (hyp_iso_dart iso_g) dartL.
have add_eq: `V, add_diag (V,E) (h v,h w) = split_fan_face (V,E) (h v,h w)`.
  by rewrite add_diag split_fan_face -dart1_eq hvw_in.
rewrite add_eq.
have [fan2 [_] f_surr2] := fan_split_fan_face fanV f_surr hvw_in.
set f := `fan_list_iso (res_inv g (dart (hypermap_of_list L)), V, E)`.
have iso_f: `hyp_iso f (hypermap_of_fan (V,E), hypermap_of_list L)`.
  apply: (hyp_iso_ext iso_inv_g) => d d_in.
  by rewrite -f_def -(hyp_iso_eq_fan_list_iso) // -dartV.
set h' := `fan_list_nodes_iso (res_inv g (dart (hypermap_of_list L)),V,E)`.
have bij_g := BIJ_pair bij_h bij_h g_eq.
have h'_eq x: `x IN elements_of_list L ==> h' (h x) = x`.
  rewrite h_cond => x_in; move: (DART_EXISTS x_in E) => [hy] hxy_in.
  have := hyp_iso_eq_fan_list_iso fanV goodL iso_inv_g hxy_in.
  rewrite fan_list_iso h'_def (res_inv_subset bij_g).
    rewrite -(iso_dart iso_g) dartV hxy_in andbT SUBSET dartL.
    by case => a b /darts_of_list_subset; rewrite IN_CROSS.
  rewrite (res_inv_pair bij_h bij_h g_eq) ?(PAIR_IN_DART_OF_FAN fanV hxy_in) //.
  by rewrite (res_inv_bij bij_h) // PAIR_EQ => <-.
have fh_eq: `f (h v, h w) = v,w`.
  by rewrite -f_def fan_list_iso h'_def !h'_eq // (darts_of_list_subset vw_in).
have := split_list_hyp_iso fanV goodL iso_f good_nodes f_surr hvw_in.
rewrite -{1}f_def fan_list_iso_invariant f_def fh_eq => iso2_f.
apply: (hyp_iso_ext (hyp_iso_inv iso2_f)) => [[a b]] ab_in.
have := fan_list_nodes_iso_BIJ fanV goodL iso_inv_g good_nodes.
rewrite h'_def => bij_h'.
have := BIJ_pair bij_h' bij_h' f; "ANTS_TAC".
  by case => x y; rewrite -f_def fan_list_iso h'_def.
move => bij_f'; rewrite (res_inv_subset bij_f').
  rewrite -(iso_dart iso2_f) ab_in andbT SUBSET => [] [x y].
  rewrite -add_eq in fan2 *; rewrite COMPONENTS_HYPERMAP_OF_FAN // IN_CROSS.
  by move/(PAIR_IN_DART_OF_FAN fan2).
move: ab_in; rewrite (components_hypermap_of_list (good_split `v,w`)).
move/darts_of_list_subset; rewrite els_eq => ab_in2.
rewrite (res_inv_pair bij_h' bij_h').
  by rewrite !ab_in2 !andbT; case => x y; rewrite -f_def fan_list_iso h'_def.
have hab_inV: `h a IN V /\ h b IN V`.
  by move: bij_h; rewrite BIJ INJ => [] [] [h_in] _ _; rewrite !h_in.
by rewrite -{1}(h'_eq a) // -{1}(h'_eq b) // !(res_inv_bij bij_h').
Qed.


End Lp_cond.


Lemma lp_cond_trans L V E g h ds: `lp_cond (L,g,h) (V,E)
        ==> lp_cond (split_list_list L ds, g, h) (V, add_diag_list (g,V,E) ds)`.
Proof.
move => cond.
elim: ds => [|h t Ih]; rewrite split_list_list add_diag_list !foldr //.
by rewrite -split_list_list -add_diag_list /= lp_cond_trans1.
Qed.

Lemma bij_in f s t: `BIJ f s t ==> (!x. x IN s ==> f x IN t)`.
Proof. by rewrite BIJ INJ => [] [] [bij_in] _ _ x /bij_in. Qed.

Lemma list_sum_neg s f: `list_sum s (\x. --(f x)) = --(list_sum s f)`.
Proof. by rewrite REAL_NEG_MINUS1 list_sum_lmul -REAL_NEG_MINUS1. Qed.

Lemma list_sum_sub s f1 f2: `list_sum s (\x. f1 x - f2 x) = list_sum s f1 - list_sum s f2`.
Proof. by rewrite !real_sub list_sum_add list_sum_neg. Qed.

Lemma list_sum_filter s a f: `list_sum (filter a s) f = list_sum s (\x. if a x then f x else &0)`.
Proof.
elim: s => [|h t Ih]; rewrite filter ?list_sum_nil //.
rewrite list_sum_cons /= -Ih.
case ah: `a h` => /=; first by rewrite list_sum_cons.
by rewrite REAL_ADD_LID.
Qed.


(* Contravening *)
Section Contravening.

Variable V: `:real^3->bool`.
Hypothesis cV: `contravening V`.

Let fanV: `FAN (vec 0,V,ESTD V)`. Proof. by rewrite CONTRAVENING_FAN. Qed.

Lemma contravening_lp_fan: `lp_fan (V,ESTD V)`.
Proof.
rewrite lp_fan fanV CONTRAVENING_IMP_FULLY_SURROUNDED //.
rewrite contravening in cV; rewrite !cV /= => v w [vV] [wV] [vw_neq].
by apply: contraR; rewrite IN_ESTD vV wV vw_neq; arith.
Qed.

Lemma contravening_lp_cond L f: `good_list L /\ good_list_nodes L
        /\ hyp_iso f (hypermap_of_fan (V,ESTD V), hypermap_of_list L)
        ==> ?g h. lp_cond (L, g, h) (V, ESTD V)`.
Proof.
move => [goodL] [good_nodes] iso_f.
have [g [h] [cond] _] := lp_cond_lemma contravening_lp_fan goodL good_nodes iso_f.
by exists g h.
Qed.

Lemma contravening_lp_cond_alt L: `good_list L
        /\ 2 * (sizel (list_of_elements L) + sizel (list_of_faces L)) = sizel (list_of_darts L) + 4
        /\ (iso) (hypermap_of_fan (V,ESTD V)) (hypermap_of_list L)
        ==> ?g h. lp_cond (L, g, h) (V, ESTD V)`.
Proof.
move => [goodL] [eq] iso.
have [f iso_f] := iso_imp_hyp_iso iso.
apply: (contravening_lp_cond goodL iso_f).
rewrite (good_list_nodes_size_condition goodL) //.
rewrite -(iso_planar iso) -(iso_connected iso) -(iso_edge_nondegenerate iso).
by rewrite Jgtdebu.JGTDEBU5 // Jgtdebu.JGTDEBU3 // Jgtdebu.JGTDEBU1.
Qed.

Section Bij.

Variable h: `:num->real^3`.
Variable L: `:((num)list)list`.
Hypothesis bij_h: `BIJ h (elements_of_list L) V`.

Lemma lnsum_ineq: `&12 <= list_sum (list_of_elements L) (ln_list h)`.
Proof.
move: cV; rewrite contravening => [] [_] [_] [ineq] _.
suff ->: `list_sum (list_of_elements L) (ln_list h) = scriptL V` by move: ineq; arith.
rewrite list_sum_set_of_list ?uniq_list_of_elements -elements_of_list.
rewrite scriptL list_defs_th (Basics.BIJ_SUM bij_h).
by apply SUM_EQ => v vV /=; rewrite ln_fan yn_fan.
Qed.

Let cardV_eq: `CARD V = LENGTH (list_of_elements L)`.
Proof.
rewrite -Seq.size -card_set_of_list_uniq ?uniq_list_of_elements // -elements_of_list.
by rewrite (bij_card_eq bij_h) // elements_of_list FINITE_SET_OF_LIST.
Qed.

Let y_ineqs y: `MEM y (list_of_elements L) ==> &2 <= norm (h y) /\ norm (h y) <= &2 * h0`.
Proof.
rewrite -IN_SET_OF_LIST -elements_of_list => y_in.
suff: `h y IN ball_annulus` by rewrite Fnjlbxs.in_ball_annulus => [] [-> ->].
by move: cV; rewrite contravening SUBSET => ->; rewrite (bij_in bij_h).
Qed.

Lemma lnsum13_ineq: `sizel (list_of_elements L) = 13 ==> 
	list_sum (list_of_elements L) (\y. yn_list h y - &2) <= #0.52`.
Proof.
move: (cV); rewrite contravening SUBSET => [] [_] [in_ba] _ size_eq.
have eq: `list_sum (list_of_elements L) (ln_list h) 
	= inv (h0 - &1) * list_sum (list_of_elements L) (\y. h0 - yn_list h y / &2)`.
  rewrite -list_sum_lmul REAL_MUL_SYM /= -real_div -lfun.
  apply list_sum_eq => y mem_y.
  by rewrite !list_defs_th !o_THM ln_fan !yn_fan Nonlinear_lemma.lmfun_lfun ?y_ineqs.
move: lnsum_ineq; rewrite eq !list_sum_sub real_div list_sum_rmul.
rewrite (list_sum_const `h0`) (list_sum_const `&2`) size_eq.
by rewrite h0; arith.
Qed.

Lemma lnsum13_high_strict i: `MEM i (list_of_elements L)
	/\ sizel (list_of_elements L) = 13 /\ #2.36 <= yn_list h i
	==> !j. MEM j (list_of_elements L) /\ ~(j = i) ==> yn_list h j < #2.18`.
Proof.
move => [mem_i] [size13] ineq j [mem_j] j_neq_i.
set s := `delete1 i (delete1 j (list_of_elements L))`.
have: `list_sum s (\y. yn_list h y - &2)
	= list_sum (list_of_elements L) (\y. yn_list h y - &2) - (yn_list h i + yn_list h j - &4)`.
  rewrite -s_def !list_sum_delete1 mem_j /= mem_delete1_uniq ?uniq_list_of_elements //.
  by rewrite -j_neq_i /= mem_i /=; arith.
have: `&0 <= list_sum s (\y. yn_list h y - &2)`.
  rewrite list_sum_ge0 list_defs_th o_THM yn_fan => x mem_x /=.
  by rewrite REAL_SUB_LE y_ineqs (mem_delete1 j) (mem_delete1 i) s_def.
by move: (lnsum13_ineq size13) ineq; arith.
Qed.

Lemma lnsum13_high i: `MEM i (list_of_elements L)
	/\ sizel (list_of_elements L) = 13 /\ #2.36 <= yn_list h i
	==> ALL (\j. ~(j = i) ==> yn_list h j <= #2.18) (list_of_elements L)`.
Proof.
rewrite -ALL_MEM => [] [mem_i] [size13] ineq j /= mem_j j_neq_i.
by rewrite REAL_LT_IMP_LE (lnsum13_high_strict mem_i).
Qed.

Lemma lnsum13_mid i j: `MEM i (list_of_elements L) /\ MEM j (list_of_elements L) /\ ~(i = j)
	/\ sizel (list_of_elements L) = 13 
	/\ #2.18 <= yn_list h i /\ #2.18 <= yn_list h j
	==> ALL (\k. ~(k = i) /\ ~(k = j) ==> yn_list h k <= #2.18) (list_of_elements L)
		/\ yn_list h i <= #2.36 /\ yn_list h j <= #2.36`.
Proof.
rewrite -ALL_MEM => [] [mem_i] [mem_j] [i_neq_j] [size13] ineqs /=; split; last first.
  apply: contraR i_neq_j; rewrite negb_and.
  rewrite !REAL_NOT_LE; case => /REAL_LT_IMP_LE /lnsum13_high_strict; "ANTS_TAC" => //.
    by move => /(_ mem_j); move: ineqs; arith.
  by move => /(_ mem_i); move: ineqs; arith.
move => k mem_k k_neq.
set s := `delete1 k (delete1 i (delete1 j (list_of_elements L)))`.
have: `list_sum s (\y. yn_list h y - &2)
	= list_sum (list_of_elements L) (\y. yn_list h y - &2) 
		- (yn_list h k + yn_list h i + yn_list h j - &6)`.
  rewrite -s_def !list_sum_delete1 mem_j /=.
  rewrite !mem_delete1_uniq ?uniq_delete1 ?uniq_list_of_elements //.
  by rewrite i_neq_j mem_i /= !k_neq mem_k /=; arith.
have: `&0 <= list_sum s (\y. yn_list h y - &2)`.
  rewrite list_sum_ge0 list_defs_th o_THM yn_fan => x mem_x /=.
  by rewrite REAL_SUB_LE y_ineqs (mem_delete1 j) (mem_delete1 i) (mem_delete1 k) s_def.
by move: (lnsum13_ineq size13) ineqs; arith.
Qed.

End Bij.

End Contravening.


Lemma hyp_iso_comm_power H G g d: `hyp_iso g (G, H) /\ d IN dart G
	   ==> (!k. (face_map H POWER k) (g d) = g ((face_map G POWER k) d))`.
Proof.
move => [iso_g d_in].
elim => [|k Ih]; first by rewrite !POWER_0 !I_THM.
by rewrite !COM_POWER !o_THM Ih (hyp_iso_comm iso_g) // lemma_dart_invariant_power_face.
Qed.


(* ExtraDefs *)
Section ExtraDefs.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.
Variable L: `:((num)list)list`.
Variable g: `:(num#num -> real^3#real^3)`.


Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis goodL: `good_list L`.
Hypothesis iso_g: `hyp_iso g (hypermap_of_list L, hypermap_of_fan (V,E))`.

Lemma y8_list_def: `ALL (\d. y8_list (g,V,E) d
             = ye_list g (inverse (f_list_ext L) (inverse (f_list_ext L) d))) (list_of_darts L)`.
Proof.
rewrite -ALL_MEM /= => d mem_d.
rewrite !list_defs_th !o_THM.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
move: mem_d; rewrite -IN_SET_OF_LIST -darts_of_list -dartL => d_in.
rewrite -faceL -!(hyp_iso_inverse_comm iso_g) ?lemma_dart_inveriant_under_inverse_maps //.
by rewrite y8_fan y5_fan !(COMPONENTS_HYPERMAP_OF_FAN fanV) ye_fan.
Qed.

Variable h: `:num -> real^3`.
Hypothesis g_eq: `!x. g x = h (FST x), h (SND x)`.

Lemma y4'_list_def: `ALL (\d. y4'_list (g,V,E) d
                = ye_list g (SND d, FST (inverse (f_list_ext L) d))) (list_of_darts L)`.
Proof.
rewrite -ALL_MEM /= !list_defs_th !o_THM y4'_fan ye_fan => d mem_d.
rewrite {3}(pair_expand d) -pair_expand.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
have [dartH [_] [_] faceH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have d_in: `d IN dart (hypermap_of_list L)`.
  by rewrite dartL darts_of_list IN_SET_OF_LIST.
by rewrite !g_eq /= -g_eq -faceH (hyp_iso_inverse_comm iso_g).
Qed.

Lemma y4'_list_f_def: `ALL (\d. y4'_list (g,V,E) (f_list_ext L d)
                = ye_list g (SND (f_list_ext L d), FST d)) (list_of_darts L)`.
Proof.
move: y4'_list_def.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
rewrite -!ALL_MEM /= => eq1 d mem_d.
have d_in: `d IN dart (hypermap_of_list L)`.
  by rewrite dartL darts_of_list IN_SET_OF_LIST.
rewrite eq1.
  by rewrite -IN_SET_OF_LIST -darts_of_list -dartL -faceL lemma_dart_invariant.
by rewrite -faceL (PERMUTES_INVERSES `darts_of_list L`) // -dartL hypermap_lemma.
Qed.

Lemma y4'_list_inv_f_def: `ALL (\d. y4'_list (g,V,E) (inverse (f_list_ext L) d)
                = ye_list g (FST d, FST ((inverse (f_list_ext L) POWER 2) d))) (list_of_darts L)`.
Proof.
move: y4'_list_def.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
rewrite -!ALL_MEM /= => eq1 d mem_d.
have d_in: `d IN dart (hypermap_of_list L)`.
  by rewrite dartL darts_of_list IN_SET_OF_LIST.
rewrite eq1.
  by rewrite -IN_SET_OF_LIST -darts_of_list -dartL -faceL lemma_dart_inveriant_under_inverse_maps.
move: (goodL); rewrite good_list => [] [uniqL] _.
rewrite POWER_2 o_THM; congr `ye_list g (_1, _2)` => //.
rewrite f_list_ext_inverse // res -dartL d_in /=.
move: (mem_d); rewrite dart_in_face find_face_alt (pair_expand d).
by move/prev_el_list_pairs_general => [z] ->.
Qed.

Lemma y4'_list_ff_def: `ALL (\d. y4'_list (g,V,E) ((f_list_ext L POWER 2) d)
                = ye_list g (SND ((f_list_ext L POWER 2) d), SND d)) (list_of_darts L)`.
Proof.
rewrite -ALL_MEM => d mem_d /=.
rewrite !list_defs_th !o_THM.
have ->: `g (SND ((f_list_ext L POWER 2) d), SND d) = SND (g ((f_list_ext L POWER 2) d)), SND (g d)`.
  by rewrite !g_eq.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
have [dartH [_] [_] faceH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have d_in: `d IN dart (hypermap_of_list L)`.
  by rewrite dartL darts_of_list IN_SET_OF_LIST.
rewrite -faceL -(hyp_iso_comm_power iso_g) // faceH.
rewrite y4'_fan ye_fan; congr `dist (_1, _2)` => //.
rewrite POWER_2 -(o_THM `inverse _`) o_ASSOC.
rewrite (PERMUTES_INVERSES_o (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)) o_THM I_THM.
rewrite f_fan_pair_ext.
case gd_in1: `g d IN _` => /=.
  by rewrite {1}(pair_expand `g d`) f_fan_pair.
move: (hyp_iso_dart iso_g d_in); rewrite dartH dart_of_fan_eq IN_UNION gd_in1 orFb.
by rewrite IN_ELIM_THM /= {1}(pair_expand `g d`) PAIR_EQ => [] [v] [_] [-> ->].
Qed.

Lemma y4'_list_fff_def: `ALL (\d. y4'_list (g,V,E) ((f_list_ext L POWER 3) d)
            = ye_list g (SND ((f_list_ext L POWER 3) d), SND (f_list_ext L d))) (list_of_darts L)`.
Proof.
move: y4'_list_ff_def.
have [dartL [_] [_] faceL] := components_hypermap_of_list goodL.
rewrite -!ALL_MEM /= => eq1 d mem_d.
have d_in: `d IN dart (hypermap_of_list L)`.
  by rewrite dartL darts_of_list IN_SET_OF_LIST.
rewrite THREE POWER o_THM eq1 //.
by rewrite -IN_SET_OF_LIST -darts_of_list -dartL -faceL lemma_dart_invariant.
Qed.

End ExtraDefs.


(* ExtraFan *)
Section ExtraFan.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.


Lemma f_fan_pair_ext_power_inverse k d: `d IN dart_of_fan (V,E)
	/\ k < CARD (face (hypermap_of_fan (V,E)) d)
	==> (f_fan_pair_ext (V,E) POWER k) d 
	  = (inverse (f_fan_pair_ext (V,E)) POWER (CARD (face (hypermap_of_fan (V,E)) d) - k)) d`.
Proof.
move => [d_in k_lt].
set n := `CARD _`.
rewrite -(COMPONENTS_HYPERMAP_OF_FAN fanV).
rewrite (FINITE_ORBIT_MAP_INVERSE `dart_of_fan (V,E)` n).
  by rewrite -dartH !face_map_and_darts -face n_def; move: k_lt; arith.
suff ->: `n - (n - k) = k:num` by [].
by move: k_lt; arith.
Qed.

Lemma f_fan_pair_ext_power_in_dart k d: `d IN dart_of_fan (V,E)
	==> (f_fan_pair_ext (V,E) POWER k) d IN dart_of_fan (V,E)`.
Proof.
rewrite -!(COMPONENTS_HYPERMAP_OF_FAN fanV) => d_in.
by rewrite lemma_dart_invariant_power_face.
Qed.

Lemma f_fan_pair_ext_power_inj k1 k2 d: `d IN dart_of_fan (V,E)
	/\ k1 < CARD (face (hypermap_of_fan (V,E)) d) /\ k2 < CARD (face (hypermap_of_fan (V,E)) d)
	==> ((f_fan_pair_ext (V,E) POWER k1) d = (f_fan_pair_ext (V,E) POWER k2) d
		<=> k1 = k2)`.
Proof.
set n := `CARD _`.
move => [d_in] [k1_lt] k2_lt.
split; last by move => ->.
move/(ORBIT_MAP_INJ (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)); apply; exists n.
by rewrite (FINITE_DART_OF_FAN fanV) -(COMPONENTS_HYPERMAP_OF_FAN fanV) -face.
Qed.

Lemma f_fan_pair_ext_in_dart1 d: `d IN dart1_of_fan (V,E) ==> 
	f_fan_pair_ext (V,E) d IN dart1_of_fan (V,E)`.
Proof. by move => d_in; rewrite f_fan_pair_ext d_in /= E_N_F_IN_DART1_OF_FAN. Qed.

Lemma f_fan_pair_ext_power_in_dart1 k d: `d IN dart1_of_fan (V,E)
	==> (f_fan_pair_ext (V,E) POWER k) d IN dart1_of_fan (V,E)`.
Proof.
move => d_in.
elim: k => [|k Ih]; first by rewrite POWER_0 I_THM.
by rewrite COM_POWER o_THM f_fan_pair_ext_in_dart1.
Qed.

Lemma f_fan_pair_ext_in_dart d: `d IN dart_of_fan (V,E)
	==> f_fan_pair_ext (V,E) d IN dart_of_fan (V,E)`.
Proof. by move => d_in; rewrite -POWER_1 f_fan_pair_ext_power_in_dart. Qed.

Lemma inv_f_fan_pair_ext_power_in_dart1 k d: `d IN dart1_of_fan (V,E)
	==> (inverse (f_fan_pair_ext (V,E)) POWER k) d IN dart1_of_fan (V,E)`.
Proof.
move => d_in.
elim: k => [|k Ih]; first by rewrite POWER_0 I_THM.
by rewrite COM_POWER o_THM INVERSE_F_IN_DART1_OF_FAN.
Qed.

Lemma face_eq_power k d: `d IN darts_k k (hypermap_of_fan (V,E))
	==> face (hypermap_of_fan (V,E)) d = {(f_fan_pair_ext (V,E) POWER i) d | i < k}`.
Proof.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
rewrite darts_k inE face !hypV => [] [d_in] card_f.
by rewrite (FINITE_ORBIT_MAP card_f (F_FAN_PAIR_EXT_PERMUTES_DART1_OF_FAN fanV)) // finite_dart1.
Qed.

Lemma face4_eq v w: `let w' = sigma_fan (vec 0) V E v w in
		   let u = sigma_fan (vec 0) V E w' v in
	v,w IN darts_k 4 (hypermap_of_fan (V,E))
	==> (f_fan_pair_ext (V,E) (v,w) = (w,u)
		/\ (f_fan_pair_ext (V,E) POWER 2) (v,w) = (u,w')
		/\ (f_fan_pair_ext (V,E) POWER 3) (v,w) = (w',v)
		/\ f_fan_pair_ext (V,E) (w,u) = (u,w')
		/\ f_fan_pair_ext (V,E) (u,w') = (w',v)
		/\ f_fan_pair_ext (V,E) (w',v) = (v,w))
	/\ (v,w IN dart1_of_fan (V,E) /\ w,u IN dart1_of_fan (V,E)
		/\ u,w' IN dart1_of_fan (V,E) /\ w',v IN dart1_of_fan (V,E))
	/\ face (hypermap_of_fan (V,E)) (v,w) = {(v,w), (w,u), (u,w'), (w',v)}`.
Proof.
do !"CONV_TAC let_CONV".
set w' := `sigma_fan _ V E v w`.
set u := `sigma_fan _ V E w' v`.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
move => vw_in4; move: (vw_in4); rewrite darts_k inE hypV => [] [vw_in] card_f.
have := f_fan_pair_ext_power_inverse vw_in.
rewrite card_f => inv_eq.
have vw_in1: `v,w IN dart1_of_fan (V,E)`.
  by rewrite CARD_FACE_GT_1 card_f fanV; arith.
have w'v_in1: `w',v IN dart1_of_fan (V,E)`.
  by rewrite dart1_switch -w'_def sigma_in_dart1.
set f := `f_fan_pair_ext (V,E)`.
have eq0: `(inverse f POWER 2) (v,w) = (u,w')`.
  rewrite -f_def POWER_2 o_THM !INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite !res vw_in1 /= w'_def w'v_in1 /= u_def.
have ineqs: `2 < 4 /\ 4 - 2 = 2 /\ 3 < 4 /\ 4 - 3 = 1` by arith.
have eq2: `(f POWER 2) (v,w) = u,w'` by rewrite inv_eq.
have eq1: `f (v,w) = w,u`.
  rewrite pair_expand -{1}f_def f_fan_pair_ext vw_in1 /= f_fan_pair FST PAIR_EQ /=.
  move: eq2; rewrite -{1}f_def POWER_2 o_THM f_fan_pair_ext f_fan_pair_ext_in_dart1 //=.
  by rewrite f_def {1}(pair_expand `f (v,w)`) f_fan_pair PAIR_EQ => ->.
have eq3: `(f POWER 3) (v,w) = w',v`.
  rewrite inv_eq // ineqs POWER_1 -f_def INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite res vw_in1 /= w'_def.
rewrite eq1 eq2 eq3 /= -eq1 -eq2 -eq3 {1}THREE POWER POWER_2 !o_THM /=.
rewrite {1}inv_eq // ineqs POWER_1.
rewrite -{1 2}f_def (PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)) /=.
rewrite -(o_THM f f) -POWER_2 vw_in1 -f_def f_fan_pair_ext_in_dart1 //.
rewrite !f_fan_pair_ext_power_in_dart1 //.
by rewrite (face_eq_power vw_in4) "gen_FINITE_SET 4" POWER_0 POWER_1 I_THM f_def.
Qed.

Lemma face5_eq v w: `let w' = sigma_fan (vec 0) V E v w in
		   let u = sigma_fan (vec 0) V E w' v in
		   let z = sigma_fan (vec 0) V E u w' in
	v,w IN darts_k 5 (hypermap_of_fan (V,E))
	==> (f_fan_pair_ext (V,E) (v,w) = (w,z)
		/\ (f_fan_pair_ext (V,E) POWER 2) (v,w) = (z,u)
		/\ (f_fan_pair_ext (V,E) POWER 3) (v,w) = (u,w')
		/\ (f_fan_pair_ext (V,E) POWER 4) (v,w) = (w',v)
		/\ f_fan_pair_ext (V,E) (w,z) = (z,u)
		/\ f_fan_pair_ext (V,E) (z,u) = (u,w')
		/\ f_fan_pair_ext (V,E) (u,w') = (w',v)
		/\ f_fan_pair_ext (V,E) (w',v) = (v,w)
		/\ inverse (f_fan_pair_ext (V,E)) (v,w) = (w',v))
	/\ (v,w IN dart1_of_fan (V,E) /\ w,z IN dart1_of_fan (V,E) /\ z,u IN dart1_of_fan (V,E)
		/\ u,w' IN dart1_of_fan (V,E) /\ w',v IN dart1_of_fan (V,E))
	/\ face (hypermap_of_fan (V,E)) (v,w) = {(v,w), (w,z), (z,u), (u,w'), (w',v)}`.
Proof.
do !"CONV_TAC let_CONV".
set w' := `sigma_fan _ V E v w`.
set u := `sigma_fan _ V E w' v`.
set z := `sigma_fan _ V E u w'`.
have hypV := COMPONENTS_HYPERMAP_OF_FAN fanV.
move => vw_in5; move: (vw_in5); rewrite darts_k inE hypV => [] [vw_in] card_f.
have:= f_fan_pair_ext_power_inverse vw_in.
rewrite card_f => inv_eq.
have vw_in1: `v,w IN dart1_of_fan (V,E)`.
  by rewrite CARD_FACE_GT_1 card_f fanV; arith.
set f := `f_fan_pair_ext (V,E)`.
have eq_inv1: `(inverse f) (v,w) = (w',v)`.
  by rewrite -f_def INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /= w'_def.
have eq_inv2: `(inverse f POWER 2) (v,w) = (u,w')`.
  rewrite POWER_2 o_THM eq_inv1 -f_def INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite res -{1}eq_inv1 -{1}f_def INVERSE_F_IN_DART1_OF_FAN.
have eq_inv3: `(inverse f POWER 3) (v,w) = (z,u)`.
  rewrite THREE COM_POWER o_THM eq_inv2 -f_def INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  by rewrite res -{1}eq_inv2 -{1}f_def inv_f_fan_pair_ext_power_in_dart1.
have ineqs: `2 < 5 /\ 5 - 2 = 3 /\ 3 < 5 /\ 5 - 3 = 2 /\ 4 < 5 /\ 5 - 4 = 1` by arith.
have eq2: `(f POWER 2) (v,w) = z,u` by rewrite inv_eq.
have eq3: `(f POWER 3) (v,w) = u,w'` by rewrite inv_eq.
have eq4: `(f POWER 4) (v,w) = w',v` by rewrite inv_eq // ineqs POWER_1.
have eq1: `f (v,w) = w,z`.
  rewrite pair_expand -{1}f_def f_fan_pair_ext vw_in1 /= f_fan_pair FST PAIR_EQ /=.
  move: eq2; rewrite -{1}f_def POWER_2 o_THM f_fan_pair_ext f_fan_pair_ext_in_dart1 //=.
  by rewrite f_def {1}(pair_expand `f (v,w)`) f_fan_pair PAIR_EQ => ->.
rewrite eq1 eq2 eq3 eq4 eq_inv1 /=; split.
  rewrite -eq1 -eq2 -eq3 -{1}eq4 POWER_2 THREE POWER POWER_2 !o_THM /=.
  have ->: `4 = SUC 3` by arith.
  rewrite THREE !POWER POWER_2 !o_THM /=.
  by rewrite -eq_inv1 -f_def (PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)).
rewrite -eq1 -eq2 -eq3 -eq4 vw_in1 -f_def f_fan_pair_ext_in_dart1 //.
rewrite !f_fan_pair_ext_power_in_dart1 // !andTb.
by rewrite (face_eq_power vw_in5) "gen_FINITE_SET 5" POWER_0 POWER_1 I_THM f_def.
Qed.

Lemma face_last_dart v w: `v,w IN dart1_of_fan (V,E)
	==> (f_fan_pair_ext (V,E) POWER (CARD (face (hypermap_of_fan (V,E)) (v,w)) - 1)) (v,w)
		= sigma_fan (vec 0) V E v w, v`.
Proof.
move => vw_in1.
have vw_in: `v,w IN dart_of_fan (V,E)` by rewrite dart_of_fan_eq IN_UNION.
have ineq := FACE_NOT_EMPTY `hypermap_of_fan (V,E)` `v,w`.
rewrite (f_fan_pair_ext_power_inverse vw_in); first by move: ineq; arith.
rewrite subKn // POWER_1 INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
by rewrite res vw_in1.
Qed.

End ExtraFan.


(* FanAddDiag *)
Section FanAddDiag.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let in_dart_inV d: `d IN dart_of_fan (V,E) ==> FST d IN V /\ SND d IN V`.
Proof. by rewrite {1}pair_expand => /(PAIR_IN_DART_OF_FAN fanV). Qed.

Lemma add_diag_eq_E d: `CARD (face (hypermap_of_fan (V,E)) d) = 3
	==> add_diag (V,E) d = E`.
Proof.
case: d => v w card_eq; rewrite add_diag.
case vw_in1: `v,w IN _` => /=.
have vw_in: `v,w IN dart_of_fan (V,E)` by rewrite dart_of_fan_eq IN_UNION.
have := split_fan_face_eq vw_in card_eq fanV.
by rewrite split_fan_face PAIR_EQ => [] [_].
Qed.

End FanAddDiag.


Section FullySurroundedAddDiag.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Hypothesis f_surr: `fully_surrounded (V,E)`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by rewrite fully_surrounded_dart_of_fan_eq. Qed.

Lemma pack_dist x: `packing V /\ x IN dart_of_fan (V,E) ==> &2 <= dist x`.
Proof.
case: x => v w [packV]; rewrite -dart1_eq => vw_in.
apply: (iffLR (Sphere.packing_in V) packV v w).
by rewrite !(PAIR_IN_DART1_OF_FAN fanV vw_in) (PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV vw_in).
Qed.

Lemma split_fan_face_eq_add_diag d: `d IN dart_of_fan (V,E) 
	==> split_fan_face (V,E) d = V, add_diag (V,E) d`.
Proof. by case: d => v w vw_in; rewrite split_fan_face add_diag dart1_eq vw_in. Qed.

Lemma faces_add_diag v w: `v,w IN dart_of_fan (V,E)
	 ==> let H2 = hypermap_of_fan (V, add_diag (V,E) (v,w)) in
	     let H = hypermap_of_fan (V,E) in
	     let w' = sigma_fan (vec 0) V E v w in
		face_set H2 = {face H2 (v,w), face H2 (w',w)} 
			UNION (face_set H DELETE (face H (v,w)))`.
Proof.
move => vw_in; do !"CONV_TAC let_CONV".
rewrite EXTENSION IN_UNION IN_DELETE IN_INSERT IN_SING => f.
set w' := `sigma_fan _ V E v w`.
case: (fully_surrounded_card_face_alt fanV f_surr vw_in) => card_f.
  rewrite -split_fan_face_eq_add_diag // split_fan_face_eq //.
  have w'w_in: `w',w IN dart_of_fan (V,E)`.
    by rewrite -dart1_eq dart1_switch -w'_def f_fan_pair3.
  split => [->| ]; first by rewrite andTb orbC orbA orNb.
  by case => [| ->] //; case => ->; rewrite -lemma_in_face_set dartH.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f.
have := face_split_fan_face fanV f_surr vw_in.
have := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face_eq_add_diag // dart1_eq w'_def.
move => [fan2] [dart2] f_surr2 fs_eq [] [f2_vw f2_w'w] _.
have [dartH2 [_] [_] fH2] := COMPONENTS_HYPERMAP_OF_FAN fan2.
set H2 := `hypermap_of_fan _`.
split; last first.
  case; first by case => ->; rewrite -lemma_in_face_set dartH2 dart2 IN_UNION IN_INSERT.
  move => [/lemma_face_representation] [d]; rewrite dartH => [] [d_in] -> f_neq.
  rewrite -(fs_eq d_in); last by rewrite -lemma_in_face_set dartH2 dart2 IN_UNION.
  by apply: contra f_neq => /lemma_face_identity ->.
move/lemma_face_representation => [d].
rewrite dartH2 dart2 IN_UNION IN_INSERT IN_SING => [] [d_in_cond] ->.
case: d_in_cond => [d_in |]; last first.
  case => -> //; left; left.
  by rewrite eq_sym; apply lemma_face_identity; rewrite f2_vw !IN_INSERT.
case d_in_f: `d IN face (hypermap_of_fan (V,E)) (v,w)` => /=; last first.
  right; rewrite fs_eq // -lemma_in_face_set dartH d_in andTb.
  by apply: contra d_in_f; apply: contraLR => /lemma_different_faces.
case d_eq: `d = v,w \/ d = w',v` => /=; last first.
  left; right; rewrite eq_sym; apply lemma_face_identity.
  by rewrite f2_w'w IN_INSERT IN_DIFF IN_INSERT IN_SING.
left; left; case: d_eq => -> //.
by rewrite eq_sym; apply lemma_face_identity; rewrite f2_vw !IN_INSERT.
Qed.

Lemma f_fan_pair_ext_power_add_diag v w k:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
		/\ 1 <= k /\ k <= CARD f - 2
	==> (f_fan_pair_ext (V, add_diag (V,E) (v,w)) POWER k) (w',w)
		= (f_fan_pair_ext (V,E) POWER k) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
set f := `face _ (v,w)`.
move => [vw_in] [card_f] k_ineqs.
have := fan_split_fan_face fanV f_surr vw_in.
have := "let_RULE f_split_fan_face" fanV f_surr vw_in; "ANTS_TAC"; first by rewrite f_def.
set w' := `sigma_fan _ V E v w`.
rewrite split_fan_face_eq_add_diag //.
move => f_eqs [fan2] [dart2] f_surr2.
rewrite -!f_fan_pair_power //.
  by rewrite -fully_surrounded_dart_of_fan_eq // dart2 IN_UNION IN_INSERT.
elim: k k_ineqs => [|k Ih]; first by arith.
move => k_ineqs; case: (posnP k) => [-> | k_gt0].
  by rewrite -ONE !POWER_1 f_eqs.
rewrite !COM_POWER !o_THM Ih; first by move: k_gt0 k_ineqs; arith.
rewrite f_eqs // f_fan_pair_power // !negb_or.
rewrite dart2 dart1_eq IN_UNION f_fan_pair_ext_power_in_dart // orTb andTb.
have := fully_surrounded_diag_not_in_dart fanV f_surr vw_in; "ANTS_TAC"; first by rewrite f_def.
rewrite w'_def => ww'_n_in.
split.
  have {2}->: `v,w = (f_fan_pair_ext (V,E) POWER 0) (v,w)` by rewrite POWER_0 I_THM.
  rewrite (f_fan_pair_ext_power_inj fanV vw_in) -?LT_NZ // f_def.
  by move: k_ineqs; arith.
split; first by apply: contra ww'_n_in => <-; rewrite f_fan_pair_ext_power_in_dart.
split.
  by apply: contra ww'_n_in; rewrite dart_switch => <-; rewrite f_fan_pair_ext_power_in_dart.
have ->: `sigma_fan (vec 0) V E w' v, w' = (inverse (f_fan_pair_ext (V,E)) POWER 2) (v,w)`.
  rewrite POWER_2 o_THM INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  rewrite !res /= dart1_eq vw_in /= dart_switch.
  by rewrite -dart1_eq sigma_in_dart1.
have ->: `2 = CARD f - (CARD f - 2)` by move: k_ineqs; arith.
rewrite -{1}f_def -(f_fan_pair_ext_power_inverse fanV vw_in) ?f_def.
  move: k_ineqs; arith.
by rewrite (f_fan_pair_ext_power_inj fanV vw_in) ?f_def; move: k_ineqs; arith.
Qed.

Lemma inverse_f_fan_pair_ext_add_diag v w:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
	==> inverse (f_fan_pair_ext (V, add_diag (V,E) (v,w))) (w',w)
		= (inverse (f_fan_pair_ext (V,E)) POWER 2) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
move => [vw_in card_f].
have := fan_split_fan_face fanV f_surr vw_in.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f.
rewrite split_fan_face_eq_add_diag //.
set w' := `sigma_fan _ V E v w`.
set f := `face (hypermap_of_fan (V,E)) (v,w)`.
set H2 := `hypermap_of_fan _`.
move => [_] [] [_] card2_w'w _ [fan2] [dart2] f_surr2.
rewrite -POWER_1.
have ->: `1 = CARD (face H2 (w',w)) - (CARD f - 2)`.
  by rewrite card2_w'w; move: card_f; arith.
have ->: `2 = CARD f - (CARD f - 2)` by move: card_f; arith.
rewrite -H2_def -(f_fan_pair_ext_power_inverse fan2).
  by rewrite H2_def card2_w'w dart2 IN_UNION IN_INSERT /=; move: card_f; arith.
rewrite subKn; first by move: card_f; arith.
rewrite -{2}f_def -(f_fan_pair_ext_power_inverse fanV vw_in).
  by rewrite f_def; move: card_f; arith.
rewrite -w'_def ("let_RULE f_fan_pair_ext_power_add_diag" vw_in) //.
by rewrite f_def; move: card_f; arith.
Qed.

Lemma azim_dart_eq_dihV v w: `(v,w) IN dart_of_fan (V,E)
	==> azim_dart (V,E) (v,w) = dihV (vec 0) v w (sigma_fan (vec 0) V E v w)`.
Proof.
move => vw_in; move: (vw_in); rewrite -dart1_eq => vw_in1.
rewrite fully_surrounded_azim_dart_eq_azim //.
rewrite AZIM_DIVH ?(DART1_NOT_COLLINEAR fanV) ?sigma_in_dart1 //.
rewrite -fully_surrounded_azim_dart_eq_azim //.
by move: f_surr; rewrite fully_surrounded => ->.
Qed.

End FullySurroundedAddDiag.


Section Fan.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis f_surr: `fully_surrounded (V,E)`.


Lemma fan_sol_pos v w: `v,w IN dart_of_fan (V,E)
        ==> &0 <= sol (vec 0) (dart_leads_into (vec 0) V E v w)`.
Proof.
move => vw_in.
move: (fully_surrounded_imp_conforming fanV f_surr);
rewrite Conforming.conforming_fan => [] [_] [_] [_] [_] [c_angle] _.
move: c_angle; rewrite "let_RULE Conforming.conforming_solid_angle_fan" => c_angle.
have iso := fan_hypermaps_iso_explicit2 fanV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have vw_in2: `v,w IN dart (hypermap_of_fan (V,E))` by rewrite dartH.
have [_ [f_eq] _] := iso_components iso vw_in2.
move: f_eq; set f1 := `face _1 _2`; move => f1_eq.
move: (c_angle f1); "ANTS_TAC".
  by rewrite -f1_def -lemma_in_face_set (hyp_iso_dart iso).
rewrite f1_eq -dart_leads_into_eq1 //.
move => [r1] [r2] _.
move: r2; rewrite Sphere.eventually_radial => [] [r] [r_gt0] rad.
rewrite (Vol1.sol_spec r_gt0 rad) INTER_COMM ?r1 //.
rewrite REAL_LE_MUL REAL_LE_DIV; last by arith.
rewrite REAL_POW_LE; first by move: r_gt0; arith.
by rewrite -real_ge Vol1.VOLUME_PROPS_MEASURABLE.
Qed.


Lemma sol_fan_eq v w: `v,w IN dart_of_fan (V,E)
        ==> sol_fan (V,E) (face (hypermap_of_fan (V,E)) (v, w))
                = sol (vec 0) (dart_leads_into (vec 0) V E v w)`.
Proof.
rewrite sol_fan => vw_in; rewrite fully_surrounded_sol // REAL_ADD_SYM.
by rewrite REAL_ABS_REFL -fully_surrounded_sol // fan_sol_pos.
Qed.


(* Additional hypotheses *)
Hypothesis packV: `packing V`.
Hypothesis subV: `V SUBSET ball_annulus`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by rewrite fully_surrounded_dart_of_fan_eq. Qed.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let fH: `face_map (hypermap_of_fan (V,E)) = f_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let nH: `node_map (hypermap_of_fan (V,E)) = n_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let norm_v v: `v IN V ==> &2 <= norm v /\ norm v <= #2.52`.
Proof.
rewrite SUBSET in subV; move/subV.
by rewrite Fnjlbxs.in_ball_annulus h0; arith.
Qed.

Let pack_dist x: `x IN dart_of_fan (V,E) ==> &2 <= dist x`.
Proof.
case: x => v w; rewrite -dart1_eq => vw_in.
apply: (iffLR (Sphere.packing_in V) packV v w).
by rewrite !(PAIR_IN_DART1_OF_FAN fanV vw_in) (PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV vw_in).
Qed.


Lemma rho_pos v: `v IN V ==> &0 <= &1 + const1 * (&1 - ln_fan v)`.
Proof.
move => vV; rewrite REAL_LE_ADD REAL_LE_MUL; last by arith.
rewrite const1_ge0 ln_fan lmfun yn_fan h0.
by move: (norm_v vV); arith.
Qed.


(* V *)
Section V.

Variable v: `:real^3`.
Hypothesis vV: `v IN V`.

Lemma ln_def: `ln_fan v = (#2.52 - yn_fan v) / #0.52`.
Proof.
rewrite ln_fan yn_fan lmfun h0.
by move: (norm_v vV); arith.
Qed.

Lemma rho_def: `rho_fan v = (&1 + sol0 / pi) - ln_fan v * sol0 / pi`.
Proof.
rewrite rho_fan sol0_over_pi_EQ_const1.
suff: `&0 <= &1 + const1 * (&1 - ln_fan v)` by arith.
by rewrite rho_pos.
Qed.

Lemma ln_lo: `&0 <= ln_fan v`.
Proof. by rewrite ln_fan Fnjlbxs.lmfun_ge0. Qed.

Lemma ln_hi: `ln_fan v <= &1`.
Proof. by rewrite ln_fan yn_fan lmfun h0; move: (norm_v vV); arith. Qed.

Lemma yn_lo: `&2 <= yn_fan v`.
Proof. by rewrite yn_fan norm_v. Qed.

Lemma yn_hi: `yn_fan v <= #2.52`.
Proof. by rewrite yn_fan norm_v. Qed.

Lemma rho_lo: `&1 <= rho_fan v`.
Proof.
rewrite rho_fan.
suff: `&0 <= const1 * (&1 - ln_fan v)` by arith.
by rewrite REAL_LE_MUL const1_ge0; move: ln_hi; arith.
Qed.

Lemma rho_hi: `rho_fan v <= &1 + sol0 / pi`.
Proof.
rewrite rho_fan.
set x := `&1 + _`.
have ->: `abs x = x` by rewrite REAL_ABS_REFL -x_def rho_pos.
rewrite -x_def REAL_LE_LADD sol0_over_pi_EQ_const1.
rewrite -{2}(REAL_MUL_RID `const1`) REAL_LE_MUL2 const1_ge0 REAL_LE_REFL.
by rewrite ln_fan yn_fan lmfun h0; move: (norm_v vV); arith.
Qed.

End V.


(* Dart *)
Section Dart.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.

Lemma edge_sym: `ye_fan d = ye_fan (e_fan_pair_ext (V,E) d)`.
Proof.
case: d d_in => v w vw_in.
by rewrite e_fan_pair_ext dart1_eq vw_in /= e_fan_pair !ye_fan DIST_SYM.
Qed.

Lemma y1_def: `y1_fan d = yn_fan (FST d)`.
Proof. by rewrite y1_fan yn_fan. Qed.

Lemma y2_def: `y2_fan d = yn_fan (FST (f_fan_pair_ext (V,E) d))`.
Proof.
case: d d_in => v w d_in.
by rewrite f_fan_pair_ext dart1_eq d_in /= f_fan_pair y2_fan yn_fan.
Qed.

Lemma y3_def: `y3_fan (V,E) d = yn_fan (FST (inverse (f_fan_pair_ext (V,E)) d))`.
Proof. by rewrite y3_fan yn_fan. Qed.

Lemma y4_def: `y4_fan (V,E) d = ye_fan (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite y4_fan ye_fan. Qed.

Lemma y5_def: `y5_fan (V,E) d = ye_fan (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite y5_fan ye_fan. Qed.

Lemma y6_def: `y6_fan d = ye_fan d`.
Proof. by rewrite y6_fan ye_fan. Qed.

Lemma y8_def: `y8_fan (V,E) d = y5_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite y8_fan. Qed.

Lemma y9_def: `y9_fan (V,E) d = ye_fan (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite y9_fan ye_fan. Qed.

Lemma azim_lo: `&0 <= azim_dart (V,E) d`.
Proof. by rewrite "GEN_ALL AZIM_DART_POS". Qed.

Lemma azim_hi: `azim_dart (V,E) d <= pi`.
Proof. by rewrite REAL_LT_IMP_LE; move: f_surr; rewrite fully_surrounded => ->. Qed.

Lemma rhazim_lo: `&0 <= rhazim_fan (V,E) d`.
Proof. by rewrite rhazim_fan REAL_LE_MUL REAL_ABS_POS azim_lo. Qed.

Lemma rhazim_hi: `rhazim_fan (V,E) d <= pi + sol0`.
Proof.
rewrite rhazim_fan -(REAL_MUL_RID `pi + sol0`).
rewrite -{3}(REAL_MUL_LINV PI_NZ) REAL_MUL_ASSOC REAL_LE_MUL2.
rewrite azim_hi REAL_ABS_POS azim_lo /=.
rewrite REAL_ADD_RDISTRIB (REAL_MUL_RINV PI_NZ) -real_div.
have ->: `lmfun (h_dart d) = ln_fan (FST d)` by rewrite ln_fan h_dart yn_fan.
set x := `abs _`.
have fst_in: `FST d IN V`.
  by case: d d_in => v w d_in /=; rewrite (PAIR_IN_DART_OF_FAN fanV d_in).
have ->: `x = &1 + const1 * (&1 - ln_fan (FST d))`.
  by rewrite -x_def REAL_ABS_REFL rho_pos.
rewrite REAL_LE_LADD sol0_over_pi_EQ_const1 -{2}(REAL_MUL_RID `const1`).
rewrite REAL_LE_MUL2 const1_ge0 REAL_LE_REFL /=.
rewrite ln_fan yn_fan lmfun h0.
by move: (norm_v fst_in); arith.
Qed.

Lemma ye_lo: `&2 <= ye_fan d`.
Proof. by rewrite ye_fan pack_dist. Qed.

Let d_inV: `FST d IN V /\ SND d IN V`.
Proof. by apply: (PAIR_IN_DART_OF_FAN fanV); rewrite -pair_expand. Qed.

Lemma y1_lo: `&2 <= y1_fan d`.
Proof. by rewrite y1_fan norm_v. Qed.

Lemma y2_lo: `&2 <= y2_fan d`.
Proof. by rewrite y2_fan norm_v. Qed.

Lemma y1_hi: `y1_fan d <= #2.52`.
Proof. by rewrite y1_fan norm_v. Qed.

Lemma y2_hi: `y2_fan d <= #2.52`.
Proof. by rewrite y2_fan norm_v. Qed.

Lemma y6_lo: `&2 <= y6_fan d`.
Proof. by rewrite y6_fan pack_dist. Qed.

End Dart.


(* Dart3 *)
Section Dart3.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 3 (hypermap_of_fan (V,E))`.

Let card_f: `CARD (face (hypermap_of_fan (V,E)) d) = 3`.
Proof. by move: d_in; rewrite darts_k inE => ->. Qed.

Let d_in_dart: `d IN dart_of_fan (V,E)`.
Proof. by move: d_in; rewrite darts_k inE dartH => ->. Qed.


Lemma y4'_eq_y4: `y4'_fan (V,E) d = y4_fan (V,E) d`.
Proof.
case: d card_f d_in_dart => v w card_f vw_in.
have vw_in1: `v,w IN dart1_of_fan (V,E)` by rewrite dart1_eq.
rewrite y4'_fan y4_fan f_fan_pair_ext vw_in1 /=.
rewrite (f_fan_pair3 card_f) // INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
by rewrite res vw_in1.
Qed.


End Dart3.

Let fd_in d: `d IN dart_of_fan (V,E) ==> f_fan_pair_ext (V,E) d IN dart_of_fan (V,E)`.
Proof. by rewrite -dartH -fH => d_in; rewrite Hypermap.lemma_dart_invariant. Qed.

Let ifd_in d: `d IN dart_of_fan (V,E) ==> inverse (f_fan_pair_ext (V,E)) d IN dart_of_fan (V,E)`.
Proof.
by rewrite -dartH -fH => d_in; rewrite Hypermap.lemma_dart_inveriant_under_inverse_maps.
Qed.

Let in_dart_inV d: `d IN dart_of_fan (V,E) ==> FST d IN V /\ SND d IN V`.
Proof. by case: d => v w /(PAIR_IN_DART_OF_FAN fanV). Qed.

(* StdDart *)
Section StdDart.

Hypothesis std: `E = ESTD V`.

Let in_std d: `d IN dart_of_fan (V,E) ==> dist d <= #2.52 /\ dist d <= &3`.
Proof. by case: d => v w; rewrite -dart1_eq -inE_eq_in_dart1 std IN_ESTD; arith. Qed.

Section Inner.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.


Lemma ye_hi_std: `ye_fan d <= &3`.
Proof. by rewrite ye_fan in_std. Qed.

Lemma y4_hi_std: `y4_fan (V,E) d <= &3`.
Proof. by rewrite y4_fan in_std fd_in. Qed.

Lemma y5_hi_std: `y5_fan (V,E) d <= &3`.
Proof. by rewrite y5_fan in_std ifd_in. Qed.

Lemma y6_hi_std: `y6_fan d <= &3`.
Proof. by rewrite y6_fan in_std. Qed.

Lemma y8_hi_std: `y8_fan (V,E) d <= #2.52`.
Proof. by rewrite y8_fan y5_fan in_std !ifd_in. Qed.

Lemma y9_hi_std: `y9_fan (V,E) d <= #2.52`.
Proof. by rewrite y9_fan in_std fd_in. Qed.

Lemma ye_hi_std2: `ye_fan d <= &3`.
Proof. by rewrite ye_fan in_std. Qed.

Lemma y4_hi_std2: `y4_fan (V,E) d <= #2.52`.
Proof. by rewrite y4_fan in_std fd_in. Qed.

Lemma y5_hi_std2: `y5_fan (V,E) d <= #2.52`.
Proof. by rewrite y5_fan in_std ifd_in. Qed.

Lemma y6_hi_std2: `y6_fan d <= #2.52`.
Proof. by rewrite y6_fan in_std. Qed.

Lemma yy10_std: `ye_fan d <= #2.52`.
Proof. by rewrite ye_fan in_std. Qed.

End Inner.

End StdDart.



(* DartMore *)
Section DartMore.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.


Lemma azim2_lo: `&0 <= azim2_fan (V,E) d`.
Proof. by rewrite azim2_fan azim_lo fd_in. Qed.

Lemma azim2_hi: `azim2_fan (V,E) d <= pi`.
Proof. by rewrite azim2_fan azim_hi fd_in. Qed.

Lemma azim3_lo: `&0 <= azim3_fan (V,E) d`.
Proof. by rewrite azim3_fan azim_lo ifd_in. Qed.

Lemma azim3_hi: `azim3_fan (V,E) d <= pi`.
Proof. by rewrite azim3_fan azim_hi ifd_in. Qed.

Lemma rhazim2_lo: `&0 <= rhazim2_fan (V,E) d`.
Proof. by rewrite rhazim2_fan rhazim_lo fd_in. Qed.

Lemma rhazim2_hi: `rhazim2_fan (V,E) d <= pi + sol0`.
Proof. by rewrite rhazim2_fan rhazim_hi fd_in. Qed.

Lemma rhazim3_lo: `&0 <= rhazim3_fan (V,E) d`.
Proof. by rewrite rhazim3_fan rhazim_lo ifd_in. Qed.

Lemma rhazim3_hi: `rhazim3_fan (V,E) d <= pi + sol0`.
Proof. by rewrite rhazim3_fan rhazim_hi ifd_in. Qed.

Lemma y3_lo: `&2 <= y3_fan (V,E) d`.
Proof. by rewrite y3_fan norm_v in_dart_inV ifd_in. Qed.

Lemma y3_hi: `y3_fan (V,E) d <= #2.52`.
Proof. by rewrite y3_fan norm_v in_dart_inV ifd_in. Qed.

Lemma y4_lo: `&2 <= y4_fan (V,E) d`.
Proof. by rewrite y4_fan pack_dist fd_in. Qed.

Lemma y5_lo: `&2 <= y5_fan (V,E) d`.
Proof. by rewrite y5_fan pack_dist ifd_in. Qed.

Lemma y7_lo: `&2 <= y7_fan (V,E) d`.
Proof.
rewrite y7_fan {2}TWO POWER POWER_1 o_THM norm_v.
by rewrite (in_dart_inV (ifd_in (ifd_in d_in))).
Qed.

Lemma y7_hi: `y7_fan (V,E) d <= #2.52`.
Proof.
rewrite y7_fan TWO POWER POWER_1 o_THM norm_v.
by rewrite (in_dart_inV (ifd_in (ifd_in d_in))).
Qed.

Lemma y8_lo: `&2 <= y8_fan (V,E) d`.
Proof. by rewrite y8_fan y5_fan pack_dist !ifd_in. Qed.

Lemma y9_lo: `&2 <= y9_fan (V,E) d`.
Proof. by rewrite y9_fan pack_dist fd_in. Qed.

Lemma y4'_lo: `&2 <= y4'_fan (V,E) d`.
Proof.
move: packV.
rewrite Sphere.packing_in y4'_fan; apply.
rewrite (in_dart_inV d_in) (in_dart_inV (ifd_in d_in)) /=.
case: d d_in => v w vw_in.
rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in /=.
by rewrite -sigma_fan_not_fixed.
Qed.

Lemma azim2c: `azim2_fan (V,E) d = azim_dart (V,E) (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite azim2_fan. Qed.

Lemma azim3c: `azim3_fan (V,E) d = azim_dart (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite azim3_fan. Qed.

Lemma rhazim2c: `rhazim2_fan (V,E) d = rhazim_fan (V,E) (f_fan_pair_ext (V,E) d)`.
Proof. by rewrite rhazim2_fan. Qed.

Lemma rhazim3c: `rhazim3_fan (V,E) d = rhazim_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof. by rewrite rhazim3_fan. Qed.

Lemma RHA: `rhazim_fan (V,E) d >= azim_dart (V,E) d`.
Proof.
rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan.
rewrite real_ge -{1}(REAL_MUL_LID `azim_dart _ d`) REAL_LE_RMUL azim_lo // andbT.
by rewrite rho_lo in_dart_inV.
Qed.

Lemma RHB: `rhazim_fan (V,E) d <= azim_dart (V,E) d * (&1 + sol0 / pi)`.
Proof.
rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan REAL_MUL_SYM.
by rewrite REAL_LE_LMUL azim_lo // rho_hi // in_dart_inV.
Qed.

Lemma RHBLO: `yn_fan (FST d) <= #2.18 ==> rhazim_fan (V,E) d <= azim_dart (V,E) d * rho218`.
Proof.
move => ineq; rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan REAL_MUL_SYM.
rewrite REAL_LE_LMUL azim_lo // andTb rho_def ?in_dart_inV //.
rewrite ln_def ?in_dart_inV // rho218 Nonlinear_lemma.rho_alt sol0_over_pi_EQ_const1.
rewrite real_sub -REAL_ADD_ASSOC REAL_LE_LADD -real_sub.
have -> x y : `const1 - x / #0.52 * const1 <= const1 * y / #0.52 
		<=> const1 * #0.52 <= const1 * (x + y)` by arith.
by rewrite REAL_LE_LMUL const1_ge0 andTb; move: ineq; arith.
Qed.

Lemma RHBHI: `#2.18 <= yn_fan (FST d) ==> rhazim_fan (V,E) d >= azim_dart (V,E) d * rho218`.
Proof.
move => ineq; rewrite rhazim_fan h_dart -yn_fan -ln_fan -rho_fan REAL_MUL_SYM.
rewrite real_ge REAL_LE_LMUL azim_lo // andTb rho_def ?in_dart_inV //.
rewrite ln_def ?in_dart_inV // rho218 Nonlinear_lemma.rho_alt sol0_over_pi_EQ_const1.
rewrite !real_sub -REAL_ADD_ASSOC REAL_LE_LADD -!real_sub.
have -> x y : `const1 * y / #0.52 <= const1 - x / #0.52 * const1
		<=> const1 * #0.52 >= const1 * (x + y)` by arith.
by rewrite real_ge REAL_LE_LMUL const1_ge0 andTb; move: ineq; arith.
Qed.


End DartMore.


(* Node *)
Section Node.

Variable n: `:real^3#real^3->bool`.
Hypothesis n_in: `n IN node_set (hypermap_of_fan (V,E))`.

Let n_repr: `?v w. v,w IN dart_of_fan (V,E) /\ n = node (hypermap_of_fan (V,E)) (v,w)`.
Proof.
move/lemma_node_representation: n_in => [[v w]] h.
by exists v w; rewrite -dartH.
Qed.

Lemma azim_sum: `sum n (azim_dart (V,E)) = &2 * pi`.
Proof.
move: n_repr => [v] [w] [vw_in] ->.
by rewrite SUM_AZIM_DART.
Qed.

Lemma rhazim_sum: `sum n (rhazim_fan (V,E)) = &2 * pi * rho_fan (FST (CHOICE n))`.
Proof.
rewrite REAL_MUL_ASSOC -azim_sum -SUM_RMUL.
apply SUM_EQ => d d_in /=; rewrite rhazim_fan REAL_MUL_SYM REAL_EQ_MUL_LCANCEL; right.
rewrite h_dart -yn_fan -ln_fan -rho_fan; congr `rho_fan _`.
move: n_repr d_in => [v] [w] [vw_in] -> d_in.
rewrite eq_sym; apply: (fst_node_hypermap_of_fan fanV).
rewrite (lemma_node_identity d_in) CHOICE_DEF.
by rewrite -MEMBER_NOT_EMPTY; exists d; rewrite node_refl.
Qed.


End Node.



(* Face *)
Section Face.

Variable f: `:real^3#real^3->bool`.
Hypothesis f_in: `f IN face_set (hypermap_of_fan (V,E))`.

Let f_repr: `?v w. v,w IN dart_of_fan (V,E) /\ f = face (hypermap_of_fan (V,E)) (v,w)`.
Proof.
move/lemma_face_representation: f_in => [[v w]] h.
by exists v w; rewrite -dartH.
Qed.

Let confV: `conforming_fan (vec 0,V,E)`.
Proof. by rewrite (fully_surrounded_imp_conforming fanV f_surr). Qed.


Lemma sol_lo: `&0 <= sol_fan (V,E) f`.
Proof. by rewrite sol_fan REAL_ABS_POS. Qed.

Lemma tau_lo: `&0 <= tau_fan (V,E) f`.
Proof. by rewrite tau_fan REAL_ABS_POS. Qed.

Lemma sol_hi: `sol_fan (V,E) f <= &4 * pi`.
Proof.
have [v [w] [vw_in] ->] := f_repr.
rewrite sol_fan_eq //.
have iso := fan_hypermaps_iso_explicit2 fanV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have vw_in2: `v,w IN dart (hypermap_of_fan (V,E))` by rewrite dartH.
have [_ [f_eq] _] := iso_components iso vw_in2.
rewrite dart_leads_into_eq1 // -f_eq.
have := Conforming.SUM_SOL_IN_FACE_SET_EQ_4PI fanV confV.
move/REAL_EQ_IMP_LE => /SUM_POS_BOUND; "ANTS_TAC"; last first.
  move: f_eq; set f1 := `face _1 _2`; move => f_eq.
  move/(_ f1) => ->.
  by rewrite -f1_def -lemma_in_face_set (hyp_iso_dart iso).
rewrite FINITE_HYPERMAP_ORBITS andTb /=.
move => f1 /lemma_face_representation [d] [d_in] ->.
rewrite -(ext_contracted d fanV) -?(hypermap_of_fan_rep_alt fanV) //.
have cd_in: `contracted_dart d IN dart (hypermap_of_fan (V,E))`.
  by rewrite (hyp_iso_dart (fan_hypermaps_iso_explicit fanV)).
rewrite (iso_components iso) //.
rewrite (pair_expand `contracted_dart d`) -dart_leads_into_eq1 -?pair_expand -?dartH //.
by rewrite fan_sol_pos -pair_expand -dartH.
Qed.


Lemma sol_sum: `sum f (azim_dart (V,E)) = sol_fan (V,E) f + &(CARD f - 2) * pi`.
Proof.
have [v [w] [vw_in] ->] := f_repr.
rewrite sol_fan_eq // fully_surrounded_sol //.
rewrite SUM_SUB ?FACE_FINITE // (SUM_CONST `pi`) ?FACE_FINITE // (ETA_AX `azim_dart (V,E)`).
rewrite -REAL_OF_NUM_SUB; last by arith.
by move: (FULLY_SURROUNDED_IMP_CARD_FACE_GE_3 fanV f_surr vw_in); arith.
Qed.

Lemma sol_sum3: `CARD f = 3 ==> sum f (azim_dart (V,E)) = sol_fan (V,E) f + pi`.
Proof. by rewrite sol_sum => ->; arith. Qed.

Lemma sol_sum4: `CARD f = 4 ==> sum f (azim_dart (V,E)) = sol_fan (V,E) f + &2 * pi`.
Proof. by rewrite sol_sum => ->; arith. Qed.

Lemma sol_sum5: `CARD f = 5 ==> sum f (azim_dart (V,E)) = sol_fan (V,E) f + &3 * pi`.
Proof. by rewrite sol_sum => ->; arith. Qed.

Lemma sol_sum6: `CARD f = 6 ==> sum f (azim_dart (V,E)) = sol_fan (V,E) f + &4 * pi`.
Proof. by rewrite sol_sum => ->; arith. Qed.


End Face.


(* FaceTau *)
Section FaceTau.

Hypothesis tau_h: `lp_tau (V,E)`.

Section Inner.

Variable f: `:real^3#real^3->bool`.
Hypothesis f_in: `f IN face_set (hypermap_of_fan (V,E))`.

Lemma tau_sum: `sum f (rhazim_fan (V,E)) = tau_fan (V,E) f + &(CARD f - 2) * (pi + sol0)`.
Proof.
rewrite tau_fan_eq_tauVEF //.
move: (lemma_face_representation f_in) => [[v w]] []; rewrite dartH => vw_in f_eq.
rewrite {2}f_eq "let_RULE tauVEF_alt3" // -f_eq.
rewrite -REAL_OF_NUM_SUB.
  have := FULLY_SURROUNDED_IMP_CARD_FACE_GE_3 fanV f_surr vw_in.
  by rewrite -f_eq; arith.
have fin_f: `FINITE f` by rewrite f_eq FACE_FINITE.
rewrite !SUM_SUB // (SUM_CONST `pi`) // (SUM_CONST `sol0`) //.
rewrite !real_sub -!REAL_ADD_ASSOC -REAL_ADD_RID.
congr `_1 + _2:real`; last by arith.
apply SUM_EQ => d d_in_f.
have d_in: `d IN dart_of_fan (V,E)`.
  by rewrite -dartH (IN_TRANS d_in_f) f_eq lemma_face_subset dartH.
rewrite rhazim_fan !h_dart -!yn_fan -!ln_fan -rho_fan /= -!real_sub.
by rewrite rho_def ?(in_dart_inV d_in) //; arith.
Qed.

Lemma tau_sum3: `CARD f = 3 ==>
        sum f (rhazim_fan (V,E)) = tau_fan (V,E) f + (pi + sol0)`.
Proof. by rewrite tau_sum => ->; arith. Qed.

Lemma tau_sum4: `CARD f = 4 ==>
        sum f (rhazim_fan (V,E)) = tau_fan (V,E) f + &2 * (pi + sol0)`.
Proof. by rewrite tau_sum => ->; arith. Qed.

Lemma tau_sum5: `CARD f = 5 ==>
        sum f (rhazim_fan (V,E)) = tau_fan (V,E) f + &3 * (pi + sol0)`.
Proof. by rewrite tau_sum => ->; arith. Qed.

Lemma tau_sum6: `CARD f = 6 ==>
        sum f (rhazim_fan (V,E)) = tau_fan (V,E) f + &4 * (pi + sol0)`.
Proof. by rewrite tau_sum => ->; arith. Qed.

End Inner.

Hypothesis contrV: `contravening V`.

Section Inner.

Variable f: `:real^3#real^3->bool`.
Hypothesis f_in: `f IN face_set (hypermap_of_fan (V,E))`.

Let tgt_ineq: `&4 * pi - &20 * sol0 <= tgt`.
Proof.
have := "create_interval `&4 * pi - &20 * sol0`".
by rewrite interval_arith tgt; arith.
Qed.

Lemma tauVEF_hi: `tauVEF (V,E,f) <= tgt`.
Proof.
apply: REAL_LE_TRANS; exists `&4 * pi - &20 * sol0`; rewrite tgt_ineq andbT.
have := sum_tauVEF_upper_bound fanV f_surr; "ANTS_TAC".
  by move: contrV; rewrite contravening real_gt REAL_LT_LE => ->.
move/SUM_POS_BOUND => ->.
rewrite f_in FINITE_HYPERMAP_ORBITS /= => f2 f2_in.
by move: tau_h; rewrite lp_tau => ->.
Qed.

Lemma tau_hi: `tau_fan (V,E) f <= tgt`.
Proof. by rewrite tau_fan_eq_tauVEF // tauVEF_hi. Qed.

End Inner.

End FaceTau.


(* Connections between nonlinear inequalities and fan inequalities *)
Section Nonlinear.

(* V *)
Section V.

Variable v: `:real^3`.
Hypothesis vV: `v IN V`.

Lemma ln_fan_ly: `ln_fan v = ly (norm v)`.
Proof.
rewrite ln_fan yn_fan.
have ->: `v = FST (v,v)` by [].
rewrite -h_dart ly_EQ_lmfun //.
by move: (norm_v vV); rewrite h0; arith.
Qed.

Lemma rho_fan_eq_rho: `rho_fan v = rho (norm v)`.
Proof.
rewrite rho_fan Sphere.rho -ln_fan_ly.
set x := `&1 + _`.
suff ->: `abs x = x` by rewrite -x_def; arith.
by rewrite REAL_ABS_REFL -x_def rho_pos.
Qed.

End V.

(* Y *)
Section Y.

Lemma ys_eq v w: `v,w IN dart_of_fan (V,E)
        ==> y1_fan (v,w) = norm v
        /\ y2_fan (v,w) = norm w
        /\ y3_fan (V,E) (v,w) = norm (sigma_fan (vec 0) V E v w)
        /\ y4'_fan (V,E) (v,w) = dist (w, sigma_fan (vec 0) V E v w)
        /\ y5_fan (V,E) (v,w) = dist (v, sigma_fan (vec 0) V E v w)
        /\ y6_fan (v,w) = dist (v,w)`.
Proof.
move => vw_in.
rewrite y1_fan y2_fan y3_fan y4'_fan y5_fan y6_fan /=.
by rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in /= DIST_SYM.
Qed.

Lemma inverse_f_fan_pair_ext_power2 v w: `v,w IN dart_of_fan (V,E)
        ==> let w' = sigma_fan (vec 0) V E v w in
            let u = sigma_fan (vec 0) V E w' v in
        (inverse (f_fan_pair_ext (V,E)) POWER 2) (v,w) = u,w'`.
Proof.
move => vw_in; do !"CONV_TAC let_CONV".
rewrite TWO POWER POWER_1 o_THM !INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
by rewrite !res dart1_eq vw_in /= dart_switch -dart1_eq sigma_in_dart1.
Qed.

Lemma y78_eq v w: `v,w IN dart_of_fan (V,E)
        ==> let w' = sigma_fan (vec 0) V E v w in
            let u = sigma_fan (vec 0) V E w' v in
        y8_fan (V,E) (v,w) = dist (w',u) /\
        y7_fan (V,E) (v,w) = norm u`.
Proof.
move => vw_in; do !"CONV_TAC let_CONV".
rewrite DIST_SYM -"let_RULE inverse_f_fan_pair_ext_power2" //.
rewrite y8_fan y5_fan TWO POWER POWER_1 o_THM /=.
by rewrite y7_fan "let_RULE inverse_f_fan_pair_ext_power2".
Qed.

Lemma y9_eq v w: `v,w IN dart_of_fan (V,E) /\ CARD (face (hypermap_of_fan (V,E)) (v,w)) = 4
        ==> let w' = sigma_fan (vec 0) V E v w in
            let u = sigma_fan (vec 0) V E w' v in
        y9_fan (V,E) (v,w) = dist (w,u)`.
Proof.
move => [vw_in card_f]; do !"CONV_TAC let_CONV".
set w1 := `sigma_fan _ V E v w`.
rewrite y9_fan "let_RULE face4_eq" ?w1_def //.
by rewrite darts_k inE.
Qed.

Lemma ys_eq_alt d: `d IN dart_of_fan (V,E)
        ==> y1_fan d = norm (FST d)
        /\ y2_fan d = norm (SND d)
        /\ y3_fan (V,E) d = norm (sigma_fan (vec 0) V E (FST d) (SND d))
        /\ y4'_fan (V,E) d = dist (SND d, sigma_fan (vec 0) V E (FST d) (SND d))
        /\ y5_fan (V,E) d = dist (FST d, sigma_fan (vec 0) V E (FST d) (SND d))
        /\ y6_fan d = dist d`.
Proof. by case: d => v w /= /ys_eq. Qed.

End Y.


(* Dart *)
Section Dart.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.

Lemma azim_fan_eq_dih_y: `azim_dart (V,E) d
   = dih_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
case: d d_in => v w vw_in.
by rewrite "let_RULE fully_surrounded_azim_eq_dih_y" // !ys_eq.
Qed.

Lemma rhazim_fan_eq_rhazim: `rhazim_fan (V,E) d
   = rhazim (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite Sphere.rhazim -azim_fan_eq_dih_y rhazim_fan.
by rewrite h_dart -yn_fan -ln_fan -rho_fan y1_fan rho_fan_eq_rho // (in_dart_inV d_in).
Qed.

Lemma delta_y_not_neg:
   `~(delta_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)
                < &0)`.
Proof.
case: d d_in => v w vw_in.
have := "let_RULE delta_y_pos" v w `sigma_fan (vec 0) V E v w`.
by rewrite REAL_NOT_LT !ys_eq.
Qed.


End Dart.

(* Dart3 *)
Section Dart3.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 3 (hypermap_of_fan (V,E))`.

Let card_f: `CARD (face (hypermap_of_fan (V,E)) d) = 3`.
Proof. by move: d_in; rewrite darts_k inE => ->. Qed.

Let d_in_dart: `d IN dart_of_fan (V,E)`.
Proof. by move: d_in; rewrite darts_k inE dartH => ->. Qed.


Lemma dart3_yf_eq: `y1_fan (f_fan_pair_ext (V,E) d) = y2_fan d
        /\ y2_fan (f_fan_pair_ext (V,E) d) = y3_fan (V,E) d
        /\ y3_fan (V,E) (f_fan_pair_ext (V,E) d) = y1_fan d
        /\ y4_fan (V,E) (f_fan_pair_ext (V,E) d) = y5_fan (V,E) d
        /\ y5_fan (V,E) (f_fan_pair_ext (V,E) d) = y6_fan d
        /\ y6_fan (f_fan_pair_ext (V,E) d) = y4_fan (V,E) d`.
Proof.
rewrite 12!(y1_fan, y2_fan, y3_fan, y4_fan, y5_fan, y6_fan) /=.
rewrite (PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)) /=.
case: d d_in_dart card_f => v w vw_in card_f.
rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in /=.
move: (vw_in); rewrite -dart1_eq => vw_in1.
rewrite !f_fan_pair_ext dart1_eq vw_in /=.
have eq := f_fan_pair3 fanV vw_in1 card_f.
by rewrite -dart1_eq !eq.
Qed.


Lemma dart3_y_invf_eq: `y1_fan (inverse (f_fan_pair_ext (V,E)) d) = y3_fan (V,E) d
        /\ y2_fan (inverse (f_fan_pair_ext (V,E)) d) = y1_fan d
        /\ y3_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y2_fan d
        /\ y4_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y6_fan d
        /\ y5_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y4_fan (V,E) d
        /\ y6_fan (inverse (f_fan_pair_ext (V,E)) d) = y5_fan (V,E) d`.
Proof.
rewrite 12!(y1_fan, y2_fan, y3_fan, y4_fan, y5_fan, y6_fan) /=.
rewrite (PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)) /=.
case: d d_in_dart card_f => v w vw_in card_f.
move: (vw_in); rewrite -dart1_eq => vw_in1.
have := "let_RULE inverse_f_fan_pair_ext_power2" vw_in.
rewrite TWO POWER POWER_1 o_THM => ->.
rewrite "let_RULE TRIANGULAR_FACE" //.
rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /=.
by rewrite f_fan_pair_ext vw_in1 /= (f_fan_pair3 card_f).
Qed.


Lemma dart3_azim_fan_eq_dih_y: `azim_dart (V,E) d
   = dih_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof. by rewrite azim_fan_eq_dih_y // y4'_eq_y4. Qed.

Lemma dart3_rhazim_fan_eq_rhazim: `rhazim_fan (V,E) d
   = rhazim (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof. by rewrite rhazim_fan_eq_rhazim // y4'_eq_y4. Qed.

Lemma dart3_sol_fan_eq_sol: `sol_fan (V,E) (face (hypermap_of_fan (V,E)) d)
   = sol_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite -y4'_eq_y4 //.
case: d d_in_dart card_f => v w vw_in card_f.
by rewrite sol_fan_eq // "let_RULE fully_surrounded_sol_eq_sol_y" // !ys_eq.
Qed.

End Dart3.

(* Dart3_more *)
Section Dart3_more.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 3 (hypermap_of_fan (V,E))`.

Lemma dart3_azim2_fan_eq_dih2_y: `azim2_fan (V,E) d
   = dih2_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite dih2_y azim2_fan dart3_azim_fan_eq_dih_y ?f_fan_pair_ext_in_darts_k //.
by rewrite !dart3_yf_eq // Nonlinear_lemma.dih_y_sym.
Qed.

Lemma dart3_azim3_fan_eq_dih3_y: `azim3_fan (V,E) d
   = dih3_y (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite dih3_y azim3_fan dart3_azim_fan_eq_dih_y ?f_fan_pair_ext_in_darts_k //.
by rewrite !dart3_y_invf_eq.
Qed.

Lemma dart3_rhazim2_fan_eq_rhazim2: `rhazim2_fan (V,E) d
   = rhazim2 (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite rhazim2 rhazim2_fan dart3_rhazim_fan_eq_rhazim ?f_fan_pair_ext_in_darts_k //.
by rewrite node2_y !dart3_yf_eq.
Qed.

Lemma dart3_rhazim3_fan_eq_rhazim3: `rhazim3_fan (V,E) d
   = rhazim3 (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
rewrite rhazim3 rhazim3_fan dart3_rhazim_fan_eq_rhazim ?f_fan_pair_ext_in_darts_k //.
by rewrite node3_y !dart3_y_invf_eq.
Qed.

End Dart3_more.

Lemma dart4_f_fan_pair_ext_power2 d: `d IN dart_of_fan (V,E) /\
        CARD (face (hypermap_of_fan (V,E)) d) = 4
        ==> (f_fan_pair_ext (V,E) POWER 2) d = (inverse (f_fan_pair_ext (V,E)) POWER 2) d`.
Proof.
move => [d_in card_f].
rewrite -(COMPONENTS_HYPERMAP_OF_FAN fanV) eq_sym.
have {2}->: `2 = 4 - 2` by arith.
apply FINITE_ORBIT_MAP_INVERSE; exists `dart (hypermap_of_fan (V,E))`.
by rewrite !face_map_and_darts -face card_f; arith.
Qed.


(* Dart4 *)
Section Dart4.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 4 (hypermap_of_fan (V,E))`.

Let card_f: `CARD (face (hypermap_of_fan (V,E)) d) = 4`.
Proof. by move: d_in; rewrite darts_k inE => ->. Qed.

Let d_in_dart: `d IN dart_of_fan (V,E)`.
Proof. by move: d_in; rewrite darts_k inE dartH => ->. Qed.


Lemma dart4_yf_eq: `y1_fan (f_fan_pair_ext (V,E) d) = y2_fan d
        /\ y2_fan (f_fan_pair_ext (V,E) d) = y7_fan (V,E) d
        /\ y3_fan (V,E) (f_fan_pair_ext (V,E) d) = y1_fan d
        /\ y5_fan (V,E) (f_fan_pair_ext (V,E) d) = y6_fan d
        /\ y6_fan (f_fan_pair_ext (V,E) d) = y9_fan (V,E) d
        /\ y7_fan (V,E) (f_fan_pair_ext (V,E) d) = y3_fan (V,E) d
        /\ y8_fan (V,E) (f_fan_pair_ext (V,E) d) = y5_fan (V,E) d
        /\ y9_fan (V,E) (f_fan_pair_ext (V,E) d) = y8_fan (V,E) d`.
Proof.
case: d d_in_dart card_f => v w vw_in card_f.
have inv_f_f := PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV).
rewrite !(y1_fan, y3_fan, y5_fan, y6_fan, y9_fan) !y2_def ?fd_in // !inv_f_f !yn_fan /=.
rewrite !y8_fan !y5_fan !y7_fan.
rewrite -(o_THM `f_fan_pair_ext (V,E)`) -POWER_2.
by rewrite dart4_f_fan_pair_ext_power2 // POWER_2 !o_THM inv_f_f.
Qed.

Lemma dart4_y_invf_eq: `y1_fan (inverse (f_fan_pair_ext (V,E)) d) = y3_fan (V,E) d
        /\ y2_fan (inverse (f_fan_pair_ext (V,E)) d) = y1_fan d
        /\ y3_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y7_fan (V,E) d
        /\ y5_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y8_fan (V,E) d
        /\ y6_fan (inverse (f_fan_pair_ext (V,E)) d) = y5_fan (V,E) d
        /\ y7_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y2_fan d
        /\ y8_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y9_fan (V,E) d
        /\ y9_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d) = y6_fan d`.
Proof.
case: d d_in_dart card_f => v w vw_in card_f.
have inv_f_f := PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV).
rewrite !y1_fan !y2_fan !y3_fan !y8_fan !y5_fan !y6_fan !y7_fan !y9_fan inv_f_f /=.
rewrite {1}INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in /=.
rewrite -(o_THM `inverse _`) -POWER_2 /=.
set f := `f_fan_pair_ext _`.
have -> x: `(inverse f POWER 2) (inverse f x) = inverse f ((inverse f POWER 2) x)`.
  by rewrite COM_POWER_FUNCTION -(o_THM `inverse f POWER 2`) -POWER.
rewrite -f_def -dart4_f_fan_pair_ext_power2 // f_def.
rewrite POWER_2 !o_THM inv_f_f /=.
by rewrite -f_def f_fan_pair_ext dart1_eq vw_in /= f_fan_pair.
Qed.

Lemma dart4_cross_eq_y4': `y4'_fan (V,E) (f_fan_pair_ext (V,E) d)
                        = y4'_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
Proof.
have inv_f_f := PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV).
case: d d_in_dart card_f => v w vw_in card_f.
rewrite !y4'_fan inv_f_f DIST_SYM; congr `dist _`; rewrite PAIR_EQ; split.
  by rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in.
rewrite -(o_THM `inverse _`) -POWER_2 -dart4_f_fan_pair_ext_power2 //.
rewrite -{1}(POWER_1 `f_fan_pair_ext (V,E)`) -!f_fan_pair_power //.
by rewrite POWER_1 POWER_2 o_THM !f_fan_pair.
Qed.

Lemma dart4_cross_eq_enclosed: `y4'_fan (V,E) (f_fan_pair_ext (V,E) d)
    = enclosed (y1_fan d) (y5_fan (V,E) d) (y6_fan d) (y4'_fan (V,E) d)
        (y2_fan d) (y3_fan (V,E) d) (y7_fan (V,E) d) (y8_fan (V,E) d) (y9_fan (V,E) d)`.
Proof.
rewrite dart4_cross_eq_y4'.
case: d d_in_dart card_f => v w vw_in card_f.
have := "let_RULE fully_surrounded_enclosed" fanV f_surr vw_in.
rewrite !ys_eq // !"let_RULE y78_eq" // "let_RULE y9_eq" //.
set w' := `sigma_fan _ V E v w`.
set u := `sigma_fan _ V E w' v`.
move => <-.
rewrite y4'_fan -[`FST _`](o_THM `inverse _`) -POWER_2.
rewrite "let_RULE inverse_f_fan_pair_ext_power2" // w'_def u_def.
by rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in.
Qed.


End Dart4.


(* Tau *)
Section Tau.

Lemma dart3_tauVEF_eq_taum d: `d IN darts_k 3 (hypermap_of_fan (V,E))
   ==> tauVEF (V,E,face (hypermap_of_fan (V,E)) d)
    = taum (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
move => d_in3; rewrite -y4'_eq_y4 //.
have: `d IN dart_of_fan (V,E)`.
  by move: d_in3; rewrite darts_k inE dartH => ->.
case: d d_in3 => v w vw_in3 vw_in.
have := "let_RULE fully_surrounded_tau_eq_taum" fanV f_surr subV vw_in; "ANTS_TAC".
  by move: vw_in3; rewrite darts_k inE => ->.
by rewrite !ys_eq.
Qed.

Lemma dart4_tauVEF_eq_tauq d: `d IN darts_k 4 (hypermap_of_fan (V,E))
   ==> tauVEF (V,E,face (hypermap_of_fan (V,E)) d)
    = tauq (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d)
        (y5_fan (V,E) d) (y6_fan d) (y7_fan (V,E) d) (y8_fan (V,E) d) (y9_fan (V,E) d)`.
Proof.
move => d_in4.
move: (d_in4); rewrite darts_k inE dartH.
case: d => v w [vw_in] card_f.
have := "let_RULE fully_surrounded_tau_eq_tauq" fanV f_surr subV vw_in card_f.
by rewrite !ys_eq // !"let_RULE y78_eq" // "let_RULE y9_eq".
Qed.


Hypothesis tau_h: `lp_tau (V,E)`.

Lemma dart3_tau_fan_eq_taum d: `d IN darts_k 3 (hypermap_of_fan (V,E))
   ==> tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)
    = taum (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4_fan (V,E) d) (y5_fan (V,E) d) (y6_fan d)`.
Proof.
move => d_in3; move: (d_in3); rewrite darts_k inE dartH => [] [d_in] card_f.
by rewrite tau_fan_eq_tauVEF -?lemma_in_face_set // dart3_tauVEF_eq_taum.
Qed.

Lemma dart4_tau_fan_eq_tauq d: `d IN darts_k 4 (hypermap_of_fan (V,E))
   ==> tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)
    = tauq (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d)
        (y5_fan (V,E) d) (y6_fan d) (y7_fan (V,E) d) (y8_fan (V,E) d) (y9_fan (V,E) d)`.
Proof.
move => d_in4; move: (d_in4); rewrite darts_k inE dartH => [] [d_in] card_f.
by rewrite tau_fan_eq_tauVEF -?lemma_in_face_set // dart4_tauVEF_eq_tauq.
Qed.

End Tau.

End Nonlinear.

End Fan.


(* Sym *)
Section Sym.

Variables y1 y2 y3 y4 y5 y6: `:real`.

Lemma sol_y_sym_reflect: `sol_y y1 y2 y3 y4 y5 y6 = sol_y y1 y3 y2 y4 y6 y5`.
Proof.
rewrite !sol_y !real_sub.
rewrite Nonlinear_lemma.dih_y_sym REAL_EQ_ADD_LCANCEL.
rewrite !REAL_ADD_ASSOC REAL_EQ_ADD_RCANCEL REAL_ADD_SYM.
rewrite Nonlinear_lemma.dih_y_sym REAL_EQ_ADD_LCANCEL.
by rewrite Nonlinear_lemma.dih_y_sym.
Qed.

Lemma taum_sym_reflect: `taum y1 y2 y3 y4 y5 y6 = taum y1 y3 y2 y4 y6 y5`.
Proof.
rewrite !taum sol_y_sym_reflect !real_sub REAL_EQ_ADD_LCANCEL !lnazim.
rewrite -!REAL_MUL_LNEG REAL_EQ_MUL_LCANCEL; right.
rewrite Nonlinear_lemma.dih_y_sym REAL_EQ_ADD_LCANCEL REAL_ADD_SYM.
rewrite Nonlinear_lemma.dih_y_sym REAL_EQ_ADD_LCANCEL.
by rewrite Nonlinear_lemma.dih_y_sym.
Qed.

End Sym.



(* NonlinearSplit *)
Section NonlinearSplit.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis f_surr: `fully_surrounded (V,E)`.
(* Additional hypotheses *)
Hypothesis packV: `packing V`.
Hypothesis subV: `V SUBSET ball_annulus`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by rewrite fully_surrounded_dart_of_fan_eq. Qed.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let fH: `face_map (hypermap_of_fan (V,E)) = f_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let nH: `node_map (hypermap_of_fan (V,E)) = n_fan_pair_ext (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.


(* Dart *)
Section Dart.

Variables d: `:real^3#real^3`.
Hypothesis d_in: `d IN dart_of_fan (V,E)`.

Let split_eq: `split_fan_face (V,E) d = V, add_diag (V,E) d`.
Proof.
case: d d_in => v w vw_in.
by rewrite split_fan_face add_diag dart1_eq vw_in.
Qed.

Lemma add_diag_sigma_eq v w: `v,w IN dart_of_fan (V,E)
        /\ ~(v = SND d) /\ ~(v = sigma_fan (vec 0) V E (FST d) (SND d))
        ==> sigma_fan (vec 0) V (add_diag (V,E) d) v w = sigma_fan (vec 0) V E v w`.
Proof.
case: d d_in split_eq => a b ab_in split_eq /= [vw_in neq].
have := n_split_fan_face_eq1 fanV f_surr ab_in `v,w`; "ANTS_TAC".
  by rewrite (fan_split_fan_face ab_in) // dart1_eq IN_UNION vw_in /= !neq.
by rewrite split_eq !n_fan_pair PAIR_EQ.
Qed.

Lemma inverse_f_ext_d_split_eq: `inverse (f_fan_pair_ext (V,add_diag (V,E) d)) d
        = inverse (f_fan_pair_ext (V,E)) d`.
Proof.
case: d d_in split_eq add_diag_sigma_eq => v w /= vw_in split_eq sigma_eq.
move: (vw_in); rewrite -dart1_eq => vw_in1.
have [fan2 [dart2_eq] f_surr2] := fan_split_fan_face fanV f_surr vw_in.
rewrite split_eq in fan2 f_surr2 dart2_eq.
rewrite (PERMUTES_INVERSE_EQ (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fan2)).
rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res dart1_eq vw_in /=.
have vw'_in1 := sigma_in_dart1 fanV vw_in1.
rewrite f_fan_pair_ext -(fully_surrounded_dart_of_fan_eq fan2) // dart_switch.
rewrite dart2_eq IN_UNION vw'_in1 /= -sigma_eq.
  by rewrite vw_in !(PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV) // dart1_switch.
rewrite (f_fan_pair_last fan2) // -(fully_surrounded_dart_of_fan_eq fan2) //.
by rewrite dart2_eq dart1_eq IN_UNION.
Qed.


Lemma ys_split_eq: `y3_fan (V,add_diag (V,E) d) d = y3_fan (V,E) d
        /\ y4'_fan (V,add_diag (V,E) d) d = y4'_fan (V,E) d
        /\ y5_fan (V,add_diag (V,E) d) d = y5_fan (V,E) d`.
Proof. by rewrite !(y3_fan, y4'_fan, y5_fan) inverse_f_ext_d_split_eq. Qed.

Lemma ys_split_eq2 v w:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
		==> y1_fan (w',w) = y3_fan (V,E) (v,w)
		/\ y2_fan (w',w) = y2_fan (v,w)
		/\ y3_fan (V, add_diag (V,E) (v,w)) (w',w) = y7_fan (V,E) (v,w)
		/\ y5_fan (V, add_diag (V,E) (v,w)) (w',w) = y8_fan (V,E) (v,w)
		/\ y6_fan (w',w) = y4'_fan (V,E) (v,w)
		/\ y9_fan (V, add_diag (V,E) (v,w)) (w',w) = y9_fan (V,E) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
move => [vw_in card_f].
set w' := `sigma_fan _ V E v w`.
rewrite !(ys_eq vw_in) // w'_def y1_fan y2_fan y6_fan (DIST_SYM w') /=.
rewrite y3_fan y5_fan.
rewrite -w'_def "let_RULE inverse_f_fan_pair_ext_add_diag" //.
rewrite y7_fan /= y8_fan y5_fan POWER_2 o_THM /=.
rewrite !y9_fan -POWER_1 "let_RULE f_fan_pair_ext_power_add_diag" ?POWER_1 //.
by rewrite fanV f_surr vw_in card_f leqnn; move: card_f; arith.
Qed.


End Dart.


(* Split *)
Section Split4.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 4 (hypermap_of_fan (V,E))`.

Let card_f: `CARD (face (hypermap_of_fan (V,E)) d) = 4`.
Proof. by move: d_in; rewrite darts_k inE => ->. Qed.

Let d_in_dart: `d IN dart_of_fan (V,E)`.
Proof. by move: d_in; rewrite darts_k inE dartH => ->. Qed.

Lemma dart4_azim2_eq_sum: `azim2_fan (V,E) d
        = dih_y (y2_fan d) (y3_fan (V,E) d) (y1_fan d)
                (y5_fan (V,E) d) (y6_fan d) (y4'_fan (V,E) d) +
          dih_y (y2_fan d) (y7_fan (V,E) d) (y3_fan (V,E) d)
                (y8_fan (V,E) d) (y4'_fan (V,E) d) (y9_fan (V,E) d)`.
Proof.
case: d d_in_dart card_f => v w vw_in card_f.
rewrite azim2_fan f_fan_pair_ext dart1_eq vw_in /=.
have card_gt3: `3 < CARD (face (hypermap_of_fan (V,E)) (v,w))`.
  by rewrite card_f; arith.
rewrite ("let_RULE azim_split_fan_face_add" fanV f_surr vw_in card_gt3).
have := fan_split_fan_face fanV f_surr vw_in.
have split_eq: `split_fan_face (V,E) (v,w) = V, add_diag (V,E) (v,w)`.
  by rewrite split_fan_face add_diag dart1_eq vw_in.
rewrite split_eq => [] [fan2] [dart2] f_surr2.
set w' := `sigma_fan _ V E v w`.
have ww'_in: `w,w' IN dart_of_fan (V,add_diag (V,E) (v,w))`.
  by rewrite dart2 IN_UNION IN_INSERT IN_SING.
congr `_1 + _2:real`.
  rewrite azim_fan_eq_dih_y //.
  rewrite !(ys_eq vw_in) // w'_def !(ys_eq ww'_in) //.
  suff ->: `sigma_fan (vec 0) V (add_diag (V,E) (v,w))  w w' = v` by rewrite !(DIST_SYM v).
  have := "let_RULE n_split_fan_face" fanV f_surr card_gt3 vw_in.
  rewrite w'_def => [] [_] [_] [_].
  by rewrite split_eq n_fan_pair PAIR_EQ => [] [[_] ->].
set d2 := `f_fan_pair (V,E) (v,w)`.
have d2_in: `d2 IN dart_of_fan (V,add_diag (V,E) (v,w))`.
  rewrite -d2_def dart2 dart1_eq IN_UNION -dartH -(POWER_1 `f_fan_pair (V,E)`).
  by rewrite f_fan_pair_power // POWER_1 -fH lemma_dart_invariant.
have dart2_1 := fully_surrounded_dart_of_fan_eq f_surr2 fan2.
have d2_eq: `d2 = f_fan_pair_ext (V,add_diag (V,E) (v,w)) (w',w)`.
  rewrite -d2_def -("let_RULE f_split_fan_face" fanV f_surr vw_in) // split_eq.
  by rewrite f_fan_pair_ext -dart2_1 dart_switch ww'_in.
have w'w_in: `w', w IN dart_of_fan (V,add_diag (V,E) (v,w))`.
  by rewrite dart2 IN_UNION IN_INSERT.
have w'w_in3: `w',w IN darts_k 3 (hypermap_of_fan (V,add_diag (V,E) (v,w)))`.
  rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fan2) w'w_in andTb.
  have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_gt3.
  rewrite split_eq; set H2 := `hypermap_of_fan _`.
  by rewrite w'_def => [] [_] ->; rewrite card_f; arith.
have d2_in3: `d2 IN darts_k 3 (hypermap_of_fan (V,add_diag (V,E) (v,w)))`.
  by rewrite d2_eq f_fan_pair_ext_in_darts_k.
rewrite azim_fan_eq_dih_y //.
rewrite y4'_eq_y4 // d2_eq !dart3_yf_eq // -y4'_eq_y4 //.
rewrite !(ys_eq w'w_in) // !(ys_eq vw_in) //.
rewrite !("let_RULE y78_eq" vw_in) // "let_RULE y9_eq" // w'_def.
set u := `sigma_fan _ V E w' v`.
suff ->: `sigma_fan (vec 0) V (add_diag (V,E) (v,w)) w' w = u` by rewrite !(DIST_SYM w).
have := "let_RULE n_split_fan_face" fanV f_surr card_gt3 vw_in.
rewrite w'_def => [] [eq] _.
by move: eq; rewrite split_eq !n_fan_pair u_def PAIR_EQ => [] [_].
Qed.

Lemma tauq_cross_split: `tauq (y1_fan d) (y2_fan d) (y3_fan (V,E) d) (y4'_fan (V,E) d)
        (y5_fan (V,E) d) (y6_fan d) (y7_fan (V,E) d) (y8_fan (V,E) d) (y9_fan (V,E) d)
      = taum (y1_fan d) (y3_fan (V,E) d) (y7_fan (V,E) d)
                 (y8_fan (V,E) d) (y4'_fan (V,E) (f_fan_pair_ext (V,E) d)) (y5_fan (V,E) d)
        + taum (y1_fan d) (y2_fan d) (y7_fan (V,E) d)
                (y9_fan (V,E) d) (y4'_fan (V,E) (f_fan_pair_ext (V,E) d)) (y6_fan d)`.
Proof.
rewrite -dart4_tauVEF_eq_tauq //.
rewrite -(lemma_face_identity `f_fan_pair_ext (V,E) d`).
  rewrite -fH face -{2}POWER_1 -(lemma_orbit_power `dart_of_fan (V,E)`) ?orbit_reflect //.
  by rewrite -dartH !face_map_and_darts.
rewrite dart4_tauVEF_eq_tauq ?f_fan_pair_ext_in_darts_k //.
rewrite !dart4_yf_eq // tauq REAL_ADD_SYM taum_sym; congr `_1 + _2:real`.
  by rewrite taum_sym_reflect.
by rewrite taum_sym taum_sym_reflect.
Qed.

End Split4.


(* MoreSplit4 *)
Section MoreSplit4.

Variable d: `:real^3#real^3`.
Hypothesis d_in: `d IN darts_k 4 (hypermap_of_fan (V,E))`.

Lemma dart4_azim_cross_split: `azim_dart (V,E) d
      = dih_y (y1_fan d) (y3_fan (V,E) d) (y7_fan (V,E) d)
                 (y8_fan (V,E) d) (y4'_fan (V,E) (f_fan_pair_ext (V,E) d)) (y5_fan (V,E) d)
        + dih_y (y1_fan d) (y2_fan d) (y7_fan (V,E) d)
                (y9_fan (V,E) d) (y4'_fan (V,E) (f_fan_pair_ext (V,E) d)) (y6_fan d)`.
Proof.
have ->: `azim_dart (V,E) d = azim2_fan (V,E) (inverse (f_fan_pair_ext (V,E)) d)`.
  by rewrite azim2_fan (PERMUTES_INVERSES (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)).
rewrite dart4_azim2_eq_sum ?f_fan_pair_ext_in_darts_k //.
by rewrite !dart4_y_invf_eq // dart4_cross_eq_y4' // Nonlinear_lemma.dih_y_sym.
Qed.

End MoreSplit4.

End NonlinearSplit.


(* QuadIneqs *)
Section QuadIneqs.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis h_fan: `lp_fan (V,E)`.

Lemma y4'_lo_2h0 k d: `3 < k /\ d IN darts_k k (hypermap_of_fan (V,E))
        ==> #2.52 <= y4'_fan (V,E) d`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag_dist] _.
case: d => v w.
rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fanV) => [] [k_gt] [vw_in] card_f.
move: (vw_in); rewrite fully_surrounded_dart_of_fan_eq // => vw_in1.
rewrite y4'_fan INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /= diag_dist.
rewrite (PAIR_IN_DART_OF_FAN vw_in) // sigma_fan_inV // -sigma_fan_not_fixed //.
rewrite inE_eq_in_dart1 -fully_surrounded_dart_of_fan_eq //=.
by rewrite fully_surrounded_diag_not_in_dart.
Qed.

Lemma dart4_y4'_lo d: `d IN darts_k 4 (hypermap_of_fan (V,E))
        ==> #2.52 <= y4'_fan (V,E) d`.
Proof. by apply/y4'_lo_2h0; arith. Qed.

Lemma y4'_hi d: `d IN dart_of_fan (V,E)
        ==> y4'_fan (V,E) d <= &4 * h0`.
Proof.
rewrite lp_fan SUBSET in h_fan.
case: d => v w vw_in.
move: (vw_in); rewrite fully_surrounded_dart_of_fan_eq // => vw_in1.
rewrite y4'_fan INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res vw_in1 /=.
set w' := `sigma_fan _ V E v w`.
apply DIST_TRIANGLE_LE; exists `vec 0`; rewrite !DIST_0.
have ->: `&4 * h0 = &2 * h0 + &2 * h0` by arith.
rewrite REAL_LE_ADD2 (iffLR (Fnjlbxs.in_ball_annulus w)) ?(iffLR (Fnjlbxs.in_ball_annulus w')) //.
  by rewrite h_fan (PAIR_IN_DART_OF_FAN vw_in).
by rewrite -w'_def h_fan sigma_fan_inV.
Qed.

Section Y4_hi_bound.

Hypothesis ineq: "(hd (Ineq.getexact \"3287695934\")).ineq".

Lemma dart4_y4'_hi d: `d IN darts_k 4 (hypermap_of_fan (V,E))
        ==> y5_fan (V,E) d <= #2.52
        /\ y6_fan d <= #2.52
        /\ y8_fan (V,E) d <= #2.52
        /\ y9_fan (V,E) d <= #2.52
        ==> y4'_fan (V,E) d <= #4.37`.
Proof.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] h_fan2.
have [dartH [_] [_] fH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
case: d => v w vw_in4.
move: (vw_in4); rewrite darts_k inE dartH => [] [vw_in] card_f bounds.
case: (REAL_LE_TOTAL `y4'_fan (V,E) (v,w)` `#4.37`) => // y4_bound.
move: (ineq `y4'_fan (V,E) (v,w)` `y9_fan (V,E) (v,w)` `y6_fan (v,w)`
          `y4'_fan (V,E) (f_fan_pair_ext (V,E) (v,w))` `y5_fan (V,E) (v,w)` `y8_fan (V,E) (v,w)`).
rewrite INEQ_ALT !ALL /=; "ANTS_TAC".
  have ->: `&2 * h0 = #2.52` by rewrite h0; arith.
  have ->: `#2.0 = &2` by arith.
  rewrite y4_bound y4'_hi // !bounds /= (y6_lo vw_in) //.
  rewrite (y9_lo vw_in) // (y5_lo vw_in) // (y8_lo vw_in) //.
  rewrite dart4_y4'_lo ?f_fan_pair_ext_in_darts_k //.
  by rewrite y4'_hi // -fH -dartH lemma_dart_invariant dartH.
rewrite !(ys_eq fanV) // ("let_RULE y78_eq" fanV) // ("let_RULE y9_eq" fanV) //.
set w' := `sigma_fan _ V E v w`.
set u := `sigma_fan _ V E w' v`.
rewrite dart4_cross_eq_y4' //.
rewrite y4'_fan -[`FST _`](o_THM `inverse _`) -POWER_2.
rewrite "let_RULE inverse_f_fan_pair_ext_power2" // w'_def u_def.
rewrite INVERSE_F_FAN_PAIR_EXT_EXPLICIT // res.
rewrite -fully_surrounded_dart_of_fan_eq // vw_in /=.
rewrite delta_y -!REAL_POW_2 -DELTA_EQ_DELTA_X.
rewrite !(DIST_SYM v).
have := Collect_geom.DELTA_POS_4POINTS w w' u v.
by arith.
Qed.


Section Std.

Hypothesis std: `E = ESTD V`.

Lemma dart4_y4'_hi_std d: `d IN darts_k 4 (hypermap_of_fan (V,E))
        ==> y4'_fan (V,E) d <= #4.37`.
move => d_in4; move: (d_in4); rewrite darts_k inE => [] [d_in _].
apply: (dart4_y4'_hi d_in4).
rewrite lp_fan in h_fan; rewrite COMPONENTS_HYPERMAP_OF_FAN // in d_in.
by rewrite y5_hi_std2 // (y6_hi_std2 std) // y8_hi_std // y9_hi_std.
Qed.

End Std.

End Y4_hi_bound.

End QuadIneqs.
