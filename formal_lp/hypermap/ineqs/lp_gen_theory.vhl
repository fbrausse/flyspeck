"needs \"../formal_lp/hypermap/ssreflect/list_hypermap-compiled.hl\"".

Module Lp_gen_theory.

"open Ssrbool".
"open Ssrnat".
"open Seq".
"open Seq2".
"open Fan_defs".
"open Hypermap".
"open Hypermap_and_fan".
"open Hypermap_iso".
"open List_hypermap".


(* IsoLemmas *)
Section IsoLemmas.

Variable G: `:(B)hypermap`.
Variable H: `:(A)hypermap`.
Variable g: `:B->A`.

Hypothesis g_iso: `hyp_iso g (G,H)`.

Lemma hyp_iso_comm_special d: `d IN dart G
	==> face_map H (g d) = g (face_map G d)
	   /\ node_map H (g d) = g (node_map G d)
	   /\ edge_map H (g d) = g (edge_map G d)`.
Proof. by move/(hyp_iso_comm g_iso) => /=. Qed.

Lemma hyp_iso_inv_comm d: `d IN dart G
	==> inverse (face_map H) (g d) = g (inverse (face_map G) d)
            /\ inverse (node_map H) (g d) = g (inverse (node_map G) d)`.
Proof. by move/(hyp_iso_inverse_comm g_iso) => /=. Qed.

Lemma card_face_iso f: `f IN face_set G ==> CARD (IMAGE g f) = CARD f`.
Proof.
move/lemma_face_representation => [d] [d_in] ->.
by rewrite -(iso_components g_iso) // (hyp_iso_card_components g_iso).
Qed.

Lemma sum_node_iso r n: `n IN node_set G ==> sum (IMAGE g n) r = sum n (r o g)`.
Proof.
move/lemma_node_representation => [d] [d_in] ->.
move: (lemma_node_subset d_in); rewrite SUBSET => x_in.
by rewrite SUM_IMAGE // => x y [/x_in] xG [/x_in] yG /(hyp_iso_inj g_iso) ->.
Qed.

Lemma sum_face_iso r f: `f IN face_set G ==> sum (IMAGE g f) r = sum f (r o g)`.
Proof.
move/lemma_face_representation => [d] [d_in] ->.
move: (lemma_face_subset d_in); rewrite SUBSET => x_in.
by rewrite SUM_IMAGE // => x y [/x_in] xG [/x_in] yG /(hyp_iso_inj g_iso) ->.
Qed.

Lemma iso_dart_trans P: `(!d. d IN dart H ==> P d) ==> (!d. d IN dart G ==> P (g d))`.
Proof. by move => h d d_in; rewrite h (hyp_iso_dart g_iso). Qed.

Lemma iso_face_trans P: `(!f. f IN face_set H ==> P f) 
	==> (!f. f IN face_set G ==> P (IMAGE g f))`.
Proof.
move => h f /lemma_face_representation [d] [d_in] ->.
by rewrite -(iso_components g_iso) // h -lemma_in_face_set (hyp_iso_dart g_iso).
Qed.

Lemma iso_node_trans P: `(!n. n IN node_set H ==> P n) 
	==> (!n. n IN node_set G ==> P (IMAGE g n))`.
Proof.
move => h f /lemma_node_representation [d] [d_in] ->.
by rewrite -(iso_components g_iso) // h -lemma_in_node_set (hyp_iso_dart g_iso).
Qed.

End IsoLemmas.


(* BijLemmas *)
Section BijLemmas.

Variable h: `:D->C`.

Lemma bij_trans R V: `BIJ h R V
	==> !P. (!x. x IN V ==> P x) ==> (!x. x IN R ==> P (h x))`.
Proof. by rewrite BIJ INJ => bij_h p h x x_in; rewrite h bij_h. Qed.

Lemma fst_iso_trans g: `(!d. g d = h (FST d), h (SND d))
	==> (!d. FST (g d) = h (FST d))`.
Proof. by move => g_eq d; rewrite g_eq FST. Qed.

End BijLemmas.


Lemma list_sum_set_of_list_gen s: `uniq s ==> list_sum s = sum (set_of_list s)`.
Proof. by move => uniq_s; rewrite FUN_EQ_THM => f; rewrite list_sum_set_of_list. Qed.


(* ListLemmas *)
Section ListLemmas.

Variable L: `:((A)list)list`.

Lemma e_list_ext_eq_e_list d: `MEM d (list_of_darts L) ==> e_list_ext L d = e_list d`.
Proof. by rewrite e_list_ext res darts_of_list IN_SET_OF_LIST => ->. Qed.

Lemma fst_choice_of_list_node g h n: `MEM n (list_of_nodes L)
	/\ (!d. g d = h (FST d), h (SND d):C)
	==> FST (CHOICE (IMAGE g (set_of_list n))) = FST (g (HD n))`.
Proof.
move => [mem_n] g_eq.
set x := `CHOICE _`.
set y := `HD n`.
have: `x IN IMAGE g (set_of_list n)`.
  by rewrite -x_def CHOICE_DEF IMAGE_EQ_EMPTY SET_OF_LIST_EQ_EMPTY (node_of_list_not_nil mem_n).
rewrite IN_IMAGE IN_SET_OF_LIST => [] [d] [->] mem_d.
have mem_y: `MEM y n`.
  rewrite -y_def.
  by case: n (node_of_list_not_nil mem_n) => [|h t] //; rewrite HD MEM.
move: mem_n; rewrite list_of_nodes -map_MAP mapP => [] [t] [_] /= n_eq.
by move: mem_y mem_d; rewrite n_eq !mem_filter /= !g_eq => [] [->] _ ->.
Qed.


Hypothesis goodL: `good_list L`.

Lemma card_set_of_list_node n: `MEM n (list_of_nodes L) ==> CARD (set_of_list n) = LENGTH n`.
Proof. by move => mem_n; rewrite card_set_of_list_uniq ?(uniq_node goodL) // Seq.size. Qed.

Lemma card_set_of_list_face f: `MEM f (list_of_faces L) ==> CARD (set_of_list f) = LENGTH f`.
Proof. by move => mem_n; rewrite card_set_of_list_uniq ?(uniq_face goodL) // Seq.size. Qed.

Lemma dart_list_all P: `(!d. d IN dart (hypermap_of_list L) ==> P d)
	<=> (!d. MEM d (list_of_darts L) ==> P d)`.
Proof. by rewrite (components_hypermap_of_list goodL) darts_of_list IN_SET_OF_LIST. Qed.

Lemma elements_list_all P: `(!x. x IN elements_of_list L ==> P x)
	<=> (!x. MEM x (list_of_elements L) ==> P x)`.
Proof. by rewrite elements_of_list IN_SET_OF_LIST. Qed.

Lemma sum_node_list_all P: `good_list_nodes L
	==> ((!n. n IN node_set (hypermap_of_list L) ==> P n (sum n))
		<=> (!n. MEM n (list_of_nodes L) ==> P (set_of_list n) (list_sum n)))`.
Proof.
rewrite good_list_nodes => ->; rewrite IN_SET_OF_LIST nodes_of_list -map_MAP mapP.
split => [h n mem_n | h t [n] [mem_n] ->].
  by rewrite list_sum_set_of_list_gen ?(uniq_node mem_n) // h; exists n.
by rewrite -list_sum_set_of_list_gen ?(uniq_node mem_n) // h.
Qed.

Lemma sum_face_list_all P: `(!f. f IN face_set (hypermap_of_list L) ==> P f (sum f))
		<=> (!f. MEM f (list_of_faces L) ==> P (set_of_list f) (list_sum f))`.
Proof.
rewrite face_set_eq_list // IN_SET_OF_LIST faces_of_list -map_MAP mapP.
split => [h f mem_f | h t [f] [mem_f] ->].
  by rewrite list_sum_set_of_list_gen ?(uniq_face mem_f) // h; exists f.
by rewrite -list_sum_set_of_list_gen ?(uniq_face mem_f) // h.
Qed.


End ListLemmas.
