"needs \"../formal_lp/hypermap/ineqs/lp_ineqs_proofs-compiled.hl\"".
"needs \"local/RNSYJXM-compiled.hl\"".

Module Lp_main_estimate.

"open Localization".
"open Tame_defs".
"open Ssrbool".
"open Ssrnat".
"open Lp_ineqs_def".
"open Lp_ineqs_proofs".
"open Hypermap_and_fan".
"open Fan_defs".
"open Hypermap".
"open Add_triangle".
"open Tame_general".
"open Hypermap_iso".
"open Rnsyjxm".
"open List_hypermap".

(* Some definitions from local/appendix_main_estimate.hl *)

"let rho_fun = new_definition
	`rho_fun y =  &1 + (inv (&2 * h0 - &2)) * (inv pi) * sol0 * (y - &2)`".

"let tau_fun = new_definition
	`tau_fun V E f =  sum (f) (\e. rho_fun(norm(FST e)) * (azim_in_fan e E)) 
			- (pi + sol0) * &(CARD f -2)`".

"let tau3 = new_definition `tau3 (v1:real^3) v2 v3 = 
  rho (norm v1) * dihV (vec 0) v1 v2 v3 + rho(norm v2) * dihV (vec 0) v2 v3 v1 +
    rho(norm v3) * dihV (vec 0) v3 v1 v2 - (pi + sol0)`".

"let JEJTVGB_std_concl = 
  `!V E FF. 
    convex_local_fan (V,E,FF) /\
    packing V /\
    V SUBSET ball_annulus /\
    4 <= CARD V /\ CARD V <= 6 /\
    (!v w. ~(v = w) /\ v IN V /\ w IN V /\ ~({v,w} IN E) ==> &2 * h0 <= dist(v,w)) /\
    (!v w. {v,w} IN E ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0) ==>
    d_tame (CARD V) <= tau_fun V E FF`".

"let JEJTVGB_std3_concl = 
  `!v1 v2 v3. 
    &2 <= norm v1 /\
    &2 <= norm v2 /\
    &2 <= norm v3 /\
    norm v1 <= &2 * h0 /\
    norm v2 <= &2 * h0 /\
    norm v3 <= &2 * h0 /\
    &2 <= dist(v1,v2) /\
    &2 <= dist(v1,v3) /\
    &2 <= dist(v2,v3) /\
    dist(v1,v2) <= &2 * h0 /\
    dist(v1,v3) <= &2 * h0 /\
    dist(v2,v3) <= &2 * h0 ==>
    &0 <= tau3 v1 v2 v3`".

"let JEJTVGB_pent_diag_concl = 
  `!V E FF. 
    convex_local_fan (V,E,FF) /\
    packing V /\
    V SUBSET ball_annulus /\
    CARD V = 5 /\
    (!v w. ~(v = w) /\ v IN V /\ w IN V /\ ~({v,w} IN E) ==> sqrt8 <= dist(v,w)) /\
    (!v w. {v,w} IN E ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0) ==>
    #0.616 <= tau_fun V E FF`".

"let JEJTVGB_pent_pro_concl = 
  `!V E FF. 
    convex_local_fan (V,E,FF) /\
    packing V /\
    V SUBSET ball_annulus /\
    CARD V = 5 /\ 
    (!v w. ~(v = w) /\ v IN V /\ w IN V /\ ~({v,w} IN E) ==> &2 * h0 <= dist(v,w)) /\
    (?v0 w0.
       (!v w. {v,w} IN E /\ ~({v,w} = {v0,w0}) ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0) /\
       {v0,w0} IN E /\
       &2 *h0 <= dist(v0,w0) /\ dist(v0,w0) <= sqrt8)
     ==>
    #0.616 <= tau_fun V E FF`".

"let JEJTVGB_quad_pro_concl = 
  `!V E FF. 
    convex_local_fan (V,E,FF) /\
    packing V /\
    V SUBSET ball_annulus /\
    CARD V = 4 /\ 
    (!v w. ~(v = w) /\ v IN V /\ w IN V /\ ~({v,w} IN E) ==> sqrt8 <= dist(v,w)) /\
    (?v0 w0.
       (!v w. {v,w} IN E /\ ~({v,w} = {v0,w0}) ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0) /\
       {v0,w0} IN E /\
       &2 *h0 <= dist(v0,w0) /\ dist(v0,w0) <= sqrt8)
     ==>
    #0.477 <= tau_fun V E FF`".

"let JEJTVGB_quad_diag_concl = 
  `!V E FF. 
    convex_local_fan (V,E,FF) /\
    packing V /\
    V SUBSET ball_annulus /\
    CARD V = 4 /\
    (!v w. ~(v = w) /\ v IN V /\ w IN V /\ ~({v,w} IN E) ==> &3 <= dist(v,w)) /\
    (!v w. {v,w} IN E ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0) ==>
    #0.567 <= tau_fun V E FF`".

"let JEJTVGB_concl = 
  let co = [JEJTVGB_std_concl;JEJTVGB_std3_concl;JEJTVGB_pent_diag_concl;JEJTVGB_pent_pro_concl;
				      JEJTVGB_quad_pro_concl;JEJTVGB_quad_diag_concl] in
    list_mk_conj co".


"let lp_main_estimate = new_definition (mk_eq (`lp_main_estimate:bool`,JEJTVGB_concl))".

(* Misc *)
Section Misc.

Implicit Type f: `:real^3#real^3->bool`.

Lemma rho_rho_fun y: `rho_fun y = rho y`.
Proof.
rewrite Sphere.rho rho_fun Sphere.const1 Sphere.ly Sphere.interp.
rewrite -Nonlinear_lemma.sol0_EQ_sol_y Sphere.h0.
by move: PI_POS; "CONV_TAC REAL_FIELD".
Qed.

Lemma packing_v_prime V f: `packing V ==> packing (v_prime V f)`.
Proof. by apply/Rdwkarc.PACKING_SUBSET; rewrite V_PRIME_SUBSET_V. Qed.

Lemma v_prime_subset V X f: `V SUBSET X ==> v_prime V f SUBSET X`.
Proof. by apply/(SUBSET_TRANS `v_prime V f`); rewrite V_PRIME_SUBSET_V. Qed.

Lemma in_e_prime E f v w: `{v,w} IN e_prime E f <=> {v,w} IN E /\ (v,w IN f \/ w,v IN f)`.
Proof.
rewrite e_prime IN_ELIM_THM /=.
split => [[a] [b] [ab_in] | [vw_inE]]; last first.
  by case => in_f; [exists v w | exists w v; rewrite "GEN_ALL Collect_geom.PER_SET2"].
rewrite "GEN_ALL Geomdetail.PAIR_EQ_EXPAND".
by case => [] [-> ->] //; rewrite "GEN_ALL Collect_geom.PER_SET2".
Qed.

Lemma set_vv_eq_v v: `{v,v} = {v}`.
Proof. by rewrite EXTENSION IN_INSERT IN_SING. Qed.

End Misc.


(* Fan *)
Section Fan.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let in_dart_inV d: `d IN dart_of_fan (V,E) ==> FST d IN V /\ SND d IN V`.
Proof. by rewrite {1}pair_expand => /(PAIR_IN_DART_OF_FAN fanV). Qed.

Lemma add_diag_eq_E d: `CARD (face (hypermap_of_fan (V,E)) d) = 3
	==> add_diag (V,E) d = E`.
Proof.
case: d => v w card_eq; rewrite add_diag.
case vw_in1: `v,w IN _` => /=.
have vw_in: `v,w IN dart_of_fan (V,E)` by rewrite dart_of_fan_eq IN_UNION.
have := split_fan_face_eq vw_in card_eq fanV.
by rewrite split_fan_face PAIR_EQ => [] [_].
Qed.

Lemma f_fan_pair_ext_power_inverse k d: `d IN dart_of_fan (V,E)
	/\ k < CARD (face (hypermap_of_fan (V,E)) d)
	==> (f_fan_pair_ext (V,E) POWER k) d 
	  = (inverse (f_fan_pair_ext (V,E)) POWER (CARD (face (hypermap_of_fan (V,E)) d) - k)) d`.
Proof.
move => [d_in k_lt].
set n := `CARD _`.
rewrite -(COMPONENTS_HYPERMAP_OF_FAN fanV).
rewrite (FINITE_ORBIT_MAP_INVERSE `dart_of_fan (V,E)` n).
  by rewrite -dartH !face_map_and_darts -face n_def; move: k_lt; arith.
suff ->: `n - (n - k) = k:num` by [].
by move: k_lt; arith.
Qed.

Lemma f_fan_pair_ext_power_in_dart k d: `d IN dart_of_fan (V,E)
	==> (f_fan_pair_ext (V,E) POWER k) d IN dart_of_fan (V,E)`.
Proof.
rewrite -!(COMPONENTS_HYPERMAP_OF_FAN fanV) => d_in.
by rewrite lemma_dart_invariant_power_face.
Qed.

Lemma f_fan_pair_ext_power_inj k1 k2 d: `d IN dart_of_fan (V,E)
	/\ k1 < CARD (face (hypermap_of_fan (V,E)) d) /\ k2 < CARD (face (hypermap_of_fan (V,E)) d)
	==> ((f_fan_pair_ext (V,E) POWER k1) d = (f_fan_pair_ext (V,E) POWER k2) d
		<=> k1 = k2)`.
Proof.
set n := `CARD _`.
move => [d_in] [k1_lt] k2_lt.
split; last by move => ->.
move/(ORBIT_MAP_INJ (F_FAN_PAIR_EXT_PERMUTES_DART_OF_FAN fanV)); apply; exists n.
by rewrite (FINITE_DART_OF_FAN fanV) -(COMPONENTS_HYPERMAP_OF_FAN fanV) -face.
Qed.

Lemma face_last_dart v w: `v,w IN dart1_of_fan (V,E)
	==> (f_fan_pair_ext (V,E) POWER (CARD (face (hypermap_of_fan (V,E)) (v,w)) - 1)) (v,w)
		= sigma_fan (vec 0) V E v w, v`.
Proof.
move => vw_in1.
have vw_in: `v,w IN dart_of_fan (V,E)` by rewrite dart_of_fan_eq IN_UNION.
have ineq := FACE_NOT_EMPTY `hypermap_of_fan (V,E)` `v,w`.
rewrite (f_fan_pair_ext_power_inverse vw_in); first by move: ineq; arith.
rewrite subKn // POWER_1 INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
by rewrite res vw_in1.
Qed.

Lemma fan_aff_gt_1_2_not_empty v w: `v,w IN dart_of_fan (V,E)
	==> ~(aff_gt {vec 0} {v,w} = {})`.
Proof.
move => vw_in.
have n0: `~(v = vec 0) /\ ~(w = vec 0)`.
  have inV := PAIR_IN_DART_OF_FAN vw_in fanV.
  move: fanV; rewrite FAN fan2 => [] [_] [_] [_] [n0V] _.
  by split; apply: contra n0V => <-.
move: vw_in; rewrite dart_of_fan_eq IN_UNION; case => [vw_in1 | ].
  move: (Planarity.POINT_IN_CLOSURE_AFF_GT_1_2 `vec 0` v w).
  rewrite (PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ vw_in1) // -!n0 /=.
  by apply: contraL => ->; rewrite CLOSURE_EMPTY NOT_IN_EMPTY.
rewrite IN_ELIM_THM /= PAIR_EQ => [] [x] [_] [<- ->].
rewrite set_vv_eq_v AFF_GT_1_1 ?"GEN_ALL Local_lemmas.DISJOINT_DOUBLE_SING" -?n0 //.
rewrite -MEMBER_NOT_EMPTY inE.
exists `#0.5 % v` `#0.5` `#0.5`.
rewrite andbA; split; first by arith.
by "VECTOR_ARITH_TAC".
Qed.

Lemma tau_fun_local f: `f IN face_set (hypermap_of_fan (V,E))
	==> tau_fun (v_prime V f) (e_prime E f) f = tau_fun V E f`.
Proof.
move => f_in; move/lemma_face_representation: (f_in) => [[v w]] [vw_in] f_eq.
rewrite !tau_fun !real_sub REAL_EQ_ADD_RCANCEL.
apply SUM_EQ => d d_in /=.
rewrite -("GEN_ALL Lvducxu.AZIM_IN_FAN_EQ_IZIM_E_PRIME" fanV `v,w`) //.
by rewrite hypermap_HYP_elim.
Qed.


(* BallAnnulus *)
Section BallAnnulus.

Hypothesis subV: `V SUBSET ball_annulus`.

Let norm_inV v: `v IN V ==> &2 <= norm v /\ norm v <= &2 * h0`.
Proof. by rewrite SUBSET in subV; move/subV; rewrite Fnjlbxs.in_ball_annulus. Qed.

Lemma tau_fun_eq_tauVEF f: `f IN face_set (hypermap_of_fan (V,E)) /\ 2 <= CARD f
	==> tau_fun V E f = tauVEF (V,E,f)`.
Proof.
rewrite tau_fun tauVEF => [] [f_in card_f].
rewrite -REAL_OF_NUM_SUB // real_sub -REAL_MUL_RNEG REAL_NEG_SUB REAL_EQ_ADD_RCANCEL.
apply SUM_EQ => d d_in_f /=.
have d_in: `d IN dart_of_fan (V,E)` by rewrite -dartH (in_face_imp_in_dart_alt d_in_f).
rewrite rho_rho_fun (azim_in_fan_eq_azim_dart fanV) //.
rewrite Sphere.rho ly_EQ_lmfun ?norm_inV ?(in_dart_inV d_in) //.
by rewrite sol0_over_pi_EQ_const1; arith.
Qed.

End BallAnnulus.

End Fan.


(* FullySurrounded *)
Section FullySurrounded.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis fanV: `FAN (vec 0,V,E)`.
Hypothesis f_surr: `fully_surrounded (V,E)`.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by rewrite fully_surrounded_dart_of_fan_eq. Qed.


Lemma pack_dist x: `packing V /\ x IN dart_of_fan (V,E) ==> &2 <= dist x`.
Proof.
case: x => v w [packV]; rewrite -dart1_eq => vw_in.
apply: (iffLR (Fnjlbxs.packing V) packV v w).
by rewrite !(PAIR_IN_DART1_OF_FAN fanV vw_in) (PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV vw_in).
Qed.

Lemma f_surr_in_e_prime f v w: `f IN face_set (hypermap_of_fan (V,E))
	==> ({v,w} IN e_prime E f <=> (v,w IN f \/ w,v IN f))`.
Proof.
rewrite in_e_prime => f_in; split => [-> | ] //.
rewrite (inE_eq_in_dart1 V) dart1_eq.
move => h; rewrite h andbT.
move/lemma_face_representation: f_in => [d] [d_in] f_eq.
by case: h; [|rewrite dart_switch]; rewrite -dartH f_eq => /in_face_imp_in_dart; apply.
Qed.

Lemma diag_not_in_dart a b f: `f IN face_set (hypermap_of_fan (V,E))
	/\ a IN v_prime V f /\ b IN v_prime V f /\
	~(a,b IN f) /\ ~(b,a IN f)
	==> ~(a,b IN dart_of_fan (V,E))`.
Proof.
move => [/lemma_face_representation] [[v w]].
rewrite dartH => [] [vw_in] f_eq.
rewrite v_prime !inE => [] [a_in] [b_in] not_in_f.
have := fan_hypermaps_iso_explicit2 fanV.
set h := `ext_dart _`.
rewrite -implybF => h_iso ab_in.
have: `~(aff_gt {vec 0} {a,b} INTER xfan (vec 0,V,E) = {})`.
  rewrite Vol1.subset_inter ?(fan_aff_gt_1_2_not_empty fanV) //.
  apply (SUBSET_TRANS (AFF_GT_SUBSET_AFF_GE `{vec 0}` `{a,b}`)).
  by rewrite Planarity.AFF_GE_SUBSET_XFAN (inE_eq_in_dart1 V) dart1_eq.
rewrite implybF negbK.
suff: `aff_gt {vec 0} {a,b} SUBSET dart_leads_into (vec 0) V E v w`.
  move/SUBSET_TRANS => /(_ `yfan (vec 0,V,E)`).
  rewrite Planarity.topological_component_subset_yfan /=.
    rewrite Topology.dart_leads_into_fan_in_topological_component_yfan.
    by rewrite (inE_eq_in_dart1 V) dart1_eq.
  rewrite yfan SUBSET IN_DIFF IN_UNIV andTb EXTENSION NOT_IN_EMPTY /= => h x.
  rewrite IN_INTER negb_and.
  by case x_in: `x IN _` => /=; exact: h.
move: b_in a_in => [bV] [b'] bb'_in_f [aV] [a'] aa'_in_f.
have [aa'_in bb'_in]: `a,a' IN dart_of_fan (V,E) /\ b,b' IN dart_of_fan (V,E)`.
  move: vw_in; rewrite -dartH => vw_in.
  by rewrite !(in_face_imp_in_dart vw_in) // -f_eq.
move: (fully_surrounded_imp_conforming f_surr fanV).
rewrite Conforming.conforming_fan Conforming.conforming_diagonal_fan.
move => [_] [_] [_] [_] [_] /(_ `IMAGE h f` `h (a,a')` `h (b,b')`); "ANTS_TAC".
  rewrite {1}f_eq -(iso_components h_iso) // -lemma_in_face_set.
  rewrite (hyp_iso_dart h_iso) // !IN_IMAGE andTb.
  split; first by exists `a,a'`.
  split; first by exists `b,b'`.
  move: (ab_in); rewrite -dart1_eq => /(PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV).
  by apply: contra => /(hyp_iso_inj h_iso); rewrite PAIR_EQ => ->.
move => [_].
rewrite -{2 4}h_def !fan_map_ext // h_def.
case.
  move/(hyp_iso_inj h_iso); "ANTS_TAC".
    by rewrite dartH aa'_in -dart1_eq E_N_F_IN_DART1_OF_FAN.
  rewrite f_fan_pair PAIR_EQ => [] [eq] _.
  by move: bb'_in_f not_in_f; rewrite eq => ->.
case.
  move/(hyp_iso_inj h_iso); "ANTS_TAC".
    by rewrite dartH bb'_in -dart1_eq E_N_F_IN_DART1_OF_FAN.
  rewrite f_fan_pair PAIR_EQ => [] [eq] _.
  by move: aa'_in_f not_in_f; rewrite eq => ->.
by rewrite -h_def !ext_dart !Fan.pr2 /= f_eq -Tame_lemmas.dart_leads_into_eq1.
Qed.


Lemma split_fan_face_eq_add_diag d: `d IN dart_of_fan (V,E) 
	==> split_fan_face (V,E) d = V, add_diag (V,E) d`.
Proof. by case: d => v w vw_in; rewrite split_fan_face add_diag dart1_eq vw_in. Qed.

Lemma faces_add_diag v w: `v,w IN dart_of_fan (V,E)
	 ==> let H2 = hypermap_of_fan (V, add_diag (V,E) (v,w)) in
	     let H = hypermap_of_fan (V,E) in
	     let w' = sigma_fan (vec 0) V E v w in
		face_set H2 = {face H2 (v,w), face H2 (w',w)} 
			UNION (face_set H DELETE (face H (v,w)))`.
Proof.
move => vw_in; do !"CONV_TAC let_CONV".
rewrite EXTENSION IN_UNION IN_DELETE IN_INSERT IN_SING => f.
set w' := `sigma_fan _ V E v w`.
case: (fully_surrounded_card_face_alt fanV f_surr vw_in) => card_f.
  rewrite -split_fan_face_eq_add_diag // split_fan_face_eq //.
  have w'w_in: `w',w IN dart_of_fan (V,E)`.
    by rewrite -dart1_eq dart1_switch -w'_def f_fan_pair3.
  split => [->| ]; first by rewrite andTb orbC orbA orNb.
  by case => [| ->] //; case => ->; rewrite -lemma_in_face_set dartH.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f.
have := face_split_fan_face fanV f_surr vw_in.
have := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face_eq_add_diag // dart1_eq w'_def.
move => [fan2] [dart2] f_surr2 fs_eq [] [f2_vw f2_w'w] _.
have [dartH2 [_] [_] fH2] := COMPONENTS_HYPERMAP_OF_FAN fan2.
set H2 := `hypermap_of_fan _`.
split; last first.
  case; first by case => ->; rewrite -lemma_in_face_set dartH2 dart2 IN_UNION IN_INSERT.
  move => [/lemma_face_representation] [d]; rewrite dartH => [] [d_in] -> f_neq.
  rewrite -(fs_eq d_in); last by rewrite -lemma_in_face_set dartH2 dart2 IN_UNION.
  by apply: contra f_neq => /lemma_face_identity ->.
move/lemma_face_representation => [d].
rewrite dartH2 dart2 IN_UNION IN_INSERT IN_SING => [] [d_in_cond] ->.
case: d_in_cond => [d_in |]; last first.
  case => -> //; left; left.
  by rewrite eq_sym; apply lemma_face_identity; rewrite f2_vw !IN_INSERT.
case d_in_f: `d IN face (hypermap_of_fan (V,E)) (v,w)` => /=; last first.
  right; rewrite fs_eq // -lemma_in_face_set dartH d_in andTb.
  by apply: contra d_in_f; apply: contraLR => /lemma_different_faces.
case d_eq: `d = v,w \/ d = w',v` => /=; last first.
  left; right; rewrite eq_sym; apply lemma_face_identity.
  by rewrite f2_w'w IN_INSERT IN_DIFF IN_INSERT IN_SING.
left; left; case: d_eq => -> //.
by rewrite eq_sym; apply lemma_face_identity; rewrite f2_vw !IN_INSERT.
Qed.

Lemma tauVEF_add_diag_eq d f: `d IN dart_of_fan (V,E)
	/\ f IN face_set (hypermap_of_fan (V, add_diag (V,E) d))
	/\ f IN face_set (hypermap_of_fan (V,E))
	==> tauVEF (V, add_diag (V,E) d, f) = tauVEF (V, E, f)`.
Proof.
case: d => v w [vw_in] [f_in2] f_in.
case: (fully_surrounded_card_face_alt fanV f_surr vw_in) => card_f.
  by rewrite add_diag_eq_E.
rewrite add_diag dart1_eq vw_in /= (tau_split_fan_face_eq fanV f_surr vw_in) //.
rewrite IN_DELETE f_in andTb -implybF => f_eq.
move: f_in2; rewrite f_eq "let_RULE faces_add_diag" //.
rewrite IN_UNION IN_DELETE /= IN_INSERT IN_SING.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f.
rewrite split_fan_face_eq_add_diag // => [] [fs_eq] [_] [] [_] [_] n_in _.
set w' := `sigma_fan _ V E v w`.
rewrite !fs_eq negb_or; split; last first.
  by apply: contra n_in => ->; rewrite IN_INSERT.
have: `~(w,w' IN face (hypermap_of_fan (V,E)) (v,w))`.
  have := fully_surrounded_diag_not_in_dart fanV f_surr vw_in card_f.
  by apply: contra; rewrite w'_def -dartH => /in_face_imp_in_dart ->.
by apply: contra => ->; rewrite !IN_INSERT.
Qed.

Lemma f_fan_pair_ext_power_add_diag v w k:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
		/\ 1 <= k /\ k <= CARD f - 2
	==> (f_fan_pair_ext (V, add_diag (V,E) (v,w)) POWER k) (w',w)
		= (f_fan_pair_ext (V,E) POWER k) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
set f := `face _ (v,w)`.
move => [vw_in] [card_f] k_ineqs.
have := fan_split_fan_face fanV f_surr vw_in.
have := "let_RULE f_split_fan_face" fanV f_surr vw_in; "ANTS_TAC"; first by rewrite f_def.
set w' := `sigma_fan _ V E v w`.
rewrite split_fan_face_eq_add_diag //.
move => f_eqs [fan2] [dart2] f_surr2.
rewrite -!f_fan_pair_power //.
  by rewrite -fully_surrounded_dart_of_fan_eq // dart2 IN_UNION IN_INSERT.
elim: k k_ineqs => [|k Ih]; first by arith.
move => k_ineqs; case: (posnP k) => [-> | k_gt0].
  by rewrite -ONE !POWER_1 f_eqs.
rewrite !COM_POWER !o_THM Ih; first by move: k_gt0 k_ineqs; arith.
rewrite f_eqs // f_fan_pair_power // !negb_or.
rewrite dart2 dart1_eq IN_UNION f_fan_pair_ext_power_in_dart // orTb andTb.
have := fully_surrounded_diag_not_in_dart fanV f_surr vw_in; "ANTS_TAC"; first by rewrite f_def.
rewrite w'_def => ww'_n_in.
split.
  have {2}->: `v,w = (f_fan_pair_ext (V,E) POWER 0) (v,w)` by rewrite POWER_0 I_THM.
  rewrite (f_fan_pair_ext_power_inj fanV vw_in) -?LT_NZ // f_def.
  by move: k_ineqs; arith.
split; first by apply: contra ww'_n_in => <-; rewrite f_fan_pair_ext_power_in_dart.
split.
  by apply: contra ww'_n_in; rewrite dart_switch => <-; rewrite f_fan_pair_ext_power_in_dart.
have ->: `sigma_fan (vec 0) V E w' v, w' = (inverse (f_fan_pair_ext (V,E)) POWER 2) (v,w)`.
  rewrite POWER_2 o_THM INVERSE_F_FAN_PAIR_EXT_EXPLICIT //.
  rewrite !res /= dart1_eq vw_in /= dart_switch.
  by rewrite -dart1_eq sigma_in_dart1.
have ->: `2 = CARD f - (CARD f - 2)` by move: k_ineqs; arith.
rewrite -{1}f_def -(f_fan_pair_ext_power_inverse fanV vw_in) ?f_def.
  move: k_ineqs; arith.
by rewrite (f_fan_pair_ext_power_inj fanV vw_in) ?f_def; move: k_ineqs; arith.
Qed.

Lemma inverse_f_fan_pair_ext_add_diag v w:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
	==> inverse (f_fan_pair_ext (V, add_diag (V,E) (v,w))) (w',w)
		= (inverse (f_fan_pair_ext (V,E)) POWER 2) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
move => [vw_in card_f].
have := fan_split_fan_face fanV f_surr vw_in.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f.
rewrite split_fan_face_eq_add_diag //.
set w' := `sigma_fan _ V E v w`.
set f := `face (hypermap_of_fan (V,E)) (v,w)`.
set H2 := `hypermap_of_fan _`.
move => [_] [] [_] card2_w'w _ [fan2] [dart2] f_surr2.
rewrite -POWER_1.
have ->: `1 = CARD (face H2 (w',w)) - (CARD f - 2)`.
  by rewrite card2_w'w; move: card_f; arith.
have ->: `2 = CARD f - (CARD f - 2)` by move: card_f; arith.
rewrite -H2_def -(f_fan_pair_ext_power_inverse fan2).
  by rewrite H2_def card2_w'w dart2 IN_UNION IN_INSERT /=; move: card_f; arith.
rewrite subKn; first by move: card_f; arith.
rewrite -{2}f_def -(f_fan_pair_ext_power_inverse fanV vw_in).
  by rewrite f_def; move: card_f; arith.
rewrite -w'_def ("let_RULE f_fan_pair_ext_power_add_diag" vw_in) //.
by rewrite f_def; move: card_f; arith.
Qed.

Lemma azim_dart_eq_dihV v w: `(v,w) IN dart_of_fan (V,E)
	==> azim_dart (V,E) (v,w) = dihV (vec 0) v w (sigma_fan (vec 0) V E v w)`.
Proof.
move => vw_in; move: (vw_in); rewrite -dart1_eq => vw_in1.
rewrite fully_surrounded_azim_dart_eq_azim //.
rewrite AZIM_DIVH ?(DART1_NOT_COLLINEAR fanV) ?sigma_in_dart1 //.
rewrite -fully_surrounded_azim_dart_eq_azim //.
by move: f_surr; rewrite fully_surrounded => ->.
Qed.

Lemma tau3_eq_tau_fun v w: `(v,w) IN dart_of_fan (V,E) 
	/\ CARD (face (hypermap_of_fan (V,E)) (v,w)) = 3
	==> tau3 (sigma_fan (vec 0) V E v w) v w 
		= tau_fun V E (face (hypermap_of_fan (V,E)) (v,w))`.
Proof.
move => [vw_in card3].
move: (vw_in); rewrite -dart1_eq => vw_in1.
have := "let_RULE TRIANGULAR_FACE" fanV vw_in1 card3 => f_eq.
set w' := `sigma_fan _ V E v w`.
rewrite tau_fun card3 f_eq.
have neqs: `~(v = w) /\ ~(w = w')`.
  by rewrite !(PAIR_IN_DART1_OF_FAN_IMP_NOT_EQ fanV) // -w'_def f_fan_pair3.
rewrite !SUM_CLAUSES ?(FINITE_INSERT, FINITE_EMPTY) //.
rewrite !(IN_INSERT, NOT_IN_EMPTY) !PAIR_EQ !neqs /= -neqs /=.
have -> x: `x * &(3 - 2) = x` by arith.
have in_dart: `w,w' IN dart_of_fan (V,E) /\ w',v IN dart_of_fan (V,E)`.
  rewrite dart_of_fan_eq !IN_UNION -w'_def f_fan_pair3 //=; left.
  by rewrite dart1_switch sigma_in_dart1.
rewrite !rho_rho_fun !(azim_in_fan_eq_azim_dart fanV) //.
rewrite tau3 !azim_dart_eq_dihV // !f_eq w'_def.
by arith.
Qed.


(* BallAnnulus *)
Section BallAnnulus.

Hypothesis subV: `V SUBSET ball_annulus`.

Lemma f_surr_tau_fun_eq_tauVEF f: `f IN face_set (hypermap_of_fan (V,E))
	==> tau_fun V E f = tauVEF (V,E,f)`.
Proof.
move => f_in; rewrite (tau_fun_eq_tauVEF fanV) // subV f_in.
move/lemma_face_representation: f_in => [x]; rewrite dartH => [] [x_in] ->.
by move: (FULLY_SURROUNDED_IMP_CARD_FACE_GE_3 fanV f_surr x_in); arith.
Qed.

Lemma f_surr_tau_fun_eq_tauVEF_alt d: `d IN dart_of_fan (V,E)
	==> tau_fun V E (face (hypermap_of_fan (V,E)) d) 
		= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof. by rewrite -dartH lemma_in_face_set => /f_surr_tau_fun_eq_tauVEF. Qed.

Lemma f_surr_tau3_eq_tauVEF v w: `(v,w) IN dart_of_fan (V,E) 
	/\ CARD (face (hypermap_of_fan (V,E)) (v,w)) = 3
	==> tau3 (sigma_fan (vec 0) V E v w) v w 
		= tauVEF (V, E, face (hypermap_of_fan (V,E)) (v,w))`.
Proof. by move => h; rewrite tau3_eq_tau_fun // f_surr_tau_fun_eq_tauVEF_alt. Qed.

End BallAnnulus.

End FullySurrounded.


(* MainEstimate *)
Section MainEstimate.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Hypothesis h_fan: `lp_fan (V,E)`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by move: h_fan; rewrite lp_fan => h; rewrite fully_surrounded_dart_of_fan_eq. Qed.

Lemma local_diag f v w: `f IN face_set (hypermap_of_fan (V,E))
	/\ ~(v = w) /\ v IN v_prime V f /\ w IN v_prime V f
	/\ ~({v,w} IN e_prime E f) ==> &2 * h0 <= dist (v,w)`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag] _.
rewrite in_e_prime negb_and negb_or => [] [f_in] [v_n_w] [v_in] [w_in] h.
suff nE: `~({v,w} IN E)`.
  have ->: `&2 * h0 = #2.52` by rewrite h0; arith.
  rewrite diag nE v_n_w /=.
  by move: v_in w_in; rewrite v_prime !inE => -> ->.
case: h => // not_in_f.
rewrite (inE_eq_in_dart1 V) dart1_eq.
exact: (diag_not_in_dart fanV f_surr f_in).
Qed.

Lemma local_std f d: `f = face (hypermap_of_fan (V,E)) d /\ d IN dart_of_fan (V,E)
	==> ((!v w. {v,w} IN e_prime E f ==> &2 <= dist(v,w) /\ dist(v,w) <= &2 * h0)
		<=> (!k. k < CARD f ==> dist ((f_fan_pair_ext (V,E) POWER k) d) <= #2.52))`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [_] [_] packV [f_eq d_in].
have [dartH [_] [_] fH] := COMPONENTS_HYPERMAP_OF_FAN fanV.
have ->: `&2 * h0 = #2.52` by rewrite h0; arith.
have f_in: `f IN face_set (hypermap_of_fan (V,E))`.
  by rewrite f_eq -lemma_in_face_set.
have x_in_f x: `x IN f <=> ?k. k < CARD f /\ x = (f_fan_pair_ext (V,E) POWER k) d`.
  rewrite {1}f_eq face (FINITE_ORBIT_MAP `dart_of_fan (V,E)` `CARD f`).
    by rewrite -dartH !face_map_and_darts -face -f_eq.
  by rewrite fH IN_ELIM_THM.
split => [h k k_lt | h v w].
  set x := `(_1 POWER k) d`.
  move: (h `FST x` `SND x`); rewrite -pair_expand => ->.
  rewrite (f_surr_in_e_prime fanV f_surr) // -pair_expand; left.
  by rewrite x_in_f; exists k.
rewrite (f_surr_in_e_prime fanV) // => h_vw.
have vw_in: `v,w IN dart_of_fan (V,E)`.
  by case: h_vw; [|rewrite dart_switch]; rewrite -dartH f_eq => /in_face_imp_in_dart; apply.
rewrite (pack_dist fanV) // andTb.
by case: h_vw; [|rewrite DIST_SYM]; rewrite x_in_f => [] [k] [/h] ineq ->.
Qed.


(* Face3 *)
Section Face3.

Hypothesis ineq: "JEJTVGB_std3_concl".

Lemma ineq_tau3_tauVEF d: `d IN darts_k 3 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y4_fan (V,E) d <= #2.52
	==> &0 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
case: d => v w vw_in3.
move: (vw_in3); rewrite darts_k inE dartH => [] [vw_in] card_f bounds.
rewrite -f_surr_tau3_eq_tauVEF // ineq.
have ->: `&2 * h0 = #2.52` by rewrite h0; arith.
set w' := `sigma_fan _ V E v w`.
rewrite !(DIST_SYM w') -w'_def.
rewrite -!(ys_eq vw_in) // y4'_eq_y4 // !bounds.
rewrite (y1_lo vw_in) // (y2_lo vw_in) // (y3_lo vw_in) //.
rewrite (y1_hi vw_in) // (y2_hi vw_in) // (y3_hi vw_in) //.
by rewrite (y4_lo vw_in) // (y5_lo vw_in) // (y6_lo vw_in).
Qed.

(* tau_fan is always positive *)
Lemma ineq_tau3 d: `d IN darts_k 3 (hypermap_of_fan (V,E))
	==> &0 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof. by rewrite tau_fan REAL_ABS_POS. Qed.

Section Std.

Hypothesis std: `E = ESTD V`.

Lemma ineq_tau3_tauVEF_std d: `d IN darts_k 3 (hypermap_of_fan (V,E))
	==> &0 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
move => d_in3; apply: (ineq_tau3_tauVEF d_in3).
move: d_in3; rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fanV) => [] [d_in] _.
by rewrite y5_hi_std2 // (y6_hi_std2 fanV) // y4_hi_std2.
Qed.

End Std.

End Face3.


(* Face4 *)
Section Face4.

Hypothesis ineq: "JEJTVGB_std_concl".

Lemma ineq_tau4_tauVEF d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	==> #0.206 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
case: d => v w vw_in4.
move: (vw_in4); rewrite darts_k inE dartH => [] [vw_in] card_f bounds.
rewrite -f_surr_tau_fun_eq_tauVEF -?lemma_in_face_set //.
have c_local := "let_RULE f_surr_localization_convex_local" fanV f_surr vw_in.
set f := `face _ (v,w)`.
have f_in: `f IN face_set (hypermap_of_fan (V,E))`.
  by rewrite -f_def -lemma_in_face_set.
move: (c_local); rewrite convex_local_fan => [] [local] _.
move: (ineq c_local).
rewrite -("GEN_ALL Local_lemmas.LOFA_IMP_CARD_FF_V_EQ" local) card_f d_tame.
have -> /=: `~(4 = 3)` by arith.
rewrite tau_fun_local -?f_def -?lemma_in_face_set //; apply.
rewrite packing_v_prime // v_prime_subset // leqnn !andTb.
split; first by arith.
split => [a b h|]; first by rewrite (local_diag f_in).
rewrite (local_std vw_in) // card_f => k k_lt.
have: `k = 0 \/ k = 1 \/ k = 2 \/ k = 3` by move: k_lt; arith.
do !case; move => ->.
(* 1 *)
by rewrite POWER_0 I_THM -y6_fan.
(* 2 *)
by rewrite POWER_1 -y9_fan.
(* 3 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `4 - 2 = 2` by arith.
by rewrite POWER_2 o_THM -y5_fan -y8_fan.
(* 4 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `4 - 3 = 1` by arith.
by rewrite POWER_1 -y5_fan.
Qed.

Lemma ineq_tau4 d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	==> #0.206 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof.
move => d_in4 bounds.
have := ineq_tau4_tauVEF d_in4 bounds.
by rewrite tau_fan; arith.
Qed.

Section Std.

Hypothesis std: `E = ESTD V`.

Lemma ineq_tau4_tauVEF_std d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> #0.206 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
move => d_in4; apply: (ineq_tau4_tauVEF d_in4).
move: d_in4; rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fanV) => [] [d_in] _.
by rewrite y5_hi_std2 // (y6_hi_std2 fanV) // y8_hi_std // y9_hi_std.
Qed.

Lemma ineq_tau4_std d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> #0.206 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof. by move/ineq_tau4_tauVEF_std; rewrite tau_fan; arith. Qed.

End Std.

End Face4.


(* Face5 *)
Section Face5.

Hypothesis ineq: "JEJTVGB_std_concl".

Lemma ineq_tau5_tauVEF d: `d IN darts_k 5 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 2) d) <= #2.52
	==> #0.4819 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
case: d => v w vw_in_k.
move: (vw_in_k); rewrite darts_k inE dartH => [] [vw_in] card_f bounds.
rewrite -f_surr_tau_fun_eq_tauVEF -?lemma_in_face_set //.
have c_local := "let_RULE f_surr_localization_convex_local" fanV f_surr vw_in.
set f := `face _ (v,w)`.
have f_in: `f IN face_set (hypermap_of_fan (V,E))`.
  by rewrite -f_def -lemma_in_face_set.
move: (c_local); rewrite convex_local_fan => [] [local] _.
move: (ineq c_local).
rewrite -("GEN_ALL Local_lemmas.LOFA_IMP_CARD_FF_V_EQ" local) card_f d_tame.
have -> /=: `~(5 = 3)` by arith.
have -> /=: `~(5 = 4)` by arith.
rewrite tau_fun_local -?f_def -?lemma_in_face_set //; apply.
rewrite packing_v_prime // v_prime_subset // !andTb.
split; first by arith.
split; first by arith.
split => [a b h|]; first by rewrite (local_diag f_in).
rewrite (local_std vw_in) // card_f => k k_lt.
have: `k = 0 \/ k = 1 \/ k = 2 \/ k = 3 \/ k = 4` by move: k_lt; arith.
do !case; move => ->.
(* 1 *)
by rewrite POWER_0 I_THM -y6_fan.
(* 2 *)
by rewrite POWER_1 -y9_fan.
(* 3 *)
by rewrite -ye_fan.
(* 4 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `5 - 3 = 2` by arith.
by rewrite POWER_2 o_THM -y5_fan -y8_fan.
(* 5 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `5 - 4 = 1` by arith.
by rewrite POWER_1 -y5_fan.
Qed.

Lemma ineq_tau5 d: `d IN darts_k 5 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 2) d) <= #2.52
	==> #0.4819 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof.
move => d_in bounds.
have := ineq_tau5_tauVEF d_in bounds.
by rewrite tau_fan; arith.
Qed.

Section Std.

Hypothesis std: `E = ESTD V`.

Lemma ineq_tau5_tauVEF_std d: `d IN darts_k 5 (hypermap_of_fan (V,E))
	==> #0.4819 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
move => d_in5; apply: (ineq_tau5_tauVEF d_in5).
move: d_in5; rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fanV) => [] [d_in] _.
rewrite y5_hi_std2 // (y6_hi_std2 fanV) // y8_hi_std // y9_hi_std //.
by rewrite -y6_def ?(y6_hi_std2 fanV) ?f_fan_pair_ext_power_in_dart.
Qed.

Lemma ineq_tau5_std d: `d IN darts_k 5 (hypermap_of_fan (V,E))
	==> #0.4819 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof. by move/ineq_tau5_tauVEF_std; rewrite tau_fan; arith. Qed.

End Std.

End Face5.


(* Face6 *)
Section Face6.

Hypothesis ineq: "JEJTVGB_std_concl".

Lemma ineq_tau6_tauVEF d: `d IN darts_k 6 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 2) d) <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 3) d) <= #2.52
	==> #0.712 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: h_fan; rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
have [dartH _] := COMPONENTS_HYPERMAP_OF_FAN fanV.
case: d => v w vw_in_k.
move: (vw_in_k); rewrite darts_k inE dartH => [] [vw_in] card_f bounds.
rewrite -f_surr_tau_fun_eq_tauVEF -?lemma_in_face_set //.
have c_local := "let_RULE f_surr_localization_convex_local" fanV f_surr vw_in.
set f := `face _ (v,w)`.
have f_in: `f IN face_set (hypermap_of_fan (V,E))`.
  by rewrite -f_def -lemma_in_face_set.
move: (c_local); rewrite convex_local_fan => [] [local] _.
move: (ineq c_local).
rewrite -("GEN_ALL Local_lemmas.LOFA_IMP_CARD_FF_V_EQ" local) card_f d_tame.
have neqs: `~(6 = 3) /\ ~(6 = 4) /\ ~(6 = 5)` by arith.
rewrite !neqs /= tau_fun_local -?f_def -?lemma_in_face_set //; apply.
rewrite packing_v_prime // v_prime_subset // leqnn !andTb.
split; first by arith.
split => [a b h|]; first by rewrite (local_diag f_in).
rewrite (local_std vw_in) // card_f => k k_lt.
have: `k = 0 \/ k = 1 \/ k = 2 \/ k = 3 \/ k = 4 \/ k = 5` by move: k_lt; arith.
do !case; move => ->.
(* 1 *)
by rewrite POWER_0 I_THM -y6_fan.
(* 2 *)
by rewrite POWER_1 -y9_fan.
(* 3 *)
by rewrite -ye_fan.
(* 4 *)
by rewrite -ye_fan.
(* 5 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `6 - 4 = 2` by arith.
by rewrite POWER_2 o_THM -y5_fan -y8_fan.
(* 6 *)
rewrite (f_fan_pair_ext_power_inverse fanV vw_in) f_def card_f; first by arith.
have ->: `6 - 5 = 1` by arith.
by rewrite POWER_1 -y5_fan.
Qed.

Lemma ineq_tau6 d: `d IN darts_k 6 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 2) d) <= #2.52
	/\ ye_fan ((f_fan_pair_ext (V,E) POWER 3) d) <= #2.52
	==> #0.712 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof.
move => d_in bounds.
have := ineq_tau6_tauVEF d_in bounds.
by rewrite tau_fan; arith.
Qed.

Section Std.

Hypothesis std: `E = ESTD V`.

Lemma ineq_tau6_tauVEF_std d: `d IN darts_k 6 (hypermap_of_fan (V,E))
	==> #0.712 <= tauVEF (V,E,face (hypermap_of_fan (V,E)) d)`.
Proof.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
move => d_in6; apply: (ineq_tau6_tauVEF d_in6).
move: d_in6; rewrite darts_k inE (COMPONENTS_HYPERMAP_OF_FAN fanV) => [] [d_in] _.
rewrite y5_hi_std2 // (y6_hi_std2 fanV) // y8_hi_std // y9_hi_std //.
rewrite -y6_def ?(y6_hi_std2 fanV) ?f_fan_pair_ext_power_in_dart //.
by rewrite -y6_def ?(y6_hi_std2 fanV) ?f_fan_pair_ext_power_in_dart.
Qed.

Lemma ineq_tau6_std d: `d IN darts_k 6 (hypermap_of_fan (V,E))
	==> #0.712 <= tau_fan (V,E) (face (hypermap_of_fan (V,E)) d)`.
Proof. by move/ineq_tau6_tauVEF_std; rewrite tau_fan; arith. Qed.

End Std.

End Face6.

End MainEstimate.


(* LpTau *)
Section LpTau.

Variable V: `:real^3->bool`.
Variable E: `:(real^3->bool)->bool`.

Section Contravening.

Hypothesis main_estimate: `lp_main_estimate`.
Hypothesis contrV: `contravening V`.

Let h_fan: `lp_fan (V,ESTD V)`.
Proof. by rewrite contravening_lp_fan. Qed.

(* TODO: remove when proved *)
Hypothesis p_bound: `perimeterbound (V,ESTD V)`.

Lemma contravening_lp_tau: `lp_tau (V,ESTD V)`.
Proof.
rewrite lp_tau.
have := Crttxat_tame.CRTTXAT contrV p_bound Jgtdebu.JGTDEBU4.
rewrite tame_9a => card_f_ineq.
move => f /lemma_face_representation [d] [d_in] f_eq.
have: `CARD f = 3 \/ CARD f = 4 \/ CARD f = 5 \/ CARD f = 6`.
  by move: (card_f_ineq d_in); rewrite -f_eq; arith.
do !case; move => card_f.
(* 3 *)
rewrite f_eq (ineq_tau3_tauVEF_std h_fan) darts_k inE -f_eq d_in card_f /=.
by move: main_estimate; rewrite lp_main_estimate /=.
(* 4 *)
apply: REAL_LE_TRANS; exists `#0.206`; split; first by arith.
rewrite f_eq (ineq_tau4_tauVEF_std h_fan) darts_k inE -f_eq d_in card_f /=.
by move: main_estimate; rewrite lp_main_estimate /=.
(* 5 *)
apply: REAL_LE_TRANS; exists `#0.4819`; split; first by arith.
rewrite f_eq (ineq_tau5_tauVEF_std h_fan) darts_k inE -f_eq d_in card_f /=.
by move: main_estimate; rewrite lp_main_estimate /=.
(* 6 *)
apply: REAL_LE_TRANS; exists `#0.712`; split; first by arith.
rewrite f_eq (ineq_tau6_tauVEF_std h_fan) darts_k inE -f_eq d_in card_f /=.
by move: main_estimate; rewrite lp_main_estimate /=.
Qed.

End Contravening.


(* Split *)
Section Split.

Hypothesis h_fan: `lp_fan (V,E)`.

Let dart1_eq: `dart1_of_fan (V,E) = dart_of_fan (V,E)`.
Proof. by move: h_fan; rewrite lp_fan => h; rewrite fully_surrounded_dart_of_fan_eq. Qed.

Let dartH: `dart (hypermap_of_fan (V,E)) = dart_of_fan (V,E)`.
Proof. by move: h_fan; rewrite lp_fan => h; rewrite COMPONENTS_HYPERMAP_OF_FAN. Qed.

Let split_eq d: `d IN dart_of_fan (V,E) ==> split_fan_face (V,E) d = V, add_diag (V,E) d`.
Proof. by case: d => v w vw_in; rewrite split_fan_face add_diag dart1_eq vw_in. Qed.


Lemma ys_split_eq2 v w:
	`let f = face (hypermap_of_fan (V,E)) (v,w) in
	 let w' = sigma_fan (vec 0) V E v w in
		v,w IN dart_of_fan (V,E) /\ 3 < CARD f
		==> y1_fan (w',w) = y3_fan (V,E) (v,w)
		/\ y2_fan (w',w) = y2_fan (v,w)
		/\ y3_fan (V, add_diag (V,E) (v,w)) (w',w) = y7_fan (V,E) (v,w)
		/\ y5_fan (V, add_diag (V,E) (v,w)) (w',w) = y8_fan (V,E) (v,w)
		/\ y6_fan (w',w) = y4'_fan (V,E) (v,w)
		/\ y9_fan (V, add_diag (V,E) (v,w)) (w',w) = y9_fan (V,E) (v,w)`.
Proof.
do !"CONV_TAC let_CONV".
move => [vw_in card_f].
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
set w' := `sigma_fan _ V E v w`.
rewrite !(ys_eq vw_in) // w'_def y1_fan y2_fan y6_fan (DIST_SYM w') /=.
rewrite y3_fan y5_fan.
rewrite -w'_def "let_RULE inverse_f_fan_pair_ext_add_diag" //.
rewrite y7_fan /= y8_fan y5_fan POWER_2 o_THM /=.
rewrite !y9_fan -POWER_1 "let_RULE f_fan_pair_ext_power_add_diag" ?POWER_1 //.
by rewrite fanV f_surr vw_in card_f leqnn; move: card_f; arith.
Qed.


(* Split4 *)
Section Split4.

Hypothesis h_tau: `lp_tau (V,E)`.

Section Apex_flat.

Hypothesis ineq103: "(hd (Ineq.getexact \"6988401556\")).ineq".

Lemma lp_tau_split4_apex_flat d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ y4'_fan (V,E) d <= sqrt8
	==> lp_tau (V, add_diag (V,E) d)`.
Proof.
case: d => v w vw_in4 bounds.
move: (vw_in4); rewrite darts_k inE dartH => [] [vw_in] card_f.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
rewrite lp_tau => f f_in2.
move: (f_in2); rewrite "let_RULE faces_add_diag" // IN_UNION IN_DELETE IN_INSERT IN_SING.
set w' := `sigma_fan _ V E v w`.
case => [f_eqs | [f_in] _]; last first.
  by rewrite tauVEF_add_diag_eq //; move: h_tau; rewrite lp_tau => ->.
have card_f_gt3: `3 < CARD (face (hypermap_of_fan (V,E)) (v,w))` by rewrite card_f; arith.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f_gt3.
have := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face_eq_add_diag // w'_def card_f.
have ->: `4 - 1 = 3` by arith.
set H2 := `hypermap_of_fan _`.
move: f_in2 => _ [fan2] [dart2] f_surr2 [] [f2_vw f2_w'w] [] [card2_vw card2_w'w] _.
move: (COMPONENTS_HYPERMAP_OF_FAN fan2); rewrite H2_def => [] [dartH2] _.
have eqs: `#2.0 = &2 /\ &2 * h0 = #2.52` by rewrite h0; arith.
rewrite real_gt Ineq.apex_flat INEQ_ALT !eqs in ineq103.
rewrite REAL_LT_IMP_LE; apply REAL_LT_TRANS; exists `#0.103`; split; first by arith.
case: f_eqs => ->.
  have vw_in2_3: `v,w IN darts_k 3 H2`.
    by rewrite darts_k inE dartH2 dart2 dart1_eq IN_UNION.
  rewrite -H2_def dart3_tauVEF_eq_taum // -y4'_eq_y4 // !ys_split_eq //.
  rewrite ineq103 !"GEN_ALL ALL" /= !bounds.
  rewrite (y1_lo vw_in) // (y1_hi vw_in) // (y2_lo vw_in) // (y2_hi vw_in) //.
  by rewrite y3_lo // y3_hi // y5_lo // (y6_lo vw_in) // dart4_y4'_lo.
have w'w_in2_3: `w',w IN darts_k 3 H2`.
  by rewrite darts_k inE dartH2 dart2 dart1_eq IN_UNION IN_INSERT.
move: (w'w_in2_3); rewrite darts_k inE dartH2 => [] [w'w_in2] _.
rewrite -H2_def dart3_tauVEF_eq_taum // y4_def // -y9_def //.
rewrite -w'_def !"let_RULE ys_split_eq2" // Tame_lemmas.taum_sym.
rewrite ineq103 !"GEN_ALL ALL" /= !bounds.
rewrite y7_lo // y7_hi // (y2_lo vw_in) // (y2_hi vw_in) // y3_lo // y3_hi //.
by rewrite y8_lo // y9_lo // dart4_y4'_lo.
Qed.

End Apex_flat.


Section Apex_sup_flat.

Hypothesis ineq86: "(hd (Ineq.getexact \"1642527039\")).ineq".

Let ineq_tau y1 y2 y3 y4 y5 y6: `ineq (apex_sup_flat y1 y2 y3 y4 y5 y6)
		(&0 <= taum y1 y2 y3 y4 y5 y6)`.
Proof.
rewrite !INEQ_ALT /= in ineq86 *; move => ys_all.
rewrite REAL_LT_IMP_LE; apply: REAL_LT_TRANS.
exists `#0.128 + #0.053 * ((y5 + y6 - &4) - #2.75 / &2 * (y4 - sqrt8))`; split.
  move: ys_all; rewrite Ineq.apex_sup_flat !"GEN_ALL ALL" /=.
  by move: Flyspeck_constants.bounds; arith.
have -> a b c: `a + c < b <=> &0 < (b - a) - c` by arith.
by rewrite -real_gt ineq86.
Qed.

Lemma lp_tau_split4_apex_sup_flat d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ sqrt8 <= y4'_fan (V,E) d
	/\ y4'_fan (V,E) d <= &3
	==> lp_tau (V, add_diag (V,E) d)`.
Proof.
case: d => v w vw_in4 bounds.
move: (vw_in4); rewrite darts_k inE dartH => [] [vw_in] card_f.
move: (h_fan); rewrite lp_fan => [] [fanV] [f_surr] [diag] [subV] packV.
rewrite lp_tau => f f_in2.
move: (f_in2); rewrite "let_RULE faces_add_diag" // IN_UNION IN_DELETE IN_INSERT IN_SING.
set w' := `sigma_fan _ V E v w`.
case => [f_eqs | [f_in] _]; last first.
  by rewrite tauVEF_add_diag_eq //; move: h_tau; rewrite lp_tau => ->.
have card_f_gt3: `3 < CARD (face (hypermap_of_fan (V,E)) (v,w))` by rewrite card_f; arith.
have := "let_RULE face_split_fan_face_explicit" fanV f_surr vw_in card_f_gt3.
have := fan_split_fan_face fanV f_surr vw_in.
rewrite split_fan_face_eq_add_diag // w'_def card_f.
have ->: `4 - 1 = 3` by arith.
set H2 := `hypermap_of_fan _`.
move: f_in2 => _ [fan2] [dart2] f_surr2 [] [f2_vw f2_w'w] [] [card2_vw card2_w'w] _.
move: (COMPONENTS_HYPERMAP_OF_FAN fan2); rewrite H2_def => [] [dartH2] _.
have eqs: `#2.0 = &2 /\ #3.0 = &3` by arith.
rewrite INEQ_ALT Ineq.apex_sup_flat !eqs in ineq_tau.
case: f_eqs => ->.
  have vw_in2_3: `v,w IN darts_k 3 H2`.
    by rewrite darts_k inE dartH2 dart2 dart1_eq IN_UNION.
  rewrite -H2_def dart3_tauVEF_eq_taum // -y4'_eq_y4 // !ys_split_eq //.
  rewrite ineq_tau !"GEN_ALL ALL" /= !bounds.
  rewrite (y1_lo vw_in) // (y1_hi vw_in) // (y2_lo vw_in) // (y2_hi vw_in) //.
  by rewrite y3_lo // y3_hi // y5_lo // (y6_lo vw_in).
have w'w_in2_3: `w',w IN darts_k 3 H2`.
  by rewrite darts_k inE dartH2 dart2 dart1_eq IN_UNION IN_INSERT.
move: (w'w_in2_3); rewrite darts_k inE dartH2 => [] [w'w_in2] _.
rewrite -H2_def dart3_tauVEF_eq_taum // y4_def // -y9_def //.
rewrite -w'_def !"let_RULE ys_split_eq2" // Tame_lemmas.taum_sym.
rewrite ineq_tau !"GEN_ALL ALL" /= !bounds.
rewrite y7_lo // y7_hi // (y2_lo vw_in) // (y2_hi vw_in) // y3_lo // y3_hi //.
by rewrite y8_lo // y9_lo.
Qed.

End Apex_sup_flat.


Hypothesis ineq103: "(hd (Ineq.getexact \"6988401556\")).ineq".
Hypothesis ineq86: "(hd (Ineq.getexact \"1642527039\")).ineq".

Lemma lp_tau_split4 d: `d IN darts_k 4 (hypermap_of_fan (V,E))
	==> y5_fan (V,E) d <= #2.52
	/\ y6_fan d <= #2.52
	/\ y8_fan (V,E) d <= #2.52
	/\ y9_fan (V,E) d <= #2.52
	/\ y4'_fan (V,E) d <= &3
	==> lp_tau (V, add_diag (V,E) d)`.
Proof.
move => d_in4 bounds.
case: (REAL_LE_TOTAL `y4'_fan (V,E) d` `sqrt8`) => y4'_ineq.
  by rewrite lp_tau_split4_apex_flat.
by rewrite lp_tau_split4_apex_sup_flat.
Qed.

End Split4.

End Split.

End LpTau.
