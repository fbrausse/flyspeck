needs "../formal_lp/hypermap/ineqs/lp_ineqs.hl";;
needs "../formal_lp/hypermap/ineqs/lp_head_ineqs.hl";;
needs "../formal_lp/hypermap/ineqs/lp_body_ineqs.hl";;
needs "../formal_lp/hypermap/computations/list_hypermap_computations.hl";;
needs "../formal_lp/more_arith/prove_lp.hl";;

(* module Flyspeck_lp = struct *)

open Arith_misc;;
open Linear_function;;
open Prove_lp;;
open Arith_nat;;
open Misc_vars;;
open List_hypermap_computations;;
open List_conversions;;
open Lp_approx_ineqs;;
open Lp_ineqs;;

Lp_head_ineqs.add_head_ineqs();;
Lp_body_ineqs.add_body_ineqs();;
Lp_ineqs.process_raw_ineqs();;


(* Prepare theorems for the final inequality: &12 <= scriptL V *)
let to_lin_f_ineq ineq_th =
  let lhs, rhs = dest_binop le_op_real (concl ineq_th) in
  let lhs_th = LIN_F_CONV lhs in
    EQ_MP (AP_THM (AP_TERM le_op_real lhs_th) rhs) ineq_th;;

let FINAL_INEQ = (MY_RULE_NUM o prove)(`lin_f [] <= -- &n <=> n = 0`,
		     REWRITE_TAC[LIN_F_EMPTY; REAL_NEG_GE0; REAL_OF_NUM_LE; LE]);;

let lnsum_ineqs =
  let DECIMAL_INT = prove(`!n. DECIMAL n 1 = &n`, REWRITE_TAC[DECIMAL; REAL_DIV_1]) in
  let ineq_th = (add_lp_hyp false o REWRITE_RULE[GSYM IMP_IMP]) Lp_ineqs_proofs.lnsum_ineq in
  let ineq_tm = concl ineq_th in
  let ths1 = create_approximations [9;12;15] ineq_tm in
  let ths2 = map generalize_hyp ths1 in
  let ths3 = map (itlist PROVE_HYP Lp_ineqs_def.list_var_pos) ths2 in
  let ths4 = map (C MP ineq_th) ths3 in
  let r = CONV_RULE(REWRITE_CONV[DECIMAL_INT; GSYM LIST_SUM_LMUL] THENC DEPTH_CONV Arith_nat.NUMERAL_TO_NUM_CONV) in
  let ths5 = map r ths4 in
    zip (3--5) ths5;;



(* Performs the following conversions:
   (a + ... + c) + d = a + ... + c + d *)
let plus_assoc_conv = 
  let REAL_ADD_ASSOC' = (SYM o SPEC_ALL) REAL_ADD_ASSOC in
  let rec plus_conv tm =
    if (is_binop add_op_real tm) then
      let lhs, rhs = dest_binop add_op_real tm in
	if (is_binop add_op_real lhs) then
	  let x_tm, y_tm = dest_binop add_op_real lhs in
	  let th0 = INST[x_tm, x_var_real; y_tm, y_var_real; rhs, z_var_real] REAL_ADD_ASSOC' in
	  let ltm, rtm = dest_comb(rand(concl th0)) in
	    TRANS th0 (AP_TERM ltm (plus_conv rtm))
	else
	  REFL tm
    else
      REFL tm
  in plus_conv;;


(**********************)

let convert_ineq hyp_fun =
  let rec rewrite_lhs tm =
    let rewrite_one tm =
      if (is_binop mul_op_real tm) then
	let mul_tm, var_tm = dest_comb tm in
	let var_f, arg = dest_comb var_tm in
	    
	let rec convert_arg arg =
	  if (is_comb arg) then
	    let ltm, sub_arg' = dest_comb arg in
	    let const_name = (fst o dest_const) (if (is_const ltm) then ltm else rator ltm) in
	      (* Str.first_chars const_name 1 = "D" is a hack *)
	      if (Str.first_chars const_name 1 = "D" or const_name = "_0" 
		  or const_name = "," or const_name = "CONS" or const_name = "INSERT") then
		REFL arg
	      else
		try
		  let sub_arg_th = convert_arg sub_arg' in
		  let th0 = AP_TERM ltm sub_arg_th in
		  let rtm = rand(concl th0) in
		  let th1 = 
		    if (const_name = "set_of_list") then
		      set_of_list_conv rtm
		    else if (const_name = "FST") then
		      fst_conv rtm
		    else if (const_name = "SND") then
		      snd_conv rtm
		    else if (const_name = "HD") then
		      hd_conv rtm
		    else if (const_name = "e_list") then
		      e_list_conv_num rtm
		    else
		      hyp_fun const_name (rand rtm) in
		    TRANS th0 th1
		with _ ->
		  failwith ("convert_arg: "^const_name)
	  else
	    REFL arg in
	    
	let arg_th = convert_arg arg in
	  AP_TERM mul_tm (AP_TERM var_f arg_th)
	      
      else
	(* tm should be list_sum *)
	list_sum_conv BETA_CONV tm in
	
      if (is_binop add_op_real tm) then
	let lhs, rhs = dest_binop add_op_real tm in
	let lhs_th = rewrite_one lhs in
	let rhs_th = rewrite_lhs rhs in
	let th1 = MK_COMB(AP_TERM add_op_real lhs_th, rhs_th) in
	  if (is_binop add_op_real (rand(concl lhs_th))) then
	    let th2 = plus_assoc_conv (rand(concl th1)) in
	      TRANS th1 th2
	  else
	    th1
      else
	rewrite_one tm in
      
    fun ineq_tm ->
      let ltm, rtm = dest_comb ineq_tm in
      let op_tm, l_tm = dest_comb ltm in
      let lhs_eq_th = rewrite_lhs l_tm in
	AP_THM (AP_TERM op_tm lhs_eq_th) rtm;;


let convert_tm =
  let num_str = (fst o dest_const) Arith_hash.num_const in
  let rec convert hyp_fun tm =
    if (is_comb tm) then
      let ltm, rtm = dest_comb tm in
      let op_tm = if is_comb ltm then rator ltm else ltm in
	if is_const op_tm then
	  let const_name = (fst o dest_const) op_tm in
	    if const_name = "real_of_num" or const_name = "DECIMAL" then
	      REFL tm
	    else if const_name = "ye_list" then
	      if is_pair rtm then
		let ltm', b_tm = dest_comb rtm in
		let pair_op, a_tm = dest_comb ltm' in
		let a_th = convert hyp_fun a_tm and
		    b_th = convert hyp_fun b_tm in
		  AP_TERM ltm (MK_COMB (AP_TERM pair_op a_th, b_th))
	      else
		let rtm_th = convert hyp_fun rtm in
		  AP_TERM ltm rtm_th
	    else
	      let rtm_th = convert hyp_fun rtm in
	      let th0 = AP_TERM ltm rtm_th in
	      let arg = rand (concl th0) in
	      let th1 =
		if const_name = num_str then
		  INST[rand arg, n_var_num] Arith_hash.NUM_THM
		else
		  match const_name with
		    | "set_of_list" -> set_of_list_conv arg
		    | "FST" -> fst_conv arg
		    | "SND" -> snd_conv arg
		    | "HD" -> hd_conv arg
		    | "e_list" -> e_list_conv_num arg
		    | "LENGTH" -> length_conv arg
		    | _ ->
			(try hyp_fun const_name (rand arg)
			 with Failure _ -> REFL arg) in
		TRANS th0 th1
	else
	  REFL tm
    else
      REFL tm in
    convert;;


let convert_condition hyp_fun tm =
  if is_comb tm then
    let ltm, rtm = dest_comb tm in
    let r_th = convert_tm hyp_fun rtm in
      if is_comb ltm then
	let op_tm, larg = dest_comb ltm in
	let l_th = convert_tm hyp_fun larg in
	  MK_COMB (AP_TERM op_tm l_th, r_th)
      else
	AP_TERM ltm r_th
  else
    convert_tm hyp_fun tm;;



let rec simplify_ineq_tm hyp_fun tm =
  if is_imp tm then
    let ltm, q_tm = dest_comb tm in
    let imp_tm, p_tm = dest_comb ltm in
    let p_eq_th = convert_condition hyp_fun p_tm in
    let q_eq_th = simplify_ineq_tm hyp_fun q_tm in
      MK_COMB (AP_TERM imp_tm p_eq_th, q_eq_th)
  else
    convert_ineq hyp_fun tm;;


let simplify_ineq hyp_fun ineq_th =
  let eq_th = simplify_ineq_tm hyp_fun (concl ineq_th) in
    EQ_MP eq_th ineq_th;;


let rec prove_conditions ineq_th =
  let concl_tm = concl ineq_th in
    if is_imp concl_tm then
      let p_tm = lhand concl_tm in
      let flag, p_th =
	if is_eq p_tm then
	  let ltm, rtm = dest_eq p_tm in
	    if ltm = rtm then
	      true, REFL ltm
	    else
	      false, TRUTH
	else
	  false, TRUTH in
      let th1 =
	if flag then
	  MP ineq_th p_th
	else
	  UNDISCH ineq_th in
	prove_conditions th1
    else
      ineq_th;;
      

let get_ineqs (hyp_list_tm, hyp_set, hyp_fun) std_flag precision name indices =
  let ineq0_th = (find_ineq std_flag precision name).ineq_th in
  let ineq1_th = INST[hyp_list_tm, l_cap_var] ineq0_th in
  let all_tm, set_tm = dest_comb (concl ineq1_th) in
  let set_eq_th = hyp_set ((fst o dest_const o rator) set_tm) in
  let ineq2_th = EQ_MP (AP_TERM all_tm set_eq_th) ineq1_th in
  let ineq0_ths = select_all ineq2_th indices in
  let ineq1_ths = map MY_BETA_RULE ineq0_ths in
  let ineq2_ths = map (simplify_ineq hyp_fun) ineq1_ths in
  let ineq3_ths = map prove_conditions ineq2_ths in
    ineq3_ths;;



(****************************)

let prove_flyspeck_lp_step1 hyp_list_tm hyp_set hyp_fun std_flag precision constraints target_variables variable_bounds =
  let precision_constant = Int 10 **/ (Int precision) in

(* This function generates all inequalities with the given name and indices,
   multiplies these inequalities by given coefficients, and finds the sum of 
   the generated inequalities *)
  let sum_step = fun (name, indices, c) ->
    try
      let ineqs = get_ineqs (hyp_list_tm, hyp_set, hyp_fun) std_flag precision name indices in
      let s1 = map transform_le_ineq (zip ineqs c) in
	List.fold_left add_step' dummy s1
    with 
      | Failure str -> failwith (sprintf "Problem: %s (%s)" name str)
      | _ ->  failwith ("Problem: "^name) in

  let s1' = List.fold_left add_step' dummy (map sum_step constraints) in
  let s1 = mul_step s1' (mk_real_int precision_constant) in
  let s2 = List.fold_left add_step' dummy (map sum_step target_variables) in
  let s3 = List.fold_left add_step' dummy (map sum_step variable_bounds) in
  let s4 = add_step' (add_step' s1 s2) s3 in

  let ineq_th0 = assoc precision lnsum_ineqs in
  let ineq_th1 = (INST[hyp_list_tm, l_cap_var]) ineq_th0 in
  let ineq_th2 = EQ_MP (term_rewrite (concl ineq_th1) (hyp_set "list_of_elements")) ineq_th1 in
  let ineq_th3 = simplify_ineq hyp_fun ineq_th2 in
  let ineq_th4 = to_lin_f_ineq ineq_th3 in

  let r1 = add_step' ineq_th4 s4 in
  let n_tm = (rand o rand o rand o concl) r1 in
  let r_eq_th = INST[n_tm, n_var_num] FINAL_INEQ in
  let not_zero_th = NUM_EQ0_HASH_CONV n_tm in
    EQ_MP not_zero_th (EQ_MP r_eq_th r1);;


(*************************)


(*************************)

loadt "../formal_lp/glpk/ex1/bb1_out.hl";;
loadt "../formal_lp/glpk/ex2/bb2_1_out.hl";;
loadt "../formal_lp/glpk/ex2/bb2_2_out.hl";;
loadt "../formal_lp/glpk/ex2/bb2_3_out.hl";;
loadt "../formal_lp/glpk/ex2/bb2_4_out.hl";;
loadt "../formal_lp/glpk/ex2/bb2_5_out.hl";;


let test_list = (to_num o create_hol_list_str) hypermap_string;;
(* bb2_1, bb2_3 *)
let split_list = eval_split_list_hyp test_list (to_num `1,2`);;
(* bb2_2, bb2_4 *)
let split_list = eval_split_list_hyp test_list (to_num `0,1`);;
let test_list = (rand o concl) split_list;;

let hyp_set, hyp_fun = compute_all test_list None;;

prove_flyspeck_lp_step1 test_list hyp_set hyp_fun false precision constraints target_variables variable_bounds;;
prove_flyspeck_lp_step1 test_list hyp_set hyp_fun true precision constraints target_variables variable_bounds;;
(* 10, bb1: 2.256 *)
(* 10, bb2_1: 2.224 *)
(* 10, bb2_2: 2.532 *)
(* 10, bb2_3: *)
(* 10, bb2_4: *)
(* 10, bb2_5: 2.580 *)
test 1 (prove_flyspeck_lp_step1 test_list hyp_set hyp_fun false precision constraints target_variables) variable_bounds;;

let th = it;;
length (filter (is_binop le_op_real) (hyp th));;


(************************)

let hyp_list_tm = test_list;;
let std_flag = true;;

let hyp_set, hyp_fun = compute_all hyp_list_tm None;;


(********************)

let name, indices, _ = find (fun name,_,_ -> name = "ineq118") constraints;;
let name, indices, _ = List.nth variable_bounds 22;;
get_ineqs (hyp_list_tm, hyp_set, hyp_fun) std_flag precision name indices;;


generate_ineq (find_raw_ineq "y9_def");;

let x = 2;;



(******************)

let precision_constant = Int 10 **/ (Int precision) and
    target_bound = `&12`;;

(* This function generates all inequalities with the given name and indices,
   multiplies these inequalities by given coefficients, and finds the sum of 
   the generated inequalities *)
let sum_step = fun (name, indices, c) ->
  try
    let ineqs = get_ineqs (hyp_list_tm, hyp_set, hyp_fun) std_flag precision name indices in
    let s1 = map transform_le_ineq (zip ineqs c) in
      List.fold_left add_step' dummy s1
  with _ ->
    failwith ("Problem: "^name);;

let s1' = List.fold_left add_step' dummy (map sum_step constraints);;
let s1 = mul_step s1' (mk_real_int precision_constant);;
let s2 = List.fold_left add_step' dummy (map sum_step target_variables);;
let s3 = List.fold_left add_step' dummy (map sum_step variable_bounds);;
let s4 = add_step' (add_step' s1 s2) s3;;

let ineq_th0 = assoc precision lnsum_ineqs;;
let ineq_th1 = (INST[hyp_list_tm, l_cap_var] o add_lp_hyp) ineq_th0;;
let ineq_th2 = EQ_MP (term_rewrite (concl ineq_th1) (hyp_set "list_of_elements")) ineq_th1;;
let ineq_th3 = simplify_ineq hyp_fun ineq_th2;;
let ineq_th4 = to_lin_f_ineq ineq_th3;;

let r1 = add_step' ineq_th4 s4;;
let n_tm = (rand o rand o rand o concl) r1;;
let r_eq_th = INST[n_tm, n_var_num] FINAL_INEQ;;
let not_zero_th = NUM_EQ0_HASH_CONV n_tm;;
EQ_MP not_zero_th (EQ_MP r_eq_th r1);;



(* (old) Final transformations *)
let r6 = CONV_RULE (DEPTH_CONV NUM_TO_NUMERAL_CONV) s4;;
let m = term_of_rat (precision_constant */ precision_constant */ precision_constant);;
let r7 = mul_rat_step r6 (mk_comb (`(/) (&1)`, m));;
let r8 = REWRITE_RULE[lin_f; ITLIST; REAL_ADD_RID] r7;;
let r9 = EQT_ELIM (REAL_RAT_LE_CONV (mk_binop le_op_real ((rand o concl) r8) target_bound));;
MATCH_MP REAL_LE_TRANS (CONJ r8 r9);;

(find_raw_ineq false "ineq31").tm;;


(*******************************)

let ABBREV_RULE var_name tm th =
  let var_tm = mk_var (var_name, type_of tm) in
  let eq_th = ASSUME (mk_eq (tm, var_tm)) in
    (UNDISCH_ALL o PURE_REWRITE_RULE[eq_th] o DISCH_ALL) th;;

let SELECT_AND_ABBREV_RULE =
  let P = `P:A->bool` in
  let pth = prove
    (`(?) (P:A->bool) ==> P((@) P)`,
     SIMP_TAC[SELECT_AX; ETA_AX]) in
  fun th ->
    try 
      let abs = rand (concl th) in
      let var, b_tm = dest_abs abs in
      let name, ty = dest_var var in
      let select_tm = mk_binder "@" (var, b_tm) in
      let th0 = CONV_RULE BETA_CONV (MP (PINST [ty,aty] [abs,P] pth) th) in
	ABBREV_RULE name select_tm th0
    with Failure _ -> failwith "SELECT_AND_ABBREV_RULE";;

let EXPAND_RULE var_name th =
  let hyp_tm = find (fun tm -> is_eq tm && is_var (rand tm) && name_of (rand tm) = var_name) (hyp th) in
  let l_tm, var_tm = dest_eq hyp_tm in
  let th1 = INST[l_tm, var_tm] th in
    PROVE_HYP (REFL l_tm) th1;;


(***************************)

let lp_th = prove_flyspeck_lp_step1 test_list hyp_set hyp_fun true precision constraints target_variables variable_bounds;;

let inst_list = [test_list, l_cap_var; `ESTD V`, `E:(real^3->bool)->bool`];;


let th0 = (MY_RULE_NUM o REWRITE_RULE[Seq.size]) Lp_ineqs_proofs.contravening_lp_cond_alt;;
let th1 = (INST inst_list o UNDISCH_ALL o  ISPEC test_list o REWRITE_RULE[GSYM IMP_IMP]) th0;;

let good_list_nodes_th = EQT_ELIM (eval_good_list_nodes_condition hyp_set);;
let th2 = (MY_PROVE_HYP (hyp_set "good_list") o MY_PROVE_HYP good_list_nodes_th) th1;;
let th3 = (SELECT_AND_ABBREV_RULE o SELECT_AND_ABBREV_RULE o ABBREV_RULE "L" test_list) th2;;

let lp_th2 = (ABBREV_RULE "L" test_list o INST inst_list) lp_th;;
let lp_th3 = PROVE_HYP th3 lp_th2;;

let estd_refl = REFL `ESTD V`;;

let final_th = (MY_PROVE_HYP estd_refl o EXPAND_RULE "L" o EXPAND_RULE "h" o EXPAND_RULE "g") lp_th3;;




(*************************************)

let get_all_ineqs hyp_set0 all_ineq_th =
  let all_tm, set_tm = dest_comb (concl all_ineq_th) in
  let set_eq_th = hyp_set0 ((fst o dest_const o rator) set_tm) in
  let ineq1_th = EQ_MP (AP_TERM all_tm set_eq_th) all_ineq_th in
    map MY_BETA_RULE (get_all ineq1_th);;


let ye_hi_ineq = generate_ineq (find_raw_ineq true "ye_hi");;
let ye_hi_ineq2 = generate_ineq (find_raw_ineq true "yy10");;


loadt "../formal_lp/glpk/ex2/bb2_3_out.hl";;


let list0 = (to_num o create_hol_list_str) hypermap_string;;
let split_list_th = eval_split_list_hyp list0 (to_num `1,2`);;
let test_list = (rand o concl) split_list_th;;

let hyp_set, hyp_fun = compute_all test_list None;;
let hyp_set0, hyp_fun0 = compute_all list0 None;;

let lp_th1 = prove_flyspeck_lp_step1 test_list hyp_set hyp_fun false precision constraints target_variables variable_bounds;;

let ye_hi_3, ye_hi_2h0 =
  let r = get_all_ineqs hyp_set0 o INST[list0, l_cap_var; `ESTD V`, `E:(real^3->bool)->bool`] in
    r ye_hi_ineq, r ye_hi_ineq2;;

let th1 = itlist MY_PROVE_HYP ye_hi_2h0 lp_th1;;
let th2 = itlist MY_PROVE_HYP ye_hi_3 th1;;




 
